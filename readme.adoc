= Atomic Cryptography Extension (ACE)

ACE is work of the High Assurance Cryptographyc(HAC) TG at RISC-V.

ACE is an ISA extension for full-round cryptographic operations (hence, *atomic*) using _Cryptographic Contexts_, which are indivisible data structures consisting of metadata and a “content” section that contains the secrets, such as keys. 
Cryptographic Contexts live _either_ in special architectural containers called _Cryptographic Registers_ that keep the contents hidden once provisioned in them, _or_ upon export using an AEAD mode of encryption, in untrusted memory, where they are called _Sealed Cryptographic Contexts_.
Sealed Cryptographic Contexts can then be reimported into Cryptographic Registers. They can be generated by some Trusted piece of software or hardware, and then passed to the software that needs them.

The metadata in a Cryptographic Context binds the key(s) to a single algorithm and usage/access policies, thus preventing the use of the key(s) for other algorithms and (optionally) by unauthorised processes/security states/etc.  In cryprographic operations, keys can only be used by ACE if in a Cryptographic Register, which is protected by the architecture, and thus the architecture itself guarantees that the key is used only according to the policies encoded in the metadata.  When a Cryptographic Context is in memory as a Sealed Cryptographic Context, key and metadata are inseparable because of the AEAD encryption.

The algorithm encoded in the metadata can be somethibng simple such AES-128, but also something fancier like SM4-GCM-SIV. The big point here is that a small number of instructions can support hundreds of different algorithms, because the instructions themselves are agnostic to the algorithm. The metadata determines the algorithm.
Furthermore, the same binary code can support any 128-bit cipher, say, in a GCM-SIV mode, for instance AES-GCM-SIV, SM4-GCM-SIV, Kalyna-GCM-SIV, Kuznetchik-GCM-SIV and so on. The only difference would be in the metadata in the Cryptographic Context, but the sequence of instructions would be identical.


== License

This work is licensed under a Creative Commons Attribution 4.0 International License (CC-BY-4.0). For details, see the link:LICENSE[LICENSE] file.

== Contributors

The list of contributors to this specification is maintained in the link:src/contributors.adoc[contributors] file.

For guidelines on how to contribute, refer to the link:CONTRIBUTING.md[CONTRIBUTING] file.

== Building the Document

=== Directory Structure

The following directories are used to organize the contents of this repo:

* `dependencies/`: software dependencies needed to build the specification
* `docs-resources/`: resources for all specifications sourced from link:.gitmodules[git submodule]
* `src/`: source files for the specification
* `build/`: default directory where the build artifacts are generated

=== Prerequisites

To build the document, you'll need the following tools installed on your system:

* Make
* asciiDoctor-pdf, asciidoctor-bibtex, asciidoctor-diagram, and asciidoctor-mathematical
* Docker

=== Cloning the Repository

```shell
git clone --recurse-submodules https://github.com/riscv/riscv-hac.git
```

=== Building the Documentation

To start the build process, run:

```shell
cd ./riscv-hac && make build
```

The link:Makefile[] script will check the availability of Docker on your system:

* If Docker is available, the documentation will be built inside a Docker container using the image riscvintl/riscv-docs-base-container-image:latest. This ensures a consistent build environment across different systems.
* If Docker is not available, the documentation will be built directly on your system using the installed tools.

The documentation is generated from the AsciiDoctor source files in your project. The primary source file is specified by the `HEADER_SOURCE` variable in the Makefile.

The build process utilizes several options, including theming and font settings, and generates a PDF document as output.

=== Cleaning up

To clean up the generated files, run:

```shell
make clean
```


== Enabling pre-commit checks locally
The repository has some basic commit checks set up with https://pre-commit.com/[pre-commit] that will be enforced by the GitHub CI.
To ensure these checks are also run in the local repository while making changes the following command can be run:
[source,shell]
----
pip3 install pre-commit && pre-commit install
----

When enabling additional checks https://pre-commit.com/#plugins[by editing .pre-commit-config.yaml], it is recommended to run to newly added check on all files in the repository. This can be done with the following command:
[source,shell]
----
pre-commit run --all-files
----

[[Introduction]]
== Introduction

=== Objectives

ACE, the Atomic Cryptographic Extension, is an instruction set extension designed to provide high assurance cryptographic operations.
The main features are the concealment of key values, restrictions on their usage, and support for hardened implementations, with a single, streamlined instruction set.

The development of ACE is prompted by the needs of key use cases such as:

* Content protection,
* Local decryption of LLMs,
* Key management,
* Identity management,
* Communications (bulk encryption for TLS/MACsec),
* Storage encryption,
* Any cryptographic operations for Confidential VMs/Realms/TEEs,
* Secure boot and/or attestation in bootloaders without invoking a separate HW block,
* Page-fault-driven page-based memory encryption in SW (SoftME, MemShield, …),

and in general any application where cryptographic operations are required and it is desirable to offer a high level of protection to keys and intermediate values.

ACE is _architected_ as an _attached_ unit, in other words as a coprocessor with a special, fast interface to the CPU.
This is similar to the so-called streaming features of the Arm architecture or Risc-V AME.
An ACE implementation can be shared by multiple cores, with per-hart architectural state, and can operate in parallel with the CPU cores, even if the latter are in-order.
Of course, an implementation integrated into a CPU core is permitted.

=== Features

. ACE is an ISE for full-round, block-wise cryptographic operations without exposing the key.
. ACE supports multiple different cryptographic primitives and modes, including SCA resistant versions.
 Supported algorithms are discoverable. There is a mandatory list of algorithms, optional architected ones, and support for custom algorithms.
. Keys are stored in architectural states called "Cryptographic Contexts" (CC) together with metadata that restricts the usage of the key.
. ACE instructions use CCs instead of directly accessing the keys.
. ACE supports multiple CCs active at the same time.
. There is no mechanism to extract the original value of a key from a CC: CCs are not read/write in the same sense as registers are.
. By writing a key into a CC, a key is thus made _opaque_ (concealed). +
  Besides SW, additional optional sources for keys are:
.. A System Specific Key Table (SSK Table);
.. External blocks for dynamic key generation.
. ACE allows isolated, protected, or trusted SW or HW entity to deliver opaque keys to less trusted environments to perform cryptographic operations without getting visibility in the value of the key.
 Once this has been done, the opaque key can be re-used without having to call the trusted entity each time.
. ACE can associate a lifecycle to an opaque key, such as: Keys can be bound to devices, classes of devices, software environments, or be bound to a single boot cycle.
. ACE can restrict which process can use a given opaque key. In particular:
.. ACE supports separation of keys belonging to different domains.
.. ACE provides support for key preservation upon process or VM migration.
   Note that by migration here we only understand the transfer of processes and VMs from a device to another, not a migration between harts in the same device.
. ACE scales from from embedded cores to large application/server cores, with same ISA and ABI: certain features may be omitted in smaller cores without requiring changes in User SW.

// The latter is needed for cloud and edge deployment. ACE provides the minimum necessary support to enable secure key migration between machines.

// Currently, this often involves both changing context and potentially blocking operations to program keys or to perform cryptographic operations in cryptographic accelerators. This can result in large delays. ACE enables SW to set and use these keys with reduced overheads.

// ACE can be used to provide hardened primitives for TEEs and TPMs to minimize explicit key handling and reduce the attack surface.
// The cryptographic operations are per-block atomic (“one-shot instructions”), as opposed to common round-based ISAs. Besides the already stated goal of preventing direct key leakage or exposure (which is unavoidable by design in round-based extensions like AES-NI), but also to enable masked implementation for protection against side-channel attacks. The fact that these operations are performed atomically gives the extension its name.
// ACE further reduces the attack surface of key misuse attacks by binding key usage policies to specific algorithms and authorized SW environments.

=== Rationale

ACE is necessary because current solutions are inadequate:

* Round-based ISAs need to explicitly add the key between the rounds.
* Current ISAs do not provide trustworthy mechanisms for cryptographic operations. Trust is provided only in external IP blocks or by relying on costly context switch to TEEs (TZ, etc) for each cryptographic operation.
* External IP blocks with mem-mapped/coprocessor interfaces require long switching time and/or synchronization and substantial work in system stack to configure shared memory buffers and copy data around.
* Key Management (resp. KM building blocks) is not provided — except in external IP blocks.
* In modes such as AES-GCM-SIV, encryption and authentication derived keys should also not leak, hence supporting primitives only is not always sufficient.
* No current standardized/architected solution offers fast execution, key management, and trust.

=== Further Implied Features

Some additional features are necessary in order to make ACE actually useable and address the issues of the current solutions.
For instance, it is not desirable to have to switch to a different environment each time we need to use a certain key, and also context switches need to be supported by the software stack.  This means that while the value of a key cannot be extracted from a CC, there must be a mechanism to export the contents of a CC in a secure way, i.e., a way that does not compromise the confidentiality and the integrity of the key and its metadata.

//[start=10]
. ACE allows software to securely export the contents of a CC to memory by encrypting and authenticating it, as a "Sealed Cryptographic Context" (SCC).
  A SCC can then be authenticated, decrypted, and re-imported into a CC.
.. Any metadata that does not need to be encrypted and can be used to reduce overheads (for instance, to determine the total length of an input, or its expected structure) is kept in the clear.
.. Since we have public and private metadata, and keys (obviously private), we need to use an AEAD mode of operation for the export/import operations (AES-GCM-SIV as per RFC 8452).
.. Since an AEAD mode of operation is needed, ACE exposes (a variant of) it to user. For this reason, we support modes in general in ACE.
. A "secret" Cryptographic Context Transport Key (CTK) must be used for import and export. ACE optionally allows Machine to configure the CTK.
  CTK reconfigurability is one of the mechanisms by which keys can be domain separated: if Machine configures two different CTKs for two different domains, the one domain cannot authenticate and decrypt an SCC created for the other domain.

We apply the term “*opaque keys*” to both keys in CHRs and exported SCCs. Opaque keys are cryptographic keys that can be used without revealing their value.
“Opaque” means the actual key value can’t be extracted from a CHR or SCC in the clear.
The environment that generated the key will of course know its value.


=== Non-Features

Certain features are intentionally not supported by ACE:

* ACE does not support the processing of entire variable-length inputs.
* ACE does not provide complete secure key management and provisioning features, but offers building blocks that can be used to implement them, Key management can be delegated to applets in a TEE or secure VM, possibly from different owners. These applets can implement complex key management software. The feature allows entities to set up and deliver keys opaquely to less trusted SW domains. ACE does not support external schemes for directly provisioning keys into a key store.
* ACE cannot fully prevent misuse by compromised processes. If a process is compromised, the attacker obtains access to the CCs and can perform cryptographic operations — even if they do not elicit the key. Therefore, ACE complements existing security measures such as SW vulnerability exploitation countermeasures and process isolation (including TEE-like inverse sandboxing).
* Other risks remain. For instance: In counter-mode encryption, the same method enables both encryption and decryption. Similarly, MAC verification capability also enables MAC creation. Malicious processes can still misuse these operations. This also leads to the need to protect derived keys in modes of operation like AES-GCM-SIV which rely on counter-mode encryption using a derived key.


=== High Level View of the Extension

ACE provides the following instructions:

. `ace.config`, to load the clear value of a key (and some metadata) in a Cryptographic Context (CC);
. `ace.clear`, to erase/invalidate the content of a CC;
. `ace.export`, to encrypt and authenticate a CC and store it to memory as a SCC;
. `ace.import`, to authenticate, decrypt a SCC from memory and import it into a CC;
. `ace.exec`, to perform a cryptographic operation on a block (e.g., 128 bits) of the input;
. `ace.set_stage`, to configure the CC for encryption/decryption or move from one stage of an algorithm to another; and
. `ace.error`, to report an error condition, which can be implemented as a read operation from a CSR.

Other instructions are provided and these will be discussed in detail later.

The inputs and outputs of the ACE operations are:

. Cryptographic Contexts,
. Vector registers (*), and
. External memory. Memory is addressed using GPRs.

CCs are referred by a 5-bit immediate value or by the value of a GPR. +
They are denoted by `Cn`, with `n` in [0..31].

Regarding the access control policies in a CC's metadata, we must distinguish between initial (i) configuration, (ii) usage, and (iii) import/export of a CC.
These three types of operations cannot always obey the same policies — otherwise there would be opportunities for malicious adversaries to perform Denial-of-Service attacks on the ACE resources.
As a general rule, the access control policies only limit `ace.exec` and `ace.set_stage` operations.
This also means that it is always possible to clear, export a CC, and configure a CC or import a SCC into a CC, even if the latter two operations
directly overwrite an already configured CC, which implies that the previous state is discarded (TBD: we are discussing whether optional limitation to import and export can be added as well and how).



==== Differences been Cryptographic Contexts and Architectural Registers

The size of the data in a CC is variable, and this size is independent for each CC — this is an important difference with respect to GPRs and vector registers, which always have the same size. The total amount of internal "register memory" for CCs can also be exhausted when a subset of the CCs are used.
CCs contain different fields: metadata, key material, and internal state.
All three need to be architected.

The fact that CCs can be addressed indirectly has two implications:

. Adding renaming to to CCs would complicate the microarchitecture too much. Luckily, we can assume that are changed rarely, except for internal implied changes, and therefore we can assume that CCs are not renamed without performance issues.
. We need to use one bit in the instruction encoding to determine whether a CC is given by an immed or by a GPR. (Two bits for the ACE.CLONE operation.)

==== Remark On Direct Memory Access

The instructions `ace.config`, `ace.export` and `ace.import` directly access memory.
This does not contradict the principle of load/store architectures because ACE is architected as an _attached_ unit, not as a component of the CPU core.
Therefore it can have its own state and its own LSU.
Beside this, `ace.config`, `ace.export` and `ace.import` can also be viewed as special load/store instructions which need to do something "under the hood" in order to maintain the security guarantees of confidentiality and integrity of the key material.

While splitting these instructions into multiple ones is possible, even reducing configuring, importing and exporting to block-wise instructions, we find that this is undesirable because it would require the ACE implementation to keep the same internal state as with the composite instructions, for the purpose of implementing authentication and encryption, and would restrict the way these operations are implemented --- while adding significant complexity to SW using the extension.

=== An Example

In the following example, a process wants to AES-encrypt some data using a key they are not allowed to know, which belongs to a recipient.

.Simple Example: Encryption, no Authentication
[%linenums,C]
----
Call OS API to get an AES-encrypt SCC from a key management applet or HW block. X5 points to the SCC.
Allocate memory for ciphertext buffer.
// Import the SCC into Cryptographic Context C0, say:
ace.import C0, [X5]                 // This sets the op type ace.exec performs when used with CC C0
ace.error X1, C0
If X1 <> 0 then handle error
ace.set_stage C0, #ace_const_encrypt// Risc-V specific: configure 128-bit vectors.
ace.error X1, C0
if X1 <> 0 then handle error        // If encryption is not allowed
for i = 0 to ceil(len_in_bytes(plaintext)/16)-1 do
    load V0 from *(plaintext+16*i)
    ace.exec V0, C0, V              // Encrypt one block of the plaintext
    store V0 at ciphertext+16       // Write to ciphertext buffer
----


=== Algorithms

We architect support for several algorithms, and also define a minimal subset (current suggestion):

* AES-128 and AES-256 encryption and decryption.
* AES-CTR, AES-GCM, AES-GCM-SIV, AES-XTS, AES-CMAC using AES-128/256.
* SHA-2, SHA-2-HMAC.

The list of other architected algorithms is TBD, but it should include at least
* AES-192, alone and with the above modes.
* SM4 Block Cipher.
* The Ascon suite (Ascon-128/128a-AEAD, Ascon-Hash, Ascon-XOF, Ascon-80pq).
* SHA-3, SHA-3-HMAC.
* SM3 Secure Hash.

The list can be extended by the architecture owner --- there is an interval of the algorithm encoding space in the metadata for custom algorithms.


=== Terminology / Glossary

The description in this document applies to various computing architectures, and it is not limited to just a particular one.

In what follows we assume a system with up to four exception levels or modes.

* EL0 / User
* EL1 / Supervisor / Virtual Supervisor (i.e., OS)
* EL2 / Hypervisor / Supervisor
* EL3 / Monitor / Machine (DEVS-mode)

In this document we use the terms User/Supervisor/Hypervisor and Monitor.

Any process runs in a process domain which is in an EL/mode.
Any process can be pre-empted into its own parent.
The processes managed by a parent are its children.
The processes under the same parents are the siblings.

We do not make assumptions on the size and addressability of Control and Status Registers (CSRs).
When we write “We need a 256-bit CSR to store a global key” it can mean a single memory mapped register, an ad-hoc addressable set of 8 32-bit CSRs, or of 4 64-bit CSRs, etc…

GPRs are denoted by Xn.

Vector Registers are denoted by Vn.

=== Outline

The remainder of this document describes the extension in full detail.

//In <<Details>> the technical details of the architecture are presented, including a listing of the instructions and their semantics.

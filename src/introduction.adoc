[[Introduction]]
== Introduction

=== Objectives

ACE, the Atomic Cryptographic Extension, is an instruction set extension designed to provide high assurance cryptographic operations.
The main features are the concealment of key values, restrictions on their usage, and support for hardened implementations, with a single, streamlined instruction set.

The development of ACE is prompted by the needs of key use cases such as:

* Content protection,
* Local decryption of LLMs,
* Key management,
* Identity management,
* Communications (bulk encryption for TLS/MACsec),
* Storage encryption,
* Any cryptographic operations for Confidential VMs/Realms/TEEs,
* Secure boot and/or attestation in bootloaders without invoking a separate HW block,
* Page-fault-driven page-based memory encryption in SW (SoftME, MemShield, …),

and in general any application where cryptographic operations are required and it is desirable to offer a high level of protection to keys and intermediate values.

ACE is _architected_ as an _attached_ unit, in other words as a coprocessor with a special, fast interface to the CPU.
This is similar to the so-called streaming features of the Arm architecture or Risc-V AME.
An ACE implementation can be shared by multiple cores, with per-hart architectural state, and can operate in parallel with the CPU cores, even if the latter are in-order.
Of course, an implementation integrated into a CPU core is permitted.

=== Features

. ACE is an ISE for full-round, block-wise cryptographic operations without exposing the key.
. ACE supports multiple different cryptographic primitives and modes, including SCA resistant versions.
 Supported algorithms are discoverable. There is a mandatory list of algorithms, optional architected ones, and support for custom algorithms.
. Keys are stored in architectural states called "Cryptographic Contexts" (CC) together with metadata that restricts the usage of the key.
. ACE instructions use CCs instead of directly accessing the keys.
. ACE supports multiple CCs active at the same time.
. There is no mechanism to extract the original value of a key from a CC: CCs are not read/write in the same sense as registers are.
. By writing a key into a CC, a key is thus made _opaque_ (concealed). +
  Besides SW, additional optional sources for keys are:
.. A System Specific Key Table (SSK Table);
.. External blocks for dynamic key generation.
. ACE allows isolated, protected, or trusted SW or HW entity to deliver opaque keys to less trusted environments to perform cryptographic operations without getting visibility in the value of the key.
 Once this has been done, the opaque key can be re-used without having to call the trusted entity each time.
. ACE can bind an opaque key to devices, classes of devices, specific hardware or software environments, or to a single boot cycle.
. ACE can restrict which process can use a given opaque key. In particular:
.. ACE supports separation of keys belonging to different domains.
.. ACE provides support for key preservation upon process or VM migration.
   Note that by migration here we only understand the transfer of processes and VMs from a device to another, not a migration between harts in the same device.
. ACE scales from from embedded cores to large application/server cores, with same ISA and ABI: certain features may be omitted in smaller cores without requiring changes in User SW.

// The latter is needed for cloud and edge deployment. ACE provides the minimum necessary support to enable secure key migration between machines.

// Currently, this often involves both changing context and potentially blocking operations to program keys or to perform cryptographic operations in cryptographic accelerators. This can result in large delays. ACE enables SW to set and use these keys with reduced overheads.

// ACE can be used to provide hardened primitives for TEEs and TPMs to minimize explicit key handling and reduce the attack surface.
// The cryptographic operations are per-block atomic (“one-shot instructions”), as opposed to common round-based ISAs. Besides the already stated goal of preventing direct key leakage or exposure (which is unavoidable by design in round-based extensions like AES-NI), but also to enable masked implementation for protection against side-channel attacks. The fact that these operations are performed atomically gives the extension its name.
// ACE further reduces the attack surface of key misuse attacks by binding key usage policies to specific algorithms and authorized SW environments.

=== Rationale

ACE is necessary because current solutions are inadequate:

* Round-based ISAs need to explicitly add the key between the rounds.
* Current ISAs do not provide trustworthy mechanisms for cryptographic operations. Trust is provided only in external IP blocks or by relying on costly context switch to TEEs (TZ, etc) for each cryptographic operation.
* External blocks with memory mapped or coprocessor interfaces incur heavy overheads and need substantial support in system stack.
* Key Management (resp. KM building blocks) is not provided — except in external IP blocks.
* In modes such as AES-GCM-SIV, encryption and authentication derived keys should also not leak, hence supporting primitives only is not always sufficient.
* No current standardized or architected solution offers fast execution, key management, and trust.

=== Further Features

Some additional features are necessary in order to make ACE actually useable and address the issues of the current solutions.
For instance, it is not desirable to have to switch to a different environment each time we need to use a certain key, and also context switches need to be supported by the software stack.  This means that while the value of a key cannot be extracted from a CC, there must be a mechanism to export the contents of a CC in a way that does not compromise the confidentiality and the integrity of the key and of its associated metadata.

//[start=10]
. ACE allows software to securely export the contents of a CC to memory by encrypting and authenticating it, as a "Sealed Cryptographic Context" (SCC).
  A SCC can then be authenticated, decrypted, and re-imported into a CC.
.. Any metadata that does not need to be encrypted is kept in the clear.
.. Since we have public and private metadata, and keys (obviously private), we need to use an AEAD mode of operation for the export/import operations (AES-GCM-SIV as per RFC 8452).
.. Since an AEAD mode of operation is needed, ACE exposes (a variant of) it to user. For this reason, we support modes in general in ACE.
. A Cryptographic Context Transport Key (CTK) must be used for import and export.
  ACE optionally allows Machine to configure the CTK.
  In this case, the CTK is stored in 256 bits worth of CSRs, only Machine may configure the CTK.
  CTK reconfigurability is one of the mechanisms by which keys can be domain separated: if Machine configures two different CTKs for two different domains, the one domain cannot authenticate and decrypt an SCC created for the other domain.
. If the CTK is not configurable, it may be either a fixed value or randomly generated at boot.
. ACE provides a key derivation mechanism to compute Derived CTKs from the (current) CTK and a secret salt associated to a specific lifecycle. When this _Lifecycle Specific Secret_ (LSS) is changed, the corresponding CTK is also changed and all the SCCs exported with the older value of the LSS become automatically invalid.

We apply the term “*opaque keys*” to both keys in CHRs and exported SCCs. Opaque keys are cryptographic keys that can be used without revealing their value.
“Opaque” means the actual key value can’t be extracted from a CHR or SCC in the clear.
The environment that generated the key will of course know its value.


=== Non-Features

Certain features are intentionally not supported by ACE:

* ACE does not currently provide debugging features, in particular the internal representation of a CC is still hidden even when debugging is enabled.
* ACE does not support the processing of entire variable-length inputs.
* ACE does not provide complete secure key management and provisioning features, but offers building blocks that can be used to implement them, Key management can be delegated to applets in a TEE or secure VM, possibly from different owners. These applets can implement complex key management software. The feature allows entities to set up and deliver keys opaquely to less trusted SW domains. ACE does not support external schemes for directly provisioning keys into a key store.
* ACE, in its current version, does not provide a key revocation mechanism. This is a complex feature requiring additional infrastructure and coordination, for a relatively rare event. +
With the present architecture, keys that may need revocation can be boundto an Environment that is invalidated upon receiving _any_ revocation message. If the derived CTK for such a key is invalidated, any process using it must re-obtain the key from the provisioning entity; if the key is revoked within the provisioning applet or IP block, re-obtaining the key will fail. Note that keys stored in CCs can still be exported, as a mechanism to revoke keys already loaded into CCs is not defined. (A potential implementation could assign an optional 64- or 128-bit identifier to each key and use a system-wide broadcast message to instruct all ACE units to erase CCs matching that identifier.)
* ACE cannot fully prevent misuse by compromised processes. If a process is compromised, the attacker obtains access to the CCs and can perform cryptographic operations — even if they do not elicit the key. Therefore, ACE complements existing security measures such as SW vulnerability exploitation countermeasures and process isolation (including TEE-like inverse sandboxing).
* Other risks remain. For instance: In counter-mode encryption, the same method enables both encryption and decryption, hence a malicious process may be able to misuse these operations.
// If MAC verification capability also enables MAC creation.
// This also leads to the need to protect derived keys in modes of operation like AES-GCM-SIV which rely on counter-mode encryption using a derived key.


=== High Level View of the Extension

The most important instructions provided by ACE are the following:

. `ace.config`, to load the clear value of a key (and some metadata) in a Cryptographic Context (CC);
. `ace.clear`, to erase/invalidate the content of a CC;
. `ace.export`, to encrypt and authenticate a CC and store it to memory as a SCC;
. `ace.import`, to authenticate, decrypt a SCC from memory and import it into a CC;
. `ace.exec`, to perform a cryptographic operation on a block (e.g., 128 bits) of the input;
. `ace.stage/ace,dir`, to configure the CC for encryption/decryption or move from one stage of an algorithm to another; and
. `ace.error`, to report an error condition, which can be implemented as a read operation from a CSR.

Other instructions are provided and these will be discussed in detail later.

The inputs and outputs of the ACE operations are:

. Cryptographic Contexts,
. Vector registers (*), and
. External memory. Memory is addressed using GPRs.

CCs are referred by a 5-bit immediate value or by the value of a GPR. +
They are denoted by `Cn`, with `n` in [0..31].

Regarding the access control policies in a CC's metadata, we must distinguish between initial (i) configuration, (ii) usage, and (iii) import/export of a CC.
These three types of operations cannot always obey the same policies — otherwise there would be opportunities for malicious adversaries to perform Denial-of-Service attacks on the ACE resources.
As a general rule, the access control policies only limit `ace.exec` and `ace.stage` operations.
This also means that it is always possible to clear, export a CC, and configure a CC or import a SCC into a CC, even if the latter two operations
directly overwrite an already configured CC, which implies that the previous state is discarded (TBD: we are discussing whether optional limitation to import and export can be added as well and how).

==== Differences been Cryptographic Contexts and Architectural Registers

The size of the data in a CC is variable, and this size is independent for each CC — this is an important difference with respect to GPRs and vector registers, which always have the same size. The total amount of internal "register memory" for CCs can also be exhausted when a subset of the CCs are used.
CCs contain different fields: metadata, key material, and internal state.
All three need to be architected.

The fact that CCs can be addressed indirectly has two implications:

. Adding renaming to to CCs would complicate the microarchitecture too much. Luckily, we can assume that are changed rarely, except for internal implied changes, and therefore we can assume that CCs are not renamed without performance issues.
. We need to use one bit in the instruction encoding to determine whether a CC is given by an immed or by a GPR. (Two bits for the ACE.CLONE operation.)


==== Remark on the Formats for the Cryptographic Contexts

Before we proceed, we need to point out that there are different representations of the same object:

* The input format of key + metadata in the clear in memory for the initial configuration of a CC.
* What we call the CC proper, i.e. the internal representation of a key + metadata + additional state.
* The format of a SCC, defined by the format of the plaintext and its encryption and authentication method.

The first and third formats are architected, whereas the second one is `impdef`, i.e., the internal representation of the CC is left to the implementor of the microarchitecture.  However, we still define the minimum of information that must be stored in a CC, to the very least the same information that is stored in a SCC, and in some cases additional information that is specific to the algorithm or to the implementation.

This also means that the maximal size of the data inside a CC is `impdef` as well, and this size in general differs from the size of the initial information  required to configure a CC as well as from the size of a SCC.

One may observe that, on a single implementation, as long as export and import use the same formats, there would be no need requirement for the SCC format to be standardized?
There are two reasons for architecting the configuration and SCC formats.
The first one is interoperability: even on SoC by a single manufacturer there may be IP blocks defined by various designers.
We want to make sure that an IP block can use the same SCCs as a different IP block. Defining this format will simplify implementation.
The second reason is that moving VMs from a machine to another is a quite common process, not only in the cloud, even in the consumer space.
Customers therefore will not only create a VM on a client machine and upload it to the cloud, or locally generate keys that are then provisioned to a cloud VM, but the often carry a VM from an old client device to a new one, for instance a laptop with an intel CPU to an AMD laptop.
This implies not only that a single, architected format is desirable, but also that a mechanism for transferring a CTK from a device to another is necessary.

==== Remark On ACE Instructions that Access Memory

The instructions `ace.config`, `ace.export` and `ace.import` directly access memory.
This does not contradict the principle of load/store architectures because ACE is architected as an _attached_ unit, not as a component of the CPU core.
Therefore it can have its own state and its own LSU.
Beside this, `ace.config`, `ace.export` and `ace.import` can also be viewed as special load/store instructions which need to do something "under the hood" in order to maintain the security guarantees of confidentiality and integrity of the key material.

While splitting these instructions into multiple ones is possible, even reducing configuring, importing and exporting to block-wise instructions, we find that this is undesirable because it would require the ACE implementation to keep the same internal state as with the composite instructions, for the purpose of implementing authentication and encryption, and would restrict the way these operations are implemented, while adding significant complexity to SW using the extension.

=== An Example

In the following example, a process wants to AES-encrypt some data using a key they are not allowed to know, which belongs to a recipient.

.Simple Example: Encryption, no Authentication
[%linenums,C]
----
Call OS API to get the necessary SCC. X5 points to the SCC.
Allocate memory for ciphertext buffer.
ace.import C0, [X5]                  // Import the SCC into CC C0
ace.error X1, C0
If X1 <> 0 then handle error
Configure vector unit to use 128-bit vectors.
ace.stage C0, #ace_const_encrypt
ace.error X1, C0
if X1 <> 0 then handle error         // If encryption is not allowed
for i = 0 to ceil(len_in_bytes(plaintext)/16)-1 do
    load V0 from *(plaintext+16*i)
    ace.exec V0, C0, V               // Encrypt one block of the plaintext
    store V0 at *(ciphertext+16*i)
----

=== Supported Algorithms

We architect support for several algorithms, and also define a minimal subset (current suggestion):

* AES-128 and AES-256 encryption and decryption.
* AES-CTR, AES-GCM, AES-GCM-SIV, AES-XTS, AES-CMAC using AES-128/256.
* SHA-2, SHA-2-HMAC.

The list of other architected algorithms is TBD, but it should include at least

* AES-192, alone and with the above modes.
* SM4 Block Cipher.
* The Ascon suite (Ascon-128/128a-AEAD, Ascon-Hash, Ascon-XOF, Ascon-80pq).
* SHA-3, SHA-3-HMAC.
* SM3 Secure Hash.

The list can be extended by the architecture owner.
There is an interval of the algorithm encoding space in the metadata for custom algorithms.


=== Alternative Inputs and Outputs

Throughout this document, the cryptographic inputs and outputs for all `ACE` operations are vector registers.
A priori, we do not exclude versions of the specification that use only GPRs, however this is currently out of scope, and if the need arises, this should be architected as well.
We will also define a subset of the `V` extension that specifies only the vector registers, unit-strided load and stores, and a subset of vector operations including insert, extract, and logical operations, and possibly some additional ones. The goal is that code written against `ACE` and this subset of `V` shall run on any Risc-V core implementing `ACE`.

=== Terminology

[comment]
--
The description in this document applies to various computing architectures, and it is not limited to just a particular one.

In what follows we assume a system with up to four exception levels or modes.

* EL0 / User
* EL1 / Supervisor / Virtual Supervisor (i.e., OS)
* EL2 / Hypervisor / Supervisor
* EL3 / Monitor / Machine (DEVS-mode)

In this document we use the terms User/Supervisor/Hypervisor and Monitor.

Any process runs in a process domain which is in a specific mode.
Any process can be pre-empted into its own parent.
The processes managed by a parent are its children.
The processes under the same parents are the siblings.
--

We do not make assumptions on the size and addressability of Control and Status Registers (CSRs).
When we write “We need a 256-bit CSR to store a global key” it can mean a single memory mapped register, an ad-hoc addressable set of 8 32-bit CSRs, or of 4 64-bit CSRs, etc…

GPRs are denoted by `Xn`.

Vector Registers are denoted by `Vn`.

=== Outline

The remainder of this document describes the extension in full detail.

//In <<Details>> the technical details of the architecture are presented, including a listing of the instructions and their semantics.

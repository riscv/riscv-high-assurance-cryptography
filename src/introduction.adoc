[[Introduction]]
== Introduction

This document outlines an ISA extension, the *Atomic Cryptographic Extension* (ACE).

ACE’s goal is to address the needs of key use cases such as:

* *Content protection*. ACE allows software to decrypt premium content without exposing keys. Currently, this often involves both changing context and potentially blocking operations to program keys or to perform cryptographic operations in cryptographic accelerators. This can result in large delays. ACE enables SW to set and use these keys with reduced overheads.
* *Secure cryptographic implementations*. ACE can provide hardened primitives for TEEs and TPMs to minimize explicit key handling and reduce the attack surface. Compromised software is not allowed to leak keys in plaintext. ACE reduces the attack surface of key misuse attacks by binding key usage policies to specific algorithms and authorized SW environments. The latter feature is also used to support the:
* *Separation of keys belonging to different domains*.
* *Acceleration of cryptographic implementations.*
* *Key preservation upon process or VM migration*. This is needed for cloud and edge deployment. ACE provides the minimum necessary support to enable secure key migration between machines.

To enable (symmetric) encryption without exposing encryption keys, keys may be established in a separate SW or HW environment and shared securely with software that needs to use them. The software can then perform cryptographic operations without direct access to the keys.

The atomic cryptographic operations (“one-shot instructions”) serve not only to prevent direct key leakage or exposure (which is unavoidable by design in round-based extensions like AES-NI), but also to enable masked implementation for protection against side-channel attacks. The fact that these operations are performed atomically gives the extension its name.

The key functionality that is provided to address the above requirements are

[arabic]
. *Context Holding Registers* (CHRs) - Write-and-use-only registers for cryptographic keys. The CHRs are architectural registers, therefore they are defined per-hart (hardware thread) like the integer and vector registers. However, they have the unique property that, once a value is written to a CHR, it can no longer be extracted by _value_. The act of writing a key and associated policies to a CHR is called *configuration* of the CHR.
. *New CPU Instructions* that use the CHRs. These perform the following operations:
[loweralpha]
.. Setting key values and metadata in CHRs, erasure of CHR contents. It is critical that the instructions that set a key also set the metadata contextually. The metadata contains _usage_ policies, and any other operation shall respect them.
.. Atomic cryptographic operations using keys stored in CHRs.
.. Sending messages to the internal state of a CHR to modify properties of the operations being performed, for instance: various steps of an AEAD mode of operation or moving from initialization to consumption and to finalization in a hash function.
.. Secure export/import of CHR contents, whereby the contents are written to memory as an encrypted and authenticated Sealed Cryptographic Context (SCC) and a SCC can be re-imported into a CHR, thereby re-configuring it. This feature assists the implementation of key delivery from one environment to another.
.. CHR configuration using *Immutable System Keys* (ISKs).
.. CHR configuration using keys dynamically generated by the system.

Note that ACE cannot fully prevent misuse by compromised processes. If a process is compromised, the attacker obtains access to the CHRs and can perform cryptographic operations — even if they do not elicit the key. Therefore, ACE complements existing security measures such as SW vulnerability exploitation countermeasures and process isolation (including TEE-like inverse sandboxing).

Other risks remain. For instance: In counter-mode encryption, the same method enables both encryption and decryption. Similarly, MAC verification capability also enables MAC creation. Malicious processes can still misuse these operations

ACE does not directly provide secure key management and provisioning, but it can aid in implementing these features. Key management can be delegated to applets in a TEE or secure VM, possibly from different owners. These applets can implement complex key management software. The feature allows entities to set up and deliver keys opaquely to less trusted SW domains. Currently, it doesn’t support external schemes for directly provisioning keys into a key store.

ACE allows Keys to be bound to devices, classes of devices, software environments, and follow various lifecycles, from ephemeral keys not surviving a soft reset to keys carried between hosts through process or VM migration. *By migration here we only understand the transfer of processes and VMs from a device to another.*

We apply the term “*opaque keys*” to both keys in CHRs and exported SCCs. Opaque keys are cryptographic keys that can be used without revealing their value. “Opaque” means the actual key value can’t be extracted from a CHR or SCC in the clear. The environment that generated the key will of course know its value.

*Outline*

The remainder of this document described the extension in full detail.

In <<Assumptions>> we give a high-level presentation of the features of ACE, together with Goals and non-Goals of the architecture, as well as Rules that govern it.

In <<Details>> the technical details of the architecture are presented, including a listing of the instructions and their semantics.

=== Instructions

In what follows, the notation `Cn|Xn` refers to a CC directly (i.e., the
integer `n` is a 5-bit field in the instruction encoding) or a GPR containing a
number from 0 to 31 to indirectly refer to a CC.  In general, six bits are
needed to select a CC, to take into account the possibility of indirect
addressing.

NOTE: These encodings are just example encodings, and may not be the final
encodings. They serve as a starting point for discussion and refinement as
well as a proof that, at the time of this writing, the ACE instruction set
can be encoded.

NOTE: ACE seems to be an ideal candidate for the Composable Custom Extensions
framework.


==== ace.enable/ace.disable

`ace.enable` +
`ace.disable`

Description::
Enable/Disable the feature in the current process domain and (*TBD*) determine
how many contexts we need (can also be all/none) This is a pseudo-operation for
a write to a WARL CSR.

This instruction must be issued before using any ACE operation. It enables the
CCs and the instructions and also sets a bit in a CSR signaling that the
feature is used. When a process domain that has enabled ACE is preempted, the
parent process inherits the state. otherwise it would not be able to export and
re-import the CCs.
The operation is implemented as a CSRW.

When disabling:

* Care is necessary in the design to allow a locking disablement without
  erasing the registers when a parent gives control back to a child process
  that does not use the feature.

==== ace.init

`ace.init Cd|Xd, %offset(Xs)`

Encodings::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'Cd' },
    { bits:  3, name: 0x4, attr: ['ace.init'] },
    { bits:  5, name: 'rs1' },
    { bits: 12, name: 'imm', attr: ['offset'] },
]}
....
//
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x5, attr: ['ace.init'] },
    { bits:  5, name: 'rs1' },
    { bits: 12, name: 'imm', attr: ['offset'] },
]}
....


Description::
`Cd` is the source CC to be configured (encoded as a 5-bit immed). +
`Xd`, alternatively, is a GPR containing a number from 0 to 31 to select the context
to be configured. +
GPR `Xs` points to the region of memory containing the metadata and the key material.

Configures a CC with metadata and key, or using an index in the System Key Table.

[.red]#(TBdetermined whether it is secure)#
This instruction is trappable and may also be resumed or restarted.

==== ace.clear

`ace.clear Cd|Xd`

Encodings::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'Cd' },
    { bits:  3, name: 0x6, attr: ['ace.clear'] },
    { bits:  5, name: 0x0 },
    { bits: 12, name: 0x0 },
]}
....
//
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x7, attr: ['ace.clear'] },
    { bits:  5, name: 0x0 },
    { bits: 12, name: 0x0 },
]}
....

Description::
`Cd` is the source CC to be configured (encoded as a 5-bit immed). +
`Xd` alternatively, is a GPR containing a number from 0 to 31 to select the context to be configured. +
`Xs` is GPR with the pointer to the region of memory containing the metadata and the key material.

Configures a CC with metadata and either key material or index in the Immutable System Key Table.

==== ace.export

`ace.export %offset(Xd), Cs|Xs`

Encodings::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'imm[4:0]' },
    { bits:  3, name: 0x0, attr: ['ace.export'] },
    { bits:  5, name: 'Xd' },
    { bits:  5, name: 'Cs' },
    { bits:  7, name: 'imm[11:5]' },
]}
....
//
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'imm[4:0]' },
    { bits:  3, name: 0x1, attr: ['ace.export'] },
    { bits:  5, name: 'Xd' },
    { bits:  5, name: 'Xs' },
    { bits:  7, name: 'imm[11:5]' },
]}
....

Description::
`Cs` is the source CC to be exported (encoded as a 5-bit immed). Alternatively,
the number of context from which to export the CC is stored in the GPR `Xs` as
a number from 0 to 31. `Xd` is the GPR base address of the buffer where to
store the SCC.

Exports the contents of CC `Cs` to memory, starting at address `Xd`. Depending
on the type and policies of the key — which are stored in the metadata of `Cs`,
the CCWK can be either the CTK CSR or a Locale specific CTK derived from the
CTK.

The instruction (resp. `ace.import`) writes (reads) the entire internal state
of a CC or information needed to reconstruct an equivalent state — the
instruction shall be resumable in case of interrupts. This is similar to
entire-vector-register store instructions, that appear to other harts as
sequences of individual stores. If the context `Cs` is clear or does not exist
in the microarchitecture, the operation will report an error.

[.red]#(TBdetermined whether it is secure)#
This instruction is trappable and may also be resumed or restarted.

//(The SW should have the right information, so this should never happen).

==== ace.import

`ace.import Cd|Xd, %offset(Xn), S`

Encodings::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'Cd' },
    { bits:  3, name: '00S', attr: ['ace.import'] },
    { bits:  5, name: 'Xn' },
    { bits: 12, name: 'imm' },
]}
....
//
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: '01S', attr: ['ace.import'] },
    { bits:  5, name: 'Xn' },
    { bits: 12, name: 'imm' },
]}
....

Description::
`Cd` is the destination CC to be imported, as an immed (5-bit). Alternatively,
the number of context into which import the SCC is stored in the GPR `Xd` as a
number from 0 to 31. `Xn` is the GPR containing the base address of the buffer
with the SCC.

S takes the values 0 (false) or 1 true (1).
It is set to true if the key is in a system defined format and not the format
defined by the present architecture.

NOTE: There is no further specification as to
what the system defined format is in the encoding of the instruction, and in
case more than one system defined format is defined, the data format itself
must distinguish between them.  In other words, it is the responsibility of
the system to augment all the system defined formats with a unique identifier
that can be used to distinguish between them.

This means that system HW dynamically generated keys can be imported but not
exported in the same form — but, once exported, they must be in the architectural
format. If the value cannot be exported to other devices or to other Locale
stages of the same device, the internal logic must bind them to a specific
Locale CTK). The instruction imports them like SW keys, but only
internally, and sets the right policies.

[.red]#(TBdetermined whether it is secure)#
This instruction is trappable and may also be resumed or restarted.

==== ace.exec

The instruction admits four Forms, namely

[upperalpha]
. `ace.exec  Vd, Cn|Xn, Vs` -- which takes an input vector and writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}{nbsp}Cn|Xn, Vs` -- which takes an input vector but does not write to an output vector.
. `ace.exec  Vd, Cn|Xn{nbsp}{nbsp}{nbsp}{nbsp}` -- which does not take an input but writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}{nbsp}Cn|Xn{nbsp}{nbsp}{nbsp}{nbsp}` -- which does not take an input vector and does not write to an output vector.

Form D instructions just perform internal processing in the CC.

// Without this comment, the next part is not properly formatted...
Encoding::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Vd' },
    { bits:  3, name: 'ace.exec' },
    { bits:  5, name: 'Cn|Xn' },
    { bits:  5, name: 'Vs' },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....

Bit `r` (i.e., bit 27) takes the value 0 if the context is encoded as an immediate,
and it takes the value 1 if a GPR (scalar integer value) is used to reference it.
For the four Forms A-D above, the encodings are:

[upperalpha]
. `ACE.exec` = `0b000`.
. `ACE.exec` = `0b001` and `Vs`=`0b00000`.
. `ACE.exec` = `0b010` and `Vd`=`0b00000`.
. `ACE.exec` = `0b011` and `Vs`=`Vd`=`0b00000`.

Furthermore, we admit a variant of Form D to encode additional instructions:
[upperalpha,start=5]
. `ACE.exec` = `0b011` with `Vs` <> `0b00000`, and possibly more non-zero values in bits [31:25].

// To make indent in next line correct

Description::
Performs a cryptographic operation such as an encryption or decryption,
absorbing a value in a hash, and possibly returning a value.
All `ace.exec` instruction may modify the internal state of the CC.

==== ace.size

===== Context Variant

`ace.size Xd, Cn|Xn`

The instruction is encoded using the Form E `ace.exec` encoding:

Encoding::
[wavedrom, , svg]

....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x3, attr: ['ace.exec', '(Form E)'] },
    { bits:  5, name: 'Cn|Xn' },
    { bits:  5, name: 0x1, attr: ['ace.size'] },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....

Bit `r` (i.e., bit 27) takes the value 0 if the context is encoded as an immediate,
and it takes the value 1 if a GPR (scalar integer value) is used to reference it.


Description::
This instruction writes the size of the SCC corresponding to CC `Cn` (or the CC
whose number is in `Xn`) into GPR `Xd`.

Knowing the size of the SCC is important to properly implement any feature that
relies on `ace.export`, for instance context switching.

NOTE: The value can significantly differ from the internal resource usage ot the CC —
it can be larger (for simple primitives, because of the nonce/SIV overhead) but
also smaller (for keys split into shares for threshold implementations, but saved
externally in reconstructed form).

===== Immed Variant

`ace.size Xd, #immmed`

The instruction is encoded using the Form E `ace.exec` encoding:

Encoding::
[wavedrom, , svg]

....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x3, attr: ['ace.exec', '(Form E)'] },
    { bits:  5, name: 0x0 },
    { bits:  1, name: 0x1 },
    { bits:  10, name: 'immed' },
    { bits:  1, name: 0x1 },
]}
....

The 10-bit immed has the following format: the least significant 8 bits are the algorithm and the most significant 2 bits the side-channel protection level as defined in the Algorithm and SC_Protection fields of the metadata section of a CC.

Description::
This instruction writes the size of the SCC corresponding to the given algorithm and protection side-channel protection level.

==== ace.available

`ace.available Xd, #immed`

Encoding::
The instruction is just an alias to the immediate variant `ace.size`, since the latter returns zero if the algorithm is not supported.

Description::
Returns whether the algorithm defined by the immediate value is supported by the implementation.


[[ACE-instruction-clone]]
==== ace.clone

`ace.clone Cd|Xd, Cs|Xs`

The instruction is encoded using the Form E `ace.exec` encoding:

Encoding::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Cd|Xd' },
    { bits:  3, name: 0x3, attr: ['ace.exec','(Form E)'] },
    { bits:  5, name: 'Cs|Xs' },
    { bits:  5, name: 0x2, attr: ['ace.clone'] },
    { bits:  1, name: 0x0 },
    { bits:  2, name: 'R' },
    { bits:  4, name: 0x0 },
]}
....

Bits [27:26], i.e., field `R`, take following values depending on how the contexts are
referred:

[upperalpha]
. `0b00` if the source and the output contexts are both encoded as immediates.
. `0b01` if the source context is selected using a GPR and the output context is encoded as an immediate.
. `0b10` if the source context is encoded as immediate and the output context is selected using a GPR.
. `0b11` if the source and the output contexts are both selected using the values of GPRs.

// Comment to ensure the proper indentation in th next Description

Description::
Clones source CC `Cs` (or the CC indexed by `Xs`) into destination CC `Cd` (or
into the CC indexed by `Xd`).


NOTE: We note that certain attacks may be mounted on primitives if the same state can
be re-used (for instance encryption with the same counter), but this cannot be
prevented even if this instruction were not available, since a state can be
exported and re-imported as-is several times. `ace.clone` is just an
optimization for an `ace.export` instruction followed by an `ace.import`
instruction.

==== ace.derive (optional)

`ace.derive Cd|Xd, Cs|Xs`

The instruction is encoded using the Form E `ace.exec` encoding:

Encoding::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Cd|Xd' },
    { bits:  3, name: 0x3, attr: ['ace.exec','(Form E)'] },
    { bits:  5, name: 'Cs|Xs' },
    { bits:  5, name: 0x3, attr: ['ace.derive'] },
    { bits:  1, name: 0x0 },
    { bits:  2, name: 'R' },
    { bits:  4, name: 0x0 },
]}
....

Bits [27:26], i.e., field `R`, is encoded exactly as for `ace.clone` (cf.{nbsp}<<ACE-instruction-clone>>).

Description::
The instruction is used to derive a new context from an existing one.
It is similar to `ace.clone`, but the derived context is not a copy of the source context,
rather, it is a new context that is derived from it.

NOTE: This can be useful for creating new contexts that contain, for instance, derived keys, while
ensuring that they are also opaque.
If more than one derived keys are needed, the instruction can be used multiple times, and
the state of the source CC will need to keep track of the step, such as an index. +
 +
Alternatively, if the derived keys need additional inputs, these can be provided by using
`ace.stage`, then the output-less versions of `ace.exec` with an appropriate message, and
finally `ace.derive` according to rules defined in the specification of the algorithm
encoded in the source context.

[[ACE-instruction-stage]]
==== ace.stage/ace.dir

`ace.stage Cd|Xd, #immed` +
`ace.dir Cd|Xd, #immed`

Encoding::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'Cd|Xd' },
    { bits:  3, name: 0x6, attr: ['ace.stage'] },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
    { bits: 12, name: 'imm' },
]}
....

Bit `r` (i.e., bit 15) takes the value 0 if the context is encoded as an immediate,
and it takes the value 1 if a GPR (scalar integer value) is used to reference it.

Description::
Two pseudo-instructions that map to the same instruction. +
 +
`Cn` is the CC in which to set the stage of the internal state machine +
 +
`Xn` is a GPR containing a number from 0 to 31 to dynamically address the
context where we want to change the stage of the internal state machine. +
 +
The `#immed` is a constant from a set of admissible values that are defined for
each algorithm, to manage an internal state machine of said algorithm in case
more stages are needed.


[[ACE-instruction-restrict]]
==== ace.restrict/ace.harden

`ace.restrict   Cd|Xd, Xs` +
`ace.harden     Cd|Xd, Xs`

// Without this comment, the next part is not properly formatted...
Encoding::
The encoding uses the same _opcode_ and _function_ fields of `ace.exec` Form B, however, bit 28 is set.
The source register field then refers to a GPR and not to a vector register.
 +
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Cd|Xd' },
    { bits:  3, name: '001', attr: ['ace.exec', '(Form B)'] },
    { bits:  5, name: 0x0 },
    { bits:  5, name: 'Xs' },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  1, name: 0x1 },
    { bits:  3, name: 0x0 },
]}
....

Bit `r` (i.e., bit 27) takes the value 0 if the context is encoded as an immediate,
and it takes the value 1 if a GPR (scalar integer value) is used to reference it.

Description::
The instruction is   be used to further restrict the use of a CC to specific modes, and the use
of a CC to a specified `ASID` or `VMID` if not previously specified. +
Let `m` be the metadata field in the destination CC. The instruction works as follows:

* Bits [10:9] and [63:25] of the input register `Xs` have the same format as the corresponding bits of the metadata.
* Bits [8:0], [24:11] and 31 of the input register `Xs` are ignored.
* Bits [10:9] can be used to turn on or increase the level of the side-channel protection of the algorithm in the CC, if the microarchitecture supports the corresponding implementation. The levels are defined in <<ACE-SC-protection-levels>>. Downgrading side-channel protection is not permitted, and attempting to do so will result in error ace_err_invalid (cf.{nbsp}<<ACE-error-codes>>).
* A zero in any of the six bits `Xs`[30:25] means that the corresponding policy is not changed.
* A one in the any of the four bits `Xs`[28:25] means that USE by the corresponding mode is forbidden, and the corresponding bit in the metadata of the destination CC is set to 1.
* If `Xs`[29] is set and `m`[29] is NOT set, then Use_Policy_3 is set using `Xs`[22:7].
* If `Xs`[30] is set and `m`[30] is NOT set, then Use_Policy_4 is set using `Xs`[38:23].
* If `Xs`[29] and `m`[29] are both set and `Xs`[47:32] <> `m`[47:32], or if `Xs`[30] and `m`[30] are both set and `Xs`[63:48] <> `m`[63:48], then the error field of `acecsr` is set to ace_error_invalid.

==== ace.input (optional)

`ace.input Cd|Xd, [Xn]`

[.red]#(TBdetermined whether it is secure)#
This instruction is trappable and may also be resumed or restarted.

==== ace.output (optional)

`ace.output [Xd], Cs|Xs`

[.red]#(TBdetermined whether it is secure)#
This instruction is trappable and may also be resumed or restarted.

==== ace.error

`ace.error Xd, Cs|Xs`

Description::
A CC `Cs` (or indexed by `Xs`) may be in an error state due to the previous
operation. The corresponding error value is written into GPR `Xd`.

This is implemented as a CSR read operation, reading the error field of
`acecsr` and masking it.

The error value list must be architected.

// ==== ace.vr_busy
//
// `ace.vr_busy   Vd`
//
// Can be CSR read operation.
// It will return 1 or 0 whether there is at least one running ACE operation expected to write on the vector register `Vd`.
//
// ==== ace.cc_busy
//
// `ace.cc_busy   Cd|Xd`
//
// Can be CSR read operation.
// It will return 1 or 0 whether there is at least one running ACE operation using the given CC.

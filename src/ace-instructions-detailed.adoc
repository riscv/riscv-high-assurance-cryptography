=== Instructions

In what follows, the notation `Cn|Xn` refers to a CC directly (i.e., the
integer `n` is a 5-bit field in the instruction encoding) or a GPR containing a
number from 0 to 31 to indirectly refer to a CC.  In general, six bits are
needed to select a CC, to take into account the possibility of indirect
addressing.

NOTE: These encodings are just example encodings, and may not be the final
encodings. They serve as a starting point for discussion and refinement as
well as a proof that, at the time of this writing, the ACE instruction set
can be encoded.

NOTE: ACE seems to be an ideal candidate for the Composable Custom Extensions
framework.


==== ace.enable/ace.disable

`ace.enable` +
`ace.disable`

Description::
Enable/Disable the feature in the current process domain and (*TBD*) determine
how many contexts we need (can also be all/none) This is a pseudo-operation for
a write to a WARL CSR.

This instruction must be issued before using any ACE operation. It enables the
CCs and the instructions and also sets a bit in a CSR signaling that the
feature is used. When a process domain that has enabled ACE is preempted, the
parent process inherits the state. otherwise it would not be able to export and
re-import the CCs.
The operation is implemented as a CSRW.

When disabling:

* Care is necessary in the design to allow a locking disablement without
  erasing the registers when a parent gives control back to a child process
  that does not use the feature.

==== ace.init

`ace.init Cd|Xd, %offset(Xs)`

Encodings::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'Cd' },
    { bits:  3, name: 0x4, attr: ['ACE.Init'] },
    { bits:  5, name: 'rs1' },
    { bits: 12, name: 'imm', attr: ['offset'] },
]}
....
//
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x5, attr: ['ACE.Init'] },
    { bits:  5, name: 'rs1' },
    { bits: 12, name: 'imm', attr: ['offset'] },
]}
....


Description::
`Cd` is the source CC to be configured (encoded as a 5-bit immed). +
`Xd`, alternatively, is a GPR containing a number from 0 to 31 to select the context
to be configured. +
GPR `Xs` points to the region of memory containing the metadata and the key material.

Configures a CC with metadata and key, or using an index in the System Key Table.

[.red]#(TBdetermined whether it is secure)#
This instruction is trappable and may also be resumed or restarted.

==== ace.clear

`ace.clear Cd|Xd`

Encodings::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'Cd' },
    { bits:  3, name: 0x6, attr: ['ACE.Clear'] },
    { bits:  5, name: 0x0 },
    { bits: 12, name: 0x0 },
]}
....
//
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x7, attr: ['ACE.Clear'] },
    { bits:  5, name: 0x0 },
    { bits: 12, name: 0x0 },
]}
....

Description::
`Cd` is the source CC to be configured (encoded as a 5-bit immed). +
`Xd` alternatively, is a GPR containing a number from 0 to 31 to select the context to be configured. +
`Xs` is GPR with the pointer to the region of memory containing the metadata and the key material.

Configures a CC with metadata and either key material or index in the Immutable System Key Table.

==== ace.export

`ace.export %offset(Xd), Cs|Xs`

Encodings::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'imm[4:0]' },
    { bits:  3, name: 0x0, attr: ['ACE.Export'] },
    { bits:  5, name: 'Xd' },
    { bits:  5, name: 'Cs' },
    { bits:  7, name: 'imm[11:5]' },
]}
....
//
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'imm[4:0]' },
    { bits:  3, name: 0x1, attr: ['ACE.Export'] },
    { bits:  5, name: 'Xd' },
    { bits:  5, name: 'Xs' },
    { bits:  7, name: 'imm[11:5]' },
]}
....

Description::
`Cs` is the source CC to be exported (encoded as a 5-bit immed). Alternatively,
the number of context from which to export the CC is stored in the GPR `Xs` as
a number from 0 to 31. `Xd` is the GPR base address of the buffer where to
store the SCC.

Exports the contents of CC `Cs` to memory, starting at address `Xd`. Depending
on the type and policies of the key — which are stored in the metadata of `Cs`,
the CCWK can be either the CTK CSR or a Locale specific CTK derived from the
CTK.

The instruction (resp. `ace.import`) writes (reads) the entire internal state
of a CC or information needed to reconstruct an equivalent state — the
instruction shall be resumable in case of interrupts. This is similar to
entire-vector-register store instructions, that appear to other harts as
sequences of individual stores. If the context `Cs` is clear or does not exist
in the microarchitecture, the operation will report an error.

[.red]#(TBdetermined whether it is secure)#
This instruction is trappable and may also be resumed or restarted.

//(The SW should have the right information, so this should never happen).

==== ace.import

`ace.import Cd|Xd, %offset(Xn), S`

Encodings::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'Cd' },
    { bits:  3, name: '00S', attr: ['ACE.Import'] },
    { bits:  5, name: 'Xn' },
    { bits: 12, name: 'imm' },
]}
....
//
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: '01S', attr: ['ACE.Import'] },
    { bits:  5, name: 'Xn' },
    { bits: 12, name: 'imm' },
]}
....

Description::
`Cd` is the destination CC to be imported, as an immed (5-bit). Alternatively,
the number of context into which import the SCC is stored in the GPR `Xd` as a
number from 0 to 31. `Xn` is the GPR containing the base address of the buffer
with the SCC.

S takes the values 0 (false) or 1 true (1).
It is set to true if the key is in a system defined format and not the format
defined by the present architecture.

NOTE: There is no further specification as to
what the system defined format is in the encoding of the instruction, and in
case more than one system defined format is defined, the data format itself
must distinguish between them.  In other words, it is the responsibility of
the system to augment all the system defined formats with a unique identifier
that can be used to distinguish between them.

This means that system HW dynamically generated keys can be imported but not
exported in the same form — but, once exported, they must be in the architectural
format. If the value cannot be exported to other devices or to other Locale
stages of the same device, the internal logic must bind them to a specific
Locale CTK). The instruction imports them like SW keys, but only
internally, and sets the right policies.

[.red]#(TBdetermined whether it is secure)#
This instruction is trappable and may also be resumed or restarted.

==== ace.exec

The instruction admits four Types, namely

[upperalpha]
. `ace.exec  Vd, Cn|Xn, Vs` -- which takes an input vector and writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}{nbsp}Cn|Xn, Vs` -- which takes an input vector but does not write to an output vector.
. `ace.exec  Vd, Cn|Xn{nbsp}{nbsp}{nbsp}{nbsp}` -- which does not take an input but writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}{nbsp}Cn|Xn{nbsp}{nbsp}{nbsp}{nbsp}` -- which does not take an input vector and does not write to an output vector.

Type D instructions just perform internal processing in the CC.

// Without this comment, the next part is not properly formatted...
Encoding::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Vd' },
    { bits:  3, name: 'ACE.exec' },
    { bits:  5, name: 'Cn|Xn' },
    { bits:  5, name: 'Vs' },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....

Bit `r` (i.e., bit 27) takes the value 0 if the context is encoded as an immediate,
and it takes the value 1 if a GPR (scalar integer value) is used to reference it.
For the four Types A-D above, the encodings are:

[upperalpha]
. `ACE.exec` = `0b000`.
. `ACE.exec` = `0b001` and `Vs`=`0b00000`.
. `ACE.exec` = `0b010` and `Vd`=`0b00000`.
. `ACE.exec` = `0b011` and `Vs`=`Vd`=`0b00000`.

Furthermore, we admit a variant of Type D to encode additional instructions:
[upperalpha,start=5]
. `ACE.exec` = `0b011` with `Vs` <> `0b00000`, and possibly more non-zero values in bits [31:25].

// To make indent in next line correct

Description::
Performs a cryptographic operation such as an encryption or decryption,
absorbing a value in a hash, and possibly returning a value.
All `ace.exec` instruction may modify the internal state of the CC.

==== ace.size

`ace.size Xd, Cn|Xn`

The instruction is encoded using the Type E `ace.exec` encoding:

Encoding::
[wavedrom, , svg]

....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x3, attr: ['ACE.exec', '(Type E)'] },
    { bits:  5, name: 'Cn|Xn' },
    { bits:  5, name: 0x1, attr: ['ACE.size'] },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....

Bit `r` (i.e., bit 27) takes the value 0 if the context is encoded as an immediate,
and it takes the value 1 if a GPR (scalar integer value) is used to reference it.


Description::
This instruction writes the size of the SCC corresponding to CC `Cn` (or the CC
whose number is in `Xn`) into GPR `Xd`.

Knowing the size of the SCC is important to properly implement any feature that
relies on `ace.export`, for instance context switching.

NOTE: The value can significantly differ from the internal resource usage ot the CC —
it can be larger (for simple primitives, because of the nonce/SIV overhead) but
also smaller (for keys split into shares for threshold implementations, but saved
externally in reconstructed form).


[[ACE-instruction-clone]]
==== ace.clone

`ace.clone Cd|Xd, Cs|Xs`

The instruction is encoded using the Type E `ace.exec` encoding:

Encoding::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Cd|Xd' },
    { bits:  3, name: 0x3, attr: ['ACE.exec','(Type E)'] },
    { bits:  5, name: 'Cs|Xs' },
    { bits:  5, name: 0x2, attr: ['ACE.clone'] },
    { bits:  1, name: 0x0 },
    { bits:  2, name: 'R' },
    { bits:  4, name: 0x0 },
]}
....

Bits [27:26], i.e., field `R`, take following values depending on how the contexts are
referred:

[upperalpha]
. `0b00` if the source and the output contexts are both encoded as immediates.
. `0b01` if the source context is selected using a GPR and the output context is encoded as an immediate.
. `0b10` if the source context is encoded as immediate and the output context is selected using a GPR.
. `0b11` if the source and the output contexts are both selected using the values of GPRs.

// Comment to ensure the proper indentation in th next Description

Description::
Clones source CC `Cs` (or the CC indexed by `Xs`) into destination CC `Cd` (or
into the CC indexed by `Xd`).


We note that certain attacks may be mounted on primitives if the same state can
be re-used (for instance encryption with the same counter), but this cannot be
prevented even if this instruction were not available, since a state can be
exported and re-imported as-is several times. `ace.clone` is just an
optimization for an `ace.export` instruction followed by an `ace.import`
instruction.

==== ace.derive (optional)

`ace.derive Cd|Xd, Cs|Xs`

The instruction is encoded using the Type E `ace.exec` encoding:

Encoding::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Cd|Xd' },
    { bits:  3, name: 0x3, attr: ['ACE.exec','(Type E)'] },
    { bits:  5, name: 'Cs|Xs' },
    { bits:  5, name: 0x3, attr: ['ACE.derive'] },
    { bits:  1, name: 0x0 },
    { bits:  2, name: 'R' },
    { bits:  4, name: 0x0 },
]}
....

Bits [27:26], i.e., field `R`, is encoded exactly as for `ace.clone` (cf.{nbsp}<<ACE-instruction-clone>>).

The instruction is used to derive a new context from an existing one.
It is similar to `ace.clone`, but the derived context is not a copy of the source context,
rather, it is a new context that is derived from it.
This can be useful for creating new contexts that contain, for instance, derived keys, while
ensuring that they are also opaque.
If more than one derived keys are needed, the instruction can be used multiple times, and
the state of the source CC will need to keep track of the step, such as an index.

Alternatively, if the derived keys need additional inputs, these can be provided by using
`ace.stage`, then the output-less versions of `ace.exec` with an appropriate message, and
finally `ace.derive` according to rules defined in the specification of the algorithm
encoded in the source context.

==== ace.stage/ace.dir

`ace.stage Cd|Xd, #immed` +
`ace.dir Cd|Xd, #immed`

Encoding::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'Cd|Xd' },
    { bits:  3, name: 0x6, attr: ['ACE.stage'] },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
    { bits: 12, name: 'imm' },
]}
....

Bit `r` (i.e., bit 15) takes the value 0 if the context is encoded as an immediate,
and it takes the value 1 if a GPR (scalar integer value) is used to reference it.

Description::
Two pseudo-instructions that map to the same instruction.

`Cn` is the CC in which to set the stage of the internal state machine

`Xn` is a GPR containing a number from 0 to 31 to dynamically address the
context where we want to change the stage of the internal state machine.

The `#immed` is a constant from a set of admissible values that are defined for
each algorithm, to manage an internal state machine of said algorithm in case
more stages are needed.

==== ace.input (optional)

`ace.input Cd|Xd, [Xn]`

[.red]#(TBdetermined whether it is secure)#
This instruction is trappable and may also be resumed or restarted.

==== ace.output (optional)

`ace.output [Xd], Cs|Xs`

[.red]#(TBdetermined whether it is secure)#
This instruction is trappable and may also be resumed or restarted.


==== ace.harden

`ace.harden Cd|Xd, flags=level`

Description::
Turn on or increase the level of the side-channel protection of the algorithm
in the CC, if the microarchitecture supports it. The levels are defined in
<<ACE-SC-protection-levels>>.
Downgrading side-channel protection is not permitted, and attempting to do so will result in error ace_err_invalid (cf.{nbsp}<<ACE-error-codes>>).

==== ace.restrict

`ace.restrict   Cd|Xd, Xs`

Description::
Optional.
Can be used to further restrict the use of a CC to specific modes, and the use
of a CC to a specified `ASID` or `VMID` if not previously specified. Cannot
modify a current policy if already set.

Bits [37:0] of the input register `Xs` have the same format as bits [63:26] of
the metadata. + A zero in any of the six least significant bits of `Xs` means
that the corresponding policy is not changed. + A one in the any of the four
least significant bits of `Xs` means that USE by the corresponding mode is
forbidden. + Let `m` be the current metadata in the destination CC. If `Xs`[5]
is set and `m`[30] is NOT set, then Access Policy 3 is set using `Xs`[21:6]. If
`Xs`[6] is set and `m`[31] is NOT set, then Access Policy 4 is set using
`Xs`[35:22]. If `Xs`[5] and `m`[30] are both set, or if `Xs`[6] and `m`[31] are
both set, then the error field of `acecsr` is set to [.red]#*TBD*#.


==== ace.available

`ace.available Xd, Xs`

Description::
Return whether the algorithm defined by GPR `Xs` (this is the value of the
algorithm field of the metadata) is supported by the µarch. The result is
written in `Xd` as true (1) or false (0).

Implement it as CSR read?
*To be discussed* alternative option: the CSR contains a pointer to a memory
mapped bitmap (256 bits, or 1024 bits if we include the side channel resistance
information) or some other architected structure to determine what is
implemented. OTOH this can probably be obtained in other ways (like a
microarchitecture version number).

==== ace.error

`ace.error Xd, Cs|Xs`

Description::
A CC `Cs` (or indexed by `Xs`) may be in an error state due to the previous
operation. The corresponding error value is written into GPR `Xd`.

This is implemented as a CSR read operation, reading the error field of
`acecsr` and masking it.

The error value list must be architected.

// ==== ace.vr_busy
//
// `ace.vr_busy   Vd`
//
// Can be CSR read operation.
// It will return 1 or 0 whether there is at least one running ACE operation expected to write on the vector register `Vd`.
//
// ==== ace.cc_busy
//
// `ace.cc_busy   Cd|Xd`
//
// Can be CSR read operation.
// It will return 1 or 0 whether there is at least one running ACE operation using the given CC.



[WARNING]
====
We need to define the Architectural Contexts as a concatenation of domain strings for each of the levels. (rewrite this)

For instance, if we are not using the Hypervisor extension, then we have strings for User and Supervisor modes.
If we are using the Hypervisor extension, then we have strings for Virtual User, Virtual Supervisor, and Supervisor (Hypervisor) modes.
Let us call these values the Architectural Context Unique Values (ACUV).

So, we have ACUV_U, ACUV_S registers (and values), set by S and M, without the Hypervisor extension, and
ACUV_VU, ACUV_VS, ACUV_VS, set by VS, S, and M, if the the Hypervisor extension is set.
All these registers are WO, and only set by the parent (or grandparent, etc) PL.

They are an alternative to reprogramming the CTK for each SW environment in order to make switching domains faster.
Reprogramming the CTK is still useful for VM migration or to more strongly isolate Worlds.

If there ACUV_xx values are not set by the system, they have a default value of zero.
If the hardware does not support them, then they are not writeable and they are always read as zero, but are otherwise unused.
If the hardware supports them, then there must be a register to lock them, so that they they become WARZ even to the hardware.

Upon configuring a cryptographic context, the environment setting it can either provide values for the ACUV registers, including zeroes (where the zero fields will not be checked), or have them filled by the current ones.  These values are added to the metadata of a Cryptographic Context.

Any parent environment can export and import a Cryptographic Context (CHR) but any other operation can be performed
only if ACUV metadata matches (including the default matching of zero fields).

Q: How do we provide the values to a KMB?

For SW KMBs: send a message through the MM, the MM gets a key from the appropriate KMB, including the ACUVs (which are forwaded by each PL to the one above) then the MM can configure and pass it down.

For HW KMBs: the values are ACUVs automatically retrieved from the hardware (and never exposed to other SW), the KMB provides a properly configured

Several KMBs can be used at the same time, and they can be any combination of SW based and HW based ones.

====

As noted in <<Goals-Regarding-Key-Types>>, different keys may require distinct lifecycles based on specific requirements (e.g., DRM-protected content limited to certain devices).
The same mechanism is used to bind keys to specific domains.

The system manages these lifecycles through:
* Lifecycle and Architectural Contexts information stored in CHR metadata
* Lifecycle Specific Context Transport Keys (LSCTKs) for key export/import


[WARNING]
====
Do we actually need to use a derived key thought? And how to allow, say, an OS running in S mode to properly export and import keys for a process?
====

[[Support-dynamically-generated-system-keys]]
==== Support for dynamically generated system keys

Systems can dynamically generate keys for various purposes. If generated by SW, the key is placed in a CHR and exported. However, HW can also generate keys, especially in complex SoCs with third-party or legacy components that may not produce a format that is compatible with ACE’s SCC formats.

As an example, we consider here an architecture where these keys are delivered using a system defined mechanism. The latter may vary, and it does not necessarily offer the same flexibility as the methods architected in this document, therefore we cannot assume that the system defined mechanism can be used in its place.

At this point, there are two options:
[arabic]
. SoC designers modify the key-providing component to output ACE’s SCC format.
. ACE supports the foreign format by passing a bit-field to the import instruction.

Support for the latter case is provided by a bit-field passed to the import instruction.

After import from the foreign format, the CHR contents can be exported and re-imported exclusively in ACE’s SCC format. If the key is unique or uniquely provided per device or boot, this must be reflected in the metadata, and ACE must enforce this policy.

Other mechanisms, like a pure HW interface, raise significant synchronicity issues and are discouraged for non-constrained embedded environments unless blocking operations are acceptable.

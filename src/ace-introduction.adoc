[[Introduction]]
== Introduction

The ratification plan can be found https://riscv.atlassian.net/wiki/spaces/HACX/pages/484966423/High+Assurance+Crypto+Ratification+Plan[here].

=== Objectives

ACE, the Atomic Cryptographic Extension, is an instruction set extension designed to provide high assurance cryptographic operations.
The main features are the concealment of key values, restrictions on their usage, and support for hardened implementations, with a single, streamlined instruction set.

The development of ACE is prompted by the needs of key use cases such as:
content protection,
local decryption of LLMs,
key management,
identity management,
link encryption,
storage encryption,
//any cryptographic operations for confidential VMs/Enclaves/Realms/TEE,
Secure Boot and/or attestation in bootloaders,
and in general any application where cryptographic operations are required and it is desirable to offer a high level of protection to keys and intermediate values.

ACE is _architected_ as an _attached_ unit, in other words as a coprocessor with a special, fast interface to the CPU.
This is similar to the so-called streaming features of the Arm architecture or Risc-V AME.
An ACE implementation can be shared by multiple cores, with per-hart architectural state, and can operate in parallel with the CPU cores, even if the latter are in-order.
Of course, an implementation integrated into a CPU core is permitted.

=== Features

. ACE is an ISE for full-round, block-wise cryptographic operations without exposing the key.
. ACE supports multiple different cryptographic primitives and modes, including SCA resistant versions.
 Supported algorithms are discoverable. There is a mandatory list of algorithms, optional architected ones, and support for custom algorithms.
. Keys are stored in architectural states called "Cryptographic Contexts" (CC) together with metadata that restricts the usage of the key.
. ACE instructions use CCs instead of directly accessing the keys.
. ACE supports multiple CCs active at the same time.
. There is no mechanism to extract the original value of a key from a CC: CCs are not read/write in the same sense as registers are.
. By writing a key into a CC, a key is thus made _opaque_.
. Besides software, additional optional sources for keys are:
.. A System Specific Key Table (SSK Table);
.. External blocks for dynamic key generation.
. ACE allows isolated, protected, or trusted SW or HW entity to deliver opaque keys to less trusted environments to perform cryptographic operations without getting visibility in the value of the key.
 Once this has been done, the opaque key can be re-used without having to call the trusted entity again.
. ACE can bind an opaque key to a _Locale_ ([.red]#*TBD:* better name?#), defined as a device, a class of devices, a specific hardware or software configuration, a single boot cycle or even, possibly, a specific time period.
. ACE can restrict which process can use a given opaque key. In particular:
.. ACE supports separation of keys belonging to different domains.
.. ACE provides support for key preservation upon process or VM migration.
   Note that by migration here we only understand the transfer of processes and VMs from a device to another, not a migration between harts in the same device.
. ACE scales from from embedded cores to large application/server cores, with same ISA and ABI: certain features may be omitted in smaller cores without requiring changes in User SW.

// The latter is needed for cloud and edge deployment. ACE provides the minimum necessary support to enable secure key migration between machines.

// Currently, this often involves both changing context and potentially blocking operations to program keys or to perform cryptographic operations in cryptographic accelerators. This can result in large delays. ACE enables SW to set and use these keys with reduced overheads.

// ACE can be used to provide hardened primitives for TEEs and TPMs to minimize explicit key handling and reduce the attack surface.
// The cryptographic operations are per-block atomic (“one-shot instructions”), as opposed to common round-based ISAs. Besides the already stated goal of preventing direct key leakage or exposure (which is unavoidable by design in round-based extensions like AES-NI), but also to enable masked implementation for protection against side-channel attacks. The fact that these operations are performed atomically gives the extension its name.
// ACE further reduces the attack surface of key misuse attacks by binding key usage policies to specific algorithms and authorized SW environments.

=== Rationale

ACE is necessary because current solutions are inadequate:

* Round-based ISAs need to explicitly add the key between the rounds.
* Current ISAs do not provide trustworthy mechanisms for cryptographic operations. Trust is provided only in external IP blocks or by relying on costly context switch to TEEs (TZ, etc) for each cryptographic operation.
* External blocks with memory mapped or coprocessor interfaces incur heavy overheads and need substantial support in system stack.
* Key Management (resp. KM building blocks) is not provided — except in external IP blocks.
* In modes such as AES-GCM-SIV, encryption and authentication derived keys should also not leak, hence supporting primitives only is not always sufficient.
* No current standardized or architected solution offers fast execution, key management, and trust.

=== Further Features

To be practical and address the limitations of existing solutions, ACE must provide features that reduce the number of expensive environment switches and provide efficient support for software-managed context switching. Consequently, while the value of a key cannot be read from a Cryptographic Context (CC), a secure mechanism is required to export a CC's contents—preserving the confidentiality and integrity of both the key and its associated metadata.

//[start=10]
. ACE allows software to securely export the contents of a CC to memory by encrypting and authenticating it, as a "Sealed Cryptographic Context" (SCC).
  A SCC can then be authenticated, decrypted, and re-imported into a CC.
.. Any metadata that does not need to be encrypted is kept in the clear.
.. Since we have public and private metadata, and keys (obviously private), we need to use an AEAD mode of operation for the export/import operations (AES-GCM-SIV as per RFC 8452).
.. Since an AEAD mode of operation is needed, ACE exposes (a variant of) it to user. For this reason, we support modes in general in ACE.
. A Cryptographic Context Transport Key (CTK) is required for import and export operations. Optionally, ACE permits Machine mode to configure the CTK. When configurable, the CTK is held in 256 bits of CSRs that are writable only by Machine. This configurability enables domain separation: if Machine assigns distinct CTKs to different domains, a domain cannot authenticate or decrypt a Sealed Cryptographic Context (SCC) created for another domain.
. If the CTK is not configurable, it may be either a fixed value or randomly generated at boot.
. ACE provides a key-derivation mechanism that computes a Derived CTK from the current CTK and a secret salt tied to a specific _Locale_. Changing this _Locale-Specific Secret_ (LSS) also changes the corresponding Derived CTK, automatically invalidating any Sealed Cryptographic Contexts (SCCs) that were exported with the previous LSS value.

We apply the term “*opaque keys*” to both keys in CCs and SCCs. Opaque keys are cryptographic keys that can be used without revealing their value.
“Opaque” means the actual key value cannot be extracted from a CC or SCC.
The environment that generated the key will of course know its value.


=== Non-Features

Certain features are intentionally not supported by ACE:

* ACE does not provide debugging support; the internal representation of a Cryptographic Context remains concealed even when debug features are active.
* ACE does not support the processing of variable-length ciphertext or plaintext inputs.
* ACE does not provide a complete secure key management and provisioning system. Instead, it offers architectural building blocks that can be used to implement such systems. Key management can be delegated to applets within a TEE or secure VM, which may be owned by different parties. These applets can implement complex key management software. The architecture enables trusted entities to establish and deliver opaque keys to less-trusted software domains. ACE does not support external schemes for directly provisioning keys into a key store.
* ACE, in its current version, does not provide a key revocation mechanism. This is a complex feature requiring additional infrastructure and coordination, for a relatively rare event. +
The current architecture partially supports key revocation by binding keys to a _Locale_ that can be invalidated by a revocation message. If the derived CTK for a key is invalidated, any process using it must re‑acquire the key from the provisioning entity; if the key has been revoked within that entity, re‑acquisition will fail. Note that keys already loaded into CCs can still be exported, as ACE does not define a mechanism to revoke keys once they reside in a CC.  We envision that a future version of ACE may allow implementations to assign an optional 64‑ or 128‑bit identifier to each key and issue a system‑wide broadcast instructing all ACE units to erase CCs whose identifier matches a revoked key.
* ACE cannot fully prevent misuse by compromised processes. If a process is compromised, the attacker obtains access to the CCs and can perform cryptographic operations — even if they do not elicit the key. Therefore, ACE complements existing security measures such as SW vulnerability exploitation countermeasures and process isolation (including TEE-like inverse sandboxing).
* Other risks remain. For instance, in counter-mode encryption, the same method enables both encryption and decryption, hence a malicious process may be able to misuse these operations.


=== High Level View of the Extension

The most important instructions provided by ACE are the following:

. `ace.init`,  to load the clear value of a key (and some metadata) in a Cryptographic Context (CC);
. `ace.clear`, to erase/invalidate the content of a CC;
. `ace.export`, to encrypt and authenticate a CC and store it to memory as a SCC;
. `ace.import`, to authenticate, decrypt a SCC from memory and import it into a CC;
. `ace.exec`, to perform a cryptographic operation on a block (e.g., 128 bits) of the input;
. `ace.stage/ace,dir`, to configure the CC for encryption/decryption or move from one stage of an algorithm to another; and
. `ace.error`, to report an error condition, which can be implemented as a read operation from a CSR.

Other instructions are provided and these will be discussed in detail later.

The inputs and outputs of the ACE operations are:

. Cryptographic Contexts,
. Vector registers (however, see <<ace-remark-vector-registers>>), and
. External memory. Memory is addressed using GPRs.

CCs are referred by a 5-bit immediate value or by the value of a GPR. +
They are denoted by `Cn`, with `n` in [0..31].

Regarding the access control policies in a CC's metadata, we must distinguish between initial (i) configuration, (ii) usage, and (iii) import/export of a CC.
These three types of operations cannot always obey the same policies — otherwise there would be opportunities for malicious adversaries to perform Denial-of-Service attacks on the ACE resources.
As a general rule, the access control policies only limit `ace.exec` and `ace.stage` operations.
This also means that it is always possible to clear, export a CC, and configure a CC or import a SCC into a CC, even if the latter two operations
directly overwrite an already configured CC, which implies that the previous state is discarded (TBD: we are discussing whether optional limitation to import and export can be added as well and how).

[[ace-remark-vector-registers]]
*Remark {counter:remark}*:: [.red]#_Alternatives can be discussed: By using a configuration bit, we can instead use pairs of 64-bit GPRs or quartets of 32-bit GPRs. We also have `ace.input` and `ace.output` instructions that load an input from memory, resp., store output to memory.
Since no other change would be needed in the entire architecture, we suspend further discussion on this until later.
For 256-bit wide ciphers, we may need to group more GPRs, whereas the vector unit allows easier resizing or spilling into the next register._#



==== Differences been Cryptographic Contexts and Architectural Registers

The size of the data in a CC is variable, and this size is independent for each CC — this is an important difference with respect to GPRs and vector registers, which always have the same size. The total amount of internal "register memory" for CCs can also be exhausted when a subset of the CCs are used.
CCs contain different fields: metadata, key material, and internal state.
All three need to be architected.

The fact that CCs can be addressed indirectly has two implications:

. Adding renaming to to CCs would complicate the microarchitecture too much. Luckily, we can assume that are changed rarely, except for internal implied changes, and therefore we can assume that CCs are not renamed without performance issues.
. We need to use one bit in the instruction encoding to determine whether a CC is given by an immed or by a GPR. (Two bits for the `ace.clone` operation.)


==== Remark on the Formats for the Cryptographic Contexts

Before we proceed, we need to point out that there are different representations of the same object:

* The input format of key + metadata in the clear in memory for the initial configuration of a CC.
* What we call the CC proper, i.e. the internal representation of a key + metadata + additional state.
* The format of a SCC, defined by the format of the plaintext and its encryption and authentication method.

The first and third formats are architected, whereas the second one is `impdef`, i.e., the internal representation of the CC is left to the implementor of the microarchitecture.  However, we still define the minimum of information that must be stored in a CC, to the very least the same information that is stored in a SCC, and in some cases additional information that is specific to the algorithm or to the implementation.

This also means that the maximal size of the data inside a CC is `impdef` as well, and this size in general differs from the size of the initial information  required to configure a CC as well as from the size of a SCC.

// One may observe that, on a single implementation, as long as export and import use the same formats, there would be no need requirement for the SCC format to be standardized?
There are two reasons for architecting the configuration and SCC formats.
The first one is interoperability: even on SoC by a single manufacturer there may be IP blocks defined by various designers.
We want to make sure that an IP block can use the same SCCs as a different IP block.
// Defining this format will simplify implementation.
The second reason is that moving VMs from a machine to another is a quite common process, not only in the cloud, even in the consumer space.
Customers therefore will not only create a VM on a client machine and upload it to the cloud, or locally generate keys that are then provisioned to a cloud VM, but the often carry a VM from an old client device to a new one, for instance a laptop with an intel CPU to an AMD laptop.
This implies not only that a single, architected format is desirable, but also that a mechanism for transferring a CTK from a device to another is necessary.

==== Remark On ACE Instructions that Access Memory

The instructions `ace.init`, `ace.export` and `ace.import` directly access memory.
This does not contradict the principle of load/store architectures because ACE is architected as an _attached_ unit, not as a component of the CPU core.
Therefore it can have its own state and its own LSU.
Beside this, `ace.init`, `ace.export` and `ace.import` can also be viewed as special load/store instructions which need to do something "under the hood" in order to maintain the security guarantees of confidentiality and integrity of the key material.

While splitting these instructions into multiple ones is possible, even reducing configuring, importing and exporting to block-wise instructions, we find that this is undesirable because it would require the ACE implementation to keep the same internal state as with the composite instructions, for the purpose of implementing authentication and encryption, and would restrict the way these operations are implemented, while adding significant complexity to SW using the extension.

=== An Example

In the following example, a process wants to AES-encrypt some data using a key they are not allowed to know, which belongs to a recipient.

.Simple Example: Encryption, no Authentication
[%linenums,C]
----
Call OS API to get the necessary SCC. X5 points to the SCC.
Allocate memory for ciphertext buffer.
ace.import C0, [X5]                  // Import the SCC into CC C0
ace.error X1, C0
If X1 <> 0 then handle error
Configure vector unit to use 128-bit vectors.
ace.stage C0, #ace_const_encrypt
ace.error X1, C0
if X1 <> 0 then handle error         // If encryption is not allowed
for i = 0 to ceil(len_in_bytes(plaintext)/16)-1 do
    load V0 from *(plaintext+16*i)
    ace.exec V0, C0, V               // Encrypt one block of the plaintext
    store V0 at *(ciphertext+16*i)
----

=== Supported Algorithms

We architect support for several algorithms, and also define a minimal subset (current suggestion):

* AES-128 and AES-256 encryption and decryption.
* AES-CTR, AES-GCM, AES-GCM-SIV, AES-XTS, AES-CMAC using AES-128/256.
* SHA-2, SHA-2-HMAC.

The list of other architected algorithms is TBD, but it should include at least

* AES-192, alone and with the above modes.
* SM4 Block Cipher.
* The Ascon suite (Ascon-128/128a-AEAD, Ascon-Hash, Ascon-XOF, Ascon-80pq).
* SHA-3, SHA-3-HMAC.
* SM3 Secure Hash.

The list can be extended by the architecture owner.
There is an interval of the algorithm encoding space in the metadata for custom algorithms.


=== Alternative Inputs and Outputs

Throughout this document, the cryptographic inputs and outputs for all `ACE` operations are vector registers.
A priori, we do not exclude versions of the specification that use only GPRs, however this is currently out of scope, and if the need arises, this should be architected as well.
We will also define a subset of the `V` extension that specifies only the vector registers, unit-strided load and stores, and a subset of vector operations including insert, extract, and logical operations, and possibly some additional ones. The goal is that code written against `ACE` and this subset of `V` shall run on any Risc-V core implementing `ACE`.

[comment]
--
=== Terminology

The description in this document applies to various computing architectures, and it is not limited to just a particular one.

In what follows we assume a system with up to four exception levels or modes.

* EL0 / User
* EL1 / Supervisor / Virtual Supervisor (i.e., OS)
* EL2 / Hypervisor / Supervisor
* EL3 / Monitor / Machine (DEVS-mode)

In this document we use the terms User/Supervisor/Hypervisor and Monitor.

Any process runs in a process domain which is in a specific mode.
Any process can be pre-empted into its own parent.
The processes managed by a parent are its children.
The processes under the same parents are the siblings.
--

We do not make assumptions on the size and addressability of Control and Status Registers (CSRs).
When we write “We need a 256-bit CSR to store a global key” it can mean a single memory mapped register, an ad-hoc addressable set of 8 32-bit CSRs, or of 4 64-bit CSRs, etc…

GPRs are denoted by `Xn`.

Vector Registers are denoted by `Vn`.

=== Outline

The remainder of this document describes the extension in full detail.

//In <<Details>> the technical details of the architecture are presented, including a listing of the instructions and their semantics.

[[Introduction]]
== Introduction

(The ratification plan can be found https://riscv.atlassian.net/wiki/spaces/HACX/pages/484966423/High+Assurance+Crypto+Ratification+Plan[here].)

The _Atomic Cryptography Extension_ (ACE) provides an interface to high-performance cryptographic operations without giving software visibility into the keys.
(((design, high performance)))
The design of ACE has been motivated by use cases such as key and identity management, content protection (including local LLM decryption), link and storage encryption, and attestation.

ACE provides the following features:

* ACE protects secret information such as keys from exposure to software by performing cryptographic operations atomicallyâ€”for example, a complete AES block encryption/decryption or a full hash round sequence between message injections. This is in contrast to common round-based ISAs that expose the keys that must be added between cipher rounds or MAC algorithm stages.
* ACE provides a unified interface to multiple cryptographic primitives, avoiding the need for separate instructions per primitive.
* Supporting only cryptographic primitives is insufficient for modes such as AES-GCM-SIV, XTS, and OCB, because leakage of derived keys or intermediate values can compromise their security. Hence, ACE also supplies modes of operation and secure key derivation.
* The same interface can support SCA-resistant implementations of the algorithms.
* To prevent misuse, ACE associates the secret information with metadata that restricts the usafe of the former to a specific algorithm and can optionally constrain usage by process/VM, security state, and other policies. ACE then treats the metadata and the secret information as a single entity, called a Cryptographic Context (CC).
* CCs can be created and provisioned by trusted software or hardware entities, or they can be supplied by user software to itself to limit key exposure and take advantage of increased performance or of side-channel-protected implementations.
* ACE scales from embedded to server cores with a unified ISA and ABI.
* ACE is compatible with VM migration.
(((design, scalable)))
(((VM migration)))

=== Algorithms

An incomplete list of supported algorithms includes AES-128 and AES-256 encryption and decryption (ECB modes),
CTR, GCM, GCM-SIV, XTS, and CMAC algorithms using AES-128/256, but possibly also other block ciphers such as, for instance, SM4.
Hash functions include at least SHA-2, SHA-2-HMAC.
The interface offered by ACE can also be used to provide support for public key algorithms, including post-quantum ones.

[[ACE-introduction-non-features]]
=== Non-Goals

ACE intentionally excludes the following:

* **Debugging support:** The internal representation of a CR remains concealed even during debug.
* **Variable-length ciphertext and plaintext inputs:** Plaintext and ciphertexts, as well as messages of which digests are computed, are processed in fixed-size blocks.
* **Complete key management:** ACE provides only architectural building blocks that can be used for key management, where the key management logic resides in trusted software (e.g., TEE applets).
  ACE does not support external schemes for directly provisioning keys into a key store.
  Instead, it will be a local trusted SW or HW component that manages external schemes and, with the thusly obtained keys and policies, then configures CCs for the ACE unit.
* **Key revocation:**
The present specification does not include a key revocation mechanism.
While future versions may be architected to support revocation, such functionality is excluded here to avoid architectural and implementation complexity. The rationale is as follows:
. ACE is designed to prioritize performance and flexibility (for example, algorithmic abstraction). Comprehensive revocation mechanisms, such as usage counters or revocation lists, would potentially degrade performance and significantly increase the complexity of an implementation.
. Enforcing a universal revocation mechanism is impractical due to the diversity of protocols used by different key providers. Additionally, managing potentially large revocation data structures within the ACE unit is complicated by the need for secure memory access: The ACE unit would both have to be agnostic to the external software stack's memory management and support a mechanism for securely obtaining protected memory from it.
Isolated software components (e.g., enclaves, realms, TrustZone applets) are better suited to handle these protocols, their data structures, and their updates, as they are designed to integrate with the local stacks' memory management.
. Revocation typically targets root keys. Since user software generally uses derived keys, such as session keys, it suffices that revocation be handled by the trusted entity managing the root keys.
. Applications that require direct software use of master keys (for instance for link and storage encryption) are usually limited to high-privilege environments. ACE is of course available to such environments as well.

* **Prevention of misuse by compromised processes:**  ACE cannot fully prevent misuse by compromised processes, as these processes may still get access to CCs.
ACE complements existing SW vulnerability exploitation countermeasures and process isolation, but cannot replace them.
Furthermore, in certain modes, such as in counter-mode encryption, the same method enables both encryption and decryption, potentially enabling misuse by malicious processes. This type of risk cannot be mitigated by ACE.

[[ACE-outline]]
=== Outline

The remainder of this document describes the extension in full detail.

[.darkred]#*Discussion point:* _Can optional limitations even to import and export make sense and be useful?#_

[.darkred]#*Discussion point:* _Everything in this specification is still valid if the number of CRs is reduced to, say, 8. Immediate values to refer to CCs are still 5 bits long because the same field can also be used to refer to a GPR, but the only valid values for the CR number are 0 to 7._#

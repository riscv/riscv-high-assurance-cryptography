[[Introduction]]
== Introduction

(The ratification plan can be found https://riscv.atlassian.net/wiki/spaces/HACX/pages/484966423/High+Assurance+Crypto+Ratification+Plan[here].)

The _Atomic Cryptography Extension_ (ACE) provides an interface to high-performance cryptographic operations without giving software visibility into the keys.
(((design, high performance)))
The design of ACE has been motivated by use cases such as key and identity management, content protection (including local LLM decryption), link and storage encryption, and attestation.

=== Features

ACE provides the following features:

* ACE protects secret information such as keys from exposure to software by performing cryptographic operations atomicallyâ€”for example, a complete AES block encryption/decryption or a full hash round sequence between message injections. This is in contrast to common round-based ISAs that expose the keys that must be added between cipher rounds or MAC algorithm stages.
* ACE provides a unified interface to multiple cryptographic primitives, avoiding the need for separate instructions per primitive.
** Supporting only cryptographic primitives is insufficient for modes such as AES-GCM-SIV, XTS, and OCB, because leakage of derived keys or intermediate values can compromise their security. Hence, ACE also supplies modes of operation and secure key derivation.
** ACE also defines how CTR, GCM, CMAC algorithms can be exposed through its interface, and not only instantiated with AES-128/256, but also with other block ciphers like, for instance, SM4.  Hash functions are architected as well.
** The same interface can support SCA-resistant implementations of the algorithms.
** In fact, it can also be used to provide access to public-key and post-quantum algorithms.
* To prevent misuse, ACE associates the secret information with metadata that restricts the usafe of the former to a specific algorithm and can optionally constrain usage by process/VM, security state, and other policies. ACE then treats the metadata and the secret information as a single entity, called a Cryptographic Context (CC).
* CCs can be created and provisioned by trusted software or hardware entities, or they can be supplied by user software to itself to limit key exposure and take advantage of increased performance or of side-channel-protected implementations.
* ACE scales from embedded to server cores with a unified ISA and ABI.
* ACE is compatible with VM migration.
(((design, scalable)))
(((VM migration)))

[[ACE-introduction-non-features]]
=== Non-Goals

ACE intentionally excludes the following:

* **Debugging support:** The internal representation of a CR remains concealed even during debug.
* **Variable-length ciphertext and plaintext inputs:** Plaintext and ciphertexts, as well as messages of which digests are computed, are processed in fixed-size blocks.
* **Complete key management:** ACE provides only architectural building blocks that can be used for key management, where the key management logic resides in trusted software (e.g., TEE applets).
  ACE does not support external schemes for directly provisioning keys into a key store.
  Instead, it will be a local trusted SW or HW component that manages external schemes and, with the thusly obtained keys and policies, then configures CCs for the ACE unit.
* **Key revocation:**
The present specification does not include a key revocation mechanism.
While future versions may be architected to support revocation, such functionality is excluded here to avoid architectural and implementation complexity.
In detail, the rationale is:
. ACE is designed to prioritize performance and flexibility (for example, algorithmic abstraction). Comprehensive revocation mechanisms, such as usage counters or revocation lists, would potentially degrade performance and significantly increase the complexity of an implementation.
. Enforcing a universal revocation mechanism is impractical due to the diversity of protocols used by different key providers. Additionally, managing potentially unbounded revocation data structures within the ACE unit is complicated by the need for secure memory access: The ACE unit would both have to be agnostic to the external software stack's memory management, support a mechanism for securely obtaining dynamically managed protected memory from it, and trust that this memory provides strong protection against tampering. These are the guarantees offered by isolated software components such as enclaves, realms, TEE applets, which are already designed to integrate with the local stack while providing the required security guarantees.
Therefore, they are better suited to handle these protocols, their data structures, and their updates in their entirety.
. Revocation typically targets root keys. Since user software generally uses derived keys, such as session keys, it suffices that revocation be handled by the trusted entity managing the root keys.
. Applications that require direct software use of master keys (for instance for link and storage encryption) are usually limited to high-privilege environments. ACE is of course available to such environments as well.

* **Prevention of misuse by compromised processes:**  ACE cannot fully prevent misuse by compromised processes, as these processes may still get access to CCs.
ACE complements existing SW vulnerability exploitation countermeasures and process isolation, but cannot replace them.
Furthermore, in certain modes, such as in counter-mode encryption, the same method enables both encryption and decryption, potentially enabling misuse by malicious processes. This type of risk cannot be mitigated by ACE.

[[ACE-outline]]
=== Outline

The remainder of this document describes the extension in full detail.

[WARNING]
We could have used `L` in this document instead of `ACE` and `ace`, but we haven't changed it yet since a different `misa` bit and a different letter may ultimately be allocated to the extension.

[WARNING]
*Discussion point:* Can optional limitations even to import and export make sense and be useful?

[WARNING]
*Discussion point:* Everything in this specification is still valid if the number of CRs is reduced to, say, 8. Immediate values to refer to CCs are still 5 bits long because the same field can also be used to refer to a GPR, but the only valid values for the CR number are 0 to 7.

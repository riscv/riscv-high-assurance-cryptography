[[Introduction]]
== Introduction

#(The ratification plan can be found https://riscv.atlassian.net/wiki/spaces/HACX/pages/484966423/High+Assurance+Crypto+Ratification+Plan[here].)#

The _Atomic Cryptographic Extension_ (ACE) provides support for high assurance cryptographic operations.
The main features are the concealment of the values of keys and other secrets, restrictions on their usage, and support for multiple cryptographic algorithms as well as hardened implementations.

The design of ACE is prompted by the needs of key use cases such as:
content protection,
local decryption of LLMs,
key management,
identity management,
link encryption,
storage encryption,
Secure Boot and/or attestation in bootloaders, and in general any application where cryptographic operations are required and it is desirable to offer a high level of protection to keys and intermediate values.

ACE is architected to behave like an _attached_ unit, that is, like a coprocessor with a dedicated, low-latency interface to the CPU core.
In particular, interrupts need not stop cryptographic operations being performed by the ACE implementations, and the implementation may decide that the CPU pipeline may be stalled only when the mode into which the hart is being trapped needs to save the ACE state.
Page faults or other memory-subsystem related interrupts however may require restart or resumption of certain operations.

This model is analogous to streaming accelerators in other architectures.
An ACE implementation may be shared by multiple harts, each maintaining its own architectural state, and can operate concurrently with CPU cores, including in-order cores.  This does not prevent integrated implementations: we specify only the behavior of the extension, not its implementation details.

[[ACE-introduction-features]]
=== Features

. ACE is an ISE for full-round, block-wise cryptographic operations without exposing the key.
. ACE supports multiple different cryptographic primitives and modes, including SCA resistant versions.
  There is a mandatory list of algorithms, optional architected ones, and support for custom algorithms.
. Keys are stored in architectural states called _Cryptographic Contexts_ (CC) together with metadata that restricts the usage of the key.
 * There is no mechanism to extract the original value of a key from a CC: CCs are not read/write in the same sense as registers are.
   We call a key written into a CC _opaque_.
 * Besides software, additional sources for configuring CCs include a System Key Table, and external blocks for dynamic key generation.
. ACE instructions use CCs instead of directly using the key values.
. ACE supports multiple CCs active at the same time.
. ACE enables trusted entities to provision opaque keys to less-trusted environments, enabling the latter to perform cryptographic operations without exposing the key value.  Once provisioned, the opaque key can be reused without further interaction with the trusted entity.
. ACE can bind an opaque key to a _Locale_ ([.red]#*TBD:* better name?#), defined as a device, a class of devices, a specific hardware or software configuration, a single boot cycle or even, possibly, a specific time period.
. ACE can restrict which process can use a given opaque key. In particular:
 * ACE supports separation of keys belonging to different domains.
 * ACE supports key preservation upon process or VM migration from a device to another.
. ACE scales from from embedded cores to large application/server cores, with same ISA and ABI: certain features may be omitted in smaller cores without requiring changes in User SW.

// The latter is needed for cloud and edge deployment. ACE provides the minimum necessary support to enable secure key migration between machines.

// Currently, this often involves both changing context and potentially blocking operations to program keys or to perform cryptographic operations in cryptographic accelerators. This can result in large delays. ACE enables SW to set and use these keys with reduced overheads.

// ACE can be used to provide hardened primitives for TEEs and TPMs to minimize explicit key handling and reduce the attack surface.
// The cryptographic operations are per-block atomic (“one-shot instructions”), as opposed to common round-based ISAs. Besides the already stated goal of preventing direct key leakage or exposure (which is unavoidable by design in round-based extensions like AES-NI), but also to enable masked implementation for protection against side-channel attacks. The fact that these operations are performed atomically gives the extension its name.
// ACE further reduces the attack surface of key misuse attacks by binding key usage policies to specific algorithms and authorized SW environments.

[[ACE-introduction-rationale]]
=== Rationale

ACE is necessary because current solutions are inadequate:

* Round-based ISAs need to explicitly add the key between the rounds.
* Current ISAs do not provide trustworthy mechanisms for cryptographic operations. Trust is provided only in external IP blocks or by relying on costly context switch to TEEs (TZ, etc) for each cryptographic operation.
* External blocks with memory mapped or coprocessor interfaces incur heavy overheads and need substantial support in system stack.
* Key Management (resp. KM building blocks) incur the same overheads.
* In modes such as AES-GCM-SIV, encryption and authentication derived keys should also not leak, hence supporting primitives only is not always sufficient.
* No current ratified solution offers fast execution, efficient key management, and trust.

[[ACE-introduction-more-features]]
=== Further Features

To address the limitations of existing solutions in a practical manner, ACE must provide features that reduce the number of environment switches and provide efficient support for software-managed context switching.  Consequently, while the value of a key cannot be read from a Cryptographic Context (CC), a secure mechanism is required to export a CC's content—preserving the confidentiality and integrity of both the key and its associated metadata.

//[start=10]
. ACE employs authenticated encryption to export the contents of a CC to external, untrusted memory as a _Sealed Cryptographic Context_ (SCC).
  A SCC can then be later authenticated, decrypted, and re-imported into a CC. Any metadata that does not need to be encrypted is kept in the clear.
. A Context Transport Key (CTK) is required for such import and export operations.  Optionally, ACE permits Machine Mode to configure the CTK.  When configurable, the CTK is held in 256 bits worth of CSRs that are writable only in Machine Mode.  This configurability enables domain separation: if Machine assigns distinct CTKs to different domains, a domain cannot authenticate or decrypt a Sealed Cryptographic Context (SCC) created for another domain.
. If the CTK is not configurable, it may be either a fixed value or randomly generated at boot.
. ACE provides a key-derivation mechanism that computes a _Locale CTK_ from the current CTK and a secret salt tied to a specific _Locale_ (as defined above), and thus
called a _Locale Specific Secret_ (LSS).
Changing a LSS also changes the corresponding Locale CTK, automatically invalidating any Sealed Cryptographic Contexts (SCCs) that were exported with previous LSS value.

The term _opaque_ applies also to a key in a SCC.

[[ACE-introduction-non-features]]
=== Non-Features

Certain features are intentionally not supported by ACE:

* ACE does not provide debugging support. The internal representation of a Cryptographic Context remains concealed even when debug features are active.
* ACE does not support the processing of variable-length ciphertext or plaintext inputs.
* ACE does not provide a complete secure key management and provisioning system. Instead, it offers architectural building blocks that can be used to implement such systems efficiently. Key management can be delegated to applets within a TEE or secure VM, which may be owned by different parties. These applets can implement complex key management software. The architecture enables trusted entities to establish and deliver opaque keys to less-trusted software domains. ACE does not support external schemes for directly provisioning keys into a key store.
* ACE, in its current version, does not provide a key revocation mechanism.
This is a complex feature requiring additional infrastructure, which is used rarely.
// The current architecture partially supports key revocation by binding keys to a _Locale_ that can be invalidated by a revocation message. If the Locale CTK for a key is invalidated, any process using it must re‑acquire the key from the provisioning entity; if the key has been revoked within that entity, re‑acquisition will fail. Note that keys already loaded into CCs can still be exported, as ACE does not define a mechanism to revoke keys once they reside in a CC.
We envision that a future version of ACE may allow implementations to assign an optional 64‑ or 128‑bit identifier to each key and issue a system‑wide broadcast instructing all ACE units to erase CCs whose identifier matches a revoked key as well as specific revoked LSSs.
* ACE cannot fully prevent misuse by compromised processes. If a process is compromised, the attacker obtains access to the CCs and can perform cryptographic operations, even if they do not elicit the key. Therefore, ACE complements existing security measures such as SW vulnerability exploitation countermeasures and process isolation (including TEE-like inverse sandboxing).
* Other risks remain. For instance, in counter-mode encryption, the same method enables both encryption and decryption, hence a malicious process may be able to misuse these operations.


=== High Level View of the Extension

The most important instructions provided by ACE are the following:

* `ace.init`,  to load the clear value of a key (and some metadata) in a Cryptographic Context (CC);
* `ace.clear`, to erase/invalidate the content of a CC;
* `ace.export`, to encrypt and authenticate a CC and store it to memory as a SCC;
* `ace.import`, to authenticate, decrypt a SCC from memory and import it into a CC;
* `ace.exec`, to perform a cryptographic operation on a block (e.g., 128 bits) of the input;
* `ace.stage/ace.dir`, to configure the CC for encryption/decryption or move from one stage of an algorithm to another; and
* `ace.error`, to report an error condition, which can be implemented as a read operation from a CSR.

Other instructions are provided and these will be discussed in detail later.

The inputs and outputs of the ACE operations are:

. Cryptographic Contexts,
. Vector registers (but, see <<remark-alternatives>>), and
. External memory, which is addressed using GPRs.

CCs are referred by a 5-bit immediate value or by the value of a GPR. +
They are denoted by `Cn`, with `n` in [0..31].

[[remark-alternatives,Remark {remark_count}]]
*Remark {counter:remark}.* _Alternatives can be discussed:
It is possible to envision a version of ACE that uses pairs of 64-bit GPRs or quartets of 32-bit GPRs in place of 128-bit vectors.
Such a variant could be discovered and selected using configuration bits.
We can also use `ace.input` and `ace.output` instructions that load an input from memory, resp., store output to memory -- which are currently optional and ideally reserved for future algorithms that use long inputs, such as certain post-quantum public-key algorithms.
Since no other change would be needed in the entire architecture, we suspend further discussion on this until later.
For 256-bit wide ciphers, we may need to group even more GPRs, whereas the vector unit allows easier resizing or spilling into the next register._

[[ACE-introduction-differences-CCs-registers]]
==== Differences between Cryptographic Contexts and Architectural Registers

The size of the data in a CC is variable, and this size is independent for each CC — this is an important difference with respect to GPRs and vector registers, which always have the same size. The total amount of internal "register memory" for CCs can also be exhausted when a subset of the CCs are used.
CCs contain different fields: metadata, key material, and internal state.
All three need to be architected.

The fact that CCs can be addressed indirectly has two implications:

. Adding renaming to to CCs would complicate the microarchitecture too much. Luckily, we can assume that are changed rarely, except for internal implied changes, and therefore we can assume that CCs are not renamed without performance issues.
. We need to use one bit in the instruction encoding to determine whether a CC is given by an immed or by a GPR. (Two bits for the `ace.clone` operation.)

==== Remark on the Formats for the Cryptographic Contexts

An ACE implementation must support three distinct representations for cryptographic data:

* *Initial Configuration Format:* The plaintext key(s) and metadata in memory used to initialize a CC.
* *Cryptographic Context (CC):* The internal representation of the key(s), metadata, and operational state.
* *Sealed Cryptographic Context (SCC):* The format for encrypted and authenticated CC export.

The initial configuration and SCC formats are architected to ensure interoperability.
The internal CC representation is implementation-defined.
The sizes of these formats cannot be assumed to be the same.

Standardizing the configuration and SCC formats is essential for two reasons:

1. *IP Interoperability* -- It allows IP blocks from different vendors within a single system to share SCCs.
2. *VM Migration* -- It enables the migration of virtual machines across heterogeneous hardware, for instance, between CPUs from different manufacturers in cloud or consumer environments.

NOTE: While a unified architected format is necessary, mechanisms for persisting Context Transport Keys (CTKs) across reboots or transferring them between devices are (currently) outside the scope of the ACE architecture. These are system-specific and belong to Machine Mode firmware.
For cross-device migration, the use of a public-key key-encapsulation mechanism (KEM) is recommended.


==== Remark On ACE Instructions that Access Memory

The instructions `ace.init`, `ace.export`, and `ace.import` perform direct memory accesses. This does not violate the Risc-V load/store architecture principles, as ACE is architected as an _attached_ unit that works together with the CPU core rather than being an integral part of the latter.  Consequently, it _may_ maintain its own architectural state and have its own load-store unit.
// Also, these instructions can be considered specialized load/store operations that internally enforce the confidentiality and integrity of key material.

//Although it is feasible to decompose these instructions into multiple, finer-grained operations, even reducing all configuration, import, and export to block-wise steps, architecting and mandating such an approach is undesirable.  A split approach would still require the implementation to retain equivalent internal state to support all operations involved in `ace.init`, `ace.export`, and `ace.import`, while constraining implementation flexibility, and impose significant complexity on software using the extension.

=== An Example

In the following example, a process wants to AES-encrypt some data using a key they are not allowed to know, which belongs to a recipient.

.Simple Pseudocode Example: Encryption with no Authentication
[C]
----
- Call OS API to get the necessary SCC. Assume X5 points to the SCC.
- Allocate memory for ciphertext buffer.

ace.import C0, [X5]                       // Import the SCC into CC C0
ace.error X1,C0                           // Read error from a CSR
if (X1 != 0) then { handle error }        // ACE may fail to validate SCC, algorithm
                                          // not supported, or CF memory full
vsetvli zero, 4, e32, m1, ta, ma          // Use 128-bit vectors
ace.stage C0, #ace_const_encrypt          // Configure CC for encryption
ace.error X1,C0
if (X1 != 0) then { handle error }        // Error if encryption is not allowed by CC

foreach (i from 0 to len_in_bytes(plaintext)/16-1) { // assume plaintext in whole blocks
    - load V0 from address plaintext+16*i
    ace.exec V0, C0, V                    // Encrypt one block of the plaintext
    - store V0 at address ciphertext+16*i
}
----

// vle32.v  V0, (plaintext)              // load V0 from address plaintext+16*i
//                                       // assume plaintext is in a register
// ace.exec V0, C0, V                    // Encrypt one block of the plaintext
// vse32.v  V0, (ciphertext)             // store V0 at address ciphertext+16*i
// add plaintext, plaintext, 16          // advance plaintext pointer
// add ciphertext, ciphertext, 16        // advance ciphertext pointer



[[ACE-introduction-algorithms]]
=== Supported Algorithms

We architect support for several algorithms, and also define a minimal subset (current suggestion):

* AES-128 and AES-256 encryption and decryption.
* AES-CTR, AES-GCM, AES-GCM-SIV, AES-XTS, AES-CMAC using AES-128/256.
* SHA-2, SHA-2-HMAC.

The list of other architected algorithms is TBD, but it should include at least

* AES-192, alone and with the above modes.
* SM4 Block Cipher.
* The Ascon suite (Ascon-128/128a-AEAD, Ascon-Hash, Ascon-XOF, Ascon-80pq).
* SHA-3, SHA-3-HMAC.
* SM3 Secure Hash.

Algorithms are encoded in a 8 bit field.
A zero in the algorithm field means the CC is invalid.
Algorithm numbers 1-127 are architecture-defined and the list of such encodings is maintained by RVI.
Algorithm numbers 128-255 are reserved for custom algorithms.

[[ACE-alternative-registers]]
=== Alternative Inputs and Outputs

Throughout this document, the cryptographic inputs and outputs for all `ACE` operations are vector registers.
A priori, we do not exclude versions of the specification that use only GPRs, however this is currently out of scope, and if the need arises, this should be architected as well.
We will also define a subset of the `V` extension that specifies only the vector registers, unit-strided load and stores, and a subset of vector operations including insert, extract, and logical operations, and possibly some additional ones. The goal is that code written against `ACE` and this subset of `V` shall run on any Risc-V core implementing `ACE`.


[[ACE-outline]]
=== Outline

The remainder of this document describes the extension in full detail.

//In <<Details>> the technical details of the architecture are presented, including a listing of the instructions and their semantics.

[.red]#*Discussion point:* _Can optional limitations even to import and export make sense and be useful?#_

[.red]#*Discussion point:* _Everything in this specification is still valid if the number of CCs is reduced to, say, 8. Immediate values to refer to CCs are still 5 bits long because the same field can also be used to refer to a GPR, but the only valid values for the CC number are 0 to 7._#

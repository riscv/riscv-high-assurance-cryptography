[[Introduction]]
== Introduction

(The ratification plan can be found https://riscv.atlassian.net/wiki/spaces/HACX/pages/484966423/High+Assurance+Crypto+Ratification+Plan[here].)

ACE, the _Atomic Cryptography Extension_, is a ISE that provides an interface to high-performance, high-assurance cryptographic operations that do not necessitate exposure of the value of the key to software.
(((design, high performance)))
ACE has been architected to address use cases such as
key and identity management,
content protection (including local LLM decryption),
link and storage encryption,
and
attestation.
However, it can be used also to accelerate cryptographic operations in software environments that provide their own keys, for instance to make use of side-channel protected implementations or to reduce the time the keys, once de-obfuscated, are exposed in RAM, thus making memory leakage attacks less likely to succeed.

ACE is architected as an _attached_ unit, similar to a coprocessor with a dedicated, low-latency interface to the CPU core.
// In particular, standard interrupts need not stop operations being performed by an ACE implementation, except when the latter is accessing memory, and the implementation may decide to stall the CPU pipeline only if a trap requires saving ACE state.
This model is the same one as in streaming accelerators:
An ACE unit can be shared by multiple harts, each hart maintaining independent architectural state, and operates concurrently with CPU cores.
This specification only defines the extension's behavior.
In particular, implementations integrated into the CPU core are allowed.

[[ACE-introduction-features]]
=== Goals of ACE

. ACE allows software to perform cryptographic operations without requiring visibility into the keys.
. ACE supports various cryptographic primitives and modes, including versions that are resistant to Side-Channel Analysis (SCA).
. The keys can be provisioned to the software using them by other trusted software or hardware entities.
. ACE can restrict the usage of keys according to processes, supervisors, and security states.
. ACE can restrict the use of keys to _Localities_ to prevent replay across different machines, product lines, execution contexts, or even boot cycles (see <<ACE-concepts>> and <<ACE-Localities>>).
. ACE scales from embedded to server cores using a unified ISA and ABI.
. ACE is compatible with VM migration.
(((design, scalable)))
(((VM migration)))

=== Features and Rationale

* Round-based ISAs require explicit key injection between block cipher rounds or at various points in MAC algorithms.
In the absence of contract-based access control to register values, or full homomorphic encryption to operate on the data, this means that the value of the key is exposed to the environment.
To avoid this exposure, ACE performs cryptographic operations such as the full-round encryption or decryption of a block of data or the absorbption of the data into a MAC function atomically, i.e., without breaking them up into smaller operations, such as individual rounds.

* To prevent using keys for unintended purposes, ACE introduces mechanisms to restrict the usage of keys
to specific algorithms, and according to processes, supervisors, security states, and other policies.

* The most important such mechanism is the _Cryptographic Context_ (CC), a data structure that contains
the _metadata_ setting the above policies and _content_ consisting of keys and other sensible information.
Metadata and content are bound together and always treated as a single entity by ACE.

* In order to be used, a CC must be stored in a special kind of one-way architectural state called a _Crypto(graphic) Register_ (CR).
CRs are architectural and each hart has 32 CRs. ACE instructions use CRs in place of the keys.

* We also note that primitive-only support is insufficient for modes like AES-GCM-SIV, XTS, OCB.
The leakage of derived keys or values can also reduce the security of these algorithms.
Therefore, we need to protect these values as well.
To this purpose, ACE provides support for modes of operation and secure derivation of CCs from other CCs.

* ACE provides an instruction to free lockers, otherwise a process could block them all and prevent other processes from using ACE.

* By providing a mechanism to securely export and import Cryptographic Contexts from crypto registers to encrypted and authenticated _Sealed (Cryptographic) Contexts_,
ACE minimizes environment switches, supports efficient software-managed context switching, and allows software to reuse CRs without having to re-create then or having them re-provisioned.


=== Algorithms

An incomplete list of supported algorithms includes AES-128 and AES-256 encryption and decryption (ECB modes),
CTR, GCM, GCM-SIV, XTS, and CMAC algorithms using AES-128/256, but possibly also other block ciphers such as, for instance, SM4.
Hash functions include at least SHA-2, SHA-2-HMAC.
The interface offered by ACE can also be used to provide support for public key algorithms, including post-quantum ones.


[[ACE-introduction-non-features]]
=== Non-Goals

ACE intentionally excludes the following:

* **Debugging support:** The internal representation of a locker remains concealed even during debug.
* **Variable-length ciphertext and plaintext inputs:** Plaintext and ciphertexts, as well as messages of which digests are computed, are processed in fixed-size blocks.
* **Complete key management:** ACE provides only architectural building blocks that can be used for key management, where the key management logic resides in trusted software (e.g., TEE applets).
  ACE does not support external schemes for directly provisioning keys into a key store.
  Instead, it will be a local trusted SW or HW component that manages external schemes and, with the thusly obtained keys and policies, then configures CCs for the ACE unit.
* **Key revocation:**
The present specification does not include a key revocation mechanism.
While future versions may be architected to support revocation, such functionality is excluded here to avoid architectural and implementation complexity. The rationale is as follows:
. ACE is designed to prioritize performance and flexibility (for example, algorithmic abstraction). Comprehensive revocation mechanisms, such as usage counters or revocation lists, would potentially degrade performance and significantly increase the complexity of an implementation.
. Enforcing a universal revocation mechanism is impractical due to the diversity of protocols used by different key providers. Additionally, managing potentially large revocation data structures within the ACE unit is complicated by the need for secure memory access: The ACE unit would both have to be agnostic to the external software stack's memory management and support a mechanism for securely obtaining protected memory from it.
Isolated software components (e.g., enclaves, realms, TrustZone applets) are better suited to handle these protocols, their data structures, and their updates, as they are designed to integrate with the local stacks' memory management.
. Revocation typically targets root keys. Since user software generally uses derived keys, such as session keys, it suffices that revocation be handled by the trusted entity managing the root keys.
. Applications that require direct software use of master keys (for instance for link and storage encryption) is usually limited to high-privilege environments. ACE is of course available to such environments as well.

* **Prevention of misuse by compromised processes:**  ACE cannot fully prevent misuse by compromised processes, as these processes may still get access to CCs.
ACE complements existing SW vulnerability exploitation countermeasures and process isolation, but cannot replace them.
Furthermore, in certain modes, such as in counter-mode encryption, the same method enables both encryption and decryption, potentially enabling misuse by malicious processes. This type of risk cannot be mitigated by ACE.

[[ACE-outline]]
=== Outline

The remainder of this document describes the extension in full detail.

[.darkred]#*Discussion point:* _Can optional limitations even to import and export make sense and be useful?#_

[.darkred]#*Discussion point:* _Everything in this specification is still valid if the number of CCs is reduced to, say, 8. Immediate values to refer to CCs are still 5 bits long because the same field can also be used to refer to a GPR, but the only valid values for the CC number are 0 to 7._#

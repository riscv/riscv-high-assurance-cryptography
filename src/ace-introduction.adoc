[[Introduction]]
== Introduction

(The ratification plan can be found https://riscv.atlassian.net/wiki/spaces/HACX/pages/484966423/High+Assurance+Crypto+Ratification+Plan[here].)

ACE, the Atomic Cryptographic Extension, is an instruction set extension designed to provide high assurance cryptographic operations.
The main features are the concealment of the values of keys and other secrets, restrictions on their usage, and support for multiple cryptographic algorithms as well as hardened implementations.

The design of ACE is prompted by the needs of key use cases such as:
content protection,
local decryption of LLMs,
key management,
identity management,
link encryption,
storage encryption,
Secure Boot and/or attestation in bootloaders, and in general any application where cryptographic operations are required and it is desirable to offer a high level of protection to keys and intermediate values.

ACE is architected to behave like an _attached_ unit, that is, like a coprocessor with a dedicated, low-latency interface to the CPU core.
In particular, interrupts need not stop cryptographic operations being performed by the ACE implementations, and the implementation may decide that the CPU pipeline may be stalled only when the mode into which the hart is being trapped needs to save the ACE state.
Page faults or other memory-subsystem related interrupts however may require restart or resumption of certain operations.

This model is analogous to streaming accelerators in other architectures.
An ACE implementation may be shared by multiple harts, each maintaining its own architectural state, and can operate concurrently with CPU cores, including in-order cores.  This does not prevent integrated implementations: we specify only the behavior of the extension, not its implementation details.

[[ACE-introduction-features]]
=== Features

. ACE is an ISE for full-round, block-wise cryptographic operations without exposing the key.
. ACE supports multiple different cryptographic primitives and modes, including SCA resistant versions.
  There is a mandatory list of algorithms, optional architected ones, and support for custom algorithms.
. Keys are stored in architectural states called _Cryptographic Contexts_ (CC) together with metadata that restricts the usage of the key.
 * There is no mechanism to extract the original value of a key from a CC: CCs are not read/write in the same sense as registers are.
   We call a key written into a CC _opaque_.
 * Besides software, additional sources for configuring CCs include a System Key Table, and external blocks for dynamic key generation.
. ACE instructions use CCs instead of directly using the key values.
. ACE supports multiple CCs active at the same time.
. ACE enables trusted entities to provision opaque keys to less-trusted environments, enabling the latter to perform cryptographic operations without exposing the key value.  Once provisioned, the opaque key can be reused without further interaction with the trusted entity.
. ACE can bind an opaque key to a _Locale_ ([.red]#*TBD:* better name?#), defined as a device, a class of devices, a specific hardware or software configuration, a single boot cycle or even, possibly, a specific time period.
. ACE can restrict which process can use a given opaque key. In particular:
 * ACE supports separation of keys belonging to different domains.
 * ACE supports key preservation upon process or VM migration from a device to another.
. ACE scales from from embedded cores to large application/server cores, with same ISA and ABI: certain features may be omitted in smaller cores without requiring changes in User SW.

// The latter is needed for cloud and edge deployment. ACE provides the minimum necessary support to enable secure key migration between machines.

// Currently, this often involves both changing context and potentially blocking operations to program keys or to perform cryptographic operations in cryptographic accelerators. This can result in large delays. ACE enables SW to set and use these keys with reduced overheads.

// ACE can be used to provide hardened primitives for TEEs and TPMs to minimize explicit key handling and reduce the attack surface.
// The cryptographic operations are per-block atomic (“one-shot instructions”), as opposed to common round-based ISAs. Besides the already stated goal of preventing direct key leakage or exposure (which is unavoidable by design in round-based extensions like AES-NI), but also to enable masked implementation for protection against side-channel attacks. The fact that these operations are performed atomically gives the extension its name.
// ACE further reduces the attack surface of key misuse attacks by binding key usage policies to specific algorithms and authorized SW environments.

[[ACE-introduction-rationale]]
=== Rationale

ACE is necessary because current solutions are inadequate:

* Round-based ISAs need to explicitly add the key between the rounds.
* Current ISAs do not provide trustworthy mechanisms for cryptographic operations. Trust is provided only in external IP blocks or by relying on costly context switch to TEEs (TZ, etc) for each cryptographic operation.
* External blocks with memory mapped or coprocessor interfaces incur heavy overheads and need substantial support in system stack.
* Key Management (resp. KM building blocks) incur the same overheads.
* In modes such as AES-GCM-SIV, encryption and authentication derived keys should also not leak, hence supporting primitives only is not always sufficient.
* No current ratified solution offers fast execution, efficient key management, and trust.

[[ACE-introduction-more-features]]
=== Further Features

To be practical and address the limitations of existing solutions, ACE must provide features that reduce the number of expensive environment switches and provide efficient support for software-managed context switching. Consequently, while the value of a key cannot be read from a Cryptographic Context (CC), a secure mechanism is required to export a CC's contents—preserving the confidentiality and integrity of both the key and its associated metadata.

//[start=10]
. ACE employs authenticated encryption to export the contents of a CC to external, untrusted memory as a _Sealed Cryptographic Context_ (SCC).
  A SCC can then be lated authenticated, decrypted, and re-imported into a CC. Any metadata that does not need to be encrypted is kept in the clear.
. A Cryptographic Context Transport Key (CTK) is required for such import and export operations. Optionally, ACE permits Machine Mode to configure the CTK. When configurable, the CTK is held in 256 bits of CSRs that are writable only by Machine. This configurability enables domain separation: if Machine assigns distinct CTKs to different domains, a domain cannot authenticate or decrypt a Sealed Cryptographic Context (SCC) created for another domain.
. If the CTK is not configurable, it may be either a fixed value or randomly generated at boot.
. ACE provides a key-derivation mechanism that computes a Derived CTK from the current CTK and a secret salt tied to a specific _Locale_. Changing this _Locale-Specific Secret_ (LSS) also changes the corresponding Derived CTK, automatically invalidating any Sealed Cryptographic Contexts (SCCs) that were exported with the previous LSS value.

The term _opaque_ applies also to a key in a SCC.

[[ACE-introduction-non-features]]
=== Non-Features

Certain features are intentionally not supported by ACE:

* ACE does not provide debugging support; the internal representation of a Cryptographic Context remains concealed even when debug features are active.
* ACE does not support the processing of variable-length ciphertext or plaintext inputs.
* ACE does not provide a complete secure key management and provisioning system. Instead, it offers architectural building blocks that can be used to implement such systems efficiently. Key management can be delegated to applets within a TEE or secure VM, which may be owned by different parties. These applets can implement complex key management software. The architecture enables trusted entities to establish and deliver opaque keys to less-trusted software domains. ACE does not support external schemes for directly provisioning keys into a key store.
* ACE, in its current version, does not provide a key revocation mechanism. This is a complex feature requiring additional infrastructure and coordination, for a relatively rare event.
// The current architecture partially supports key revocation by binding keys to a _Locale_ that can be invalidated by a revocation message. If the derived CTK for a key is invalidated, any process using it must re‑acquire the key from the provisioning entity; if the key has been revoked within that entity, re‑acquisition will fail. Note that keys already loaded into CCs can still be exported, as ACE does not define a mechanism to revoke keys once they reside in a CC.  We envision that a future version of ACE may allow implementations to assign an optional 64‑ or 128‑bit identifier to each key and issue a system‑wide broadcast instructing all ACE units to erase CCs whose identifier matches a revoked key.
* ACE cannot fully prevent misuse by compromised processes. If a process is compromised, the attacker obtains access to the CCs and can perform cryptographic operations — even if they do not elicit the key. Therefore, ACE complements existing security measures such as SW vulnerability exploitation countermeasures and process isolation (including TEE-like inverse sandboxing).
* Other risks remain. For instance, in counter-mode encryption, the same method enables both encryption and decryption, hence a malicious process may be able to misuse these operations.


=== High Level View of the Extension

The most important instructions provided by ACE are the following:

* `ace.init`,  to load the clear value of a key (and some metadata) in a Cryptographic Context (CC);
* `ace.clear`, to erase/invalidate the content of a CC;
* `ace.export`, to encrypt and authenticate a CC and store it to memory as a SCC;
* `ace.import`, to authenticate, decrypt a SCC from memory and import it into a CC;
* `ace.exec`, to perform a cryptographic operation on a block (e.g., 128 bits) of the input;
* `ace.stage/ace.dir`, to configure the CC for encryption/decryption or move from one stage of an algorithm to another; and
* a register for error reporting.
//* `ace.error`, to report an error condition, which can be implemented as a read operation from a CSR.

Other instructions are provided and these will be discussed in detail later.

The inputs and outputs of the ACE operations are:

. Cryptographic Contexts,
. Vector registers (but, see <<remark-alternatives>>), and
. External memory, which is addressed using GPRs.

CCs are referred by a 5-bit immediate value or by the value of a GPR. +
They are denoted by `Cn`, with `n` in [0..31].

Regarding the access control policies in a CC's metadata, we must distinguish how they apply to
(i) initial configuration,
(ii) usage, and
(iii) import/export of opaque keys.
These three types of operations cannot always obey the same policies — otherwise there would be opportunities for malicious adversaries to perform Denial-of-Service attacks on the ACE resources.
As a general rule, the access control policies only limit `ace.exec` and `ace.stage` operations.
This also means that it is always possible to clear, export a CC, and configure a CC or import a SCC into a CC, even if the latter two operations
directly overwrite an already configured CC, which implies that the previous state is discarded.

[.red]#*TBD:* _Can optional limitations even to import and export make sense and be useful?#_

[[remark-alternatives,Remark {remark_count}]]
*Remark {counter:remark}.* _Alternatives can be discussed:
We can envision a version of ACE that uses pairs of 64-bit GPRs or quartets of 32-bit GPRs in place of 128-bit vectors.
These could be discovered and selected using configuration bits.
We can also use `ace.input` and `ace.output` instructions that load an input from memory, resp., store output to memory -- which are currently optional and ideally reserved for future algorithms that use long inputs, such as certain post-quantum public-key algorithms.
Since no other change would be needed in the entire architecture, we suspend further discussion on this until later.
For 256-bit wide ciphers, we may need to group even more GPRs, whereas the vector unit allows easier resizing or spilling into the next register._

[[ACE-introduction-differences-CCs-registers]]
==== Differences between Cryptographic Contexts and Architectural Registers

The size of the data in a CC is variable, and this size is independent for each CC — this is an important difference with respect to GPRs and vector registers, which always have the same size. The total amount of internal "register memory" for CCs can also be exhausted when a subset of the CCs are used.
CCs contain different fields: metadata, key material, and internal state.
All three need to be architected.

The fact that CCs can be addressed indirectly has two implications:

. Adding renaming to to CCs would complicate the microarchitecture too much. Luckily, we can assume that are changed rarely, except for internal implied changes, and therefore we can assume that CCs are not renamed without performance issues.
. We need to use one bit in the instruction encoding to determine whether a CC is given by an immed or by a GPR. (Two bits for the `ace.clone` operation.)

==== Remark on the Formats for the Cryptographic Contexts

Before we proceed, we need to point out that there are different representations of the same object:

* The input format of key + metadata in the clear in memory for the initial configuration of a CC.
* What we call the CC proper, i.e. the internal representation of a key + metadata + additional state.
* The format of a SCC, defined by the format of the plaintext and its encryption and authentication method.

The first and third formats are architected, whereas the second one is implementation defined, i.e., the internal representation of the CC is left to the implementation.  However, we still define the minimum of information that must be stored in a CC, to the very least the same information that is stored in a SCC, and in some cases additional information that is specific to the algorithm or to the implementation.

This also means that the maximal size of the data inside a CC is implementation defined as well, and this size in general differs from the size of the initial information  required to configure a CC as well as from the size of a SCC.

Architecting the configuration and SCC formats serves two purposes: ensuring interoperability and enabling VM migration. First, even within a single manufacturer's SoC, IP blocks from different designers may share SCCs. Second, VM migration is common across both cloud and consumer environments—for example, moving a VM from an laptop with a CPU from one manufacturer to a laptop with a CPU from a different manufacturer.
Consequently, a single architected format is necessary.
Mechanisms for guaranteeing that a CTK can securely survive hardware reboot and
transferring CTKs between devices are also needed, but are out of scope of the ACE architecture:
For migration, the use of a public key key-encapsulation mechanism is recommended.


==== Remark On ACE Instructions that Access Memory

The instructions `ace.init`, `ace.export`, and `ace.import` perform direct memory accesses. This does not violate the Risc-V load/store architecture principles, as ACE is architected as an _attached_ unit that works together with the CPU core rather than being an integral part of the latter.  Consequently, it _may_ maintain its own architectural state and have its own load-store unit.
// Also, these instructions can be considered specialized load/store operations that internally enforce the confidentiality and integrity of key material.

Although it is feasible to decompose these instructions into multiple, finer-grained operations, even reducing all configuration, import, and export to block-wise steps, doing so is undesirable.  A split approach would still require the implementation to retain equivalent internal state to support all operations involved in `ace.init`, `ace.export`, and `ace.import`, while constraining implementation flexibility, and impose significant complexity on software using the extension.

=== An Example

In the following example, a process wants to AES-encrypt some data using a key they are not allowed to know, which belongs to a recipient.

.Simple Example: Encryption, no Authentication
[C]
----
- Call OS API to get the necessary SCC. Assume X5 points to the SCC.
- Allocate memory for ciphertext buffer.

ace.import C0, [X5]                       // Import the SCC into CC C0
if (aceerror != 0) then { handle error }  // ACE may fail to validate SCC, algorithm
                                          // not supported, or CF memory full.
vsetvli zero, 4, e32, m1, ta, ma          // Use 128-bit vectors.
ace.stage C0, #ace_const_encrypt
if (aceerror != 0) then { handle error }  // Error if encryption is not allowed by CC

foreach (i from 0 to ceil(len_in_bytes(plaintext)/16)-1) {
    - load V0 from *(plaintext+16*i)
    ace.exec V0, C0, V                    // Encrypt one block of the plaintext
    - store V0 at *(ciphertext+16*i)
}
----

[[ACE-introduction-algorithms]]
=== Supported Algorithms

We architect support for several algorithms, and also define a minimal subset (current suggestion):

* AES-128 and AES-256 encryption and decryption.
* AES-CTR, AES-GCM, AES-GCM-SIV, AES-XTS, AES-CMAC using AES-128/256.
* SHA-2, SHA-2-HMAC.

The list of other architected algorithms is TBD, but it should include at least

* AES-192, alone and with the above modes.
* SM4 Block Cipher.
* The Ascon suite (Ascon-128/128a-AEAD, Ascon-Hash, Ascon-XOF, Ascon-80pq).
* SHA-3, SHA-3-HMAC.
* SM3 Secure Hash.

Algorithms are encoded in a 8 bit field.
Algorithm numbers 0-127 are architecture-defined and the list of such encodings is maintained by RVI.
Algorithm numbers 128-255 are reserved for custom algorithms.

[[ACE-alternative-registers]]
=== Alternative Inputs and Outputs

Throughout this document, the cryptographic inputs and outputs for all `ACE` operations are vector registers.
A priori, we do not exclude versions of the specification that use only GPRs, however this is currently out of scope, and if the need arises, this should be architected as well.
We will also define a subset of the `V` extension that specifies only the vector registers, unit-strided load and stores, and a subset of vector operations including insert, extract, and logical operations, and possibly some additional ones. The goal is that code written against `ACE` and this subset of `V` shall run on any Risc-V core implementing `ACE`.

[[ACE-need-for-trappable-operations]]
=== Need for Trappable Operations

Certain operations in `ACE` need to deal with arbitrarily long inputs and outputs.
It may be the desire of an implementor to avoid complexity in the hardware,
which are trappable, meaning that they can be intercepted by the operating system or other software components.
For this purpose we need four operations:

* An instruction to "open" a CC either for initializing, importing, or exporting;
* A load instruction, that loads a certain number of bytes into the ACE unit;
* A corresponding store instruction; and
* A "close" instruction to finalize the procedure.

[.red]#*TBD:*#
While, in theory, these instructions need only respect the value of `ccstart` (cf. <<ACE-ccstart-definition>>) and update it in accordance with architected behavior, we [.red]#*shall*# provide a non-normative definition for such a set of instructions in a later draft of the `ACE` specification.


[[ACE-outline]]
=== Outline

The remainder of this document describes the extension in full detail.

//In <<Details>> the technical details of the architecture are presented, including a listing of the instructions and their semantics.

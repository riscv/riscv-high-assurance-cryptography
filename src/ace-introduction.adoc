[[Introduction]]
== Introduction

#(The ratification plan can be found https://riscv.atlassian.net/wiki/spaces/HACX/pages/484966423/High+Assurance+Crypto+Ratification+Plan[here].)#

The _Atomic Cryptographic Extension_ (ACE) provides an interface to high-assurance cryptographic operations.
Its primary features are:

* The concealment of key values and other secrets;
* Support for various cryptographic algorithms including implementations hardened against Side-Channel Attacks;
and
* Binding key usage to processes, device and device types, software and hardware configurations.

ACE addresses use cases such as
key and identity management,
content protection (including local LLM decryption),
link and storage encryption,
and
attestation.
// It targets applications requiring cryptographic operations with high protection for keys and intermediate values.

ACE is architected as an _attached_ unit, similar to a coprocessor with a dedicated, low-latency interface to the CPU core.
In particular, standard interrupts need not stop operations being performed by an ACE implementation,
except when the latter is accessing memory,
and the implementation may decide to stall the CPU pipeline only if a trap requires saving ACE state.

This model is the same one used in streaming accelerators:
An ACE implementation can be shared by multiple harts, each maintaining independent architectural state, and operates concurrently with CPU cores.
This specification defines the extension's behavior, not its implementation.
In particular, implementations that are integrated into the CPU core are allowed.

[[ACE-introduction-features]]
=== Features

. ACE is an ISE for full-round, block-wise cryptographic operations that keeps keys concealed.
. It supports various cryptographic primitives and modes, including Side-Channel Attack (SCA) resistant versions.
  The specification includes mandatory, optional, and custom algorithms.
. Keys are stored in an architectural state called a _Cryptographic Context_ (CC), along with metadata binding the key to a specific algorithm and usage restrictions. In fact, CCs can store any type of data, not only keys, so we speak of the _contents_ of a CC.
 * The contents of a CC are _opaque_ and cannot be extracted by software. CCs are not GPRs.
 * The metadata is the _non-opaque_ part of a CC, it can be read, but not freely modified by software.
 * CCs are configured via software, System Key Tables, or dynamic key generation blocks.
. ACE instructions reference CCs rather than the raw values of their contents, such as keys.
. ACE supports multiple concurrent active CCs.
. Trusted entities can use ACE to provision opaque keys to less-trusted environments, enabling cryptographic operations without exposing key material.
  Once provisioned, keys are reusable without further interaction with the more trusted environments.
. ACE binds CCs to _Localities_ to prevent replay across different machines, product lines, or execution contexts (see <<ACE-concepts>> and <<ACE-Localities>>).
. ACE enforces process-level access control for their opaque contents, supporting:
 * Separation for keys according to processes, supervisors, security states (i.e., _process domains_).
 * Key preservation during process or VM migration.
. ACE scales from embedded to server cores using a unified ISA and ABI.
  Smaller cores may omit features transparently to user software.

// The latter is needed for cloud and edge deployment. ACE provides the minimum necessary support to enable secure key migration between machines.

// Currently, this often involves both changing context and potentially blocking operations to program keys or to perform cryptographic operations in cryptographic accelerators. This can result in large delays. ACE enables SW to set and use these keys with reduced overheads.


[[ACE-introduction-rationale]]
=== Rationale

ACE addresses the inadequacies of current solutions:

* Round-based ISAs require explicit key injection between block cipher rounds or at various points in keyed hash algorithm.
  In the absence of contract-based access control to register values, or full homomorphic encryption to operate on the data, this means that the value of the key must be exposed to the environment.
* Existing ISAs lack intrinsic trust mechanisms, relying on external IP or costly context switches to TEEs (e.g., TrustZone).
* External blocks and key management units impose significant latency and system stack overhead.
* Primitive-only support is insufficient for modes like AES-GCM-SIV, where derived keys must also remain protected, or the mask values in OCB modes.
* No currently ratified solution combines high performance, efficient key management, and high assurance.


[[ACE-introduction-more-features]]
=== Implied Features

To avoid the limitations of existing solutions, ACE minimizes environment switches and supports efficient software-managed context switching, by providing the secure export and import of Cryptographic Contexts using authenticated encryption.
The complete model is specified in <<ACE-architecture>>.


=== Algorithms

An incomplete list of supported algorithms includes AES-128 and AES-256 encryption and decryption (ECB modes),
CTR, GCM, GCM-SIV, XTS, and CMAC algorithms using AES-128/256, but possibly also other block ciphers such as, for instance, SM4.
Hash functions include at least SHA-2, SHA-2-HMAC.
The interface offered by ACE can also be used to provide support for public key algorithms, including post-quantum ones.


[[ACE-introduction-non-features]]
=== Non-Goals

ACE intentionally excludes the following:

* **Debugging support:** The internal representation of a CC remains concealed even during debug.
* **Variable-length ciphertext and plaintext inputs:** Plaintext and ciphertexts, as well as messages of which digests are computed, are processed in fixed-size blocks.
* **Complete key management:** ACE provides only architectural building blocks that can be used for key management, where the key management logic resides in trusted software (e.g., TEE applets).
  ACE does not support external schemes for directly provisioning keys into a key store.
* **Key revocation:**
The present specification does not include a key revocation mechanism.
While future versions may be architected to support revocation, such functionality is excluded here to avoid architectural and implementation complexity. The rationale is as follows:
. ACE is designed to prioritize performance and flexibility (for example, algorithmic abstraction). Comprehensive revocation mechanisms, such as usage counters or revocation lists, would potentially degrade performance and significantly increase the complexity of an implementation.
. Enforcing a universal revocation mechanism is impractical due to the diversity of protocols used by different key providers. Additionally, managing potentially large revocation data structures within the ACE unit is complicated by the need for secure memory access: The ACE unit would both have to be agnostic to the external software stack's memory management and support a mechanism for securely obtaining protected memory from it.
Isolated software components (e.g., enclaves, realms, TrustZone applets) are better suited to handle these protocols, their data structures, and their updates, as they are designed to integrate with the local stacks' memory management.
. Revocation typically targets root keys. Since user software generally uses derived keys, such as session keys, it suffices that revocation be handled by the trusted entity managing the root keys.
. Applications that require direct software use of master keys (for instance for link and storage encryption) is usually limited to high-privilege environments. ACE is of course available to such environments as well.

* **Prevention of misuse by compromised processes:**  ACE cannot fully prevent misuse by compromised processes, as these processes may still get access to CCs.
ACE complements existing SW vulnerability exploitation countermeasures and process isolation, but cannot replace them.
Furthermore, in certain modes, such as in counter-mode encryption, the same method enables both encryption and decryption, potentially enabling misuse by malicious processes. This type of risk cannot be mitigated by ACE.


[[ACE-threat-model]]
=== Threat Model

The ACE threat model is straightforward.

**Assets** consist of _keys_ and any other information that could aid an adversary in recovering plaintext or forging ciphertext. This includes items such as masks in tweakable XEX modes and derived keys in AES-GCM-SIV. The critical properties of these assets are their _confidentiality_ and _integrity_.

**Adversaries** are assumed capable of compromising processes by exploiting software vulnerabilities.
They are also able to gain access to memory contents, for instance, by abusing hardware interfaces or by SoC/memory interposition.
The model does not include adversaries capable of sophisticated hardware attacks, such as using
a Focused Ion Beam/Scanning Electron Microscope (FIB/SEM) to tamper with the hardware's functionality.

Side channel attacks are addressed optionally. ACE offers interfaces to both SCA unprotected and protected implementations of cryptographic algorithms, if these options are provided by the designer.

Threats can be addressed in four ways:

[horizontal]
**C:**:: _Control_ the threat by implementing full or partial mitigations.
**A:**:: _Accept_ the threat and its associated risks.
**T:**:: _Transfer_ the threat to another party better suited to address it.
**S:**:: _Suppress_ the features that give rise to the threat.

ACE is designed to avoid the "***A***" and "***S***" options (as much as possible). It _controls_ threats through its own mechanisms and _transfers_ residual risk—specifically, the risk of key extraction from the privileged or trusted software and hardware environments that manage keys—to those same environments. For example, trusted software environments may employ control-flow integrity, memory encryption with integrity protection, and anti-replay mechanisms, while hardware key-management blocks can be hardened to protect entrusted keys.

Direct plaintext leakage, memory corruption attacks against the ACE-using process, and Release of Unverified Plaintext (RUP) attacks on the cryptographic algorithms are considered out of scope. These threats cannot be mitigated by ACE because the processed information resides within the user process domain. Consequently, these threats are _accepted_.

[[ACE-outline]]
=== Outline

The remainder of this document describes the extension in full detail.


[.red]#*Discussion point:* _Can optional limitations even to import and export make sense and be useful?#_

[.red]#*Discussion point:* _Everything in this specification is still valid if the number of CCs is reduced to, say, 8. Immediate values to refer to CCs are still 5 bits long because the same field can also be used to refer to a GPR, but the only valid values for the CC number are 0 to 7._#

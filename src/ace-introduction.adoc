[[Introduction]]
== Introduction

#(The ratification plan can be found https://riscv.atlassian.net/wiki/spaces/HACX/pages/484966423/High+Assurance+Crypto+Ratification+Plan[here].)#

The _Atomic Cryptographic Extension_ (ACE) provides an interface to high-assurance cryptographic operations.
Its primary features are:
the concealment of key values and other secrets;
support for various cryptographic algorithms including implementations hardened against Side-Channel Attacks;
and
binding key usage to process domains, device and device types, software and hardware configurations.

ACE addresses use cases such as
key and identity management,
content protection (including local LLM decryption),
link and storage encryption,
and
attestation.
It targets applications requiring cryptographic operations with high protection for keys and intermediate values.

ACE is architected as an _attached_ unit, similar to a coprocessor with a dedicated, low-latency interface to the CPU core.
In particular, standard interrupts need not stop cryptographic operations being performed by the ACE implementations,
except when they are accessing memory,
and the implementation may decide to stall the CPU pipeline only if a trap requires saving ACE state.

This model is the same one used in streaming accelerators:
An ACE implementation can be shared by multiple harts, each maintaining independent architectural state, and operates concurrently with CPU cores.
This specification defines the extension's behavior, not its implementation.
In particular, implementations that are integrated into the CPU core are allowed.

[[ACE-introduction-features]]
=== Features

. ACE is an ISE for full-round, block-wise cryptographic operations that keeps keys concealed.
. It supports various cryptographic primitives and modes, including Side-Channel Attack (SCA) resistant versions.
  The specification includes mandatory, optional, and custom algorithms.
. Keys are stored in an architectural state called a _Cryptographic Context_ (CC), along with metadata binding the key to a specific algorithm and usage restrictions.
 * Keys in a CC are _opaque_ and cannot be extracted by software. CCs are not general-purpose read/write registers.
 * CCs are configured via software, System Key Tables, or dynamic key generation blocks.
. ACE instructions reference CCs rather than raw key values.
. ACE supports multiple concurrent active CCs.
. Trusted entities can use ACE to provision opaque keys to less-trusted environments, enabling cryptographic operations without exposing key material.
  Once provisioned, keys are reusable without further interaction.
. ACE binds CCs to _Localities_ to prevent replay across different machines, product lines, or execution contexts (see <<ACE-concepts>> and <<ACE-Localities>>).
. ACE enforces process-level access control for opaque keys, supporting:
 * Domain separation for keys.
 * Key preservation during process or VM migration.
. ACE scales from embedded to server cores using a unified ISA and ABI.
  Smaller cores may omit features transparently to user software.

// The latter is needed for cloud and edge deployment. ACE provides the minimum necessary support to enable secure key migration between machines.

// Currently, this often involves both changing context and potentially blocking operations to program keys or to perform cryptographic operations in cryptographic accelerators. This can result in large delays. ACE enables SW to set and use these keys with reduced overheads.

// ACE can be used to provide hardened primitives for TEEs and TPMs to minimize explicit key handling and reduce the attack surface.
// The cryptographic operations are per-block atomic (“one-shot instructions”), as opposed to common round-based ISAs. Besides the already stated goal of preventing direct key leakage or exposure (which is unavoidable by design in round-based extensions like AES-NI), but also to enable masked implementation for protection against side-channel attacks. The fact that these operations are performed atomically gives the extension its name.
// ACE further reduces the attack surface of key misuse attacks by binding key usage policies to specific algorithms and authorized SW environments.

[[ACE-introduction-rationale]]
=== Rationale

ACE addresses the inadequacies of current solutions:

* Round-based ISAs require explicit key injection between block cipher rounds or at various points in keyed hash algorithm.
* Existing ISAs lack intrinsic trust mechanisms, relying on external IP or costly context switches to TEEs (e.g., TrustZone).
* External blocks and key management units impose significant latency and system stack overhead.
* Primitive-only support is insufficient for modes like AES-GCM-SIV, where derived keys must also remain protected, or the mask values in OCB modes.
* No currently ratified solution combines high performance, efficient key management, and high assurance.


[[ACE-introduction-more-features]]
=== Implied Features

To avoid the limitations of existing solutions, ACE minimizes environment switches and supports efficient software-managed context switching, by providing the secure export and import of Cryptographic Contexts using authenticated encryption.
The complete model is specified in <<ACE-architecture>>.


=== Algorithms

An incomplete list of supported algorithms includes AES-128 and AES-256 encryption and decryption (ECB modes),
CTR, GCM, GCM-SIV, XTS, and CMAC algorithms using AES-128/256, but possibly also other block ciphers such as, for instance, SM4.
Hash functions include at least SHA-2, SHA-2-HMAC.


[[ACE-introduction-non-features]]
=== Non-Goals

ACE intentionally excludes the following:

* **Debugging support:** The internal representation of a CC remains concealed even during debug.
* **Variable-length ciphertext and plaintext inputs:** Plaintext and ciphertexts, as well as messages of which digests are computed, are processed in fixed-size blocks.
* **Complete key management:** ACE provides only architectural building blocks that can be used for key management, where the key management logic resides in trusted software (e.g., TEE applets).
  ACE does not support external schemes for directly provisioning keys into a key store.
* **Key revocation:** Current specifications do not include a revocation mechanism.
  Future versions may support revocation via key identifiers and system-wide revocation broadcasts.
* **Prevention of misuse by compromised processes:**  ACE cannot fully prevent misuse by compromised processes, as these processes may still get access to CCs.
ACE complements existing SW vulnerability exploitation countermeasures and process isolation, but cannot replace them.
Furthermore, in certain modes, such as in counter-mode encryption, the same method enables both encryption and decryption, potentially enabling misuse by malicious processes. This type of risk cannot be mitigated by ACE.

// === High Level View of the Extension
//
// The most important instructions provided by ACE are the following:
//
// * `ace.init`,  to load the clear value of a key (and some metadata) in a Cryptographic Context (CC);
// * `ace.clear`, to erase/invalidate the content of a CC;
// * `ace.export`, to encrypt and authenticate a CC and store it to memory as a SCC;
// * `ace.import`, to authenticate, decrypt a SCC from memory and import it into a CC;
// * `ace.exec`, to perform a cryptographic operation on a block (e.g., 128 bits) of the input;
// * `ace.state/ace.dir`, to configure the CC for encryption/decryption or move from one "stage" of an algorithm to another; and
// * `ace.error`, to report an error condition, which can be implemented as a read operation from a CSR.
//
// Other instructions are provided and these will be discussed in detail later.
//
// The inputs and outputs of the ACE operations are:
//
// . Cryptographic Contexts,
// . Vector registers, and
// . External memory.
//
// NOTE: Throughout this document, the cryptographic inputs and outputs for all `ACE` operations are vector registers.
// A priori, we do not exclude versions of the specification that use only GPRs, however this is currently out of scope, and if the need arises, this should be architected as well.
//
// === An Example
//
// In the following example, a process wants to AES-encrypt some data using a key they are not allowed to know, which belongs to a recipient.
//
// .Simple Pseudocode Example: Encryption with no Authentication
// [C]
// ----
// - Call OS API to get the necessary SCC. Assume X5 points to the SCC.
// - Allocate memory for ciphertext buffer.
//
// ace.import C0, (X5)                       // Import the SCC into CC C0
// ace.error X1,C0                           // Read error from a CSR
// if (X1 != 0) then { handle error }        // ACE may fail to validate SCC, algorithm
//                                           // not supported, or CF memory full
// vsetvli zero, 4, e32, m1, ta, ma          // Use 128-bit vectors
// ace.state C0, #ace_const_encrypt          // Configure CC for encryption
// ace.error X1, C0                          // Read error from a CSR
// if (X1 != 0) then { handle error }        // Error if encryption is not allowed by CC
//
// foreach (i from 0 to len_in_bytes(plaintext)/16-1) { // assume plaintext in whole blocks
//     - load V0 from address plaintext+16*i
//     ace.exec V0, C0, V                    // Encrypt one block of the plaintext
//     - store V0 at address ciphertext+16*i
// }
// ----

// vle32.v  V0, (plaintext)              // load V0 from address plaintext+16*i
//                                       // assume plaintext is in a register
// ace.exec V0, C0, V                    // Encrypt one block of the plaintext
// vse32.v  V0, (ciphertext)             // store V0 at address ciphertext+16*i
// add plaintext, plaintext, 16          // advance plaintext pointer
// add ciphertext, ciphertext, 16        // advance ciphertext pointer


// [[ACE-outline]]
// === Outline
//
// The remainder of this document describes the extension in full detail.


[.red]#*Discussion point:* _Can optional limitations even to import and export make sense and be useful?#_

[.red]#*Discussion point:* _Everything in this specification is still valid if the number of CCs is reduced to, say, 8. Immediate values to refer to CCs are still 5 bits long because the same field can also be used to refer to a GPR, but the only valid values for the CC number are 0 to 7._#

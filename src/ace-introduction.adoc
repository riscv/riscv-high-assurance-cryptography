[[Introduction]]
== Introduction

This brief introduction to the _Atomic Cryptography Extension_ (ACE) is not part of the specification.

The ratification plan can be found https://riscv.atlassian.net/wiki/spaces/HACX/pages/484966423/High+Assurance+Crypto+Ratification+Plan[here].

=== Features

ACE defines an interface to high-performance cryptographic operations without giving software access to the keys.
(((design, high performance)))
Its development has been prompted by use cases such as content protection (including local LLM decryption), link and storage encryption, secure boot, and attestation.

ACE's main features are:

* To prevent key misuse, ACE combines cryptographic secrets (e.g., key material) with metadata into an indivisible structure called a _Cryptographic Context_ (CC).
Using the metadata, the architecture restricts the use of the secret material to a specific algorithm, and may optionally enforce usage constraints based on process, VM, security state, boot cycle, or other policies. An expiration date mechanism is defined as well, to invalidate a key at a specific time.

* To create and use CCs, ACE introduces the concept of _Cryptographic Registers_ (CRs)–architectural containers that conceal secrets to software.
A CC is created by writing metadata and secrets into a CR.
Instead of explicitly using key values, ACE instructions operate on CRs.
A CC can be provided by a different software component, or generated by the software itself, by provisioning a CR with the necessary information and then erasing the latter.
This way, software can use keys even if the latter are not explicitly present in the process's memory-and leverage increased performance or side-channel-protected implementations.

* Operations such as full AES block encryption/decryption or absorption of data blocks into a hash function are performed _atomically_, i.e., in a single step.

* To enable CC reuse and support OS features like context switching, ACE provides a secure mechanism to store a CC to memory via authenticated encryption, producing a _Sealed Cryptographic Context_ (SCC).
An SCC can be retrieved and re-imported into a CR. If an SCC is passed to a process, the key is never exposed in that process’s memory.

* ACE provides a unified interface to multiple cryptographic primitives, avoiding the need for separate instructions per primitive.
 ** Supporting only primitives is insufficient for modes like AES-GCM-SIV, XTS, and OCB, because leakage of derived keys or intermediate values can compromise security. Therefore, ACE also defines modes of operation and secure key derivation.
 ** In addition to GCM-SIV, XTS, and OCB, ACE defines modes such as CTR, GCM, and CMAC.
If the mode applies, we also define versions with a preset IV or nonce, and versions that are encrypt-only or decrypt-only, to reduce abuse.
These can be instantiated not only with AES-128/256 but also with other block ciphers like SM4.
 ** Various hash functions are architected as well.
 ** The same interface can support SCA-resistant implementations of the algorithms.
 ** In fact, it can also be used to provide access to public-key and post-quantum algorithms.
 ** _Not all these algorithms and primitives must be supported by an ACE implementation: A minimal subset and several optional extensions are defined._

* ACE scales from embedded to server cores with a unified ISA and ABI.
* ACE is compatible with sleep, hibernation, and VM migration.
(((design, scalable)))
(((VM migration)))

//

Rationale for atomic operations:::
Assuming the primitive is secure, the key cannot be recovered from the input and output of the full cryptographic operation.
Typical round-based ISAs, which require keys to be supplied between rounds or MAC stages, allow for easy key recovery from the input and output, even if the key came from a hidden register. In fact, even if an instruction computed 4 or 5 rounds of the AES, an attacker with access to the instruction oracle would be able to efficiently recover the key cite:[Rijndael-revised].

//

[[ACE-introduction-non-features]]
=== Non-Goals

ACE intentionally excludes the following:

* **Debugging support:** The internal representation of a CR remains concealed even during debug.
* **Variable-length complete ciphertext and plaintext inputs:** Plaintext and ciphertexts, as well as messages of which digests are computed, are processed in fixed-size blocks.
* **Complete key management:** ACE provides only architectural building blocks that can be used for key management, where the key management logic resides in trusted software (e.g., TEE applets).
  ACE does not support external schemes for directly provisioning keys into a key store.
  Instead, it will be a local trusted SW or HW component that manages external schemes and, with the thus obtained keys and policies, then configures CCs for the ACE unit.
* **Key revocation:**
The present specification does not include a key revocation mechanism.
While future versions may be architected to support revocation, such functionality is excluded here to avoid architectural and implementation complexity.
In detail, the rationale is:
. ACE is designed to prioritize performance and flexibility (for example, algorithmic abstraction). Comprehensive revocation mechanisms, such as usage counters or revocation lists, would potentially degrade performance and significantly increase the complexity of an implementation.
. Implementing a universal revocation mechanism is impractical due to the diversity of protocols across key providers. Revocation data may become unbounded, and managing it within the ACE unit would require some form of dynamic secure memory access. This functionality is better handled by isolated software components such as enclaves, realms, or TEE applets, which are designed to integrate with the local software stack while providing strong security guarantees.
. Revocation typically targets root keys. Since user software generally uses derived keys, such as session keys, it suffices that revocation be handled by the trusted entity managing the root keys. The expiration date mechanism can be used to limit the lifetime of derived keys.
. Applications that require direct software use of root keys (for instance for link and storage encryption) usually run in protected environments.

* **Prevention of misuse by compromised processes:**  ACE cannot fully prevent misuse by compromised processes, as these processes may still get access to CCs.
ACE complements existing SW vulnerability exploitation countermeasures and process isolation, but cannot replace them.
Furthermore, in certain modes, such as in counter-mode encryption, the same method enables both encryption and decryption, potentially enabling misuse by malicious processes. This type of risk cannot be mitigated by ACE.

//
<<<

=== TODOs and Open Discussion Points

 * [.red]#We could use# `[.red]#L#` [.red]#in this document instead of# `[.red]#ace#` [.red]#but we haven't changed it yet since a different# `[.red]#misa#` [.red]#bit and a different letter may ultimately be allocated to the extension.#
 `[.red]#L#` [.red]#is nice because it goes “beyond K” and is also the initial of “Locker”, which could replace Cryptographic Context.#

 * [.red]#Revise all error codes and determine which ones are placed in# `[.red]#aceerror#` [.red]#CSR for each operation/state.#

 * [.red]#Can optional limitations even to import and export-beyond what localities implicitly offer-make sense and be useful?#

 * [.red]#Consider the interruptibility of the SIV computation in# `[.red]#ace.export#`[.red]#.#

 * [.red]#Everything in this specification is still valid if the number of CRs is reduced to, say, 8 or 16.
The important point here is that this number is fixed, architectural, and discoverable. The indirect addressing would allow powerful self-management of CCs/CRs.
Immediate values to refer to CCs are still 5 bits long because the same field can also be used to refer to a GPR, but the only valid values for the CR number are 0 to 7.#

 * [.red]#Regarding Trappable (Emulated) Operations (<<ACE-trappable-insns-support>>):
There are ongoing discussions on whether to formalize the auxiliary instructions and make them normative.#

 * [.red]#Overload# `[.red]#acestart#` [.red]#with# `[.red]#vstart#`[.red]#?#

 * [.red]#Discuss how to implement# `[.red]#sacefilter#`[.red]#,# `[.red]#macefilter#`[.red]#, for instance, whether to use# `[.red]#scontext#`[.red]#/#`[.red]#hcontext#`[.red]#/#`[.red]#mcontext#` [.red]#from the Sdtrig extension.#

 * [.red]#Regarding filtering by time-stamp: minutes since January 1st, 2027?#

 * [.red]#Define the CSRs for <<ACE-horizontal-exception-handling>>.#

 * [.red]#Define RVV-mini.#

 * [.red]#Complete list of sub-extensions.#

 * [.red]#Add a list of algorithm numbers!#

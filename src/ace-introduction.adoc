[[Introduction]]
== Introduction

This brief introduction to the _Atomic Cryptography Extension_ (ACE) is not part of the specification.

ACE provides an interface to high-performance cryptographic operations without giving software visibility into the keys.
(((design, high performance)))
Its development has been motivated by use cases such as key and identity management, content protection (including local LLM decryption), link and storage encryption, and attestation.

The ratification plan can be found https://riscv.atlassian.net/wiki/spaces/HACX/pages/484966423/High+Assurance+Crypto+Ratification+Plan[here].

=== Features

ACE provides the following features:

* To prevent key misuse, ACE combines cryptographic secrets (e.g., key material) with metadata into an indivisible structure called a _Cryptographic Context_ (CC).
Using the metadata, the architecture restricts the use of the secret material to a specific algorithm, and may optionally enforce usage constraints based on process, VM, security state, boot cycle, or other policies.

* To create and use CCs, ACE introduces the concept of _Cryptographic Registers_ (CRs)–architectural containers that conceal secrets to software.
A CC is created by writing metadata and secrets into a CR.

* Instead of explicitly using key values, ACE instructions operate on CRs. Operations such as full AES block encryption/decryption or absorption of data blocks
into a hash function are performed atomically.
This way, assuming the primitive is secure, the secrets cannot be recovered from the input and output of the cryptographic operation.
This contrasts with typical round-based ISAs, which require keys to be supplied between rounds or MAC stages: even if the key came from a hidden register, its value would be trivial to recover.

* To enable CC reuse and support OS features like context switching, ACE provides a secure mechanism to store a CC to memory via authenticated encryption, producing a _Sealed Cryptographic Context_ (SCC). An SCC can be retrieved and reimported into a CR. If an SCC is passed to a process, the key is never exposed in that process’s memory.

* ACE provides a unified interface to multiple cryptographic primitives, avoiding the need for separate instructions per primitive.
** Supporting only primitives is insufficient for modes like AES-GCM-SIV, XTS, and OCB, because leakage of derived keys or intermediate values can compromise security. Therefore, ACE also defines modes of operation and secure key derivation.
** In addition to GCM-SIV, XTS, and OCB, ACE defines modes such as CTR, GCM, and CMAC. These can be instantiated not only with AES-128/256 but also with other block ciphers like SM4.
** Various hash functions are architected as well.
** The same interface can support SCA-resistant implementations of the algorithms.
** In fact, it can also be used to provide access to public-key and post-quantum algorithms.
** Not all these algorithms and primitives must be supported by an ACE implementation:
 A minimal subset and several optional extensions are defined.

* Software can configure their own CCs to limit key exposure and leverage increased performance or side-channel-protected implementations.
* ACE scales from embedded to server cores with a unified ISA and ABI.
* ACE is compatible with VM migration.
(((design, scalable)))
(((VM migration)))

[[ACE-introduction-non-features]]
=== Non-Goals

ACE intentionally excludes the following:

* **Debugging support:** The internal representation of a CR remains concealed even during debug.
* **Variable-length ciphertext and plaintext inputs:** Plaintext and ciphertexts, as well as messages of which digests are computed, are processed in fixed-size blocks.
* **Complete key management:** ACE provides only architectural building blocks that can be used for key management, where the key management logic resides in trusted software (e.g., TEE applets).
  ACE does not support external schemes for directly provisioning keys into a key store.
  Instead, it will be a local trusted SW or HW component that manages external schemes and, with the thusly obtained keys and policies, then configures CCs for the ACE unit.
* **Key revocation:**
The present specification does not include a key revocation mechanism.
While future versions may be architected to support revocation, such functionality is excluded here to avoid architectural and implementation complexity.
In detail, the rationale is:
. ACE is designed to prioritize performance and flexibility (for example, algorithmic abstraction). Comprehensive revocation mechanisms, such as usage counters or revocation lists, would potentially degrade performance and significantly increase the complexity of an implementation.
. Enforcing a universal revocation mechanism is impractical due to the diversity of protocols used by different key providers. Additionally, managing potentially unbounded revocation data structures within the ACE unit is complicated by the need for secure memory access: The ACE unit would both have to be agnostic to the external software stack's memory management, support a mechanism for securely obtaining dynamically managed protected memory from it, and trust that this memory provides strong protection against tampering. These are the guarantees offered by isolated software components such as enclaves, realms, TEE applets, which are already designed to integrate with the local stack while providing the required security guarantees.
Therefore, they are better suited to handle these protocols, their data structures, and their updates in their entirety.
. Revocation typically targets root keys. Since user software generally uses derived keys, such as session keys, it suffices that revocation be handled by the trusted entity managing the root keys.
. Applications that require direct software use of master keys (for instance for link and storage encryption) are usually limited to high-privilege environments. ACE is of course available to such environments as well.

* **Prevention of misuse by compromised processes:**  ACE cannot fully prevent misuse by compromised processes, as these processes may still get access to CCs.
ACE complements existing SW vulnerability exploitation countermeasures and process isolation, but cannot replace them.
Furthermore, in certain modes, such as in counter-mode encryption, the same method enables both encryption and decryption, potentially enabling misuse by malicious processes. This type of risk cannot be mitigated by ACE.

// [[ACE-outline]]
// === Outline
//
// The remainder of this document describes the extension in full detail.


=== Open Discussion Points

[WARNING]
We could have used `L` in this document instead of `ACE` and `ace`, but we haven't changed it yet since a different `misa` bit and a different letter may ultimately be allocated to the extension.

[WARNING]
*Discussion point:* Can optional limitations even to import and export-beyond what localities implicitly offer-make sense and be useful?

[WARNING]
*Discussion point:* Everything in this specification is still valid if the number of CRs is reduced to, say, 8 or 16.
The important point here is that this number is fixed and architectural.
Immediate values to refer to CCs are still 5 bits long because the same field can also be used to refer to a GPR, but the only valid values for the CR number are 0 to 7.

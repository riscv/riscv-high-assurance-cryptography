[[Introduction]]
== Introduction

#(The ratification plan can be found https://riscv.atlassian.net/wiki/spaces/HACX/pages/484966423/High+Assurance+Crypto+Ratification+Plan[here].)#

The _Atomic Cryptographic Extension_ (ACE) provides support for high assurance cryptographic operations.
The main features are the concealment of the values of keys and other secrets, restrictions on their usage, and support for multiple cryptographic algorithms as well as hardened implementations.

The design of ACE is prompted by the needs of key use cases such as:
content protection,
local decryption of LLMs,
key management,
identity management,
link encryption,
storage encryption,
Secure Boot and/or attestation in bootloaders, and in general any application where cryptographic operations are required and it is desirable to offer a high level of protection to keys and intermediate values.

ACE is architected as an _attached_ unit, similar to a coprocessor with a dedicated, low-latency interface to the CPU core.
In particular, interrupts need not stop cryptographic operations being performed by the ACE implementations, and the implementation may decide that the CPU pipeline may be stalled only when the mode into which the hart is being trapped needs to save the ACE state.
Page faults or other memory-subsystem related interrupts however may require restart or resumption of certain operations.

This model is analogous to streaming accelerators in other architectures.
An ACE implementation may be shared by multiple harts, each maintaining its own architectural state, and can operate concurrently with CPU cores, including in-order cores.  This does not prevent integrated implementations: we specify only the behavior of the extension, not how it is implemented.

[[ACE-introduction-features]]
=== Features

. ACE is an ISE for full-round, block-wise cryptographic operations without exposing the key.
. ACE supports multiple different cryptographic primitives and modes, including SCA resistant versions.
  There is a mandatory list of algorithms, optional architected ones, and support for custom algorithms.
. A key is stored in an architectural state called a _Cryptographic Context_ (CC) together with metadata that ties the key to a specific algorithm and can restrict the use of the keys (see points 7 and 8 below).
 * There is no mechanism to extract the original value of a key from a CC: CCs are not read/write in the same sense as registers are.
   We call a key written into a CC _opaque_.
 * Besides software, additional sources for configuring CCs include a System Key Table, and dynamic key generation blocks.
. ACE instructions use CCs instead of directly using the key values.
. ACE supports multiple CCs active at the same time.
. ACE enables trusted entities to provision opaque keys to less-trusted environments, enabling the latter to perform cryptographic operations without exposing the key value.  Once provisioned, the opaque key can be reused without further interaction with the trusted entity.
. ACE provides a mechanism to prevent replay of SCCs across different machines, product lines, or execution contexts by cryptographically binding CCs to _Locales_ (cf. <<ACE-concepts>> and <<ACE-locales>>).
. ACE can restrict which process can use a given opaque key. In particular:
 * ACE supports separation of keys belonging to different domains.
 * ACE supports key preservation upon process or VM migration from a device to another.
. ACE scales from embedded cores to large application/server cores, with same ISA and ABI: certain features may be omitted in smaller cores without requiring changes in User SW.

// The latter is needed for cloud and edge deployment. ACE provides the minimum necessary support to enable secure key migration between machines.

// Currently, this often involves both changing context and potentially blocking operations to program keys or to perform cryptographic operations in cryptographic accelerators. This can result in large delays. ACE enables SW to set and use these keys with reduced overheads.

// ACE can be used to provide hardened primitives for TEEs and TPMs to minimize explicit key handling and reduce the attack surface.
// The cryptographic operations are per-block atomic (“one-shot instructions”), as opposed to common round-based ISAs. Besides the already stated goal of preventing direct key leakage or exposure (which is unavoidable by design in round-based extensions like AES-NI), but also to enable masked implementation for protection against side-channel attacks. The fact that these operations are performed atomically gives the extension its name.
// ACE further reduces the attack surface of key misuse attacks by binding key usage policies to specific algorithms and authorized SW environments.

[[ACE-introduction-rationale]]
=== Rationale

ACE is necessary because current solutions are inadequate:

* Round-based ISAs need to explicitly add the key between the rounds.
* Current ISAs do not provide trustworthy mechanisms for cryptographic operations. Trust is provided only in external IP blocks or by relying on costly context switch to TEEs (TZ, etc) for each cryptographic operation.
* External blocks with memory mapped or coprocessor interfaces incur heavy overheads and need substantial support in system stack.
* Key Management (resp. KM building blocks) incur the same overheads.
* In modes such as AES-GCM-SIV, encryption and authentication derived keys should also not leak, hence supporting primitives only is not always sufficient.
* No current ratified solution offers fast execution, efficient key management, and trust.

[[ACE-introduction-more-features]]
=== Implied Features

To address the limitations of existing solutions in a practical manner, ACE must provide features that reduce the number of environment switches and provide efficient support for software-managed context switching.
To this purpose, ACE supports secure export and import of Cryptographic Contexts using authenticated encryption.
//The keys used for authenticated encryption algorithm can be made specific to Locales (as defined above).
The complete model is specified in <<ACE-architecture>>.

=== Algorithms

An incomplete list of supported algorithms includes AES-128 and AES-256 encryption and decryption (ECB modes),
CTR, GCM, GCM-SIV, XTS, and CMAC algorithms using AES-128/256, but possibly also other block ciphers such as, for instance, SM4.
Hash functions include at least SHA-2, SHA-2-HMAC.


[[ACE-introduction-non-features]]
=== Non-Features

Certain features are intentionally not supported by ACE:

* ACE does not provide debugging support. The internal representation of a Cryptographic Context remains concealed even when debug features are active.
* ACE does not support the processing of variable-length ciphertext or plaintext inputs.
* ACE does not provide a complete secure key management and provisioning system. Instead, it offers architectural building blocks that can be used to implement such systems efficiently. Key management can be delegated to applets within a TEE or secure VM, which may be owned by different parties. These applets can implement complex key management software. The architecture enables trusted entities to establish and deliver opaque keys to less-trusted software domains. ACE does not support external schemes for directly provisioning keys into a key store.
* ACE, in its current version, does not provide a key revocation mechanism.
This is a complex feature requiring additional infrastructure, which is used rarely.
We envision that a future version of ACE may allow implementations to assign an optional 64‑ or 128‑bit identifier to each key and issue a system‑wide broadcast instructing all ACE units to erase CCs whose identifier matches a revoked key as well as specific revoked LSSs.
* ACE cannot fully prevent misuse by compromised processes. If a process is compromised, the attacker obtains access to the CCs and can perform cryptographic operations, even if they do not elicit the key. Therefore, ACE complements existing security measures such as SW vulnerability exploitation countermeasures and process isolation (including TEE-like inverse sandboxing).
* Other risks remain. For instance, in counter-mode encryption, the same method enables both encryption and decryption, hence a malicious process may be able to misuse these operations.


// === High Level View of the Extension
//
// The most important instructions provided by ACE are the following:
//
// * `ace.init`,  to load the clear value of a key (and some metadata) in a Cryptographic Context (CC);
// * `ace.clear`, to erase/invalidate the content of a CC;
// * `ace.export`, to encrypt and authenticate a CC and store it to memory as a SCC;
// * `ace.import`, to authenticate, decrypt a SCC from memory and import it into a CC;
// * `ace.exec`, to perform a cryptographic operation on a block (e.g., 128 bits) of the input;
// * `ace.state/ace.dir`, to configure the CC for encryption/decryption or move from one "stage" of an algorithm to another; and
// * `ace.error`, to report an error condition, which can be implemented as a read operation from a CSR.
//
// Other instructions are provided and these will be discussed in detail later.
//
// The inputs and outputs of the ACE operations are:
//
// . Cryptographic Contexts,
// . Vector registers, and
// . External memory.
//
// NOTE: Throughout this document, the cryptographic inputs and outputs for all `ACE` operations are vector registers.
// A priori, we do not exclude versions of the specification that use only GPRs, however this is currently out of scope, and if the need arises, this should be architected as well.
//
// === An Example
//
// In the following example, a process wants to AES-encrypt some data using a key they are not allowed to know, which belongs to a recipient.
//
// .Simple Pseudocode Example: Encryption with no Authentication
// [C]
// ----
// - Call OS API to get the necessary SCC. Assume X5 points to the SCC.
// - Allocate memory for ciphertext buffer.
//
// ace.import C0, (X5)                       // Import the SCC into CC C0
// ace.error X1,C0                           // Read error from a CSR
// if (X1 != 0) then { handle error }        // ACE may fail to validate SCC, algorithm
//                                           // not supported, or CF memory full
// vsetvli zero, 4, e32, m1, ta, ma          // Use 128-bit vectors
// ace.state C0, #ace_const_encrypt          // Configure CC for encryption
// ace.error X1, C0                          // Read error from a CSR
// if (X1 != 0) then { handle error }        // Error if encryption is not allowed by CC
//
// foreach (i from 0 to len_in_bytes(plaintext)/16-1) { // assume plaintext in whole blocks
//     - load V0 from address plaintext+16*i
//     ace.exec V0, C0, V                    // Encrypt one block of the plaintext
//     - store V0 at address ciphertext+16*i
// }
// ----

// vle32.v  V0, (plaintext)              // load V0 from address plaintext+16*i
//                                       // assume plaintext is in a register
// ace.exec V0, C0, V                    // Encrypt one block of the plaintext
// vse32.v  V0, (ciphertext)             // store V0 at address ciphertext+16*i
// add plaintext, plaintext, 16          // advance plaintext pointer
// add ciphertext, ciphertext, 16        // advance ciphertext pointer


[[ACE-outline]]
=== Outline

The remainder of this document describes the extension in full detail.

//In <<Details>> the technical details of the architecture are presented, including a listing of the instructions and their semantics.

[.red]#*Discussion point:* _Can optional limitations even to import and export make sense and be useful?#_

[.red]#*Discussion point:* _Everything in this specification is still valid if the number of CCs is reduced to, say, 8. Immediate values to refer to CCs are still 5 bits long because the same field can also be used to refer to a GPR, but the only valid values for the CC number are 0 to 7._#

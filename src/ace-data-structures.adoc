[[Cryptographic-Contexts]]
=== Cryptographic Contexts

A CC contains two types of information: the *metadata* and the *content*:

* The metadata is (mostly) algorithm independent and architected.
* The content is algorithm-specific and contains key material and possibly other algorithm-specific data.

[[Metadata]]
=== Metadata Block Format

The metadata block is 64 bits long and its format described in <<ACE-metadata-standard>>.
This format is used to for CC initialization, export and import purposes.
The internal representation of the metadata in CF memory is implementation dependent.

To initialize a CC, the first 64 bits of the input buffer contain the metadata in entirely in cleartext.
When exporting a CC, the first 64 bits of the input buffer contain the partially encrypted metadata: the fields marked as Public are not encrypted and the fields marked as Private are encrypted.
The entire metadata block is included in the computation of the authentication tag.
The details are described in <<ACE-SCC-formats>>.

[#ACE-metadata-standard]
.Metadata: 64-bit version
[width="100%",cols=">9%,^7%,17%,59%,^8%",options="header"]
|===
|   Field | Width | Name                  | Description | Type
|     [0] |   1  | Format                 | 0 for the current metadata format. +
Future format swill have a 1 in this position and may also be longer than 64 bits. | Public
|   [8:1] |   8  | Algorithm              | Algorithm (such as primitive or mode). | Public
|  [10:9] |   2  | SC_Protection          | Level of Side Channel Protection provided. +
The field's encoding is described in <<ACE-SC-protection-levels>>. | Public
| [12:11] |   2  | Direction_Policy       | Determines whether the CC may be used for encryption (bit 11 set), decryption (bit 12 set), or both (bits 11 and 12 set). +
Valid only for encryption/decryption primitives or modes, and ignored, for instance, for hash functions. | Public
| [14:13] |   2  | Key_Type               | By explicit value / Immutable (index) / Internally generated. | Public
| [18:15] |   4  | Locale                 | Field which is either -1 or an index into the Locale Secrets Table. | Public
| [20:19] |   2  | Completion             | Defined in <<ACE-CC-complete>>. +
Used to determine whether operations must be restarted. | Public
| [24:21] |   4  | Stage (also Direction) | Internal current state of the state machine of the algorithm. +
See <<stage-field>> below. +
Must be zero on configuration. +
Algorithm defined. | Private
| [28:25] |   4  | AC_Policy_1            | Forbid USE of this CC in User, Supervisor or Virtual Supervisor, Hypervisor, resp., Machine Mode if bit 25, 26, 27, resp. 28, is set. | Private
| [30:29] |   2  | AC_Policy_2            | If bit 29, resp., 30, is set, then restrict USE by `ASID`, resp., `VMID`. +
Restriction by `ASID` ignored if in S Mode or higher. +
See also <<stage-no-H-no-VMID>> below. | Private
|    [31] |   1  | Reserved               | Undefined.  | Private
| [47:32] |  16  | AC_Policy_3            | Zero if bit 29 unset, else `ASID` to enforce.  | Private
| [63:48] |  16  | AC_Policy_4            | Zero if bit 30 unset, else `VMID` to enforce. +
See also <<stage-no-H-no-VMID>> below.  | Private
|===

<<<

[[ACE-SC-protection-levels]]
.Encoding of side-channel protection levels
[float="center",align="center",width="76%",cols="^8%,<68%",options="header"]
|===
| Value | Description
|   0   | No protection.
|   1   | Data independent timing, first-order threshold implementation.
|   2   | Data independent timing, first-order threshold, fault tolerant implementation.
|   3   | Custom, algorithm dependent.
|===

Custom algorithms may offer stronger side channel protection guarantees than those specified in the encoding values 0 to 2.
In such a case, the value of the SC_Protection field must be set to 3.

[[ACE-CC-complete]]
.Encoding of completion field
[float="center",align="center",width="76%",cols="^8%,<68%",options="header"]
|===
| Value | Description
|   0   | No protection.
|   1   | `ace.init`, `ace.input`, or `ace.output` was interrupted.
|   2   | `ace.import` was interrupted.
|   3   | `ace.export` was interrupted.
|===

// Whether the CC is complete (00) or interrupted while being configured (01), imported (10) or exported (11). Necessary to know whether to restart operations.

[[stage-field,Remark {counter:remark}]]
*Remark {counter:remark}*: _The Stage field accommodates modes of operation with a small number of states.
For algorithms with more complex state machines, machine state information can be stored in a custom data section of the CC._

[[stage-no-H-no-VMID,Remark {counter:remark}]]
*Remark {counter:remark}*: _If the H extension is not enabled, bits 30 and [63:48] must be set to 0, and bit 27 must be set to 1. +
The "AC_Policy_4" field is 16-bits long for compatibility with architectures employing 16-bit `VMID` fields (for instance, in heterogeneous systems).
While interoperability cannot be guaranteed when this policy is used, this ensures that the two top bits are not used for other purposes. +
Filtering use by Supervisor Domain or World ID is not supported, and not only because of lack of space in a 64-bit metadata block:
Reconfiguring the CTK is a better approach for such isolation requirements, whereas isolation by `ASID` and `VMID` is a weaker security feature._

=== Formats of Configuration Inputs and Sealed Configuration Contexts

[[ACE-Input-format]]
==== Configuration Input

The format of the input to `ace.init` is simple: the first 8 bytes must contain the 64-bit metadata block, followed by any key and additional information in a format specified by the algorithm. The total length of this input must be a multiple of 8 bytes.
Formally, each algorithm must provide following functions:

* `metadata_deserialize()`: Takes the clear or decrypted metadata block, and deserializes it for the internal representation.
* `metadata_serialize()`: Serializes the internal metadata into a 64-bit block for export.
* `initial_content_deserialize()`: Reads the information provided to `ace.init` that follows the metadata, and deserializes it for the internal representation.
* `content_serialize()`: Serialize the content of the CC into a sequence of blocks to be encrypted for `ace.export`.
* `content_deserialize()`: Takes a sequence of decrypted SCC blocks that follow the metadata, nonce and authentication tag, and deserializes it for the internal representation of the CC's content.

See <<ACE-Algorithms>> for algorithm specific details.


[[ACE-SCC-formats]]
==== Sealed Configuration Context

We first define the RFC8452 Key Derivation and the Derived CTK Derivation functions.

.RFC8452 Key Derivation
[source,sail]
----
function RFC8452_KeyDeriv(K) = {
  struct {
    AESE256(K, (0[125:0] @ 0b101))[63:0] @
    AESE256(K, (0[125:0] @ 0b100))[63:0] @
    AESE256(K, (0[125:0] @ 0b011))[63:0] @
    AESE256(K, (0[125:0] @ 0b010))[63:0],
    AESE256(K, (0[125:0] @ 0b001))[63:0] @
    AESE256(K, (0[125:0] @ 0b000))[63:0]
  }
}
----

.Derived Key Derivation
[source,sail]
----
function RFC8452_KeyDeriv(K,L) = {
  AESE256(K, L ^ (0[125:0] @ 0b011))[63:0] @
  AESE256(K, L ^ (0[125:0] @ 0b010))[63:0] @
  AESE256(K, L ^ (0[125:0] @ 0b001))[63:0] @
  AESE256(K, L ^ (0[125:0] @ 0b000))[63:0]
}
----

We can now define the generation of the SCC from a CC.

.Generation of the SCC from a CC with standard metadata format
[source,sail]
----
metadata : bits(64);
let P : array of bits(256) = content;
M : array of bits(256);
let N : bits(96) = random(96 bits);
Kenc : bits(256);
Kauth : bits(128);
{Kenc, Kauth} = RFC8452_KeyDeriv(CTK);
let SIV : bits(96) = Poly1305(Kauth, N, metadata @ P)[95:0];

M[0][127:0] = N[63:0]
            @ ((metadata[63:21] xor AESE(Kenc, SIV @ 0x0000_0000)[63:21])
            @ metadata[20:0];
M[1][127:0] = SIV[95:0] @ N[95:64];
foreach(i from 0 to num_blocks(P)-1) {
     M[i+2][127:0] = (block i of P) xor AESE(Kenc, SIV @ (binary(i+1)[31:0]));
}
----

Since the derivation functions are quite expensive, the ACE implementation is allowed to cache recently used Derived Keys, both for the base CTK and for the derived keys.

// Notation: xor, {or}, {and}, and {lshift} denote XOR, OR, AND, and left shift, respectively.
// (Recall that by `x` @ `y` we indicate the concatenation of `x` and `y`, where the bits of `x` become the most significant part of the concatenated value, and the bits of `y` its least significant part.)

// Note that we do not encrypt public metadata bits but we encrypt the private metadata bits.

Note: In this simplification of AES-GCM-SIV there is no need to add the lengths of metadata and keys+internal state to the hash because these lengths are implied already by the clear bits of the metadata itself — which are included in the computation of the authentication tag.

Some details are fixed in general. For instance, all “pure” ciphers have only one key, whether in normal or threshold implementation, the latter always reduced to one key, as well as for some modes. In other cases, there must be a specific formatting of the state.
The length of the entire output is always assumed to be a multiple of 128 bits. If metadata and content are not multiples of 128 bits, the final block is padded with zeros.

=== Constants

==== Error Codes

In <<ACE-error-values>> we define the mandatory ACE error codes.
[.red]#The list may still be incomplete.#
Additional ones may be defined in the range [128,255] that are algorithm specific, which are allowed to overlap between algorithms.

[[ACE-error-values]]
.Error values and their meanings
[float="center",align="center",width="100%",cols="^6%,<24%,<70%",options="header"]
|===
|Value | Mnemonic                  | Examples
|  0   | ace_err_ok                | All is fine. Life is beautiful. No error from ACE.
|  1   | ace_err_authentication    | Authentication failure in `ace.import`, but can also follow `ace.exec` with certain algorithms.
|  2   | ace_err_privilege         | `ace.exec`, `ace.stage`, `ace.derive`, `ace.spawn` failed because the access control policies in the metadata prevent USE in the current architectural state.
|  3   | ace_err_invalid           | Invalid input or operation.
Examples:
the metadata block passed to `ace.init` is invalid;
encryption, resp., decryption is requested from a CC only configured for decryption, resp., encryption;
the requested change of state in `ace.stage` is not permitted;
the current state of the CC does not expect the used form of `ace.exec`;
the change in usage policies in `ace.restrict` is not permitted because it would either downgrade or overwrite the current restrictions in the CC;
a request to clone a CC violates the re-initialisation policies of the source CC.
|  4   | ace_err_unimplemented     | The requested algorithm is not implemented. May be triggered also on algorithm variants, for instance if `ace.harden` is issued on an algorithm for which a non-side channel protected version is not implemented.
|  5   | ace_err_memory            | The free internal CF memory is not sufficient to perform the `ace.init`, `ace.exec`, `ace.clone`, or `ace.derive`.
The implementation should make sure this cannot happen with any other operation.
If algorithms that support `ace.derive` are implemented, the implementation must make sure that both the input and output CCs of this operation can be allocated.
|  6   | ace_err_clearCC           | Software tried to use a cleared CC as a source in a `ace.exec`, `ace.stage`, `ace.input`, `ace.output`, `ace.clone`, `ace.derive`, `ace.harden`, `ace.restrict` operations. +
This can be used in low CF memory situations to trigger a re-load of that CC.
|===

==== Other Constants

[.red]#*To be completed.*#

In addition to error codes, ACE defines several constants, such as
those in <<ACE-set_stage_constants>> which are used in `ace.stage`/`ace.dir` to change the state of a CC.
Note that the internal state machine of a CC may also be changed implicitly by `ace.exec` or `ace.derive` operations, and the state machine of a cloned CC may be changed implicitly according to the algorithm's policies as encoded in the source CC's metadata.

[[ACE-set_stage_constants]]
.Constants defining messages sent to a CC through `ace.stage`/`ace.dir` operations
[float="center",align="center",width="100%",cols="^6%,<29%,<65%",options="header"]
|===
|Value | Mnemonic                    | Examples
|  0   | ace_const_ok                | All is fine. Life is beautiful. No error from ACE.
|  1   | ace_const_encrypt           | Encryption is requested.
|  2   | ace_const_decrypt           | Decryption is requested.
|  3   | ace_const_hash_start        | Start (and initialize) a hash function or the sub-function of an algorithm.
|  4   | ace_const_hash_finalize     | Finalize the internal state of a hash function and prepare it for outputting the result.
|  5   | ace_const_hash_update       | Update the internal state of a hash function with new data.
|  6   | ace_const_set_public_value  | Set a public value (like a nonce or an IV) in an algorithm. Some algorithms require more than one public value (for instance, a re-useable hash of some associated data and a unique nonce), in which case the second public value can be set using the next message.
|  7   | ace_const_set_public_value_2  | Set the second public value in an algorithm.
|===

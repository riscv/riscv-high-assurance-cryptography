[[Cryptographic-Contexts]]
=== Cryptographic Contexts

A CC contains two fields: the `metadata` and the `state`.

Key material and possibly other algorithm-specific data are contained in the state.

[[Metadata]]
=== Metadata Fields

*To be discussed* _We are open to agree on either using a single metadata format (the 128-bit version) or making the 64-bit format mandatory and the 128-bit format optional._

The metadata field exists in two versions, short (64-bit) and long (128-bit). The short version is structured as follows:

.Metadata: 64-bit version
[width="100%",cols=">9%,^9%,17%,57%,^8%",options="header",frame=ends, grid=rows]
|===
|   Field | Bits | Name                   | Description | Type
|     [0] |   1  | Format                 | 0 for short metadata format (64-bit) | Public
|   [8:1] |   8  | Algorithm              | Which primitive or mode (msb = 0 for architected algorithms, msb = 1 for custom ones). | Public
|     [9] |   1  | Side Channel Protected | Set if we require the implementation of the algorithm to provide Side Channel Protection. | Public
| [11:10] |   2  | Direction Policy       | Use for encryption/decryption/both (only for enc/dec primitives or modes). | Public
| [13:12] |   2  | Key Type               | By explicit value / Immutable (index) / Internally generated. | Public
| [17:14] |   4  | Locale                 | Field which is either -1 or an index into the Locale Secrets Table. | Public
| [19:18] |   2  | Complete               | Whether the CC is complete (00) or interrupted while being configured (01), imported (10) or exported (11). Necessary to know whether to restart operations. | Public
| [25:20] |   6  | Stage/Direction        | Which internal stage the algorithm is, as defined by ace_stage or implicitly. Must be ZERO on configuration. This is algorithm defined. | Private
| [29:26] |   4  | AC Policy 1            | Can a User (if bit 28 set)/Supervisor or Virtual Supervisor (bit 29 set)/Hypervisor (bit 30 set)/Machine (bit 31 set) USE this key? | Private
| [31:30] |   2  | AC Policy 2            | If bit 32, resp., 33, is set, restrict USE by `ASID`, resp., `VMID`. | Private
| [47:32] |  16  | AC Policy 3            | Zero if bit 32 unset, else `ASID` to enforce.  | Private
| [61:48] |  14  | AC Policy 4            | Zero if bit 33 unset, else `VMID` to enforce.  | Private
| [63:62] |   2  | Reserved               | Undefined.  | Private
|===

*Remark {counter:remark}*:: The short metadata format contains 20 bits of public metadata and 44 bits of private metadata.

*Remark {counter:remark}*:: The two bits after AC Policy 4 can be used in case `VMID` is extended to 16 bits, and for compatibility
of metadata formats with architectures that use a 16-bit `VMID` field, for instance in heterogeneous systems.

*Remark {counter:remark}*:: For side-channel protection, we currently only require a data-independent-timing and first-order threshold implementation.
However, we are open to discuss using more bits to specify higher orders of protection.

The long version of the metadata is structured as follows:

.Metadata: 128-bit version
[width="100%",cols=">9%,^9%,17%,57%,8%",options="header",frame=ends, grid=rows]
|===
|     Field | Bits | Name                   | Description | Type
|       [0] |   1  | Format                 | 1 for long metadata format (128-bit) | Public
|     [8:1] |   8  | Algorithm              | Which primitive or mode (msb = 0 for architected algorithms, msb = 1 for custom ones). | Public
|       [9] |   1  | Side Channel Protected | Set if we require the implementation of the algorithm to provide Side Channel Protection. | Public
|   [11:10] |   2  | Direction Policy       | Use for encryption/decryption/both (only for enc/dec primitives or modes). | Public
|   [13:12] |   2  | Key Type               | By explicit value / Immutable (index) / Internally generated. | Public
|   [17:14] |   4  | Locale                 | Field which is either -1 or an index into the Locale Secrets Table. | Public
|   [19:18] |   2  | Complete               | Whether the CC is complete (00) or interrupted while being configured (01), imported (10) or exported (11). Necessary to know whether to restart operations. | Public
|   [25:20] |   6  | Stage/Direction        | Which internal stage the algorithm is, as defined by ace_stage or implicitly. Must be ZERO on configuration. This is algorithm defined. | Private
|   [29:26] |   4  | AC Policy 1            | Can a User (if bit 28 set)/Supervisor or Virtual Supervisor (bit 29 set)/Hypervisor (bit 30 set)/Machine (bit 31 set) USE this key? | Private
|   [31:30] |   2  | AC Policy 2            | If bit 32, resp., 33, is set, restrict USE by `ASID`, resp., `VMID`. | Private
|   [47:32] |  16  | AC Policy 3            | Zero if bit 32 unset, else `ASID` to enforce.  | Private
|   [61:48] |  14  | AC Policy 4            | Zero if bit 33 unset, else `VMID` to enforce.  | Private
|   [63:62] |   2  | Reserved               | Undefined.  | Private
|   [67:64] |   4  | Version                | Metadata format version | Public
|   [83:68] |  16  | `partialsccif`         | (Partial SCC Implementation Format) ID of the µarchitectural format for CCs with interrupted operations. | Public
|  [115:84] |  28  | `marchpriv`            | Implementation private metadata | Private
| [127:112] |  16  | Reserved               | Reserved for future versions | Private
|===

*Remark {counter:remark}*:: In the 128-bit version of the metadata, the first 64-bit word (i.e., at the lowest address) contains bits [63:0] and the second 64-bit word (i.e., at the byte address of the first word, plus 8) contains bits [127:64].

*Remark {counter:remark}*::
[.red]#*We may have to redefine this!* `partialsccif` is defined with a process similar to the `marchid` register.
While we do not mandate a specific format for the plaintext data underlying the SCC for an incomplete CC, we require the implementations to provide documentation for this format, whether they are open or closed source.
These formats will be documented and published in an appendix by RVI. We do not envision many formats, and 16 bits are likely to be abundant.
This field can be used to determine whether the exported format from a suspended configure, import or export operation is compatible with the current µarchitecture, in which case the suspended operation can be resumed, otherwise the operation must be restarted anyway. All implementations must support restart, resuming is optional.#

// If is derived from the JEDEC Standard Manufacturer’s Identification Code as follows.
// The most significant bit is set to 1 if the format is private and commercial JEDEC or to 0 if the format is documented.
// If the most significant  bit is set to 1, then the remaining 23 bits are
// the 10-bit bank (number of `0x7F` Continuation Codes, minus one), a 7-bit offset, and a 6-bit revision number
// If the most significant bit is set to 0, then the remaining 23 bits are assigned and maintained by RVI to distinguish mutually non-compatible formats.
// However, since we do not expect many different formats,


*Remark {counter:remark}*:: Filtering according to Supervisor Domains/Worlds is not currently supported, since in this case we believe that re-configuring the CTK is a more solid approach. This also allows us to avoid having to define an even longer MD format, at least for now.

=== Formats of Configuration Inputs and Sealed Configuration Contexts

==== Configuration Input

===== With Short Metadata

*TBD*

===== With Long Metadata

*TBD*

==== Sealed Configuration Context

*TBD*

===== With Short Metadata

.Generation of the SCC from a CC with short metadata
[source,sail]
----
let P : bits(256) P = keys @ internal
let N : bits(96) N = random(96 bits)
Derive Kenc and Kauth from effective CTK as per RFC 8452.
let SIV : bits(96) = Poly1305(Kauth, N, metadata @ P)[95:0]
M[0][127:0] = N[63:0] @ ((metadata[63:32] xor AESE(Kenc, SIV @ 0x0000 0000)[63:32])
                      @ metadata[31:0]
M[1][127:0] = SIV[95:0] @ N[95:64]
for i = 0 to num_blocks(P)-1
     M[i+2][127:0] = (block i of P) xor AESE(Kenc, SIV @ (binary(i+1)[31:0]))
----

//Notation: xor, {or}, {and}, and {lshift} denote XOR, OR, AND, and left shift, respectively.
(Recall that by `x` @ `y` we indicate the concatenation of `x` and `y`, where the bits of `x` become the most significant part of the concatenated value, and the bits of `y` its least significant part.)



Line 4: Do not encrypt public MD bits.

Line 5: Encrypt private MD bits.

Line 6: Concatenate remaining 32 bits of the nonce and the SIV.

Note: In this simplification of AES-GCM-SIV there is no need to add the lengths of metadata and keys+internal state to the hash because these lengths are implied already by the clear bits of the metadata itself — which are included in the computation of the authentication tag
Some details are fixed in general. For instance, all “pure” ciphers have only one key, whether in normal or threshold implementation, the latter always reduced to one key, as well as for some modes. In other cases, there must be a specific formatting of the state.
Keys and additional_state fields are always a multiple of 128 bits.

===== With Long Metadata

*TBD*

=== Constants

==== Error Codes

*TBD*

==== Other Constants

*TBD*

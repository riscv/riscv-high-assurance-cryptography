=== Data Structures

[[ACE-metadata]]
==== Metadata Section Format

The metadata section is 64 bits long and its format described in <<ACE-metadata-standard>>.
This format is used to for CC initialization, export and import purposes.
The internal representation of the metadata in CF memory is implementation dependent.

To initialize a CC, the first 64 bits of the input buffer contain the metadata in entirely in cleartext.
The metadata is in cleartext also in exported SCCs.
The entire metadata section is included in the computation of the authentication tag.
The details are described in <<ACE-formats>>.

[#ACE-metadata-standard]
.Format of the Metadata Section
[width="100%",cols=">9%,^7%,17%,67%",options="header"]
|===
|   Field | Width | Name                  | Description
|     [0] |   1  | Format                 | 0 for the current metadata format. +
Future format will have a 1 in this position and may be longer than 64 bits.
|   [8:1] |   8  | Algorithm              | Algorithm (such as primitive or mode). 0 means the CC is invalid.
|  [10:9] |   2  | SC_Protection          | Level of Side Channel Protection, encoded as per <<ACE-SC-protection-levels>>.
| [12:11] |   2  | Direction_Policy       | Determines whether the CC may be used for encryption (bit 11 set), decryption (bit 12 set), or both (bits 11 and 12 set).
Valid only for encryption/decryption primitives or modes, and ignored, for instance, for hash functions.
| [14:13] |   2  | Key_Type               | By explicit value / Immutable (index) / Internally generated.
| [18:15] |   4  | Locale                 | Field which is either -1 or an index into the Locale Secrets Table.
| [20:19] |   2  | Completion             | Defined in <<ACE-CC-complete>>.
Used to determine whether an operation must be restarted.
| [24:21] |   4  | Stage (also Direction) | Encoding the current state of the state machine of the algorithm as a number (also called the "stage" of the algorithm).
It must be zero upon configuration, otherwise algorithm specific.
If, for the algorithm encoded in the CC, the number of states is less than 16, then this number is stored in this field, cf. <<stage-field>>,
otherwise an algorithm-specific representation is used in the content, and this field only admits the values 0 (initial) and 1 (anything else).
| [28:25] |   4  | UC_Policy_1            | "UC Policy" means "Use Control Policy". +
Disallow the _use_ of this CC in User, (Virtual) Supervisor, Hypervisor, resp., Machine Mode if bit 25, 26, 27, resp. 28, is set. Cf. <<stage-no-H-no-VMID>>.
| [30:29] |   2  | UC_Policy_2            | If bit 29, resp., 30, is set, then restrict USE by `ASID`, resp., `VMID`. Restriction by `ASID` ignored if in S Mode or higher. Cf. <<stage-no-H-no-VMID>>.
|    [31] |   1  | Reserved               | Undefined.
| [47:32] |  16  | UC_Policy_3            | Zero if bit 29 unset, else `ASID` to enforce.
| [63:48] |  16  | UC_Policy_4            | Zero if bit 30 unset, else `VMID` to enforce. Cf. <<stage-no-H-no-VMID>>.
|===

[[ACE-SC-protection-levels]]
.Encoding of side-channel protection levels
[float="center",align="center",width="76%",cols="^8%,<68%",options="header"]
|===
| Value | Description
|   0   | No protection.
|   1   | Data independent timing, first-order threshold implementation.
|   2   | Data independent timing, first-order threshold, fault tolerant implementation.
|   3   | Custom, algorithm dependent.
|===

Custom algorithms may offer stronger side channel protection guarantees than those specified in the encoding values 0 to 2.
In such a case, the value of the SC_Protection field must be set to 3.

<<<

[[ACE-CC-complete]]
.Encoding of completion field
[float="center",align="center",width="58%",cols="^8%,<50%",options="header"]
|===
| Value | Description
|   0   | No protection.
|   1   | `ace.init`, `ace.input`, or `ace.output` was interrupted.
|   2   | `ace.import` was interrupted.
|   3   | `ace.export` was interrupted.
|===

// Whether the CC is complete (00) or interrupted while being configured (01), imported (10) or exported (11). Necessary to know whether to restart operations.

[[stage-field,Remark {counter:remark}]]
*Remark {counter:remark}.* _The "state" field accommodates modes of operation with a small number of states.
For algorithms with more complex state machines, machine state information can be stored in a custom data section of the CC._

[[state-no-H-no-VMID,Remark {counter:remark}]]
*Remark {counter:remark}.* _If the H extension is not enabled, bit 27 must be set to 1, and bits 30 and [63:48] must be set to 0.
The "UC_Policy_4" field is 16 bits long for compatibility with architectures employing 16-bit `VMID` fields (for instance, in heterogeneous systems).
While interoperability cannot be guaranteed when this policy is used, this ensures that the two top bits are not used for other purposes. +
Filtering use by Supervisor Domain or World ID is not supported, and not only because of lack of space in a 64-bit metadata section:
Reconfiguring the CTK is a better approach for such isolation requirements, whereas isolation by `ASID` and `VMID` is a weaker security feature._

[[ACE-formats]]
==== Formats of Configuration Inputs and Sealed Configuration Contexts

The format of the input to `ace.init` is simple: the first 8 bytes must contain the 64-bit metadata section, followed by any key and additional information in a format specified by the algorithm. The total length of this input must be a multiple of 8 bytes.
The lengths of the configuration payload, of the content section, and of SCCs is given in bytes.

Each algorithm must provide following functions:

* `metadata_serialize(CC) -> byte array`: Serializes the internal metadata into a 64-bit block for export.
* `metadata_deserialize(CC,byte array) -> CC.metadata`: Takes takes a metadata block formatted as described in <<ACE-metadata>> and deserializes it for the internal representation in the CC's metadata section.
* `initial_content_deserialize(CC,byte array) -> CC.content`:
Reads the information provided to `ace.init` as the byte array that follows the metadata, and deserializes it for the internal representation.
It should be the same as the format used for the SCC except for some omitted fields.
* `content_serialize(CC) -> byte array`: Serializes a CC's content to byte array to be encrypted for export.
* `content_deserialize(CC,byte array) -> CC.content`:
Takes the decrypted byte array, that come after the the metadata, nonce and authentication tag, and deserializes it into a CC's content.
The format depends on the algorithm which is specified in metadata information.

See <<ACE-Algorithms>> for algorithm specific details.

The size of a SCC, and thus of all byte arrays read or written by the above 5 functions, is always a multiple of 8 bytes.

Format of Configuration Input:::
The first 8 bytes must contain the 64-bit metadata section as specified in <<ACE-metadata>>,
followed by the key(s) and possibly other information as specified by the algorithm.

Plaintext Format of SCC:::
bytes[7:0]{nbsp}{nbsp} contain contain the 64-bit metadata section +
bytes[19:8]{nbsp}{nbsp} contain the nonce (96 bits) +
bytes[31:20] {nbsp}{nbsp}contain the SIV (96 bits) +
bytes[u+31,32]{nbsp}{nbsp} contain `content_serialize(CC.content)`, where u is the number of bytes in `content_serialize(CC.content)`.

Only the serialization of the content is encrypted, while both metadata and content are authenticated, as described next.

//[[ACE-AEAD]]
//==== Authenticated Encryption of a Context

To describe how a SCC generated, we first define the RFC8452 Key Derivation and the Locale CTK Derivation functions.

.RFC8452 Key Derivation
[source,sail]
----
function RFC8452_KeyDeriv(K) = {
  struct {
    AESE256(K, (0[125:0] @ 0b101))[63:0] @ AESE256(K, (0[125:0] @ 0b100))[63:0] @
    AESE256(K, (0[125:0] @ 0b011))[63:0] @ AESE256(K, (0[125:0] @ 0b010))[63:0],
    AESE256(K, (0[125:0] @ 0b001))[63:0] @ AESE256(K, (0[125:0] @ 0b000))[63:0]
  }
}
----

.Derived Key Derivation
[source,sail]
----
function RFC8452_KeyDeriv(K,L) = {
  AESE256(K, L ^ (0[125:0] @ 0b011))[63:0] @ AESE256(K, L ^ (0[125:0] @ 0b010))[63:0] @
  AESE256(K, L ^ (0[125:0] @ 0b001))[63:0] @ AESE256(K, L ^ (0[125:0] @ 0b000))[63:0]
}
----

We can now define the generation of the SCC from a CC.

.Generation of the SCC from a CC
[source,sail]
----
metadata : bits(64);
last_block_fractional : bits(1);
content : array[num_blocks] of bits(128);
M : array[num_blocks+2] of bits(128);
let N : bits(96) = random(96 bits);
Kenc : bits(256);
Kauth : bits(128);
{Kenc, Kauth} = RFC8452_KeyDeriv(CTK);
let SIV : bits(96) = POLYVAL(Kauth, N, metadata @ content)[95:0];

M[0][127:0] = N[63:0] @ metadata[63:0];
M[1][127:0] = SIV[95:0] @ N[95:64];
if (last_block_fractional) then last = num_blocks - 1 else last = num_blocks - 2
foreach(i from 0 to last) {
    M[i + 2][127:0] = content[i] xor AESE(Kenc, SIV @ (binary(i)[31:0]));
}
if (last_block_fractional) then {
    M[last + 1][63:0] = content[last + 1]
                        xor AESE(Kenc, SIV @ (binary(last + 1)[31:0]))[63:0];
}
----

NOTE: Due to the computational cost of the derivation functions, implementations may cache recently used derived keys for both the base CTK and locale-derived keys.

//NOTE: This simplification of AES-GCM-SIV does not require appending the lengths of metadata and content to the hash, as these lengths are already implied by the cleartext bits of the metadata, which are included in the authentication tag computation.

NOTE: Certain format details are fixed across algorithms. All pure ciphers use a single key, regardless of whether they employ a normal or threshold implementation; threshold implementations are always reduced to a single key. Some modes follow the same convention, while others require algorithm-specific state formatting.

// The total output length must be a multiple of 64 bits. If the combined metadata and content do not meet this requirement, the final block is zero-padded.

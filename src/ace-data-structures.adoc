[[Cryptographic-Contexts]]
=== Cryptographic Contexts

A CC contains two fields: the `metadata` and the `state`.

Key material and possibly other algorithm-specific data are contained in the state.

[[Metadata]]
=== Metadata Fields

*To be discussed* _We are open to agree on either using a single metadata format (the 128-bit version) or making the 64-bit format mandatory and the 128-bit format optional._

The metadata field exists in two versions, short (64-bit) and long (128-bit). The short version is structured as follows:

.Metadata: 64-bit version
[width="100%",cols=">9%,^9%,17%,57%,^8%",options="header"]
|===
|   Field | Bits | Name                   | Description | Type
|     [0] |   1  | Format                 | 0 for short metadata format (64-bit) | Public
|   [8:1] |   8  | Algorithm              | Which primitive or mode (msb = 0 for architected algorithms, msb = 1 for custom ones). | Public
|     [9] |   1  | Side Channel Protected | Set if we require the implementation of the algorithm to provide Side Channel Protection. | Public
| [11:10] |   2  | Direction Policy       | Use for encryption/decryption/both (only for enc/dec primitives or modes). | Public
| [13:12] |   2  | Key Type               | By explicit value / Immutable (index) / Internally generated. | Public
| [17:14] |   4  | Locale                 | Field which is either -1 or an index into the Locale Secrets Table. | Public
| [19:18] |   2  | Complete               | Whether the CC is complete (00) or interrupted while being configured (01), imported (10) or exported (11). Necessary to know whether to restart operations. | Public
| [25:20] |   6  | Stage/Direction        | Which internal stage the algorithm is, as defined by ace_stage or implicitly. Must be ZERO on configuration. This is algorithm defined. | Private
| [29:26] |   4  | AC Policy 1            | Is a User (if bit 28 set)/Supervisor or Virtual Supervisor (bit 29 set)/Hypervisor (bit 30 set)/Machine (bit 31 set) forbidden to USE this key? | Private
| [31:30] |   2  | AC Policy 2            | If bit 32, resp., 33, is set, then restrict USE by `ASID`, resp., `VMID`. | Private
| [47:32] |  16  | AC Policy 3            | Zero if bit 32 unset, else `ASID` to enforce.  | Private
| [61:48] |  14  | AC Policy 4            | Zero if bit 33 unset, else `VMID` to enforce.  | Private
| [63:62] |   2  | Reserved               | Undefined.  | Private
|===

*Remark {counter:remark}*:: The short metadata format contains 20 bits of public metadata and 44 bits of private metadata.

*Remark {counter:remark}*:: The two bits after AC Policy 4 can be used in case `VMID` is extended to 16 bits, and for compatibility
of metadata formats with architectures that use a 16-bit `VMID` field, for instance in heterogeneous systems.

*Remark {counter:remark}*:: For side-channel protection, we currently only require a data-independent-timing and first-order threshold implementation.
However, we are open to discuss using more bits to specify higher orders of protection.

The long version of the metadata is structured as follows:

.Metadata: 128-bit version
[width="100%",cols=">9%,^9%,17%,57%,8%",options="header"]
|===
|     Field | Bits | Name                   | Description | Type
|       [0] |   1  | Format                 | 1 for long metadata format (128-bit) | Public
|     [8:1] |   8  | Algorithm              | Which primitive or mode (msb = 0 for architected algorithms, msb = 1 for custom ones). | Public
|       [9] |   1  | Side Channel Protected | Set if we require the implementation of the algorithm to provide Side Channel Protection. | Public
|   [11:10] |   2  | Direction Policy       | Use for encryption/decryption/both (only for enc/dec primitives or modes). | Public
|   [13:12] |   2  | Key Type               | By explicit value / Immutable (index) / Internally generated. | Public
|   [17:14] |   4  | Locale                 | Field which is either -1 or an index into the Locale Secrets Table. | Public
|   [19:18] |   2  | Complete               | Whether the CC is complete (00) or interrupted while being configured (01), imported (10) or exported (11). Necessary to know whether to restart operations. | Public
|   [25:20] |   6  | Stage/Direction        | Which internal stage the algorithm is. Must be ZERO on configuration. This is algorithm defined. | Private
|   [29:26] |   4  | AC Policy 1            | Can a User (if bit 28 set)/Supervisor or Virtual Supervisor (bit 29 set)/Hypervisor (bit 30 set)/Machine (bit 31 set) USE this key? | Private
|   [31:30] |   2  | AC Policy 2            | If bit 32, resp., 33, is set, restrict USE by `ASID`, resp., `VMID`. | Private
|   [47:32] |  16  | AC Policy 3            | Zero if bit 32 unset, else `ASID` to enforce.  | Private
|   [61:48] |  14  | AC Policy 4            | Zero if bit 33 unset, else `VMID` to enforce.  | Private
|   [63:62] |   2  | Reserved               | Undefined.  | Private
|   [67:64] |   4  | Version                | Metadata format version | Public
|   [83:68] |  16  | `partialsccif`         | (Partial SCC Implementation Format) ID of the µarchitectural format for CCs with interrupted operations. | Public
|  [115:84] |  28  | `marchpriv`            | Implementation private metadata | Private
| [127:112] |  16  | Reserved               | Reserved for future versions | Private
|===

*Remark {counter:remark}*:: In the 128-bit version of the metadata, the first 64-bit word (i.e., at the lowest address) contains bits [63:0] and the second 64-bit word (i.e., at the byte address of the first word, plus 8) contains bits [127:64].

*Remark {counter:remark}*::
[.red]#*We may have to redefine this!* `partialsccif` is defined with a process similar to the `marchid` register.
While we do not mandate a specific format for the plaintext data underlying the SCC for an incomplete CC, we require the implementations to provide documentation for this format, whether they are open or closed source.
These formats will be documented and published in an appendix by RVI. We do not envision many formats, and 16 bits are likely to be abundant.
This field can be used to determine whether the exported format from a suspended configure, import or export operation is compatible with the current µarchitecture, in which case the suspended operation can be resumed, otherwise the operation must be restarted anyway. All implementations must support restart, resuming is optional.#

// If is derived from the JEDEC Standard Manufacturer’s Identification Code as follows.
// The most significant bit is set to 1 if the format is private and commercial JEDEC or to 0 if the format is documented.
// If the most significant  bit is set to 1, then the remaining 23 bits are
// the 10-bit bank (number of `0x7F` Continuation Codes, minus one), a 7-bit offset, and a 6-bit revision number
// If the most significant bit is set to 0, then the remaining 23 bits are assigned and maintained by RVI to distinguish mutually non-compatible formats.
// However, since we do not expect many different formats,


*Remark {counter:remark}*:: Filtering according to Supervisor Domains/Worlds is not currently supported, since in this case we believe that re-configuring the CTK is a more solid approach. This also allows us to avoid having to define an even longer MD format, at least for now.

=== Formats of Configuration Inputs and Sealed Configuration Contexts

==== Configuration Input

===== With Short Metadata

*TBD*

===== With Long Metadata

*TBD*

==== Sealed Configuration Context

*TBD*

===== With Short Metadata

.Generation of the SCC from a CC with short metadata
[source,sail]
----
let P : bits(256) P = keys @ internal
let N : bits(96) N = random(96 bits)
Derive Kenc and Kauth from effective CTK as per RFC 8452.
let SIV : bits(96) = Poly1305(Kauth, N, metadata @ P)[95:0]
M[0][127:0] = N[63:0] @ ((metadata[63:32] xor AESE(Kenc, SIV @ 0x0000 0000)[63:32])
                      @ metadata[31:0]
M[1][127:0] = SIV[95:0] @ N[95:64]
for i = 0 to num_blocks(P)-1
     M[i+2][127:0] = (block i of P) xor AESE(Kenc, SIV @ (binary(i+1)[31:0]))
----

//Notation: xor, {or}, {and}, and {lshift} denote XOR, OR, AND, and left shift, respectively.
(Recall that by `x` @ `y` we indicate the concatenation of `x` and `y`, where the bits of `x` become the most significant part of the concatenated value, and the bits of `y` its least significant part.)



Line 4: Do not encrypt public MD bits.

Line 5: Encrypt private MD bits.

Line 6: Concatenate remaining 32 bits of the nonce and the SIV.

Note: In this simplification of AES-GCM-SIV there is no need to add the lengths of metadata and keys+internal state to the hash because these lengths are implied already by the clear bits of the metadata itself — which are included in the computation of the authentication tag
Some details are fixed in general. For instance, all “pure” ciphers have only one key, whether in normal or threshold implementation, the latter always reduced to one key, as well as for some modes. In other cases, there must be a specific formatting of the state.
Keys and additional_state fields are always a multiple of 128 bits.

===== With Long Metadata

*TBD*

=== Constants

==== Error Codes

In <<ACE-error-values>> we define the mandatory ACE error codes.
[.red]#The list may still be incomplete.#
Additional ones may be defined in the range [128,255] that are algorithm specific, which are allowed to overlap between algorithms.

[[ACE-error-values]]
.Error values and their meanings
[float="center",align="center",width="100%",cols="^6%,<24%,<70%",options="header"]
|===
|Value | Mnemonic                  | Examples
|  0   | ace_err_ok                | All is fine. Life is beautiful. No error from ACE.
|  1   | ace_err_authentication    | Authentication failure in `ace.import`, but can also follow `ace.exec` with certain algorithms.
|  2   | ace_err_privilege         | `ace.exec`, `ace.stage`, `ace.derive`, `ace.spawn` failed because the access control policies in the metadata prevent USE in the current architectural state.
|  3   | ace_err_invalid           | Invalid input or operation.
Examples:
the metadata field passed to `ace.init` is invalid;
encryption, resp., decryption is requested from a CC only configured for decryption, resp., encryption;
the requested change of state in `ace.stage` is not permitted;
the current state of the CC does not expect the used form of `ace.exec`;
the change in usage policies in `ace.restrict` is not permitted because it would either downgrade or overwrite the current restrictions in the CC;
a request to clone a CC violates the re-initialisation policies of the source CC.
|  4   | ace_err_unimplemented     | The requested algorithm is not implemented. May be triggered also on algorithm variants, for instance if `ace.harden` is issued on an algorithm for which a non-side channel protected version is not implemented.
|  5   | ace_err_memory            | The free internal CF memory is not sufficient to perform the `ace.init`, `ace.exec`, `ace.clone`, or `ace.derive`.
The implementation should make sure this cannot happen with any other operation.
If algorithms that support `ace.derive` are implemented, the implementation must make sure that both the input and output CCs of this operation can be allocated.
|  6   | ace_err_clearCC           | Software tried to use a cleared CC as a source in a `ace.exec`, `ace.stage`, `ace.input`, `ace.output`, `ace.clone`, `ace.derive`, `ace.harden`, `ace.restrict` operations. +
This can be used in low CF memory situations to trigger a re-load of that CC.
|===

==== Other Constants

[.red]#*To be completed.*#

In addition to error codes, ACE defines several constants, such as
those in <<ACE-set_stage_constants>> which are used in `ace.stage`/`ace.dir` to change the state of a CC.
Note that the internal state machine of a CC may also be changed implicitly by `ace.exec` or `ace.derive` operations, and the state machine of a cloned CC may be changed implicitly according to the algorithm's policies as encoded in the source CC's metadata.

[[ACE-set_stage_constants]]
.Constants defining messages sent to a CC through `ace.stage`/`ace.dir` operations
[float="center",align="center",width="100%",cols="^6%,<29%,<65%",options="header"]
|===
|Value | Mnemonic                    | Examples
|  0   | ace_const_ok                | All is fine. Life is beautiful. No error from ACE.
|  1   | ace_const_encrypt           | Encryption is requested.
|  2   | ace_const_decrypt           | Decryption is requested.
|  3   | ace_const_hash_start        | Start (and initialize) a hash function or the sub-function of an algorithm.
|  4   | ace_const_hash_finalize     | Finalize the internal state of a hash function and prepare it for outputting the result.
|  5   | ace_const_hash_update       | Update the internal state of a hash function with new data.
|  6   | ace_const_set_public_value  | Set a public value (like a nonce or an IV) in an algorithm. Some algorithms require more than one public value (for instance, a re-useable hash of some associated data and a unique nonce), in which case the second public value can be set using the next message.
|  7   | ace_const_set_public_value_2  | Set the second public value in an algorithm.
|===

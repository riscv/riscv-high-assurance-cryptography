[[Details]]
== Architecture

=== Data Structures

A CC contains two fields: the `metadata` and the `state`.

Key material and possibly other algorithm-specific data are contained in the state.

[[Metadata-Fields]]
==== Metadata Fields

The metadata field exists in two versions, short (64-bit) and long (128-bit). The short version is structured as follows:

.Metadata: 64-bit version
[width="100%",cols=">9%,17%,66%,^8%",options="header",frame=ends, grid=rows]
|===
|   Field | Name | Description| Type
|     [0] |  Format | 0 for short metadata format (64-bit) | Public
|   [4:1] |  Version | Metadata format version | Public
|  [12:5] |  Algorithm | Which primitive or mode (msb = 0 for architected algorithms, msb = 1 for custom ones). | Public
|    [13] |  Side Channel Protected | Does this implementation of the algorithm provide Side Channel Protection? We only require constant-time and a first order threshold implementation. | Public
| [15:14] |  Direction_Policy | Use for encryption/decryption/both (only for enc/dec primitives or modes). | Public
| [17:16] |  Key_Type | By explicit value / Immutable (index) / Internally generated. | Public
| [22:18] |  Lifecycle | Field which is either -1 or an index into the table of Lifecycle Binding Secrets. | Public
| [23:23] |  Sealed | Whether the CC is complete (00) or interrupted while being configured (01), imported (10) or exported (11). Necessary to restart/resume operations. | Public
| [27:24] |  Error | Last error value | Public
| [29:28] |  Cloning_Policy | Value 00 means the CC cannot be cloned, else the CC can be cloned, and the values
             01, resp., 10 and 11 mean that the clone _can_ be re-initialised, resp., _must_ be re-initialised upon cloning, and _cannot_ be re-initialised. | Public
| [37:32] |  Stage/Direction | Which internal stage the algorithm is, as defined by ace_stage or implicitly. Must be ZERO on configuration. This is algorithm defined | Private
| [41:38] |  AC_Policy_1 | Can a User/Supervisor/Hypervisor/Machine use it? (Import/export/overwrite always allowed.) | Private
| [43:42] |  AC_Policy_2 | Restrict USE to specific User/Suopervisor? (Import/export/overwrite always allowed.) | Private
| [59:44] |  AC_Policy_3 | IDs to filter User OR Supervisor (filtering both or even world, or higher resolution, is delegated to future versions, with metadata larger than 64 bits). | Private
| [63:60] |  Reserved | Zero | Private
|===

<<<
The long version of the metadata is structured as follows:

.Metadata: 128-bit version
[width="100%",cols=">9%,17%,66%,^8%",options="header",frame=ends, grid=rows]
|===
|     Field | Name | Description| Type
|       [0] |  Format | 1 for long metadata format (128-bit) | Public
|     [4:1] |  Version | Metadata format version | Public
|    [12:5] |  Algorithm | Which primitive or mode (msb = 0 for architected algorithms, msb = 1 for custom ones). | Public
|      [13] |  Side Channel Protected | Does this implementation of the algorithm provide Side Channel Protection? We only require constant-time and a first order threshold implementation. | Public
|   [15:14] |  Direction_Policy | Use for encryption/decryption/both (only for enc/dec primitives or modes). | Public
|   [17:16] |  Key_Type | By explicit value / Immutable (index) / Internally generated. | Public
|   [22:18] |  Lifecycle | Field which is either -1 or an index into the table of Lifecycle Binding Secrets. | Public
|   [23:23] |  Sealed | Whether the CC is complete (00) or interrupted while being configured (01), imported (10) or exported (11). Necessary to restart/resume operations. | Public
|   [27:24] |  Error | Last error value | Public
|   [29:28] |  Cloning_Policy | Value 00 means the CC cannot be cloned, else the CC can be cloned, and the values
               01, resp., 10 and 11 mean that the clone _can_ be re-initialised, resp., _must_ be re-initialised upon cloning, and _cannot_ be re-initialised. | Public
|   [31:30] |  Reserved | Zero | Public
|   [63:32] |  VendorID | JEDEC manufacturer ID of the provider of the core | Public
|   [67:64] |  Revision ID | Revision ID of the manufacturer’s implementation of resuming | Public
|   [83:68] |  Reserved for Partial | Information for resuming (similar to VSTART for RVV, but impdef)) | Public
|   [89:84] |  Stage/Direction | Which internal stage the algorithm is, as defined by ace_stage or implicitly. Must be ZERO on configuration. This is algorithm defined | Private
|   [93:90] |  AC_Policy_1 | Can a User/Supervisor/Hypervisor/Machine use it? (Import/export/overwrite always allowed.) | Private
|   [95:94] |  AC_Policy_2 | Restrict USE to specific User/Supervisor? (Import/export/overwrite always allowed.) | Private
|  [111:96] |  AC_Policy_3 | IDs to filter User OR Supervisor (filtering both or even world, or higher resolution, is delegated to future versions). | Private
| [127:112] |  Reserved | Zero | Private
|===

We note that in the 128-bit version of the metadata, the first 64-bit word (i.e., at the lowest address) contains bits [63:0] and the second 64-bit word
(i.e., at the byte address of the first word, plus 8) contains bits [127:64].

<<<
==== Instructions

We now give the abbreviated listing of the instructions defined by ACE.

.The ACE instructions
[width="100%",cols="17%,21%,62%",options="header",frame=ends, grid=rows]
|===
| Instruction   | Operands                  | Description
| ACE.ENABLE    | flag=blocking             |  Enable the feature in the current process domain. It also sets a bit in a feature CSR for use by the parent domain — or implemented by a CSR write (so, WARL).
| ACE.DISABLE   |                           |  Disable the feature in the current process domain.
| ACE.CONFIG    | Cn\|Xn, [Xs]              |  Sets the algorithm and either the key or info on how to fetch and use system key (keystore).
| ACE.CLEAR     | Cn\|Xn                    |  Clear a CC and mark it as no longer in use (both in the CC internal table and in the feature CSR).
| ACE.SIZE      | Xd, Cn\|Xn                |  Returns the size in bytes of the package exported from a specified CC,
| ACE.SIZE      | Xd, #immed                |  or from a specific algorithm given as #immed (including the side channel bits)
| ACE.EXPORT    | [Xn], Cs\|Xs              |  Exports the content of a CC to an encrypted and authenticated package to memory. Remember that there is no "save" instruction to extract key and all metadata in the clear.
| ACE.IMPORT    | Cd\|Xd, [Xn], flag=system |  Reads an encrypted and authenticated package from memory and imports it into a CC if ok. ace import can also provide import for system defined blobs or connect a context to an entry of an Immutable System Key table (which is usually inaccessible to SW environments) if the system flag == true.
| ACE.EXEC      | Vd, Cn\|Xn, Vs         .4+| Performs a cryptographic operation such as an encryption or decryption, absorbing a value in a hash, and possibly returning a value. The instruction may also modify an internal state machine of the CC. It has four variants: has input and output, has I but not O, has no I but produces an O, has no I and O. (The fourth variant is used to encode the next instruction, which is then a pseudo-instruction).
| ACE.EXEC      | Cn\|Xn, Vs
| ACE.EXEC      | Vd, Cn\|Xn
| ACE.EXEC      | Cn\|Xn
| ACE.SET_STAGE | Cn\|Xn, #immed         .2+| Changes the stage of a multi-stage function (such as hash functions or modes of operation) or provide additional info.  For instance, for  block cipher/mode of operation keys it also sets encryption / decryption. SET_DIR is an alias for SET_STAGE.
| ACE.SET_DIR   | Cn\|Xn, #immed
| ACE.AVAILABLE | #immed                    |  Informs whether a given primitive is supported by the µarch (IDs standardized) — Can be a CSRs read.
| ACE.ERROR     | Xd, Cn\|Xn                |  Returns the error of an operation — Can be a CSRs read.
| ACE.CLONE     | Cd\|Xd, Cs\|Xs, flag=init |  Clones a CC into a second CC.
| ACE.BUSY      | Xd                        |  Check whether the operation writing to vector register Xd has completed — Can be a CSRs read.
| ACE.CCBUSY    | Cd\|Xd                    |  Check whether the operation reading/writing to CC Cd or *Xd has completed — Can be a CSRs read.
|===

<<<
==== List of CSRs

We need four bits in a CSR called `ACE_CC_ENABLED` to denote whether the feature is enabled or disabled for the current process domain:

* Bits 0..3 are for EL0..EL3 or User/(Virtual)Supervisor/HV/MM, respectively.
* The bit corresponding to the current mode/EL is set/cleared when `ace.enable`/`ace.disable` is issued
* If one of these bit is set, the bits corresponding to higher levels are also set.
* If one of these bit is cleared, the bits corresponding to lower levels are also cleared.
* This register cannot be set directly, and it can only be read directly.

We need one `ACE_CC_BLOCKING` bit to establish whether the unit is working in a blocking way (1, default mode) or non-blocking (0).
Here, blocking means that any instruction that accesses the content of an output register of a previous ACE instruction will automatically have to wait that the results are retired, otherwise the completion status of the instruction will have to be followed in a CSR.

A 32-bit CSR `ACE_CC_USED` with a bit per CC to denote whether the register is in use or not (cleared contextually to CC erasure to dispose of the key). Read-only.

A 32-bit CSR `ACE_CC_DIRTY` with a bit per CC to keep track whether the corresponding CC has been modified since the last time the same bit has been cleared. +
Two types actions can modify a CC and thus must update also `ACE_CC_DIRTY`:

* An explicit configuration/import; and
* Certain cryptographic operations, such as absorbing information in a hash function, that modify the internal state.

It is also possible to directly write to `ACE_CC_DIRTY`, and in fact necessary to optimize context switching.

A 32-bit CSR `ACE_CC_BUSY` with a bit per vector register to keep track whether any operation writing to a certain register is still operating.

256-bit worth of CSR `ACE_CTK` to store the the CTK.

* `ACE_CTK` is writable exclusively by MM.
* `ACE_CTK` reads as zero in all cases.
//There is need to raise exceptions if any other mode/EL tries to write to it or read it.

Two CSRs at U, resp., S level, namely `UKSID` (User Key Space ID ) and/or `SKSID` (Supervisor Key Space ID), which are only writable at S, resp., a higher mode.
We can reuse the CSRs for `ASID`, resp., `VMID` for`UKSID`, resp., `SKSID`.

*Remark:* _We do not envision direct key sharing across Worlds/Supervisor Domains, so consider defining a Hypervisor or World "Key Space ID" as redundant.
It is the responsibility of the MM to change CTKs between Worlds/Supervisor Domains._

The software in each World/Supervisor Domain is normally responsible to generate their own keys, and if a process (applet) in one World/Supervisor Domain is responsible to provide keys to other Worlds/Supervisor Domains, it is the responsibility of the MM to properly import/switch the CTK/export. If `ASID`/`VMID` are reused for `UKSID`/`SKSID`, we still need to distinguish somehow the use for separating key spaces even if these fields are not used to build GVAs/GPAs (TBD).

<<<

==== Lifecycle Binding

Internally, ACE has a table of 128-bit Lifecycle Binding Secrets (LBS), the LBST.

Some of these LBSs are fixed, other values may be configurable only using an impdef authenticated HW procedure, and the remaining may be programmed by MM (*Note:* _we need to define the corresponding CSRs_).
The LBST is a global table shared across all ACE units with some fields which can be overridden by values which are architected (i.e., per hart).
Currently, the only two values that may be overridden by architectural values, in order to support multiple VMs/Supervisor Domains/Worlds are System_Secret and Boot_Session.

If the lifecycle field of a context (CC/SCC) is -1 (all ones), then the CTK is used.
Otherwise, this value is used as an index _i_ in the Lifecycle Secrets Table, and a derived key `derived_key` computed from CTK and LS:=LST[_i_] is used for import/export in place of the CTK.
The key derivation function is the same as in AES-GCM-SIV:

[%autowidth,frame=none,grid=none,align=center]
|===
>| `derived_key` = | AES-256(CTK, LS)[63:0] \|\| AES-256(CTK, LS ⊕ (0^127^ \|\| 1))[63:0] \|\|
>|               | {nbsp}{nbsp}{nbsp}{nbsp} \|\| AES-256(CTK, LS ⊕ (0^126^ \|\| 10))[63:0] \|\| AES-256(CTK, LS ⊕ (0^126^ \|\| 11))[63:0]
|===

Since the derivation function is expensive, the ACE implementation is allowed to cache recently used Lifecycle Derived.

In <<lifecycle-binding-indices>>, we list the mandatory entries and their meaning.
At least four bits are needed to encode them.
Column MM-Writeable determines whether MM can write the corresponding value.

[[lifecycle-binding-indices]]
.Mandatory Values for Lifecycle Binding
[width="100%",cols="20%,52%,^9%,^9%",options="header",frame=ends, grid=rows]
|===
.>| Name .>| Description .>| MM-Writeable .>| Value
| No lifecycle binding | | | -1
| SiP | Identifies the manufacturer of the SoC. Permanent. | N | 0
| Chip_Model | Identifies specific chip model/family. Permanent. | N | 1
| Device_ID | Unique device identifier. Shareable across multiple SoCs. Sharing mechanism impdef, i.e., not architected. Can be permanent in a device — re-generations can be optionally triggered using impdef HW authenticated mechanisms. | N | 2
| Device_Type  | Identifies device type/model. Not necessarily permanent. Reconfigurable like Device_ID. | N | 3
| OEM_Secret | Provisioned by OEM to differentiate their products from the competition. Reconfigurable like Device_ID. | N | 4
| System_Secret | Identifies System (Stack). Not permanent, must be configured during (virtual) boot. | Y | 5
| Boot_Session | Regenerated at each (virtual) boot. | Y | 6
| _Reserved for Revocation_ | Regenerated at boot or at each revocation event. | Y | 7
|===

*Remark:* _We need to discuss what to do in case there is a reboot of a VM. Then we need to "virtualize" the seventh string, or use a secondary CTK for that purpose, since some VMs may reboot while others may not.
Also, do we want to allow a VM to have a different virtual hardware? Or does it always declare the same configuration as the underlying hardware?_
In principle, all this can be done by calling into MM. MM would need to keep track of the lifecycle binding values and ensure that they are updated correctly when necessary.

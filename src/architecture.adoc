[[Details]]
== Architecture
:sectnums:
:section-refsig:

=== Data Structures

A CC contains two fields: the `metadata` and the `state`.

Key material and possibly other algorithm-specific data are contained in the state.

[[Metadata-Fields]]
==== Metadata Fields

The metadata field exists in two versions, short (64-bit) and long (128-bit). The short version is structured as follows:

.Metadata: 64-bit version
[width="100%",cols=">9%,17%,66%,^8%",options="header",frame=ends, grid=rows]
|===
|   Field | Name | Description| Type
|     [0] |  Format | 0 for short metadata format (64-bit) | Public
|   [4:1] |  Version | Metadata format version | Public
|  [12:5] |  Algorithm | Which primitive or mode (msb = 0 for architected algorithms, msb = 1 for custom ones). | Public
|    [13] |  Side Channel Protected | Does this implementation of the algorithm provide Side Channel Protection? We only require constant-time and a first order threshold implementation. | Public
| [15:14] |  Direction Policy | Use for encryption/decryption/both (only for enc/dec primitives or modes). | Public
| [17:16] |  Key Type | By explicit value / Immutable (index) / Internally generated. | Public
| [22:18] |  Locale  | Field which is either -1 or an index into the Locale Secrets Table. | Public
| [23:23] |  Sealed | Whether the CC is complete (00) or interrupted while being configured (01), imported (10) or exported (11). Necessary to restart/resume operations. | Public
| [27:24] |  Error | Last error value | Public
| [31:28] |  Reserved | Zero | Public
| [37:32] |  Stage/Direction | Which internal stage the algorithm is, as defined by ace_stage or implicitly. Must be ZERO on configuration. This is algorithm defined | Private
| [41:38] |  AC Policy 1 | Can a User/Supervisor/Hypervisor/Machine USE this key?) | Private
| [43:42] |  AC Policy 2 | Restrict USE to specific User (if bit 42 set) or Supervisor (if bit 43 set)? Only one bit may be set. | Private
| [59:44] |  AC Policy 3 | IDs to filter by `UKSID` or `SKSID` (*to be double-checked: reuse `ASID` and `VMID`*).
(Filtering according to both needs the long format metadata.) | Private
| [63:60] |  Reserved | Zero | Private
|===

The short MD format contains 32 bits of public MD and 32 bits of private MD.


<<<
The long version of the metadata is structured as follows:

.Metadata: 128-bit version
[width="100%",cols=">9%,17%,66%,^8%",options="header",frame=ends, grid=rows]
|===
|     Field | Name | Description| Type
|       [0] |  Format | 1 for long metadata format (128-bit) | Public
|     [4:1] |  Version | Metadata format version | Public
|    [12:5] |  Algorithm | Which primitive or mode (msb = 0 for architected algorithms, msb = 1 for custom ones). | Public
|      [13] |  Side Channel Protected | Does this implementation of the algorithm provide Side Channel Protection? We only require constant-time and a first order threshold implementation. | Public
|   [15:14] |  Direction Policy | Use for encryption/decryption/both (only for enc/dec primitives or modes). | Public
|   [17:16] |  Key Type | By explicit value / Immutable (index) / Internally generated. | Public
|   [22:18] |  Locale  | Field which is either -1 or an index into the Locale Secrets Table. | Public
|   [23:23] |  Sealed | Whether the CC is complete (00) or interrupted while being configured (01), imported (10) or exported (11). Necessary to restart/resume operations. | Public
|   [27:24] |  Error | Last error value | Public
|   [31:28] |  Reserved | Zero | Public

|   [37:32] |  Stage/Direction | Which internal stage the algorithm is, as defined by ace_stage or implicitly. Must be ZERO on configuration. This is algorithm defined | Private
|   [41:38] |  AC Policy 1 | Can a User/Supervisor/Hypervisor/Machine use this context? | Private
|   [43:42] |  AC Policy 2 | Restrict USE to specific User (bit 42)/Supervisor (bit 43)? Both bits may be set in this version of the metadata. | Private
|   [59:44] |  AC Policy 3 | IDs to filter by `UKSID` (*to be double-checked: reuse `ASID`*) | Private
|   [73:60] |  AC Policy 4 | IDs to filter by `SKSID` (*to be double-checked: reuse `VMID`*) | Private
|   [79:74] |  Reserved | Zero | Private
|  [111:80] |  VendorID | JEDEC manufacturer ID of the provider of the core | Public
|  [115:112] |  Revision ID | Revision ID of the manufacturer’s implementation of resuming | Public
| [127:116] |  Reserved | Zero | Private
|===

We note that in the 128-bit version of the metadata, the first 64-bit word (i.e., at the lowest address) contains bits [63:0] and the second 64-bit word (i.e., at the byte address of the first word, plus 8) contains bits [127:64].

The long MD format contains 72 bits of public MD and 56 bits of private MD.
The first 64-bit word thus only contains public MD.
The 8 least significant bits of the second 64-bit word contain public MD and the rest is private MD.

Furthermore, we do not architect a field information to assist resuming in the metadata (similarly to VSTART for the V extension) because this is impdef information and therefore it will be included in the internal state of the CC. (This also means that the `ace.size` operation will have to take this into account.)

Filtering according to Supervisor Domains/Worlds is not currently supported, since in this case we believe that re-configuring the CTK is a more solid approach. This also allows us to avoid having to define an even longer MD format, at least for now.

<<<
==== Instructions Overview

.The ACE instructions
[width="100%",cols="16%,16%,68%",options="header",frame=ends, grid=rows]
|===
| Instruction     | Operands                  |  Description
| `ace.enable`    | flag=blocking             |  Enable the feature in the current process domain. It also sets a bit in a feature CSR for use by the parent domain — or implemented by a CSR write (so, WARL).
| `ace.disable`   |                           |  Disable the feature in the current process domain.
| `ace.config`    | Cn\|Xn, [Xs]              |  Sets the algorithm and either the key or info on how to fetch and use system key (keystore).
| `ace.clear`     | Cn\|Xn                    |  Clear a CC and mark it as no longer in use (both in the CC internal table and in the feature CSR).
| `ace.size`      | Xd, Cs\|Xs                |  Returns the size in bytes of the package exported from a specified CC,
| `ace.size`      | Xd, #immed                |  or from a specific algorithm given as #immed (including the side channel bits)
| `ace.export`    | [Xn], Cs\|Xs              |  Exports the content of a CC to an encrypted and authenticated package to memory. Remember that there is no "save" instruction to extract key and all metadata in the clear.
| `ace.import`    | Cd\|Xd, [Xn], flag=system |  Reads an encrypted and authenticated package from memory and imports it into a CC if ok. ace import can also provide import for system defined blobs or connect a context to an entry of an Immutable System Key table (which is usually inaccessible to SW environments) if the system flag == true.
| `ace.exec`      | Vd, Cn\|Xn, Vs         .4+| Performs a cryptographic operation such as an encryption or decryption, absorbing a value in a hash, and possibly returning a value. The instruction may also modify an internal state machine of the CC. It has four variants: +
(i) accepts an input and produces an output, (ii) accepts an input but produces no output,
(iii) accepts no input but produces an output, (iv) accepts no input and produces no output.
| `ace.exec`      | Cn\|Xn, Vs
| `ace.exec`      | Vd, Cn\|Xn
| `ace.exec`      | Cn\|Xn
| `ace.input`     | Cd\|Xd, [Xs]              |  Optional. Provides an input to the algorithm configured in the CC `Cd` or `C[Xd]`, in place of providing it through the `ace.exec` instruction. Useful when the inputs are very long, such as the inputs to certain public key schemes. Mandatory only if required by some algorithms.
| `ace.output`    | [Xd], Cs\|Xs              |  Optional. Writes the output of an algorithm configured in the CC `Cs` or `C[Xs]`, in place of providing it through the `ace.exec` instruction. Useful when the outputs are very long, such as the outputs of certain public key schemes. Mandatory only if required by some algorithms.
| `ace.stage`     | Cn\|Xn, #immed         .2+| Changes the stage of a multi-stage function (such as hash functions or modes of operation) or provide additional info.  For instance, for  block cipher/mode of operation keys it also sets encryption / decryption. `ace.dir` is an alias for `ace.stage`.
| `ace.dir`       | Cn\|Xn, #immed
| `ace.available` | #immed                    |  Informs whether a given primitive is supported by the µarchitecture.
| `ace.error`     | Xd, Cn\|Xn                |  Returns the error of an operation — Can be a CSRs read.
| `ace.clone`     | Cd\|Xd, Cs\|Xs            |  Clones a CC into a second CC.
| `ace.spawn`     | Cd\|Xd, Cs\|Xs            |  Optional. Uses the source CC to configure the destination CC. Used if the source CC is, for instance, a KEM that configures the destination CC with a symmetric key. Then, the SW can clear the source CC to release resources.
| `ace.vr_busy`   | Xd                        |  Check whether the operation writing to vector register Xd has completed. Can be a CSRs read.
| `ace.cc_busy`   | Cd\|Xd                    |  Check whether the operation reading/writing to CC Cd or *Xd has completed. Can be a CSRs read.
|===

<<<
==== List of CSRs

The following CSRs are _architectural_, namely, their contents are per hart:

`ACE_CC_STATUS`: four RO bits, to denote whether the feature is enabled or disabled for the various Modes:

* Bits 0..3 are for User, (Virtual) Supervisor, Supervisor (Hypervisor), Machine Modes, respectively.
* Bit 2 is ignored if the H extension is not enabled.
* The bit for the current Mode is set, resp., cleared when `ace.enable`, resp., `ace.disable` is executed.
* If one of these bit is set, the bits corresponding to the higher privileged Modes are also set.
* If one of these bit is cleared, the bits corresponding to the lower privileged Modes are also cleared.

256-bit worth of CSR `ACE_CTK` to store the the CTK.

* `ACE_CTK` is writable exclusively by MM.
* `ACE_CTK` reads as zero in all cases.
//There is need to raise exceptions if any other mode/EL tries to write to it or read it.

`ACE_CC_USED`: 32 bits, with a bit per CC to denote whether the register is in use or not (cleared contextually to CC erasure to dispose of the key). Read-only.

`ACE_CC_DIRTY`: 32 bits, with a bit per CC to track whether the corresponding CC has been modified since the last time the same bit has been cleared. +
Two types actions can modify a CC and thus must update also `ACE_CC_DIRTY`:

* An explicit configuration/import; and
* Certain cryptographic operations, such as absorbing information in a hash function, that modify the internal state.

It is also possible to directly write to `ACE_CC_DIRTY`, and in fact necessary to optimize context switching.

`ACE_CC_BLOCKING`: one bit to establish whether the unit is working in a blocking way (value 1, default mode) or non-blocking (value 0).
Here, "blocking" means that _any instruction that accesses the content of an output register of a previous ACE instruction will automatically have to wait that the results are retired, otherwise the completion status of the instruction will have to be followed in a CSR._ +
The mode is initially configured in by the `ace.enable` instruction (which may be implemented as a CSRW itself), but it can be changed at any time by writing to the `ACE_CC_BLOCKING` register.

`ACE_VR_BUSY`: 32 bits, one bit per vector register to track whether any operation writing to a certain register is still running.
In non-blocking mode, it is the responsibility of the user SW to avoid issuing a second instruction that reads from the output register of the first without waiting first for the completion of the previous operation. In blocking mode, the second instruction will be executed only after the first instruction has been retired and its result placed in to the destination register.
This register does not distinguish whether one or more operations are still running that have the same output registers.
RO.

`ACE_CC_BUSY`. 32 bits, one bit per CC to track whether at least one operation tied to a CC is still running.
This register does not distinguish whether one or more operations are still running with the given CC.
RO.

*Remark {counter:remark}*:: _Setting the `ACE_CC_BLOCKING` bit while operations are in progress may result in undefined behavior. Therefore, any modifications to it should only be done when no operations are in progress, by checking the `ACE_VR_BUSY` and `ACE_CC_BUSY` registers.  This is particularly important for any component of the system stack that may preempt lower privileged software, such as context switches or interrupt handlers._

Two CSRs at U, resp., S level, namely `UKSID` (User Key Space ID ) and/or `SKSID` (Supervisor Key Space ID), which are only writable at S, resp., a higher mode.
(*TBD*) We may reuse the CSRs for `ASID`, resp., `VMID` for `UKSID`, resp., `SKSID`.
Therefore, the maximal bit length of `UKSID` is 9 for Sv32 addresses or 16 for Sv39, Sv48, and Sv57.
Similarly, the maximal bit length of `SKSID` is 7 for Sv32x4 or 14 for Sv39x4, Sv48x4, and Sv57x4.
In the metadata fields, `UKSID` and `SKSID` are always zero padded to the maximal lengths of 16 and 14 bits, respectively.

*Remark {counter:remark}*:: _We do not envision direct key sharing across Worlds/Supervisor Domains, so consider defining a Hypervisor or World "Key Space ID" as redundant.
It is the responsibility of the MM to change CTKs between Worlds/Supervisor Domains._

*Remark {counter:remark}*:: _The software in each World/Supervisor Domain is normally responsible to generate their own keys, and if a process (applet) in one World/Supervisor Domain is responsible to provide keys to other Worlds/Supervisor Domains, it is the responsibility of the MM to properly import/switch the CTK/export._
//If `ASID`/`VMID` are reused for `UKSID`/`SKSID`, we still need to distinguish somehow the use for separating key spaces even if these fields are not used to build GVAs/GPAs (TBD).

<<<

==== Locales

Internally, ACE has a table of 128-bit Locale Secrets (LS), the Locale Secrets Table (LST).

Some of these EBTs are fixed, other values may be configurable only using an impdef authenticated HW procedure, and the remaining may be programmed by MM (*Note:* _we need to define the corresponding CSRs_).
The LST is a global table shared across all ACE units with some fields which can be overridden by values which are architected (i.e., per hart).
//Currently, the only two values that may be overridden by architectural values, in order to support multiple VMs/Supervisor Domains/Worlds are System_Secret and Boot_Session.

If the Locale Field of a context (CC/SCC) is -1 (all ones), then the CTK is used.
Otherwise, this value is used as an index _i_ in the HST, and a derived key `derived_key` computed from CTK and _b_ := HST[_i_] is used for import/export in place of the CTK.
The key derivation function is the same as in AES-GCM-SIV:

[%autowidth,frame=none,grid=none,align=center]
|===
>| `derived_key` {nbsp} = | AES-256(CTK, _b_)[63:0] \|\| AES-256(CTK, _b_ {oplus} (0^127^ \|\| 1))[63:0] \|\|
>|                        | {nbsp}{nbsp}{nbsp}{nbsp} \|\| AES-256(CTK, _b_ {oplus} (0^126^ \|\| 10))[63:0] \|\| AES-256(CTK, _b_ {oplus} (0^126^ \|\| 11))[63:0]
|===

Since this derivation function is quite expensive, the ACE implementation is allowed to cache recently used Derived Keys.
In <<binding-indices>>, we list the mandatory entries and their meaning.
//At least four bits are needed to encode them.
In the column "MM-Writeable" we indicate whether MM can write the corresponding Locale Token.

[[binding-indices]]
.Mandatory Locale Values
[width="100%",cols="20%,52%,^9%,^9%",options="header",frame=ends, grid=rows]
|===
.>| Name .>| Description .>| MM-Writeable .>| Value
| No lifecycle binding      | | | -1
| Chip Manufacturer         | Identifies the manufacturer of the SoC. Permanent. | N | 0
| Chip Model                | Identifies specific chip model/family. Permanent. | N | 1
| OEM Secret                | Provisioned by OEM to differentiate their products from the competition.
                              Can be permanent in a device — re-generations can be optionally triggered using impdef HW authenticated mechanisms. | N | 2
| Product                   | Identifies device/system type/model (product). Not necessarily permanent. Reconfigurable like OEM_Secret. | N | 3
| Device                    | Unique device (entire system) secret (not the device ID such as a serial number, but it can be derived from it, for instance by hashing).
                               Shared across all harts in a Soc and shareable across multiple SoCs in a single device. Sharing mechanism impdef, i.e., not architected.
                               Reconfigurable like OEM_Secret. | N | 4
| OS Secret                 | Identifies Operating System (or System Stack). +
                              Not permanent, must be configured during (virtual) boot. | Y | 5
| Boot_Session              | Regenerated at each (virtual) boot. | Y | 6
| _Reserved for Revocation_ | Regenerated at boot or at each revocation event. | Y | 7
|===

*Remark {counter:remark}*:: _We need to discuss what to do in case there is a reboot of a VM. Then we need to "virtualize" the seventh string, or use a secondary CTK for that purpose, since some VMs may reboot while others may not.
Also, do we want to allow a VM to have a different virtual hardware? Or does it always declare the same configuration as the underlying hardware?_
In principle, all this can be done by calling into MM. MM would need to keep track of the lifecycle binding values and ensure that they are updated correctly when necessary.

*Example*:: If a key has the value of “2” in the Locale field of ita metadata, then not the CTK, but a value derived from the CTK and the "OEM Secret" will be used for import/export.
This means that, while `ace.export` will always work on the same device (which is fundamental to allow context switching), attempts to use `ace.import` on the same blob on a device from a different OEM will result in an authentication failure.

*Remark {counter:remark}*:: _In a CC, a key may be referred to using an index into an internal, system defined key table, called the System Specific Key Table (SSTK).
If some of these keys are device specific, they will not work on a second device.
However, if the Locale of this CC is not restricted, the internal key index may be interpreted as the corresponding internal keys on a different device, with unpredictable consequences.
Hence the implementation of the SSTK must also provide the proper Locale metadata to the ACE XU to configure a CC._

<<<

=== Instructions

In what follows, the notation `Cn|Xn` refers to a CC directly (i.e., the integer `n` is a 5-bit field in the instruction encoding) or a GPR containing a number from 0 to 31 to indirectly refer to a CC.  In general, six bits are needed to address a CC, to take into account the possibility of indirect addressing.


[#insns-add_uw,reftext=Add unsigned word]
==== Instruction Template (from add.uw)

Synopsis::
Add unsigned word

Mnemonic::
add.uw _rd_, _rs1_, _rs2_

Pseudoinstructions::
zext.w _rd_, _rs1_ {rightarrow} add.uw _rd_, _rs1_, zero

Encoding::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x3b, attr: ['OP-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x0, attr: ['ADD.UW'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x04, attr: ['ADD.UW'] },
]}
....

Description::
This instruction performs an XLEN-wide addition between _rs2_ and the zero-extended least-significant word of _rs1_.

Operation::
[source,sail]
--
let base = X(rs2);
let index = EXTZ(X(rs1)[31..0]);

X(rd) = base + index;
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zba (<<zba>>)
|0.93
|Ratified
|===

<<<

==== ace.enable

`ace.enable flag` +

This instruction must be issued before using any ACE operation.
It enables the CCs and the instructions and also sets a bit in a CSR signaling that the feature is used.
When a process domain that has enabled ACE is preempted, the parent process inherits the state.
otherwise it would not be able to export and re-import the CCs.
The flag `flag` determines whether the ISE is used in blocking or non-blocking mode.
The operation is implemented as a CSRW.

====  ace.disable​

`ace.disable` signals that the current process domain has stopped using the ACE and all CCs are therefore invalidated.
The operation is implemented as a CSRW.

Care is necessary in the design to allow a locking disablement without erasing the registers when a parent
gives control back to a child process that does not use the feature.

In non-blocking mode, if the instruction is issued before all ACE operations are retired, then all operations in the ACE unit issued by the current hart are aborted.

==== ace.config / ace.clear

`ace.config Cd|Xd, [Xs]` +
`ace.clear Cd|Xd`

`Cd` is the source CC to be configured (encoded as a 5-bit immed). +
`Xd` alternatively, is a GPR containing a number from 0 to 31 to address the context to be configured. +
`Xs` is GPR with the pointer to the region of memory containing the metadata and the key material.

Configures a CC with metadata and key, or using an index in the Immutable System Key Table.

// NB: Since we assume CCs are NOT renamed, we CAN use a GPR and have “dynamic addressing”.
// `Xs` is a
// Executing `ace.config` will always clear the destination CC, even in case of error while reading the metadata and key material.
// Check bit   n  of the CC_USED CSR, i.e. CC_USED[n] to verify whether the operation has had success.

==== ace.export

`ace.export [Xd], Cs|Xs`

`Cs` is the source CC to be exported (encoded as a 5-bit immed). +
`Xs` alternatively, is a GPR containing a number from 0 to 31 to address the context to be exported. +
`Xd` is the GPR base address of the buffer where to store the SCC.

Exports the contents of CC `Cs` to memory, starting at address `Xd`.
Depending on the type and policies of the key — which are stored in the metadata of `Cs`, the CCWK can be either the CTK CSR or a Locale specific CTK derived from the CTK.

The instruction (resp. ace.import) writes (reads) the entire internal state of a CC or information needed to reconstruct an equivalent state — the instruction shall be resumable in case of interrupts.
This is similar to entire-vector-register store instructions, that appear to other harts as sequences of individual stores.
If the context `Cs` is clear or does not exist in the µarch, the operation will report an error.

//(The SW should have the right information, so this should never happen).

==== ace.import

`ace.import Cd|Xd, [Xn], S`

`Cd` is the destination CHR to be imported, as an immed (5-bit). Alternatively,+
`Xd` is a GPR containing a number from 0 to 31 to dynamically address the context into which import the SCC. +
`Xn` is the GPR containing the base address of the buffer with the SCC.

S = 0,1  true (1) if the key is in a system defined format and not the format defined by the architecture.

This means that system HW dynamically generated keys can be imported but not exported in the same form — if exported they must be in the architectural format.
If the value cannot be exported to other devices or to other Locale stages of the same device, the internal logic must bind them to a specific Locale derived CTK).
The instruction imports them like SW keys, but only internally, and sets the right policies.

==== ace.size

`ace.size Xd, Cn|Xn`

This instruction writes the size of the SCC corresponding to CC `Cn` (or the CC whose number is in `Xn`) into GPR `Xd`.

The value can significantly differ from the internal resource usage ot the CC — it can be larger (for simple primitives, because of the nonce/SIV overhead) but also smaller (if for instance keys are split into shares for threshold implementations).

The size of the SCC is important to properly implement features such as context switching, and in general before any export operation.

==== ace.clone

`ace.clone Cd|Xd, Cs|Xs`

Clones source CC `Cs` (or the CC indexed by `Xs`) into destination CC `Cd` (or into the CC indexed by `Xd`).

We note that certain attacks may be mounted on primitives if the same state can be re-used (for instance encryption with the same counter), but this cannot be prevented even if this instruction were not available, since a state can be exported and re-imported as-is several times. `ace.clone` is just an optimization for an `ace.export` instruction followed by an `ace.import` instruction.

==== ace.exec

`ace.exec  Vd, Cn|Xn, Vs` +
`ace.exec  Cn|Xn, Vs` +
`ace.exec  Vd, Cn|Xn` +
`ace.exec  Cn|Xn`

Performs a cryptographic operation such as an encryption or decryption, absorbing a value in a hash, and possibly returning a value. The instruction may also modify an internal state machine of the CC. It has four variants: has input and output, has I but not O, has no I but produces an O, has no I and O. (The fourth variant is used to encode the next instruction, which is then a pseudo-instruction).  In certain cases the `ace.exec` instruction may modify the internal state machine of the CC.

==== ace.input (optional)

`ace.input Cd|Xd, [Xn]`

==== ace.output (optional)

`ace.output [Xd], Cs|Xs`

==== ace.spawn (optional)

`ace.spawn Cd|Xd, Cs|Xs`

==== ace.stage/ace.dir

`ace.stage Cn|Xn, #immed` +
`ace.dir Cn|Xn, #immed`

Two pseudo-instructions that map to the same instruction.

`Cn` is the CC in which to set the stage of the internal state machine

`Xn` is a GPR containing a number from 0 to 31 to dynamically address the context where we want to change the stage of the internal state machine.

The `#immed` is a constant from a set of admissible values that are defined for each algorithm, to manage an internal state machine of said algorithm in case more stages are needed.

==== ace.available

`ace.available Xd, Xs`

Return whether the algorithm defined by GPR `Xs` (this is the value of the algorithm field of the metadata) is supported by the µarch.
The result is written in `Xd` as true (1) or false (0).

Implement it as CSR read?
Trivially, we would need at least one bit worth of CSR per algorithm, and this is extended also by the side channel resistance information, so we would have 512 bits. Of course if the ARC so wants, it can be a read-from-CSR pseudo-instruction

*To be discussed* alternative option: the CSR contains a pointer to a memory mapped bitmap or some other architected structure to determine what is implemented. OTOH this can probably be obtained in other ways (like a µarch version number). Or use the error mechanism.

==== ace.error

`ace.error Xd, Cs|Xs`

A CC `Cs` (or indexed by `Xs`) may be in an error state due to the previous operation.
The corresponding error value is written into GPR `Xd`.
The error value list must be architected.

==== ace.vr_busy

`ace.vr_busy   Vd`

Can be CSR read operation.

It will return 1 or 0 whether there is at least one running ACE operation expected to write on the vector register `Vd`.

==== ace.cc_busy

`ace.cc_busy   Cd|Xd`

Can be CSR read operation.

It will return 1 or 0 whether there is at least one running ACE operation using the given CC.

<<<

=== Formats of Configuration Inputs and Sealed Configuration Contexts

==== Configuration Input

===== With Short Metadata

*TBD*

===== With Long Metadata

*TBD*

==== Sealed Configuration Context

*TBD*

===== With Short Metadata

.Simple Example: Encryption, no Authentication
[%linenums,C,subs=normal]
----
P ← key(s) { || additional_state }
Pick random 96-bit nonce N, Derive Kenc and Kauth from K as per RFC 8452.
SIV ← 0 ||  Poly1305(Kauth, N, metadata || P) [95:0]
M[0] ← (metadata {and} 0xFFFF FFFF)
       {or} ((metadata {oplus} AESE(Kenc, SIV || 032)) {and} 0xFFFF FFFF 0000 0000)
       {or} (N[63:0] {lshift} 64)
M[1] ← N[95:64] ∨ (SIV[95:0] {lshift} 96)
for i = 0 to num_blocks(P)-1
     M[i+2] ← (block # i of P) {oplus} AESE(Kenc, SIV[95:0] || (binary(i+1)[31:0]))
----

Notation: {oplus}, {or}, {and}, and {lshift} denote XOR, OR, AND, and left shift, respectively.

Line 4: Do not encrypt public MD bits.

Line 5: Encrypt private MD bits.

Line 6: Concatenate remaining 32 bits of the nonce and the SIV.

Note: In this simplification of AES-GCM-SIV there is no need to add the lengths of metadata and keys+internal state to the hash because these lengths are implied already by the clear bits of the metadata itself — which are included in the computation of the authentication tag
Some details are fixed in general. For instance, all “pure” ciphers have only one key, whether in normal or threshold implementation, the latter always reduced to one key, as well as for some modes. In other cases, there must be a specific formatting of the state.
Keys and additional_state fields are always a multiple of 128 bits.

===== With Long Metadata

*TBD*

<<<

=== Note on threshold implementations

Some threshold implementations may need 2, 3 or even more shares.

We are assuming that recovering the key or re-randomizing the key are easy operations.

The ACE XU must have access to a source of randomness or PRNG.

SCCs from CCs with threshold keys will contain the reconstructed key, not the shares, guaranteeing that the key can be ported across architectures.

Example: AES-128 with a threshold implementation of a key. On implementations with two shares, the CC contains
`[MD, first share, second share]`
and on implementations with three shares, the CC contains
`[MD, first share, second share, third share]`.
The SCC will however always contain data in one of the following two formats +
`[MD (64-bits, partially encrypted), Nonce (96 bits), SIV (96 bits), key (encrypted,128-bits)]` or +
`[MD (128-bits, partially encrypted), Nonce (96 bits, 32-bit zero padding on top), SIV (96 bits, 32-bit zero padding at bottom), key (encrypted,128-bits)]`. +
This allows a VM to be migrated from a machine that has 2-share implementation to a machine with a 3-share implementation.

<<<

=== Constants

==== Error Codes

*TBD*

==== Other Constants

*TBD*

<<<

=== Impact and Dependency on Other Extensions

The only impacted extension is RVV.
However, we do not need all features of RVV to allow ACE to be be fully functional.
It is therefore possible to define a "RVV-mini" that MUST be supported in order for ACE to work.
We need at least:

* A register file with 128-bit registers or longer.
* `vconfig` (to also determine how many vector registers we need).
* `vsetvli` (accepting only the necessary subset of parameters, for instance "`vsetvli zero, 4, e32, m1, ta, ma`" is we are only dealing with 128-bit blocks).
error in other cases).
* Load and store operations, we only need the unit-strided versions.
* Vector `xor`, `and`, and `or` to assist implementation of padding or of additional modes or protocols.
* `vsplatx` can also be useful to quickly fill a register with a pattern.
* We do not need floating point and fixed point operations, and probably also most arithmetic operations on vector elements (such as `add`, `sub`, `mul`, etc).
* If more complex calculations are needed, one can perform them on GPRs and use `vins`/`vext`.

We must re-use the same opcodes for the same operations —- code written for ACE with RVV-mini must be guaranteed to also run with full RVV.

[comment]
--
NO MOPs (Maybe OPerations): In theory if the vectors are 128 bits in an implementation or this RVV-mini, and in the same implementation ACE does not provide any input/output other than 128 bits in length, everything could work without “”. However, we still require it and, if it is not issued the vector instructions may not work, just as in full RVV. Hence, we do NOT ignore some of the parameters, but we also require them to be correct.
So in this case it seems that we can support vsetvli zero, 4, e32, m1, t?, ma. I think ma is necessary and t? could probably be tu or ta.
The RVV extension (subset) must be enabled on its own, so we also need vconfig something (the “original” one from RVV, not some ace.vconfig monster :-) ), vconfig 0. (vconfig imm where imm[4:0] is the number of registers we need, minus 1. Not sure we need a value for imm[6:5] and imm[7] since we do not need special lengths for the elements and Fixed point arithmetic, but since the example configuration is “vsetvli zero, 4, e32, m1, ta, ma” and the usual AES instructions require 4 32-bit elements, we can ask for imm[6:5] = 11 resp. 00 for 32 resp. 64 bit max element width). It is up to the implemented whether to allow the configuration of lengths such as 8 or 16 bits, which may be incompatible with ACE, in which case the ACE instructions (starting from ace.enable) will return an error (as per ace.error/CSR read).
We probably do not need shifts and permutations? Insertion and extraction could be useful if we need to build padding schemes (as written above). We would not need them for metadata and, since we load the metadata from memory, and we build it with the integer instructions and store it to memory. This is to be discussed further. However, having the metadata set separately in ace.config can have advantages and we would need to make sure we either load one or two GPRs or a 128-bit vector register for the vector format.
Modes of operation: integer addition may be useful for counter-based modes which are not implemented in the HW. Counters can be computed in the integer registers and then vinserted into the vectors. This is not a problem not even in small in order devices, because updating counters can be done while one is waiting for the previous cryptographic operation to be completed in non-blocking mode. So we do not strictly need vector based integer operations.
--

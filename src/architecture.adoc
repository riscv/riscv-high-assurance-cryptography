[[Details]]
== Architecture

=== Data Structures

A CC contains two fields: the `metadata` and the `state`.

Key material and possibly other algorithm-specific data are contained in the state.

[[Metadata-Fields]]
==== Metadata Fields

The metadata field exists in two versions, short (64-bit) and long (128-bit). The short version is structured as follows:

.Metadata: 64-bit version
[width="100%",cols=">9%,17%,66%,^8%",options="header",frame=ends, grid=rows]
|===
|   Field | Name | Description| Type
|     [0] |  Format | 0 for short metadata format (64-bit) | Public
|   [4:1] |  Version | Metadata format version | Public
|  [12:5] |  Algorithm | Which primitive or mode (msb = 0 for architected algorithms, msb = 1 for custom ones). | Public
|    [13] |  Side Channel Protected | Does this implementation of the algorithm provide Side Channel Protection? We only require constant-time and a first order threshold implementation. | Public
| [15:14] |  Direction Policy | Use for encryption/decryption/both (only for enc/dec primitives or modes). | Public
| [17:16] |  Key Type | By explicit value / Immutable (index) / Internally generated. | Public
| [22:18] |  Environment  | Field which is either -1 or an index into the table of Environment Tokens. | Public
| [23:23] |  Sealed | Whether the CC is complete (00) or interrupted while being configured (01), imported (10) or exported (11). Necessary to restart/resume operations. | Public
| [27:24] |  Error | Last error value | Public
| [29:28] |  Cloning Policy | Value 00 means the CC cannot be cloned, else the CC can be cloned, and the values
             01, resp., 10 and 11 mean that the clone _can_ be re-initialised, resp., _must_ be re-initialised upon cloning, and _cannot_ be re-initialised. | Public
| [37:32] |  Stage/Direction | Which internal stage the algorithm is, as defined by ace_stage or implicitly. Must be ZERO on configuration. This is algorithm defined | Private
| [41:38] |  AC Policy 1 | Can a User/Supervisor/Hypervisor/Machine use it? (Import/export/overwrite always allowed.) | Private
| [43:42] |  AC Policy 2 | Restrict USE to specific User/Suopervisor? (Import/export/overwrite always allowed.) | Private
| [59:44] |  AC Policy 3 | IDs to filter User OR Supervisor (filtering both or even world, or higher resolution, is delegated to future versions, with metadata larger than 64 bits). | Private
| [63:60] |  Reserved | Zero | Private
|===

<<<
The long version of the metadata is structured as follows:

.Metadata: 128-bit version
[width="100%",cols=">9%,17%,66%,^8%",options="header",frame=ends, grid=rows]
|===
|     Field | Name | Description| Type
|       [0] |  Format | 1 for long metadata format (128-bit) | Public
|     [4:1] |  Version | Metadata format version | Public
|    [12:5] |  Algorithm | Which primitive or mode (msb = 0 for architected algorithms, msb = 1 for custom ones). | Public
|      [13] |  Side Channel Protected | Does this implementation of the algorithm provide Side Channel Protection? We only require constant-time and a first order threshold implementation. | Public
|   [15:14] |  Direction Policy | Use for encryption/decryption/both (only for enc/dec primitives or modes). | Public
|   [17:16] |  Key Type | By explicit value / Immutable (index) / Internally generated. | Public
|   [22:18] |  Environment  | Field which is either -1 or an index into the table of Environment Tokens. | Public
|   [23:23] |  Sealed | Whether the CC is complete (00) or interrupted while being configured (01), imported (10) or exported (11). Necessary to restart/resume operations. | Public
|   [27:24] |  Error | Last error value | Public
|   [29:28] |  Cloning Policy | Value 00 means the CC cannot be cloned, else the CC can be cloned, and the values
               01, resp., 10 and 11 mean that the clone _can_ be re-initialised, resp., _must_ be re-initialised upon cloning, and _cannot_ be re-initialised. | Public
|   [31:30] |  Reserved | Zero | Public
|   [63:32] |  VendorID | JEDEC manufacturer ID of the provider of the core | Public
|   [67:64] |  Revision ID | Revision ID of the manufacturer’s implementation of resuming | Public
|   [83:68] |  Reserved for Partial | Information for resuming (similar to VSTART for RVV, but impdef)) | Public
|   [89:84] |  Stage/Direction | Which internal stage the algorithm is, as defined by ace_stage or implicitly. Must be ZERO on configuration. This is algorithm defined | Private
|   [93:90] |  AC Policy 1 | Can a User/Supervisor/Hypervisor/Machine use it? (Import/export/overwrite always allowed.) | Private
|   [95:94] |  AC Policy 2 | Restrict USE to specific User/Supervisor? (Import/export/overwrite always allowed.) | Private
|  [111:96] |  AC Policy 3 | IDs to filter User OR Supervisor (filtering both or even world, or higher resolution, is delegated to future versions). | Private
| [127:112] |  Reserved | Zero | Private
|===

We note that in the 128-bit version of the metadata, the first 64-bit word (i.e., at the lowest address) contains bits [63:0] and the second 64-bit word
(i.e., at the byte address of the first word, plus 8) contains bits [127:64].

<<<
==== Instructions

We now give the abbreviated listing of the instructions defined by ACE.

.The ACE instructions
[width="100%",cols="17%,21%,62%",options="header",frame=ends, grid=rows]
|===
| Instruction   | Operands                  | Description
| `ace.enable`   | flag=blocking             |  Enable the feature in the current process domain. It also sets a bit in a feature CSR for use by the parent domain — or implemented by a CSR write (so, WARL).
| `ace.disable`  |                           |  Disable the feature in the current process domain.
| `ace.config`   | Cn\|Xn, [Xs]              |  Sets the algorithm and either the key or info on how to fetch and use system key (keystore).
| `ace.clear`    | Cn\|Xn                    |  Clear a CC and mark it as no longer in use (both in the CC internal table and in the feature CSR).
| `ace.size`     | Xd, Cn\|Xn                |  Returns the size in bytes of the package exported from a specified CC,
| `ace.size`     | Xd, #immed                |  or from a specific algorithm given as #immed (including the side channel bits)
| `ace.export`   | [Xn], Cs\|Xs              |  Exports the content of a CC to an encrypted and authenticated package to memory. Remember that there is no "save" instruction to extract key and all metadata in the clear.
| `ace.import`   | Cd\|Xd, [Xn], flag=system |  Reads an encrypted and authenticated package from memory and imports it into a CC if ok. ace import can also provide import for system defined blobs or connect a context to an entry of an Immutable System Key table (which is usually inaccessible to SW environments) if the system flag == true.
| `ace.exec`     | Vd, Cn\|Xn, Vs         .4+| Performs a cryptographic operation such as an encryption or decryption, absorbing a value in a hash, and possibly returning a value. The instruction may also modify an internal state machine of the CC. It has four variants: has input and output, has I but not O, has no I but produces an O, has no I and O. (The fourth variant is used to encode the next instruction, which is then a pseudo-instruction).
| `ace.exec`     | Cn\|Xn, Vs
| `ace.exec`     | Vd, Cn\|Xn
| `ace.exec`     | Cn\|Xn
| `ace.stage`    | Cn\|Xn, #immed         .2+| Changes the stage of a multi-stage function (such as hash functions or modes of operation) or provide additional info.  For instance, for  block cipher/mode of operation keys it also sets encryption / decryption. ACE.DIR is an alias for ACE.STAGE.
| `ace.dir`      | Cn\|Xn, #immed
| `ace.available` | #immed                    |  Informs whether a given primitive is supported by the µarch (IDs standardized) — Can be a CSRs read.
| `ace.error`    | Xd, Cn\|Xn                |  Returns the error of an operation — Can be a CSRs read.
| `ace.clone`    | Cd\|Xd, Cs\|Xs, flag=init |  Clones a CC into a second CC.
| `ace.busy`     | Xd                        |  Check whether the operation writing to vector register Xd has completed — Can be a CSRs read.
| `ace.ccbusy`   | Cd\|Xd                    |  Check whether the operation reading/writing to CC Cd or *Xd has completed — Can be a CSRs read.
|===

<<<
==== List of CSRs

We need four bits in a CSR called `ACE_CC_ENABLED` to denote whether the feature is enabled or disabled for the current process domain:

* Bits 0..3 are for EL0..EL3 or User/(Virtual)Supervisor/HV/MM, respectively.
* The bit corresponding to the current mode/EL is set/cleared when `ace.enable`/`ace.disable` is issued
* If one of these bit is set, the bits corresponding to higher levels are also set.
* If one of these bit is cleared, the bits corresponding to lower levels are also cleared.
* This register cannot be set directly, and it can only be read directly.

We need one `ACE_CC_BLOCKING` bit to establish whether the unit is working in a blocking way (1, default mode) or non-blocking (0).
Here, blocking means that any instruction that accesses the content of an output register of a previous ACE instruction will automatically have to wait that the results are retired, otherwise the completion status of the instruction will have to be followed in a CSR.

A 32-bit CSR `ACE_CC_USED` with a bit per CC to denote whether the register is in use or not (cleared contextually to CC erasure to dispose of the key). Read-only.

A 32-bit CSR `ACE_CC_DIRTY` with a bit per CC to keep track whether the corresponding CC has been modified since the last time the same bit has been cleared. +
Two types actions can modify a CC and thus must update also `ACE_CC_DIRTY`:

* An explicit configuration/import; and
* Certain cryptographic operations, such as absorbing information in a hash function, that modify the internal state.

It is also possible to directly write to `ACE_CC_DIRTY`, and in fact necessary to optimize context switching.

A 32-bit CSR `ACE_CC_BUSY` with a bit per vector register to keep track whether any operation writing to a certain register is still operating.

256-bit worth of CSR `ACE_CTK` to store the the CTK.

* `ACE_CTK` is writable exclusively by MM.
* `ACE_CTK` reads as zero in all cases.
//There is need to raise exceptions if any other mode/EL tries to write to it or read it.

Two CSRs at U, resp., S level, namely `UKSID` (User Key Space ID ) and/or `SKSID` (Supervisor Key Space ID), which are only writable at S, resp., a higher mode.
We can reuse the CSRs for `ASID`, resp., `VMID` for`UKSID`, resp., `SKSID`.

*Remark:* _We do not envision direct key sharing across Worlds/Supervisor Domains, so consider defining a Hypervisor or World "Key Space ID" as redundant.
It is the responsibility of the MM to change CTKs between Worlds/Supervisor Domains._

The software in each World/Supervisor Domain is normally responsible to generate their own keys, and if a process (applet) in one World/Supervisor Domain is responsible to provide keys to other Worlds/Supervisor Domains, it is the responsibility of the MM to properly import/switch the CTK/export. If `ASID`/`VMID` are reused for `UKSID`/`SKSID`, we still need to distinguish somehow the use for separating key spaces even if these fields are not used to build GVAs/GPAs (TBD).

<<<

==== Environment

Internally, ACE has a table of 128-bit Environment Tokens (EBT), the Environment Tokens Table (EBTT).

Some of these EBTs are fixed, other values may be configurable only using an impdef authenticated HW procedure, and the remaining may be programmed by MM (*Note:* _we need to define the corresponding CSRs_).
The EBTT is a global table shared across all ACE units with some fields which can be overridden by values which are architected (i.e., per hart).
//Currently, the only two values that may be overridden by architectural values, in order to support multiple VMs/Supervisor Domains/Worlds are System_Secret and Boot_Session.

If the Environment  Field of a context (CC/SCC) is -1 (all ones), then the CTK is used.
Otherwise, this value is used as an index _i_ in the Environment Tokens Table, and a derived key `derived_key` computed from CTK and _b_:=EBTT[_i_] is used for import/export in place of the CTK.
The key derivation function is the same as in AES-GCM-SIV:

[%autowidth,frame=none,grid=none,align=center]
|===
>| `derived_key` {nbsp} = | AES-256(CTK, _b_)[63:0] \|\| AES-256(CTK, _b_ ⊕ (0^127^ \|\| 1))[63:0] \|\|
>|                        | {nbsp}{nbsp}{nbsp}{nbsp} \|\| AES-256(CTK, _b_ ⊕ (0^126^ \|\| 10))[63:0] \|\| AES-256(CTK, _b_ ⊕ (0^126^ \|\| 11))[63:0]
|===

Since this derivation function is quite expensive, the ACE implementation is allowed to cache recently used Derived Keys.
In <<binding-indices>>, we list the mandatory entries and their meaning.
//At least four bits are needed to encode them.
In the column "MM-Writeable" we indicate whether MM can write the corresponding Environment Token.

[[binding-indices]]
.Mandatory Environment Values
[width="100%",cols="20%,52%,^9%,^9%",options="header",frame=ends, grid=rows]
|===
.>| Name .>| Description .>| MM-Writeable .>| Value
| No lifecycle binding      | | | -1
| Chip_Manufacturer         | Identifies the manufacturer of the SoC. Permanent. | N | 0
| Chip_Model                | Identifies specific chip model/family. Permanent. | N | 1
| OEM_Secret                | Provisioned by OEM to differentiate their products from the competition.
                              Can be permanent in a device — re-generations can be optionally triggered using impdef HW authenticated mechanisms. | N | 2
| Product                   | Identifies device/system type/model (product). Not necessarily permanent. Reconfigurable like OEM_Secret. | N | 3
| Device_ID                 | Unique device (entire system) identifier.  Shared across all harts in a Soc and shareable across multiple SoCs in a single device. Sharing mechanism impdef, i.e., not architected. Reconfigurable like OEM_Secret. | N | 4
| OS_Secret                 | Identifies Operating System (or System Stack). +
                              Not permanent, must be configured during (virtual) boot. | Y | 5
| Boot_Session              | Regenerated at each (virtual) boot. | Y | 6
| _Reserved for Revocation_ | Regenerated at boot or at each revocation event. | Y | 7
|===

*Remark:* _We need to discuss what to do in case there is a reboot of a VM. Then we need to "virtualize" the seventh string, or use a secondary CTK for that purpose, since some VMs may reboot while others may not.
Also, do we want to allow a VM to have a different virtual hardware? Or does it always declare the same configuration as the underlying hardware?_
In principle, all this can be done by calling into MM. MM would need to keep track of the lifecycle binding values and ensure that they are updated correctly when necessary.

Example: if a key has the value of “2” in the Environment field of ita metadata, then not the CTK, but a value derived from the CTK and the "OEM_Secret" will be used for import/export.
This means that, while `ace.export` will always work on the same device (which is fundamental to allow context switching), attempts to use `ace.import` on the same blob on a device from a different OEM will result in an authentication failure.

In a CC, a key may be referred to using an index into an internal, system defined key table, called the System Specific Key Table (SSTK).
If some of these keys are device specific, they will not work on a second device.
However, if the Environment of this CC is not restricted, the internal key index may be interpreted as the corresponding internal keys on a different device, with unpredictable consequences.
Hence the implementation of the SSTK must also provide the proper Environment metadata to the ACE XU to configure a CC.



=== Instructions

==== ace.enable

==== ace.disable

==== ace.config

==== ace.clear

==== ace.size

==== ace.export

==== ace.import

==== ace.exec

==== ace.stage/ace.dir

==== ace.available

==== ace.error

==== ace.clone

==== ace.busy/ace.ccbusy

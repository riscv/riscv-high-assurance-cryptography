[[Details]]
== Architecture

=== Data Structures

A CC contains two fields: the `metadata` and the `state`.

Key material and possibly other algorithm-specific data are contained in the state.

[[Metadata-Fields]]
==== Metadata Fields

The metadata field exists in two versions, short (64-bit) and long (128-bit). The short version is structured as follows:

.Metadata: 64-bit version
[width="100%",cols=">9%,17%,66%,^8%",options="header",]
|===
|   Field | Name | Description| Type
|     [0] |  Format | 0 for short metadata format (64-bit) | Public
|   [4:1] |  Version | Metadata format version | Public
|  [12:5] |  Algorithm | Which primitive or mode (msb = 0 for architected algorithms, msb = 1 for custom ones). | Public
|    [13] |  Side Channel Protected | Does this implementation of the algorithm provide Side Channel Protection? We only require constant-time and a first order threshold implementation. | Public
| [15:14] |  Direction_Policy | Use for encryption/decryption/both (only for enc/dec primitives or modes). | Public
| [17:16] |  Key_Type | By explicit value / Immutable (index) / Internally generated. | Public
| [22:18] |  Lifecycle | Field which is either -1 or an index into the table of Lifecycle Binding Secrets. | Public
| [23:23] |  Sealed | Whether the CC is complete (00) or interrupted while being configured (01), imported (10) or exported (11). Necessary to proper restart or resume operations. | Public
| [27:24] |  Error | Last error value | Public
| [29:28] |  Cloning_Policy | 00 cannot be cloned. Can be cloned: 01 can be reinit, 10 must be reinit, 11 cannot be reinit. | Public
| [31:30] |  Reserved | Zero | Public
| [37:32] |  Stage/Direction | Which internal stage the algorithm is, as defined by ace_stage or implicitly. Must be ZERO on configuration. This is algorithm defined | Private
| [41:38] |  AC_Policy_1 | Can a User/Supervisor/Hypervisor/Machine use it? (Import/export/overwrite always allowed.) | Private
| [43:42] |  AC_Policy_2 | Restrict USE to specific User/Suopervisor? (Import/export/overwrite always allowed.) | Private
| [59:44] |  AC_Policy_3 | IDs to filter User OR Supervisor (filtering both or even world, or higher resolution, is delegated to future versions, with metadata larger than 64 bits). | Private
| [63:60] |  Reserved | Zero | Private
|===

<<<
The long version of the metadata is structured as follows:

.Metadata: 128-bit version
[width="100%",cols=">9%,17%,66%,^8%",options="header",]
|===
|     Field | Name | Description| Type
|       [0] |  Format | 1 for long metadata format (128-bit) | Public
|     [4:1] |  Version | Metadata format version | Public
|    [12:5] |  Algorithm | Which primitive or mode (msb = 0 for architected algorithms, msb = 1 for custom ones). | Public
|      [13] |  Side Channel Protected | Does this implementation of the algorithm provide Side Channel Protection? We only require constant-time and a first order threshold implementation. | Public
|   [15:14] |  Direction_Policy | Use for encryption/decryption/both (only for enc/dec primitives or modes). | Public
|   [17:16] |  Key_Type | By explicit value / Immutable (index) / Internally generated. | Public
|   [22:18] |  Lifecycle | Field which is either -1 or an index into the table of Lifecycle Binding Secrets. | Public
|   [23:23] |  Sealed | Whether the CC is complete (00) or interrupted while being configured (01), imported (10) or exported (11). Necessary to proper restart or resume operations. | Public
|   [27:24] |  Error | Last error value | Public
|   [29:28] |  Cloning_Policy | 00 cannot be cloned. Can be cloned: 01 can be reinit, 10 must be reinit, 11 cannot be reinit. | Public
|   [31:30] |  Reserved | Zero | Public
|   [63:32] |  VendorID | JEDEC manufacturer ID of the provider of the core | Public
|   [67:64] |  Revision ID | Revision ID of the manufacturer’s implementation of resuming | Public
|   [83:68] |  Reserved for Partial | Information for resuming (similar to VSTART for RVV, but impdef)) | Public
|   [89:84] |  Stage/Direction | Which internal stage the algorithm is, as defined by ace_stage or implicitly. Must be ZERO on configuration. This is algorithm defined | Private
|   [93:90] |  AC_Policy_1 | Can a User/Supervisor/Hypervisor/Machine use it? (Import/export/overwrite always allowed.) | Private
|   [95:94] |  AC_Policy_2 | Restrict USE to specific User/Supervisor? (Import/export/overwrite always allowed.) | Private
|  [111:96] |  AC_Policy_3 | IDs to filter User OR Supervisor (filtering both or even world, or higher resolution, is delegated to future versions). | Private
| [127:112] |  Reserved | Zero | Private
|===

We note that in the 128-bit version of the metadata, the first 64-bit word (i.e., at the lowest address) contains bits [63:0] and the second 64-bit word
(i.e., at the byte address of the first word, plus 8) contains bits [127:64].

<<<
==== Instructions

We now give the abbreviated listing of the instructions defined by ACE.

.The ACE instructions
[width="100%",cols="17%,21%,62%",options="header",]
|===
| Instruction   | Operands                  | Description
| ACE.ENABLE    | flag=blocking             |  Enable the feature in the current process domain. It also sets a bit in a feature CSR for use by the parent domain — or implemented by a CSR write (so, WARL).
| ACE.DISABLE   |                           |  Disable the feature in the current process domain.
| ACE.CONFIG    | Cn\|Xn, [Xs]              |  Sets the algorithm and either the key or info on how to fetch and use system key (keystore).
| ACE.CLEAR     | Cn\|Xn                    |  Clear a CC and mark it as no longer in use (both in the CC internal table and in the feature CSR).
| ACE.SIZE      | Xd, Cn\|Xn                |  Returns the size in bytes of the package exported from a specified CC,
| ACE.SIZE      | Xd, #immed                |  or from a specific algorithm given as #immed (including the side channel bits)
| ACE.EXPORT    | [Xn], Cs\|Xs              |  Exports the content of a CC to an encrypted and authenticated package to memory. Remember that there is no "save" instruction to extract key and all metadata in the clear.
| ACE.IMPORT    | Cd\|Xd, [Xn], flag=system |  Reads an encrypted and authenticated package from memory and imports it into a CC if ok. ace import can also provide import for system defined blobs or connect a context to an entry of an Immutable System Key table (which is usually inaccessible to SW environments) if the system flag == true.
| ACE.EXEC      | Vd, Cn\|Xn, Vs         .4+| Performs a cryptographic operation such as an encryption or decryption, absorbing a value in a hash, and possibly returning a value. The instruction may also modify an internal state machine of the CC. It has four variants: has input and output, has I but not O, has no I but produces an O, has no I and O. (The fourth variant is used to encode the next instruction, which is then a pseudo-instruction).
| ACE.EXEC      | Cn\|Xn, Vs
| ACE.EXEC      | Vd, Cn\|Xn
| ACE.EXEC      | Cn\|Xn
| ACE.SET_STAGE | Cn\|Xn, #immed         .2+| Changes the stage of a multi-stage function (such as hash functions or modes of operation) or provide additional info.  For instance, for  block cipher/mode of operation keys it also sets encryption / decryption. SET_DIR is an alias for SET_STAGE.
| ACE.SET_DIR   | Cn\|Xn, #immed
| ACE.AVAILABLE | #immed                    |  Informs whether a given primitive is supported by the µarch (IDs standardized) — Can be a CSRs read.
| ACE.ERROR     | Xd, Cn\|Xn                |  Returns the error of an operation — Can be a CSRs read.
| ACE.CLONE     | Cd\|Xd, Cs\|Xs, flag=init |  Clones a CC into a second CC.
| ACE.BUSY      | Xd                        |  Check whether the operation writing to vector register Xd has completed — Can be a CSRs read.
| ACE.CCBUSY    | Cd\|Xd                    |  Check whether the operation reading/writing to CC Cd or *Xd has completed — Can be a CSRs read.
|===



<<<
==== List of CSRs

We need four bits in a CSR called `ACE_CC_ENABLED` to denote whether the feature is enabled or disabled for the current process domain:

* Bits 0..3 are for EL0..EL3 or User/(Virtual)Supervisor/HV/MM, respectively.
* The bit corresponding to the current mode/EL is set/cleared when `ace.enable`/`ace.disable` is issued
* If one of these bit is set, the bits corresponding to higher levels are also set.
* If one of these bit is cleared, the bits corresponding to lower levels are also cleared.
* This register cannot be set directly, and it can only be read directly.

We need one `ACE_CC_BLOCKING` bit to establish whether the unit is working in a blocking way (1, default mode) or non-blocking (0).
Here, blocking means that any instruction that accesses the content of an output register of a previous ACE instruction will automatically have to wait that the results are retired, otherwise the completion status of the instruction will have to be followed in a CSR.

A 32-bit CSR `ACE_CC_USED` with a bit per CC to denote whether the register is in use or not (cleared contextually to CC erasure to dispose of the key). Read-only.

A 32-bit CSR `ACE_CC_DIRTY` with a bit per CC to keep track whether the corresponding CC has been modified since the last time the same bit has been cleared. +
Two types actions can modify a CC and thus must update also `ACE_CC_DIRTY`:

* An explicit configuration/import; and
* Certain cryptographic operations, such as absorbing information in a hash function, that modify the internal state.

It is also possible to directly write to `ACE_CC_DIRTY`, and in fact necessary to optimize context switching.

A 32-bit CSR `ACE_CC_BUSY` with a bit per vector register to keep track whether any operation writing to a certain register is still operating.

256-bit worth of CSR `ACE_CTK` to store the the CTK.

* `ACE_CTK` is writable exclusively by MM.
* `ACE_CTK` reads as zero in all cases.
//There is need to raise exceptions if any other mode/EL tries to write to it or read it.

Two CSRs at U, resp., S level, namely `UKSID` (User Key Space ID ) and/or `SKSID` (Supervisor Key Space ID), which are only writable at S, resp., a higher mode.
We can reuse the CSRs for `ASID`, resp., `VMID` for`UKSID`, resp., `SKSID`.

*Remark:* _We do not envision direct key sharing across Worlds/Supervisor Domains, so consider defining a Hypervisor or World "Key Space ID" as redundant.
It is the responsibility of the MM to change CTKs between Worlds/Supervisor Domains._

The software in each World/Supervisor Domain is normally responsible to generate their own keys, and if a process (applet) in one World/Supervisor Domain is responsible to provide keys to other Worlds/Supervisor Domains, it is the responsibility of the MM to properly import/switch the CTK/export. If `ASID`/`VMID` are reused for `UKSID`/`SKSID`, we still need to distinguish somehow the use for separating key spaces even if these fields are not used to build GVAs/GPAs (TBD).

<<<

==== Lifecycle Binding

Internally, ACE has a table of Lifecycle Binding Secrets (LBST)

These can be configured by the RoT and how to do it is impdef.

These lifecycle specific secrets are 256 bits long, like the CTK.

If the lifecycle field of a context (CC/SCC) is zero, then the CTK is used.

If the value is non-zero, then this number minus one is used as an index _i_ in the Lifecycle Secrets Table.

The value Derivation(CTK, LST[_i_]) is used for import/export in place of the CTK.

Since the derivation function can be seen as expensive, the ACE implementation is allowed to cache recently used Lifecycle Derived.

The RoT must configure a LBST, accessible to each ACE Unit (can be duplicated or not) at each reset cycle.

The mandatory entries are these, at least four bits are needed.
The index in the LBST is Value-1.

.Mandatory Values for Lifecycle Binding
[width="100%",cols="20%,52%,^9%,^9%",options="header",]
|===
.>| Name .>| Description .>| MM-Writeable .>| Value
| No lifecycle binding | | N/A | 0
| SiP | Identifies the manufacturer of the SoC. Permanent. | N | 1
| Chip_Model | Identifies specific chip model/family. Permanent. | N | 2
| Device_ID | Unique device identifier. Shareable across multiple SoCs. Sharing mechanism impdef, i.e., not architected. Can be permanent in a device — re-generations can be optionally triggered using impdef HW authenticated mechanisms. | N | 3
| Device_Type  | Identifies device type/model. Not necessarily permanent. Reconfigurable like Device_ID. | N | 4
| OEM_Secret | Provisioned by OEM to differentiate their products from the competition. Product dependent. | Y | 5
| System_Secret | Identifies System (Stack). Not permanent, must be configured during (virtual) boot. | Y | 6
| Boot_Session | Regenerated at each (virtual) boot. | Y | 7
| _Reserved for Revocation_ | Regenerated at boot or at each revocation event. | Y | 8
|===


*Remark:* _We need to discuss what to do in case there is a reboot of a VM. Then we need to "virtualize" the seventh string, or use a secondary CTK for that purpose, since some VMs may reboot while others may not.
Also, do we want to allow a VM to have a different virtual hardware? Or does it always declare the same configuration as the underlying hardware?_
In principle, all this can be done by calling into MM. MM would need to keep track of the lifecycle binding values and ensure that they are updated correctly when necessary.

<<<
The key length is determined by:

[arabic]
. The cryptographic algorithm requirements.
. The number of shares used for threshold implementations to enhance side-channel protection.

For example, a system based on the XEX mode operation using AES-128 with two independent keys and three shares requires:

[arabic]
. 768 bits total storage (2 keys * 128 bits * 3 shares).
. Only 256 bits when passing the key value through a vector register.
. Full state import/export when the key is split into shares.

The state length is specified by a 6-bit value (the maximum value is 62) that defines the architectural state field length in 128-bit blocks. This is controlled by the MAX_CHR_STATE_LENGTH system register (range 1-62), limiting the maximum state length to 7936 bits. In practice, a mode of operation using two 256-bit encryption keys and one 256-bit hashing key, and keeping internally a 256-bit counter, all divided into three shares, uses 3072 bits. Thus, MAX_CHR_STATE_LENGTH can be taken as, say, 24. Together with the metadata, this amounts to 3136 bits, whereas, externally, a SCC would be 3200+128=3328 bits. We view this as a maximum CHR state length, and in practice we expect most implementations to implement a smaller state.

To circumvent the problem of potentially small states, two or more CHRs may be “pooled/grouped” (as in some vector extensions) to combine their storage. In this case only the first CHR of a group would be accessible through the instructions and export operations would fail if invoked on one of the chained CHRs. Import operations on any CHR in a group would invalidate all CHRs in the group that are not directly overwritten by the import operation. This may increase the number of registers from 8 to 16, all with 1024 bit states?


*LIFECYCLE* a 4’b0000 means that the lifecycle is unrestricted. A value _i_ <> 0 mean that the _i_-th lifecycle key has to be used to restrict the lifecycle of the key.

metadata[32:25] |*ISKT_INDEX* a| If KEYTYPE != HW_KEY, then

Reserved for future use, currently WARZ

else

Immutable System Key Table Index


==== Format of a Sealed Cryptographic Context

The format of the SCC is very simple

____
Byte 0 Key type and State length

Bytes 1 to 15 SIV

Bytes 16 to end Encrypted metadata (padded with zeros to 128 bits) and State
____

The recommended algorithm to create the SCC is 256-bit AES-GCM-SIV as per RFC8452, with the only difference is that the SIV is truncated to 120 bits (removing bits 0:7 and replacing it with zeros for the purpose of performing the CTR encryption. Therefore, when the SIV is re-computed for integrity verification, these bits are ignored in the comparison.

The length of a SCC should be as small as possible, in other words only contain the state which is used by the algorithm specified in the metadata, and not the entire length of the CHR. This allows for faster context switching times.

=== The ACE_CHR_VALID Status Registers

A system register ACE_CHR_VALID_x should be provided for PL x = UL, OL, HL, to report whether a CHR has been set or used by a process. This is used to determine whether the contents must be saved by the parent PL upon context switch.

Only an execution level higher than ELx can directly clear the content of ACE_CHR_VALID_x. The instruction provided by the ISA to manipulate CSRs are used for this purpose and are not architected by ACE.

The register should implement as many bits as CHRs, except for c31 In other words, each ACE_CHR_VALID_x contains at most 31 bits and bit 31 is WARZ.

[[System-Keys]]
=== System Keys

In current SoCs, _system keys_ mostly come in two flavors.

[arabic]
. *A Table of Immutable System Keys, the ISKT*, which is provided at boot. We shall assume that this table is made available to the CPU as an array of keys and metadata in an internal RAM. This table can be provided either as a data package in memory or transmitted using an internal HW channel. +
Since such operations can be expensive, the operation is allowed to return immediately and delay successive operations that access the key table RAM.

____
This can speed up the boot process significantly.
____



[arabic, start=2]
. *Dynamically Generated Keys* which can be obtained by sending a request to a special HW block. The delivery of such keys may be very different from SiP to SiP and even within the product portfolio of a single SiP. __We only require that such operation stores key and compatible policies in a specified CHR. +
__The two ways such keys can be transferred to a SS are mentioned in <<Support-dynamically-generated-system-keys>> and to address the import of a foreign key format, the import operation can be extended to support such formats. +
Since such operations can be expensive, they may operate asynchronously and return immediately, blocking any successive operations that access the destination CHR.

*Example:* _On certain chips,
keys are transferred using a mailbox interface from a key management hardware to key consumer end points.
the communication channel can be created by first transferring a wrapping key from the key management hardware to the key consumer end points, or by using RTL keys.  Different end points may use different wrapping keys, thus guaranteeing the separation of Subsystems.
Thereafter each end point can authenticate and decrypt keys provided by the key management hardware as data blobs in shared RAM._

_Such end points usually, authenticates and decrypt a key table at boot.
The key table itself can vary according to the receiving end.
ACE can receive such a table.
The contents of the table shall not be revealed to any SW environment.
However, ACE can refer to the keys in the table by an index, and we allow such keys to be referred by index or, if internal metadata allows, by value in CHRs._

Although such an approach might seem redundant, it allows for faster export and import of these keys into the local CXU pipelines, ultimately saving time.

=== Initialization at system boot

Most functionality of the extension does not require special initialization.

In <<System-Keys>> (see also <<Goals-Regarding-Key-Types>>) we described how a system, optionally, may have various system keys. It is the responsibility of the implementor to design the mechanisms to collect and collate the keys the CXU is allowed to use. These keys are placed, together with their metadata, in the ISKT in an internal RAM. It is critical that any policy associated with them is suitably translated to compatible ones as defined by the ACE architecture.

There is no need for the system key RAM to be per hart. In fact, it would be a waste of resources. A single memory block per cluster, or even shared in the entire Subsystem is suitable for the purpose. After the list has been initialized, it is write locked, and it cannot be modified until the next reboot.

Hence, after boot, the system has access to a read-only table of key/metadata pairs:

systemKeys[MAX_SYSTEM_KEYS].{key, sk_metadata}

where the metadata field here must contain at least the following information:

[width="100%",cols="28%,72%",options="header",]
|===
|Field |Description
|sk_metadata[15:0] |ALGORITHM: Same as in in Section 3.1.1
|sk_metadata[16] |FWD_ALLOW: Forward direction allowed (for instance, encryption)
|sk_metadata[17] |BCK_ALLOW: Backward direction allowed (for instance, decryption)
|sk_metadata[18] |CAN_USE: if the system key can be used directly, 0 if not
|sk_metadata[?:19] a|
ACPOLICY: a list of Els/SSs/master combinations that are allowed to use this key at all. This is highly implementation dependent. We write +
if sk_metadata.ACPOLICY[current /WORLD/master] == 0/1 +
for the corresponding AC verification (0 = false, 1 = true)

This field may be longer than the one in the CHR.metadata, because a key may be, say, available only to LPASS and not to the APSS, and therefore it would not be mapped to the key list in the APSS.

|===

This metadata table is only an example. If modes of operations and primitives that admit more than two sub-operations/variations are implemented, additional bits may be included. This table is only for internal use by the microarchitecture, and its format is implementation dependent. Only the named fields are mandatory. It is the responsibility of the implementation to properly translate the system key policies (for instance the Levels in Qualcomm Key Tables) into compatible ACE policies.

=== Derivation of Lifecycle CTKs

This derivation is implementation specific, however the requirement is that the output depends in a cryptographically strong way (as in the sense of a PRF) from both the CTK and the DUDEK.

The operation is written as

*Lifecycle Specific CTK = Uniquify(CTK,LTST[i])*

in the pseudocode.

The default computation of Uniquify is simply the XOR of the current CTK with *`LTST[i]`*.

We are open to consider more sophisticated merges, such as separate encryption of the two 128-bit halves of *LTST[i]* using the CTK as the key, or a single-round Benes construction. This construction would be defined as:

IN_HI = LTST[i][8:15]

IN_LO = LTST[i][0:7]

OUT_HI = IN_HI ^ AES-256(IN_LO; CTK)

OUT_LO = IN_LO ^ AES-256(IN_HI ^ 128h’0...01; CTK)

return OUT_HI || OUT_LO

Further computations are not needed since the result is used only as a key and is never directly revealed.

=== Instructions

All instruction encodings are just examples. They represent, mostly, exercises to verify whether the instructions can be safely encoded in 32 bits. No attempt has been made to verify whether there is sufficient encoding space in existing architectures to add them.

In this section we write, AES256_Encrypt(K,P) for the encryption of P using AES-256 under the key K.

ACE may or may not be implemented as part of the VXU. The HW block or component implementing the feature is called the *Cryptography Execution Unit* (CXU). It may share components with other cryptographic functionality or instructions of the PE, however extra care must be taken to prevent leakage of CHR contents.

[[ace-set-clear]]
==== ace.set/ace.clear

*ace.set* configures a CHR with a key/metadata pair, or a system key number.

*ace.clear* clears the contents of `cd`, including setting C[d].metadata[VALID] to zero, and mark it as unused in the corresponding ACE_CHR_VALID_x, by setting the d-th bit to zero. This serves to notify the parent environment that the process is finished using that CHR and it does not need to be saved and restored by upon context switch.

*Remark:* _Clearing a CHR after it has been used is good hygiene to reduce the likelihood that another process may use its contents. In a SW architecture, processes should inform the OS via a system call that they are going to use the feature. This will allow the OS to clear all CHRs when switching to a process that is not using the feature._

The CHR `cd` is the CHR to be configured.

The integer register `xn` contains the metadata.

There are two main ways the instruction operates:

[arabic]
. The key is a SW key (KeyType 0 in the metadata), then the key is an explicitly given bit-string in the vector register `va`, or in the pair [V[a+1]:`va`].
. If the KeyType field `t` is equal to 1, then the bit string `va` is a descriptor for an immutable system key (also called a HW key)

Bit 63 of the metadata field is always set to 1 to properly configure a CHR.


*_Encoding_*

* `ace.set` `cd`, `xn`, `va` -- use R-type encoding with `cd` as the destination.
* `ace.set` `cd`, `xn`, [`xa`] -- use R-type encoding with `cd` as the destination.
* `ace.clear` `cd` -- use R-type encoding with `cd` as the destination.
* ace.clear is encoded as _pseudoinstruction_ `ace.set` `cd`, `xn`,`va` with `xn`=0, i.e. with null metadata.
* The encoding also contains two special bits, `a` and `t`.

*_Decode for this encoding_*

[subs="specialcharacters,quotes"]
----
integer metadata = UInt(`xn`);
integer d = UInt(`cd`);
bit a = 0 if key passed through `va` (or `va` and the following registers in groups of 2, 4, or 8 registers, as per RVV extension) or memory addressed;
integer key = UInt(`va`) if a == 0, else *`xa`
----

*_Assembler symbols_*

* `cd` is the name of the destination CHR.
* `va` is the name of the (first) source vector register holding the key or the system key descriptor.
* `xa` is the name of the register containing the addess of a key (if very long or consisting of the concatenation of several keys). It is used in place of `va`.
//We do not preclude a priori the use of different addressing methods if the architecture supports them.
* `xn` is the name of the integer register containing the metadata. Bit 63 of this register is ignored and always set to 1 by this instruction.

*_Operation_*

.Pseudocode for ace.set/ace.clear
[,,linenums]
----
integer type;
integer algorithm;
integer key_blocks;

if !ACE_is_Implemented() then UNDEFINED;

// Only the MM may touch c31.
if (d == 31) && (CURRENTPL != MM) then
    *Error!*

bits(256) K; // Can be larger is longer keys are supported
if d != 31 then
    type = metadata.KEYTYPE;
    algorithm = metadata.ALGORITHM;
    key_blocks = AlgoKeyLength(algorithm);
else
    type = SW_KEY;
    key_blocks = 2; // Algorithm is implicit for the CTK
if (metadata[VALID] == 0) && (d != 31) then
    if metadata == 0 then
        // Implement ace.clear
        ACE_CHR_VALID_x[d] = 0;
        C[d].state = 0;
        C[d].metadata = 0;
        Return;
    else
        *Error!*

// If it is a SW-defined key –– simplified code handling only 128 and 256 bit
// keys and vector register length
if type == SW_KEY then
    if a == 0 then // read from registers
        if key_blocks == 2 && `vl` == 128 then
            K = V[key]:V[key+1];
        else if key_blocks == 2 && `vl` == 256 then
            K = V[key];
        else if key_blocks == 1 then
            K = 0^128^ :V[key][127:0];
        else
            (manage other lengths)
    else
        K = [`xa`] // read key_blocks 128-bit blocks
    C[d].state[key_blocks * 128 – 1 : 0] = K;
else
    index = metadata.INDEX;
    K = ISKT[index].key;
    metadata = _merge ISKT[index].sk_metadata with original metadata_
    // TODO, which fields to pick, exemplarily
    metadata.INDEX = index;
    _if (encryption/decryption bits are incompatible with K’s policies,_
        _according to an internal table) then *Error!*_
    C[d].state[key_blocks * 128 - 1:0]= K;
    if d != 31 then
        C[d].metadata = metadata; // note that bit 63 is equal to 1
        ACE_CHR_VALID_x[d] = 1;

Perform any additional operations on the state that are required by the algorithm, such as creating shares for a threshold implementation.
----

[[ace-export]]
==== ace.export

The instruction exports a CHR to external, untrusted memory.

// For simplicity, in the example below we implement only one addressing mode.
// Additional addressing modes are possible if supported by the architecture. We do not write their ASL to focus on the essentials.

*_Encoding_*

* ace.export [`xn`], `cs`; -- Use R-type encoding, with `xn` as the destination.

*_Decode for this encoding_*

[subs="specialcharacters,quotes"]
----
integer n = UInt(`xn`);
bits(64) address = X[n];
integer s = Uint(`cs`);
----

*_Assembler symbols_*

* `cs` is the name of the source CHR to be exported
* `xn` is an integer register containing the base address of the buffer where to store the SCC

*_Operation_*

.Pseudocode for ace.export
[subs="specialcharacters,quotes"]
----
if !ACE_is_Implemented() then UNDEFINED;

bits(64) storage = X[n]; // Memory Address to store SCC.
bits(256) transport_key = C[31].key; // At least initially
bits(64) metadata = C[s].metadata;
bits(128) SIV;
integer keytype = metadata.KEYTYPE;
integer algorithm = metadata.ALGORITHM;
bits(4) lifecycle = metadata.LIFECYCLE if keytype == SW_KEY;
bits(8) ISKT_index = metadata.ISKT_INDEX if keytype == HW_KEY;
bits(6) state_blocks; // Includes the key and any additional data.

// Do we have privileges?
if metadata.ACPOLICY[CURRENTPL,CURRENTWORLD] == False then *Error!*

// Sanity check.
if metadata[VALID] == 0 then *Error!*

// The MM is supposed to know and keep the values.
// We also explicitly disable exporting of c31 for the MM, as its own
// knowledge would be needed to recover it.
if s == 31 then *Error!*

// Determine number of blocks beside the metadata half block.
// It includes the key and additional information.
state_blocks = AlgoStateLength(algorithm);

if type == HW_KEY then
    transport_key = Uniquify(transport_key, LTST[bootunique_key_index]);
else if metadata.LIFECYCLE != 0 then
    transport_key = Uniquify(transport_key, LTST[lifecycle]);
else
    transport_key = transport_key; // actually do nothing

Encrypt padded(metadata)||state using AES-GCM-SIV-256 as per RFC8452
Mem[storage] = key_type || lifecycle
Mem[storage+1:15] = SIV
Mem[storage+16:storage+16*(1+state_blocks)] = ciphertext
----

==== ace.import

ace.import is the inverse of ace.export.

It verifies the tag in the exported CHR, and if verification fails, then the content of the CHR is not overwritten (nor invalidated) and the instruction shall raise an exception, otherwise the content is successfully imported.

The instruction may, optionally, implement an operation to import a table of immutable keys. Such instruction may be invoked only once per boot cycle and takes a system defined table and imports it into the internal RAM. Those keys may not be imported.

The instruction may, optionally, also implement a system defined import mechanism for dynamic system keys. Note that, ACE can only import such keys and cannot export in that format.

//The same remark as for ace.export applies regarding memory addressing modes.


*_Encoding_*

* *ace.import `cd`, [`xn`]*  -- use R-Type or I-Type encoding with `xn` as the first source.

Optionally, one of the following three variants (when a specific bit `t` in the encoding == 1)

* *ace.import.system_table `xn`* -- use R-Type or I-Type encoding with `xn` as the first source.
* *ace.import.system_table [`xn`]* -- use R-Type or I-Type encoding with `xn` as the first source.
//* *ace.import.system_table `vn`*

Optionally, one of the following three variants (when bit y == 1)

* *ace.import.system_dynamic `cd`, `xn`*
* *ace.import.system_dynamic `cd`, [`xn`]*
//* *ace.import.system_dynamic `cd`, `vn`*

*_Decode for this encoding_*

[subs="specialcharacters,quotes"]
----
integer n = UInt(`xn`);
bits(64) address = X[n];
integer d = Uint(`cd`);
bool is_system_dynamic = y;
bool is_system_table = t;
----

*_Assembler symbols_*

* `cd` is the name of the destination CHR to be exported;
* `xn` is the name of an integer register containing the base address of the SCC’s buffer;
* `t` true if the internal key table is being initialized with an impdef mechanism;
* y true if the key is dynamically generated (“d” is already used, so we use the second letter in the word, it is in a system defined format and not the format defined by the ACE architecture.

*_Dependencies_*

The function optionally supports the “t” (Table initialization) bit, which allows initialization of an internal key table. It relies on the operation

success = ACE_ImportSystemTable({address|token})

that imports a table, which can be in memory (the, the address is provided in `xn`) or described by a token (a value that is stored in `xn` or `vn`). The Boolean value success, which is true if the operation is successful.

In this case there is also an internal flag

ACE_keyRAMInitialized

that is reset to false at each boot and set to true once this version of the instruction is successfully executed.

The function can optionally support the “s” (System Transported) bit, which relies on the following operation.

success, K, metadata = ACE_ImportSystemKey({address|token})

That returns three values:

* A Boolean value success, which is true if all following conditions are satisfied:
** verification and decryption of the blob has succeeded,
** the key length is admissible,
** the associated algorithm is supported or there is functionality available in the CXU that allows to implement it without reducing the required security posture.
** the key’s access policies are compatible with the current PE/SS/EL, and
** the metadata has an equivalent in the configuration offered by the CXU.
* A key K
* A metadata values metadata, which is expressed in the format offered by the CXU.

*_Operation_*

.Pseudocode for ace.import
[subs="specialcharacters,quotes"]
----
if !ACE_is_Implemented() then UNDEFINED;

bits(64) storage;
bits(64, 128 or 256) token;
bool success;
bits(256) transport_key = C[31].key;
bits(128) SIV = Mem[storage,16];
integer algorithm;
bits(4) state_blocks;
bits(64) tmp_metadata;
bits(MAX_STATE_LENGTH*128) tmp_state;
bits(6) lifecycle;
bits(8) type = SIV[0]

key_type || lifecycle = type
if is_system_table == True then
    if ACE_keyRAMInitialized == True then
        *Error!*
    Set *one* of the following two values // system specific
        a. storage = X[n];                // Address of the key table in memory
        b. token = X[n] or V[n];          // System specific
    success = ACE_ImportSystemKey({storage|token}) // System specific
    if success == True
        ACE_keyRAMInitialized = True
        Return
    else
        *Error!*

// The MM is supposed to know and keep the value for VM/process migration purposes.
// Therefore, we explicitly disable importing into c31 *also* for the MM
if d == 31 then *Error!*

if is_system_dynamic == True then
    Set *one* of the following two values
        a. storage = X[n]; // Address of system wrapped key in memory
        b. token = X[n] or V[n]; // System specific
    success, K, metadata = ACE_ImportSystemKey({storage|token}) // System specific
    if success == True
        C[d].state[255:0] = K
        C[d].metadata = metadada
        ACE_CHR_VALID_x[d] = 1
        Return
    else
        *Error!*

// Sanity check.
if lifecycle != 0 then
    transport_key = Uniquify(transport_key, LTST[lifecycle]);

SIV[0] = 0
Decrypt and verify SSC into CHR[d].metadata and CHR[d].state using using AES-GCM-SIV-256 as per RFC8452, with a 120-bit SIV.
Perform any additional operations on the state that are required by the algorithm.
ACE_CHR_VALID_x[d] = 1;
----

==== ace.execute

This instruction applies the cryptographic primitive defined in a CHR, parametrized by the corresponding key, to a user given input.

*_Encoding_*

* ace.execute `vo`, `vi`, `cs`, d (with `t` == 0) -- R-type encoding.
* ace.execute `vo`, `vi`, `vn`, `cs`, d (with `t` == 1) -- encoding not clear at the moment, we may need to overwrite an input or use the R4-Type.

*_Decode for this encoding_*

integer s = Uint(`cs`);

integer direction = UInt(d);

integer hasSecondInput = UInt(t); // This serves only with algorithms that have

// tweaks or IVs, otherwise ignored.

integer input = UInt(`vi`);

integer output = UInt(`vo`);

*_Remark_*

hasSecondInput has been defined as a separate bit independently in order to simplify decoding and renaming: if the need for a specific register is determined only after another one is read, then the logic is much more complex, and it may also cause delays in the pipeline.

*_Assembler symbols_*

* `cs` is the name of the CHR that selects the algorithm and provides the key to be used
* `vi` is the name of the vector register containing the input to the algorithm
* `vo` is the name of the vector register where the output of the algorithm is stored
* `vi2` is the name of the vector register containing a second input to the algorithm if defined (this applies for instance to tweakable ciphers)

*_Issues_*

The encoding space is limited. If we need to support more than two “directions”, for instance for a hash function or a mode of operation with different phases (AEAD, modes with ciphertext sealing), then we may need a wider field. However, if such operations (to be verified!) do not need the `vi2` input, so the field can be used to determine which stage of the underlying algorithm is being invoked by ace.execute, instead of holding a vector register number. Alternatively, the “stage” is set by the ace.message operation.

*_Operation_*

.Pseudocode for ace.execute
[subs="specialcharacters,quotes"]
----
if !ACE_is_Implemented() then UNDEFINED;
integer algorithm = C[s].metadata.ALGORITHM;

// Only the MM may use c31.
if s == 31 then *Error!*
if CURRENTPL != MM then *Error!*
if C[s].metadata[VALID] == 0 then *Error!*;
// Sanity checks
if (t == True) and (Algorithm does not need a require a second input) then
    *Error!* (invalid value/instruction);
if (t == False) and (Algorithm requires a second input) then
    *Error!* (invalid value/instruction);
ACE_CHR_VALID_x[s] = 1;
if algorithm == AES-128 then
    if direction == 0 then
        if C[s].metadata.FWD_ALLOW == 1 then
            V[o] = AES128_Encrypt(V[i], C[s].key);
        else
            *Error!*
    else // direction == 1
        if C[s].metadata.BCK_ALLOW == 1 then
            V[o] = AES128_Decrypt(V[i], C[s].key);
        else
            *Error!*
else if algorithm == AES-192 then
etc...
----


For obvious reasons, the description of this operation is very sketchy. The provided pseudocode should be sufficient to understand how the instruction would be implemented in case of other ciphers.


==== ace.message

*ace.message `xd`, `ca`, #immed8*

*ace.message `xd`, `ca`, `xs`*

*ace.message `xd`, `ca`, [`xa`]*

It depends heavily on the algorithm, so this definition is just a simple interface accepting a destination CHR index and an immediate, a value in a register, or an address. A return value is written to integer register `xd` (ignored if `xd`=X0 is hardwired to zero in the ISA) and it is also algorithm specific, with the value 0 understood as “ok/no error”.

==== ace.size

*ace.size `xd`, `cs`* stores into register `xd` the size in bytes of the SCC resulting from exporting CHR `cs`.

There is no need for a more detailed description of this instruction for the purpose of this proposal.

*Example:* _If a 128-bit key is programmed in the given CHR,the instruction would write the value 40 in `xd`, (as in 40 bytes), and if a 256-bit key is programmed in the given CHR, it would write 56 in `xd` (as in 56 bytes)._

==== ace.available/ace.PSCAH

*ace.available `xd`, #immed8*

*ace.available `xd`, `xs`*

*ace.PSCAH `xd`, #immed8q*

*ace.PSCAH `xd`, `xs`*

ace.available writes 1 (True) in `xd` if the algorithm expressed by the immed8 or by the least significant 8 bits of `xs` is implemented by the microarchitecture, otherwise 0 (false).

ace.PSCAH will return a bit-string that described the level of hardening against physical side channel attack the implementation provides. The value shall contain

[arabic]
. One bit for timing (not meaningful for AES and QARMA, or Galois Multiplication, but may be useful for future algorithms);
. Order of hardness against POWER CONSUMPTION SCAs. We suggest using 4 bits to encode values from 0 (no protection) to 8 at least, and one bit regarding template attacks;
. Order of hardness against EM emission SCAs: Also 5 bits;
. Order of hardness against photon emission SCAs: Also 5 bits;
. Order of hardness against acoustic crypanalysis: Also 5 bits; and
. Fields for any other relevant physical side channel attack vector.

The values must be obtained by an evaluation performed by an external third-party and then hardwired in production runs or provisioned in some form of OTP memory. We do not define here the bit string in higher detail, as it will be done as part of the normal ISA standardization process.

There is no need for a more detailed description of this instruction for the purpose of this proposal.

*Remark:* _If ACE becomes part of an ISA then this will be reflected in ID register. However, we would not want to add a bit for every possible algorithm, since we have room for up to 256, even though in practice there would be very few. Therefore, the SW should check only whether the extension is available and, if so, use this instruction to verify whether a given algorithm is supported._

//== Example of data flow in SW
//image:media/image2.emf[media/image2,width=624,height=616]

//== Example of design of an implementation
//
//image:media/image3.emf[media/image3,width=570,height=509]

//The Key Table needs only be unique _per_ _subsystem_. So. the APSS would have one Key Table. It is up to implementors to decide whether, once it has been provisioned and locked, it shall be broadcast to local copies in each cluster. This is represented in the next Figure.

//image:media/image4.emf[media/image4,width=530,height=530]

//Here we see an example of an Application Sub-System that contains several clusters of processing elements. Many of them support only one hart per core and therefore contain only one CHR file. However, one cluster, possibly of power-efficient cores, supports two harts per core, and therefore there are two CHR files, like for any other architectural register file.

//For performance reasons, each cluster contains its own local copy of the ISKT. At boot only one hart may retrieve the ISKT from the system, and then, once it has been write-locked, this table is broadcast to the other clusters, which receive it and write-lock their local copies.

//It is also possible to have a unique ISKT for the entire subsystem, or that a ISKT is shared among a few clusters. These are all implementation decisions and are not architected.

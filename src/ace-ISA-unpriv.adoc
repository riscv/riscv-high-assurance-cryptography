[[ACE-unpriv]]
== Unprivileged Architecture

[[ACE-concepts]]
=== Fundamental Concepts and Definitions

ACE is a complex architecture and relies on certain fundamental concepts, which we introduce here.
While this leads to some repetitions, we believe that it also brings better clarity to the presentation.

Cryptographic Context:::
(((Cryptographic Context)))
The *Cryptographic Context* (CC) is the fundamental concept of ACE.
A CC is an indivisible structure consisting of a *Metadata* section and a *Content* section; all cryptographic operations performed by ACE execute within the constraints defined by a CC.
The Metadata has a fixed format and specifies the cryptographic algorithm and optional usage control policies associated with the CC.
(((Cryptographic Context, Metadata)))
The Content has an algorithm-specific format and holds sensitive material such as keys and internal algorithm state.
(((Cryptographic Context, Content)))
The Metadata requires integrity; the Content requires both integrity and confidentiality.
These requirements are architecturally enforced by ACE.

Cryptographic Register:::
(((Cryptographic Register)))
CCs are realized using *Cryptographic Registers* (CRs), per-hart architectural containers that safeguard CCs.
A CR is *provisioned* by writing Metadata and Content into it; this operation binds the latter to form a CC.
There is no store-like instruction to extract the Content of the CR in a manner that compromises its confidentiality.
A CC may be used for cryptographic operations only while resident in a CR.
Only the ACE unit may access or modify a CC residing in a CR, in accordance with architectural rules and the algorithm bound to the CC.

Sealed Cryptographic Context:::
(((Cryptographic Context, sealed)))
To support context switching while at the same time protecting CCs outside architectural state, a CC may be *exported* from a CR as a *Sealed Cryptographic Context* (SCC), an encrypted and authenticated representation of a CC that can later be *imported* into a CR.
SCC export and import use a _Context Sealing Key_ (CSK), which may be programmable by M-mode.
A CC sealed under one CSK cannot be re-imported under a different CSK, enabling cryptographic domain separation across spatial and temporal domains.

Object-Orientation:::
(((Cryptographic Context, object-oriented)))
CCs act as *objects* exposing a uniform interface across algorithms.
A CC encapsulates algorithm-specific behavior, enabling interchangeable use of different primitives (e.g., AES-128, AES-256, SM4) in identical modes (e.g., ECB, GCM-SIV, XTS) without requiring changes to compiled code.
Side-channel attack (SCA) resistant variants are supported transparently.

Usage Control Policy:::
(((Cryptographic Context, usage control)))
(((Cryptographic Context, management operations)))
(((Cryptographic Context, usage operations)))
ACE distinguishes between CC/CR *management* and *usage* operations.
(((Cryptographic Context, export)))
Management operations include *configuration* (e.g., CR provisioning, SCC import, cloning, key derivation) and *export* of a CR as an SCC.
Usage operations include cryptographic operations and state changes.
Key derivation is both a configuration and a usage operation.
(((Cryptographic Context, access)))
All operations represent a form of *access* to CRs.
To prevent denial-of-service scenarios, management operations, in particular configuration operations, are far less restricted than usage operations.
_Usage Control_ policies restrict only certain CC/CR usage operations.

Localities:::
(((Cryptographic Context, Locality)))
ACE can bind CCs to a *Localities*, i.e., restrict usage to specific devices or device classes, hardware configurations, physical or virtual boot cycles,
and process domains at various privilege modes.
This binding is achieved by using the Localities as _tweaks_ in the encryption and decryption of SCCs.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-extensions-overview-unpriv]]
=== Extensions Overview

[WARNING]
[.red]#This list is an early draft.#

* `Zlio` {implies} Support for `ace.input`/`ace.output` operations.
* `Zleaes128p` {implies} Support for AES-128 encryption and decryption (all applicable modes)—the `p` at the end denotes a primitive.
* `Zleaes192p` {implies} Support for AES-192 encryption and decryption (all applicable modes).
* `Zleaes256p` {implies} Support for AES-256 encryption and decryption (all applicable modes).
* `Zlsm4p` {implies} Support for SM-4 encryption and decryption (all applicable modes).
* `Zlctrm` {implies} Support for counter mode-the `m` at the end denotes a mode.
* `Zlxctrm` {implies} Support for XCTR mode.
* `Zlgcmm` {implies} Support for GCM mode.
* `Zlgcmsivm` {implies} Support for GCM-SIV mode.
* `Zlxexm` {implies} Support for XEX and XTS modes.
* `Zlocbm` {implies} Support for OCB mode.
* `Zlcmacm` {implies} Support for CMAC.
* `Zlesha2h` {implies} Support for SHA-2 (all applicable modes)—the `h` at the end denotes a hash function.
* `Zlesha3h` {implies} Support for SHA-3 (all applicable modes).
* `Zlsm3h` {implies} Support for SM-3 hash function (all applicable modes).
* `Zlhmacm` {implies} Support for HMAC.
* `Zlascon` {implies} Support for the ASCON suite.
* `Zlkned` {implies} NIST Suite: AES Block Cipher. Depends on `Zleaes128` and `Zleaes256`.
* `Zlkn` {implies} NIST Algorithm Suite. Depends on `Zlkned` and `Zlesha2`.
* `Zlv` {implies} Requires V (or a suitable subset thereof). Must support for the following CSRs: `aceerror` and `acestart` (this is a dependency for Zicsr); must support the following instructions: `ace.prov`, all four forms of `ace.exec`, `ace.clear`, `ace.export`, `ace.import`, `ace.clone`, `ace.size` (and thus `ace.avail`), and `ace.restrict`; must support `Zleaes128` and `Zleaes256` in ECB and GCM-SIV modes.
* `Zlio` {implies} Must support for the following CSRs: `aceerror`, `acestart` (this is a dependency for Zicsr), `aceiobuflen` and `aceiobuftop`; must support the following instructions: `ace.prov`, Form D of `ace.exec`, `ace.input` and `ace.output`, `ace.clear`, `ace.export`, `ace.import`, `ace.clone`, `ace.size` (and thus `ace.avail`), and `ace.restrict`; must support `Zleaes128` and `Zleaes256` in ECB and GCM-SIV modes.
* At least one of `Zlv` or `Zlio` must be implemented. (Note that, currently, we are not considering a version of ACE that uses the GPRs in place of the vectors registers.)

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-dependencies-unpriv]]
==== Dependencies on Other Extensions

ACE inputs and outputs may be conveyed through vector registers or through an architectural input/output buffer (ACEIOBUF) loadable from and storable to memory; these two mechanisms are not mutually exclusive.

When vector registers are used, the full V extension is not required. ACE depends only on a minimal subset, denoted RVV-mini.
(((RVV-mini)))
RVV-mini must be fully opcode-compatible with RVV: code written for RVV-mini must execute with identical behavior under RVV.
The required features are:

* Vector registers wide enough to support the inputs and outputs of the implemented algorithms;
* The `vsetvli` instruction with restricted parameters (e.g., `vsetvli zero,4,e32,m1,ta,ma` for 128-bit operations); unsupported configurations must produce defined errors;
* Unit-strided vector loads and stores; and
* Vector bitwise logical operations: `vxor`, `vand`, and `vor`.

Floating-point, fixed-point, and general arithmetic vector operations are not required. Complex operations for certain cryptographic algorithms may be performed in GPRs, with data inserted into vector registers and result extracted from them via `vins`/`vext`.

[WARNING]
[.red]#RVV-mini need not be formally defined before ACE ratification begins; it may be defined later, with the ACE specification amended accordingly. This allows additional requirements to be collected, for example whether to mandate `vclmul.v[vx]` and `vclmulh.v[vx]` from `Zvbc`.#

// ///////////////////////////////////////////////////////////////////////////////////////////

=== Programmer-Visible Architectural State

[[ACE-cryptographic-registers]]
==== Cryptographic Registers

{empty}
(((Cryptographic Context)))
ACE defines up to 32 Cryptographic Registers (CRs), numbered 0 to 31 and denoted `K0`–`K31`.
CRs are architectural, i.e., per-hart.
(((Cryptographic Register File)))
CRs reside in a dedicated, per-hart _CR file_ (CRF) accessible only to the ACE implementation.

In ACE instructions, a CR may be addressed directly, as a 5-bit immediate, or indirectly, via a GPR value.
Accessing a CR with an index outside [0..31] raises an illegal instruction exception.

Unlike a conventional register, a CR can be _unconfigured_, meaning it holds no information.

We summarize the most important operations on CRs:

* Metadata and Content are loaded into a CR via `ace.prov` (<<ACE-instruction-init>>).
* A CR is cleared and unconfigured using `ace.clear` (<<ACE-instruction-clear>>).
* `ace.export` (<<ACE-instruction-export>>) exports a CR to memory as an SCC.
* An SCC may later re-imported into a CR via `ace.import` (<<ACE-instruction-import>>).  Import may fail if the SCC has been modified.
* `ace.exec` (<<ACE-instruction-exec>>) performs cryptographic operations on data blocks according to the algorithm configured in a CR.
* `ace.state` (<<ACE-instruction-state>>) transitions between states of a cryptographic algorithm.

[NOTE]
====
CRF capacity consumed by a CR depends on the configured algorithm; two CRs may consume different amounts. Insufficient residual CRF capacity may prevent execution of a configuration instruction (`ace.prov`, `ace.import`, `ace.clone` (<<ACE-instruction-clone>>); software must then free capacity by unconfiguring other CRs.

CRF capacity is implementation-defined. Implementations must provide sufficient capacity for all supported operations. At a minimum, the CRF must hold the largest possible single CR, or the largest CR pair used in cloning or derivation operations. An optional, implementation-specific mechanism for estimating required capacity is described in <<ACE-instruction-size>>.
====

[NOTE]
====
Indirect CR addressing has two microarchitectural implications:

. Adding CR renaming would significantly increase microarchitectural complexity.
However, CRs are redefined far less frequently than GPRs or FP registers (internal implied changes aside), so the absence of CR renaming
is not expected to cause performance issues.
. An additional bit in the instruction encoding selects between a 5-bit immediate CR number and a GPR-supplied CR number.
====

[WARNING]
====
VM migration can become an issue when the destination machine has a smaller CRF than the source machine.
Migration could fail, or the VM may have to let some processes terminate abnormally.
A lazy-loading mechanism may be used to load CRs on demand; see <<ACE-lazy-loading>>.
====

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-iobuf]]
==== ACE Input/Output Buffer

The preferred mechanism for supplying inputs to, and collecting outputs from, ACE operations is the vector register file of the V extension. ACE also defines an optional architectural, per-hart input/output buffer (ACEIOBUF) that may be used in place of vector registers, as described in <<ACE-usage-input-output>>.
The ACEIOBUF is separate from the CRs. It may reside within CRF memory or in its own memory region internal to the ACE state.
Support for vector registers and for the ACEIOBUF is not mutually exclusive.

The total length and the range of the ACEIOBUF used in cryptographic instructions are controlled by the `aceiobuflen` (<<ACE-CSR-aceiobuflen>>) and `aceiobuftop` (<<ACE-CSR-aceiobuftop>>) CSRs.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-Metadata]]
==== Metadata Header

ACE defines two external CC formats:

. The _Provisioning Input_ (PI), loaded into a CR to create a CC; and
. The _Sealed Cryptographic Context_ (SCC), an encrypted and authenticated representation of a CC used when exporting a CR to memory for later re-import.

{empty}
(((Cryptographic Context,Metadata)))
(((Cryptographic Context,Metadata,Header)))
Both formats begin with a 64-bit Metadata Header, whose format is defined below.

[[ACE-Metadata-header]]
.Format of the Metadata Header
[width="100%",cols="^9%,^7%,14%,70%",options="header"]
|===
|   Field | Width | Name               | Description
|   [0:0] |   1   | _Format_           | Set to 0 for the current Metadata format version.
|  [11:1] |  11   | _Algorithm_        | Cryptographic algorithm (primitive, mode, or protocol). See <<ACE-Algorithm-field>>.
| [13:12] |   2   | _AlgorithmPolicy_  | Allowed algorithm variants(s). See <<ACE-Algorithm-field>>.
| [15:14] |   2   | _SCProtection_     | Side-channel protection level. See <<ACE-SCProtection-field>>.
| [16:16] |   1   | _KeyType_          | 0: key is an explicit value in Content.
1: key is an index into the system-specific System Keys Table (SKT).
| [20:17] |   4   | _StateNumber_      | Current algorithm state-machine state, encoded as an integer.
| [28:21] |   8   | _Locality_         | Zero, or an index determining a Locality Secret. See <<ACE-Localities>>.
| [31:29] |   3   | _UsagePolicy_      | Usage (Control) Policy. Bits 29, 30, and 31, when set, disallow CC usage in U-mode, (V)S-mode, and H-mode, respectively.
| [45:32] |  14   | _AdditionalData_   | If non-zero, indicates an additional data segment appended to Content. The length of this additional Data segment is _AdditionalData_ × 8 bytes (up to 128 KiB).
| [63:46] |  18   | _ExpirationDate_   | If non-zero, the expiration date of this CC. See <<ACE-Metadata-expiration-date>>.
|===

Selected fields require additional explanation, provided in the following subsections.

//

[[ACE-Algorithm-field]]
===== Algorithm and AlgorithmPolicy Fields

Algorithms are encoded in an 11-bit field. Values 0–1535 are architecture-defined; the list of encodings is maintained by RVI (see <<ACE-algorithms>>). The remaining values are available for custom algorithms.

For encryption/decryption primitives and modes, the _AlgorithmPolicy_ field indicates whether the CC may be used for encryption (lower bit set), decryption (upper bit set), or both.
For asymmetric primitives supporting signatures, the lower bit permits signature generation and the upper bit permits verification.
For other primitives, the _AlgorithmPolicy_ field may encode additional algorithm identifiers to expand the effective encoding space of the _Algorithm_ field.

//

[[ACE-SCProtection-field]]
===== SCProtection Field

The architecture defines the following side-channel protection levels.

[[ACE-SC-protection-levels]]
.Encoding of Side-Channel Protection levels
[%autowidth,float="center",align="center",cols="^,<"options="header"]
|===
| Value | Description
|   0   | No protection.
|   1   | Data-independent execution latency (DIEL); first-order threshold implementation.
|   2   | DIEL; first-order threshold, fault-tolerant implementation.
|   3   | Custom, algorithm-dependent.
|===

Custom algorithms offering stronger protection than encodings 0–2 shall set _SCProtection_ to 3.

//

[[ACE-StateNumber-field]]
===== StateNumber Field

The _StateNumber_ field shall be zero in a PI.

The architected  _StateNumber_ values common to all algorithms are defined in <<ACE-state-constants-fixed>>.

[[ACE-state-constants-fixed]]
.Global CC State Numbers
[float="center",align="center",width="100%",cols="^6%,<20%,<12%,<62%",options="header"]
|===
| Value | Mnemonic                | State Name   | Description
|   0   | ace_state_initial       | _initial_    | CC immediately after provisioning or reset; ready for operation.
|  14   | ace_state_invalid       | _invalid_    | Algorithm terminated abnormally, or interrupted provisioning/import.
|  15   | ace_state_completed     | _completed_  | Algorithm has completed (not necessarily without error).
|===

All states other than _invalid_ are termed _valid_. Unless an algorithm's specification explicitly states otherwise, a transition from any valid state to _initial_ is always permitted.

If an algorithm defines 16 or fewer states (including the three fixed states), the current state is stored in the _StateNumber_ field.
For algorithms with more than 16 states, additional state information is stored in the Content section.
In all cases, the _StateNumber_ field shall be set to _initial_ (0), _invalid_ (14), or _completed_ (15) when the CC is in the corresponding state, and to a different value otherwise.
These three fixed states must be identifiable solely from the _StateNumber_ field, without inspecting the Content.

During `ace.prov` and `ace.import`, _StateNumber_ is set to _invalid_ for the duration of the operation and updated to the correct value only upon successful completion (see <<ACE-provisioning-export-import>>). By the rules of <<ACE-invalidation>>, a partially provisioned or imported CR cannot be exported. If a context switch occurs during such an operation, privileged code must unconfigure the CR; upon resumption, the instruction is restarted. An invalid CR with a nonzero `acestart` is recognized as an incomplete CR, permitting resumption of provisioning or import.
This state change to _invalid_ does not occur during `ace.export`.

////
This state change to _invalid_ does not occur during `ace.export`, but operations that could modify the internal state should not be performed on a CR with an interrupted export operation.
The following situation may occur:

. A process is exporting a threshold CC from a CR.
. The process is interrupted for context switching.
. The privileged code saves the context, exporting each multi-share field as a single share.
. Later, the privileged code re-imports the SCC into a CR.
. This means that the shares have been re-imported with a different randomization.
. When the export operation resumes, it will continue to export the values as single shares, i.e., with the same value.

This works because the actual value of the key is not changed.
However, if any value of the state (such as a counter, or a partial hash value) is altered between the interruption and resumption of an export operation, the resumed export may use an incorrect SIV for the remaining SCC data, causing a subsequent import to fail authentication. This is a general issue with CRs, since more privileged code can use them unless blocked by the _UsagePolicy_. We do not consider this a security threat: it affects only SCC availability, not confidentiality or integrity,
and privileged code can always deny resources to user processes.
////

//

[[ACE-Localities]]
===== Locality Field

ACE maintains a table of 128-bit Locality Secrets (LS), the Locality Secrets Table (LST). Some entries are fixed or configurable only via an implementation-specific authenticated hardware procedure; these are global and shared across all ACE units in the same SoC. Other entries are per-hart architectural state programmed by privileged modes. Eleven LST entries are currently architected: the first six constitute the _HW Binding Group_, binding SCCs to the hardware; entries 8–10 form the _SW Filter Group_.

<<ACE-locality-indexes>> lists the architected Localities. For each Locality we provide: index in the LST; domain (SoC-, device-, VM-wide, or per-process); configurability; bit-field encoding and value. Seven of the eight _Locality_ field bits are defined; bit 7 is reserved for future use or custom Localities [.red]#(Partitioning TBdef.)#.

[[ACE-locality-indexes]]
.Architected Localities
[width="100%",cols="^5%,18%,47%,^9%,^9%,^6%,^6%",options="header"]
|===
|  Idx  | Field                   | Description                                                                      | Domain | Config?|  Bits  | Value
2+|   _No HW Binding_             | Independent of Chip, OEM, Device                                                ^|  --   ^|   --   | [2:0]  |   0
|   0   | SiPSecret               | Identifies the designer of the SoC. Permanent.                                   |  SoC   |   No   | [2:0]  |   1
|   1   | ChipFamilySecret        | Identifies specific chip/SoC model/family. Permanent.                            |  SoC   |   No   | [2:0]  |   2
|   2   | ChipSecret              | Unique for each SoC. Permanent.                                                  |  SoC   |   No   | [2:0]  |   3
|   3   | OEMSecret               | Provisioned by OEM to differentiate their products from the competition.
Permanent, or reconfigurable via a custom hardware authenticated mechanism.                                          | Device |   HW   | [2:0]  |   4
|   4   | ProductSecret           | Identifies device/system type/model (product).
Permanent or reconfigurable like OEMSecret.                                                                          | Device |   HW   | [2:0]  |   5
|   5   | DeviceSecret            | Unique device (entire system) secret.
Shared across all harts in a SoC and shareable across multiple SoCs in a single device using an implementation-defined mechanism.
Reconfigurable like OEMSecret.                                                                                       | Device |   HW   | [2:0]  |   6
|   6   | PhysBootSecret          | Unique per the boot session of the host hardware and its firmware stack.
Configured by M-mode during the boot process of the host (see <<ACE-CSR-macePhysBootSecret>>).                       | Device |   M    |   3    |  0/1
|   7   | VirtBootSecret          | Unique per the boot session of the virtual hardware and its software stack.
Regenerated by H or higher at each virtual boot of a VM (see <<ACE-CSR-haceVirtBootSecret>>).                        |   VM   |  H/M   |   4    |  0/1
2+|   _No Binding at Modes_       | Independent of M-, S-, or VS-mode filters.                                      ^|  --   ^|   --   | [6:5]  |   0
|   8   | MLocality               | Configurable by M to mutually isolate processes in lower-privileged modes.       |  S/HS  |   M    | [6:5]  |   1
|   9   | HLocality               | Configurable by H to mutually isolate processes in lower-privileged modes.       |  VS    |   H    | [6:5]  |   2
|  10   | SLocality               | Configurable by (V)S to mutually isolate processes in U-mode.                    |  U     |  (V)S  | [6:5]  |   3
|===

Implementations are not required to populate every entry in the HW Binding Group, except for ChipSecret and DeviceSecret.
If an entry is unconfigured, it is transparently replaced by the next defined entry in its chain:
SiPSecret {rightarrow} ChipFamilySecret {rightarrow} ChipSecret, and OEMSecret {rightarrow} ProductSecret {rightarrow} DeviceSecret.

HLocality is active only when the H extension is enabled and V=1; otherwise, it mirrors MLocality.

NOTE: A system-key index may refer to keys with unrelated purposes on different devices, leading to unspecified behavior.
Implementations shall assign usage policies at least as restrictive as the key's own native policies, and supply an appropriate _Locality_ during CR provisioning.

Up to three Localities may be active concurrently:
one from the HW Binding Group, one of either PhysBootSecret or VirtBootSecret, and one from the SW Filter Group.
The enforcement of the policies by including them in the export and import operations is explained in <<ACE-provisioning-export-import>>.

//

[[ACE-UsagePolicy-field]]
===== UsagePolicy Field

Bit 0, 1, resp., 2 of this field is ignored if U-, S-, resp., H-mode is not supported or not enabled.

[[ACE-extra-content]]
===== AdditionalData Field

The first eight bytes of the additional data segment hold a copy of the `acemarchid` CSR (<<ACE-CSR-acemarchid>>) of the originating machine, and are counted within the length recorded by the _AdditionalData_ field. The importing implementation uses this value to determine whether the additional data can be used.

NOTE: Examples of additional data are: “decryption AES keys”, i.e., the last one or two AES round keys, from which one can work backwards when performing AES decryptions;
precomputed point multiples for elliptic curve scalar multiplication (their computation can be far more expensive than their encryption and decryption); and auxiliary data for side-channel-protected implementations, such as key shares or other data to accelerate share reconstruction.

[[ACE-Metadata-expiration-date]]
===== ExpirationDate Field

If non-zero, _ExpirationDate_ specifies the CC expiration time as a number of hours elapsed since the base date of January 1, 2027. The 18-bit field provides for a span of approximately 30 years (2^18^ hours). Future extended formats (with _Format_ = 1) may support expanded time spans.

// ////////////////////////////////////////////////////////////////////

[[ACE-CSR-unpriv]]
=== CSRs

ACE provides a number of unprivileged CSRs.
// The privileged CSRs are documented in <<ACE-priv>>.


[[ACE-CSRs-unpriv]]
.ACE Unprivileged CSRs.
[cols="^10%,^10%,<18%,<62%"]
[float="center",options="header"]
|===
|  Address | Privilege | Field            | Description
|  0xXXX   | URW       | `aceerror`       | Error code of the last ACE instruction
|  0xXXX   |  RO       | `acemarchid`     | ID of the microarchitecture of the ACE unit
| `vstart` | URW       | `acestart`       | ACE start byte index
|  0xXXX   | URW       | `aceiobuflen`    | ACE input/output buffer length
|  0xXXX   | URW       | `aceiobuftop`    | ACE input/output buffer limit for current transfers
|  0xXXX   | URW       | `acesequence`    | Sequence number of the last ACE instruction
|  0xXXX   | URW       | `aceactivecr`    | Active CR for `ace.input`/`ace.output`
|  0xXXX   | URW       | `acehtrapmask`   | [.red]#{warn} Discuss:# Mask to determine which ACE exceptions horizontally trap
|  0xXXX   | URW       | `acehtrapvector` | [.red]#{warn} Discuss:# Address of the horizontal ACE trap handler
|===

//


[[ACE-CSR-ace-error]]
==== `aceerror`

{empty}
(((CSR,`aceerror`)))
`aceerror` is an XLEN-bit CSR, of which only the least significant 4 bits are defined, and the top XLEN - 4 bits are WARZ.
It holds the error code from the most recent ACE instruction.
A read of this CSR may stall until the preceding ACE operation completes.
The CSR is writable to support context switching.

The phrase “_raises ACE error X_” means that `aceerror` is set to value _X_.
The same event may also trigger a vertical or horizontal trap; the handler may inspect `aceerror` to determine the error type.

[[ACE-error-codes]]
.Error codes and their meanings
[float="center",align="center",width="100%",cols="^7%,<23%,<70%",options="header"]
|===
|Value | Mnemonic                   | Examples (((ACE, error codes)))
|  0   | ace_err_no_error           | No error.
|  1   | ace_err_import_auth        | Authentication failure with `ace.import`.
|  2   | ace_err_unconf_CR          | Use of an unconfigured, or partially configured CR as a source in any instruction except `ace.size`.
Use of an out of range CR with indirect addressing.
|  3   | ace_err_unconf_buf         | Use of ACEIOBUF as an input or an output when it was unconfigured.
|  4   | ace_err_invalid_CR         | Attempted to use an _invalid_, but not expired, CR.
|  5   | ace_err_expired_CR         | Attempted to use an expired CR.
|  6   | ace_err_memory             | Insufficient CRF memory for configuration instruction.
|  7   | ace_err_unimpl             | Not implemented algorithm or variant.
State number not allowed in current algorithm in `ace.state`.
|  8   | ace_err_invalid_value      | Invalid value, except ace_err_unimpl (see below).
|  9   | ace_err_privilege          | Violation of Usage Control policies.
| 10   | ace_err_auth               | Authentication failure in an algorithm.
|===

////
ace_err_invalid_value covers, among others:

* Invalid Metadata in `ace.prov` or `ace.import` (other than `ace_err_unimpl`), such as, for instance: Nonzero bits in reserved fields; Unsupported _Locality_ value; and Nonzero _StateNumber_ in a PI.
* An ACE operation issued with an invalid or zero ACEIOBUF transfer length (`aceiobuftop` − `acestart`); see <<ACE-CSR-acestart>> and <<ACE-CSR-aceiobuftop>>.
* Invalid operand to `ace.restrict`.

Using an incomplete CC in `ace.size` is allowed.
////

We now list the errors in order of priority.

[[norm:ace_exc_priority]]
.ACE error priority in decreasing priority order.
[float="center",align="center",width="100%",cols="^9%,>7%,<84%",options="header"]
|===
.>|Priority   .>|Error +
Code        .>|Description
.>|_Highest_  | 4      .>| Attempt to use an invalid, but not expired, CR.
|           .>| 2      .>| Attempt to use an out of range, unconfigured or partially configured CR.
|           .>| 5      .>| Attempt to use an expired CR.
|           .>| 9      .>| Violation of Usage Control policies.
|           .>| 8      .>| Invalid value, except ace_err_unimpl or invalid state.
|           .>| 7      .>| Not implemented algorithm or variant. State number not allowed in current algorithm in `ace.state`.
|           .>| 5, 6   .>| Invalid Metadata section in `ace.prov` or `ace.import`, including specifying a not implemented algorithm or side-channel protected variant.
|           .>| 4      .>| Insufficient CRF memory.
|           .>| 3      .>| Use of ACEIOBUF as an input or an output when it was unconfigured.
|           .>| 2, 1   .>| Usage Control Failure or authentication failure with `ace.import`.
|           .>| 10     .>| Authentication failure in an algorithm.
.>|_Lowest_ .>| 0      .>| No error.
|===

//

[[ACE-CSR-acemarchid]]
==== `acemarchid`

{empty}
(((CSR, `acemarchid`)))
`acemarchid` identifies the microarchitectural version of the ACE unit, analogously to `marchid` for the hart.

//

[[ACE-CSR-acestart]]
==== `acestart`

{empty}
(((CSR, `acestart`)))
`acestart` is an alias for `vstart`.
ACE defines it also when the V extension is not enabled.

// The XLEN-bit RW CSR
`acestart` tracks the progress of interruptible ACE instructions, namely `ace.prov`, `ace.import`, `ace.export`, `ace.input`, and `ace.output`.
It also applies to `ace.exec` when iteratively processing a multi-block operand, as `ace.exec` may be interrupted between blocks.
Only these instructions honor a nonzero `acestart`; all other instructions ignore it and are restarted, with `acestart` also being cleared.
Provisioning, import, and export are resumed only under certain conditions, as explained in <<ACE-provisioning-export-import>>.

Since ACE does not have an _intrinsic_ concept of element length, `acestart` counts the number of bytes processed so far, not the number of elements.
Hardware typically writes this register on interruption.
Software may write zero to force a full restart and may save and restore the register across context switches.
Writing an invalid or non-supported nonzero value may raise ACE exception ace_err_invalid_value.

When a vector instruction is interrupted, the CSR follows `vstart` semantics, i.e., it counts the number of processed elements.
When an ACE instruction is interrupted, the CSR follows `acestart` semantics, namely, it counts the number of bytes processed so far.

////
[NOTE]
====
_A single `acestart` value suffices due to the way the init/import/export instructions operate:_

* `_ace.prov_` _and_ `_ace.import_` _use a single pass: all blocks are processed sequentially._
* `_ace.export_` _uses two passes. However, the first pass to compute the SIV is purely internal, and never accesses memory, so page faults cannot occur.
This first pass is uninterruptible.
The second pass writes Metadata, the SIV, and then the Content to memory.
Only the second pass can cause page faults and may require resumption._

This design obviates the need to separate data transfer from cryptographic processing during import and export operations. A separate transfer phase would require buffering the entire input within the ACE unit before processing, increasing internal resource requirements, whereas the current architecture can process data inline and load it with minimal overhead.
====
////

//

[[ACE-CSR-aceiobuflen]]
==== `aceiobuflen`

{empty}
(((CSR, `aceiobuflen`)))
`aceiobuflen` is an XLEN-bit RW CSR that programs the ACEIOBUF length for use by `ace.input` and `ace.output`.
Writing this register-even when re-writing the old value-also zeroes the buffer and sets `aceiobuftop` to the same length and `acestart` to zero.

When `aceiobuflen` is zero, the ACEIOBUF is _unconfigured_ (analogous to an unconfigured CR in state Initial); `ace.input` and `ace.output` raise `ace_err_unconf_buf`.

Writing a value larger than the implementation maximum raises `ace_err_memory`.

To discover the maximum buffer size supported by an implementation, or by the current residual capacity of the internal memory of the ACE unit, write all-ones to `aceiobuflen`: `ace_err_memory` is raised, but a subsequent read of `aceiobuflen` returns the actual maximum length; the buffer is simultaneously configured to that length, `aceiobuftop` is set accordingly, and `acestart` is set to zero.

//

[[ACE-CSR-aceiobuftop]]
==== `aceiobuftop`

{empty}
(((CSR, `aceiobuftop`)))
`aceiobuftop` is an XLEN-bit RW CSR that marks the upper bound of the buffer range used by `ace.input` and `ace.output`. Together with `acestart`, it defines the active transfer window.

The constraints `acestart` {le} `aceiobuftop` {le} `aceiobuflen` must hold; violating either bound raises ace_err_invalid_value. Modifying `aceiobuftop` does not alter or invalidate buffer contents.

Using ACEIOBUF when `aceiobuftop` − `acestart` is zero (with `aceiobuflen` nonzero) or an invalid transfer size raises ACE error ace_err_invalid_value.

NOTE: `aceiobuftop` allows per-operation length adjustment without reconfiguring ACEIOBUF. For example, when processing a residual block shorter than the nominal block size, or when supplying a short IV or nonce, software adjusts only `aceiobuftop` rather than resizing the buffer—avoiding the zeroing and potential resizing overhead that a write to `aceiobuflen` would entail.

NOTE: The dirtiness of ACEIOBUF is not tracked.
We recommend software to set `aceiobuftop` to zero once the contents of the ACEIOBUF are no longer needed.
Context switching code can use this information to avoid unnecessary save and restore of ACEIOBUF contents.

//

[[ACE-CSR-acesequence]]
==== `acesequence`

{empty}
(((CSR, `acesequence`)))
`acesequence` is an XLEN-bit URW CSR; only the low 2 bits are defined. It is zero when vector registers are used for the current ACE instruction, and takes nonzero values when `ace.input`/`ace.output` are used in place of vector registers, as described in <<ACE-usage-input-output>>.

//

[[ACE-CSR-aceactivecr]]
==== `aceactivecr`

{empty}
(((CSR, `aceactivecr`)))
`aceactivecr` is an XLEN-bit URW CSR; only the low 5 bits are defined. It binds `ace.input`, `ace.output`, `ace.exec`, and `ace.state` to a specific CR. Valid values are 0–31 (selecting a CR) or 32 (disabled).

`aceactivecr` may only be modified when `acesequence` is zero or an illegal instruction exception is raised.

When `aceactivecr` is not 32, the CR operand in all single-CR instructions and the source CR in `ace.clone` must equal the selected value; any deviation raises an illegal instruction exception, ensuring correct instruction sequencing.

//

[[ACE-CSR-acehtrapmask]]
==== `acehtrapmask`

{empty}
(((CSR, `acehtrapmask`)))
Mask that determines which ACE exceptions horizontally trap.
Bit __i__ of this CSR is set if ACE error __i__+1 may cause a horizontal trap.

[[ACE-CSR-acehtrapvector]]
==== `acehtrapvector`

{empty}
(((CSR, `acehtrapvector`)))
Address of the horizontal ACE trap handler.
If this pointer is NULL, then, horizontal traps on ACE exceptions are disabled.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-instructions-detailed]]
=== Instructions

[WARNING]
The encodings presented here are preliminary. The usage of `custom-0` for load-type, `custom-1` for store-type, and `custom-2` for operational instructions aligns with the base ISA and FP instruction-set conventions.

ACE provides a set of unprivileged instructions, some of which are implemented as CSR read/write operations. This section specifies their semantics and encodings.

The notation `K(Xd)` denotes the CR whose index is held in GPR `Xd`. `Kn|K(Xn)` indicates two alternative encodings: a 5-bit immediate CR index (`Kn`) or a CR number supplied by GPR `Xn`. Use of the zero register `X0` as a CR index register raises an illegal instruction exception unless explicitly indicated otherwise.

Each instruction is characterized by the following properties:

* _Modifies state_: whether the instruction may modify ACE architectural state;
* _Usage-controlled_: whether the instruction is subject to usage control policies (_UsagePolicy_);
* _Trappable_: whether the instruction may be implemented by privileged code via trap-and-emulate; and
* _Interruptible_: whether execution may be interrupted (e.g., by a context switch or page fault) and later resumed or restarted.

NOTE: Trappability refers solely to the CPU-side implementation—for example, to enable decomposition of certain ACE instructions into smaller custom operations. This is distinct from custom algorithm implementations within the ACE unit itself (e.g., via a secure embedded CPU with updatable firmware), which are outside the scope of this specification.

//

[[ACE-instruction-init]]
==== ace.prov

_Synopsis_::
Provision Metadata and secrets into a CR.

_Mnemonic_::
`ace.prov Kd|K(Xd), %offset(Xs)`
(((ACE, instruction, ace.prov)))

_Encoding_::
`ace.prov` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'context', attr: ['Kd','K(Xd)'] },
    { bits:  3, name: 'ace.prov', attr: [0x4,0x5] },
    { bits:  5, name: 'Xs' },
    { bits: 12, name: 'immed12', attr: ['offset'] },
]}
....

_Description_::
`ace.prov` provisions a CR with Metadata and Content to create a CC.
`Kd` or `K(Xd)` denotes the CR to be provisioned.
`Xs` points to the region of memory containing the Metadata and the key material.
The PI must be stored at an 8-byte aligned address, and its length must be a multiple of 8 bytes.
+
All previous contents of the target CR are destroyed, even if the instruction fails.
+
ACE error ace_err_unimpl is raised if the combination of Algorithm, AlgorithmPolicy, and SCProtection is not supported.
+
ACE error ace_err_invalid_value is raised if the Metadata is invalid (other than `ace_err_unimpl`), such as, for instance:
nonzero bits in reserved fields; unsupported _Locality_ value; or a nonzero _StateNumber_ in a PI.
+
Similarly to vector store instructions, `ace.prov` appears to other harts as a sequence of individual reads.
+
The operation is described in detail in <<ACE-provisioning-export-import>>.

_Properties_::
Possibly modifies state: *YES*. +
Usage-controlled: *NO*. +
Trappable: *YES*. +
Interruptible: *YES*. +

NOTE: `ace.prov`, like `ace.import`, `ace.export`, `ace.input`, and `ace.output`, which are described later, can be viewed as special kinds of load and store instructions, and therefore they do not violate the load/store architecture principle.

//

[[ACE-instruction-clear]]
==== ace.clear/ace.reset

_Synopsis_::
Clears and unconfigures a CR, or the ACE state.

_Mnemonic_::
`ace.clear Kd|K(Xd)` +
(((ACE, instruction, ace.clear)))
`ace.reset`
(((ACE, instruction, ace.reset)))

_Encoding_::
`ace.clear`/`ace.reset` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'context', attr: ['Ks','K(Xd)'] },
    { bits:  3, name: 'ace.clear', attr: [0x4,0x5] },
    { bits:  5, name: 0x0 },
    { bits:  5, name: 0x0 },
    { bits:  7, name: 0x0 },
]}
....

_Description_::
`ace.clear` unconfigures the state of the CR `Kd` or `K(Xd)` and releases its resources in the CRF.
+
`ace.reset` unconfigures all the CRs and the ACEIOBUF.
It uses the encoding for `ace.clear` with indirect CR addressing and `Xd` = `X0`.

_Properties_::
Possibly modifies state: `ace.clear` only makes any status flag (global of per-CR) Dirty if the CR was configured before.
Usage-controlled: *NO*. +
Trappable: +
``{fournbsp}ace.clear``: *NO*; +
``{fournbsp}ace.reset``: *YES* (it can be implemented as multiple `ace.clear` and a write to `aceiobuflen`). +
Interruptible: *NO*. +

//

[[ACE-instruction-export]]
==== ace.export

_Synopsis_::
Export a CR as a SCC in memory.

_Mnemonic_::
`ace.export %offset(Xd), Ks|K(Xs)`
(((ACE, instruction, ace.export)))

_Encoding_::
`ace.export` is an S-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'immed[4:0]' },
    { bits:  3, name: 'ace.export', attr: [0x0,0x1] },
    { bits:  5, name: 'Xd' },
    { bits:  5, name: 'context', attr: ['Ks','K(Xs)'] },
    { bits:  7, name: 'immed[11:5]' },
]}
....

_Description_::
Exports the CR `Ks` or `K(Xs)` to memory at address `Xd`, using the procedure described in <<ACE-provisioning-export-import>>.
The SCC must be stored at an 8-byte aligned address, and its length must be a multiple of 8 bytes.
+
The instruction must follow the interruptibility rules defined in <<ACE-CSR-acestart>> and <<ACE-provisioning-export-import>>.
+
`ace.export` appears to other harts as a sequence of individual stores.
+
The operation is described in detail in <<ACE-provisioning-export-import>>.

_Properties_::
Possibly modifies state: *NO*. +
Usage-controlled: *NO*. +
Trappable: *YES*. +
Interruptible: *YES*. +

//

[[ACE-instruction-import]]
==== ace.import/ace.import.S

_Synopsis_::
Import a SCC from memory into a CR.

_Mnemonics_::
`ace.import{nbsp}{nbsp}{nbsp}Kd|K(Xd), %offset(Xn)` +
`ace.import.S{nbsp}Kd|K(Xd), %offset(Xn)`
(((ACE, instruction, ace.import)))
(((ACE, instruction, ace.import.S)))

_Encoding_::
`ace.import` is an I- (or R-) type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'context', attr: ['Kd','K(Xd)'] },
    { bits:  3, name: 'ace.import', attr: ['0    0    S','0    1    S'] },
    { bits:  5, name: 'Xn' },
    { bits: 12, name: 'immed12' },
]}
....

_Description_::
`Kd` or `K(Xd)` denotes the CR into which the SCC is to be imported.
`Xn` is the GPR containing the base address of the buffer with the source SCC.
The SCC base address must be 8-byte aligned.
+
All previous contents of the target CR are destroyed, even if the instruction fails.
+
ACE error ace_err_unimpl is raised if the combination of Algorithm, AlgorithmPolicy, and SCProtection is not supported.
+
ACE error ace_err_invalid_value is raised if the Metadata is invalid (other than `ace_err_unimpl`), such as, for instance:
nonzero bits in reserved fields; or unsupported _Locality_ value..
+
The bit S takes the values 0 (false) or 1 (true).
It is set to true if the key is in a system-defined format
(`ace.import.S`)
and not the format defined by the present architecture
(`ace.import`).
+
`ace.import` must follow the interruptibility rules defined in <<ACE-CSR-acestart>> and <<ACE-provisioning-export-import>>.
It appears to other harts as a sequence of individual loads.
+
The operation of `ace.import` is described in detail in <<ACE-provisioning-export-import>>.
+
The behavior of `ace.import.S` is implementation-defined.
If there are no system-defined formats, `ace.import.S` raises an illegal instruction exception.

NOTE: The instruction encoding includes a single bit to indicate a system-defined format.
If multiple system-defined formats are supported, the system is responsible for distinguishing them.
These formats do not necessarily include the key value itself, they may contain a “recipe” for an implementation-defined mechanism to generate the key.
Such system generated keys are also system-specific. In place of the PI, the provisioning operation reads a system-specific “recipe”, which is not portable.  After internal key generation, the actual key value—not the recipe—is stored in the CR and SCC.
For all keys provisioned using `ace.import.S`, the _KeyType_ field in the Metadata is 0, denoting a key represented by its value.

NOTE: The `ace.export` instruction does not have an `ace.export.S` analog to `ace.import.S`.
This means that system-specific dynamically generated keys can be imported but not exported in the same form: they must be exported in the format architected here for ACE CCs.

_Properties_::
Possibly modifies state: *YES*. +
Usage-controlled: *NO* +
Trappable: *YES*. +
Interruptible: *YES*. +

//

[[ACE-instruction-exec]]
==== ace.exec

_Synopsis_::
Perform a cryptographic operation in the ACE unit.

_Mnemonic_::
The `ace.exec` instruction admits four Forms, namely
(((ACE, instruction, ace.exec)))

[upperalpha]
. `ace.exec  Vd, Kn|K(Xn), Vs` {nbsp}{nbsp} takes an input vector and writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}{nbsp}Kn|K(Xn), Vs` {nbsp}{nbsp} takes an input vector but does not write to an output vector.
. `ace.exec  Vd, Kn|K(Xn){nbsp}{nbsp}{nbsp}{nbsp}` {nbsp}{nbsp} does not take an input but writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}{nbsp}Kn|K(Xn){nbsp}{nbsp}{nbsp}{nbsp}` {nbsp}{nbsp} does not take an input vector and does not write to an output vector.

// Without this comment, the next part is not properly formatted...

_Encoding_::
`ace.exec` is an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'rd', attr: ['Vd','—','Vd','—'] },
    { bits:  3, name: 0x0, attr: ['ace.exec'] },
    { bits:  5, name: 'rs1', attr: ['Kn|K(Xn)'] },
    { bits:  5, name: 'rs2', attr: ['Vs','Vs','—','—'] },
    { bits:  1, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  1, name: 0x0 },
    { bits:  2, name: 'Form', attr: ['0    0','0    1','1    0','1    1'] },
    { bits:  2, name: 0x0 },
]}
....
+
Bit `r` (i.e., bit 26) takes the value 0 if the context is encoded as an immediate, and it takes the value 1 if a
GPR (scalar integer value) is used to reference it.
+
For the four Forms A–D above, the encodings are:
+
[upperalpha]
. `Form` = `0b00`.
. `Form` = `0b01` and `rd` = `0b00000`.
. `Form` = `0b10` and `rs2` = `0b00000`.
. `Form` = `0b11` and `rs2` = `rd` = `0b00000`.

// To make indent in next line correct

_Description_::
Performs a cryptographic operation such as an encryption or decryption, absorbing a value in a hash,
an elliptic curve point addition or scalar multiplication, etc., and possibly returning a value.
+
If the V extension register file is not implemented, only Form D is supported
(the derived Forms used to define other instructions are still supported) and `ace.input`, `ace.output` must be used to
provide inputs and extract outputs from `ace.exec`.
<<ACE-usage-input-output>> describes how this is done.

_Properties_::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *NO*. +
Interruptible: See interruptibility rules in <<ACE-generic-rules>>. +

//

[[ACE-instruction-state]]
==== ace.state

_Synopsis_::
Change the state of the algorithm encoded in the CC in a CR.

_Mnemonic_::
The `ace.state` instruction admits three Forms, namely
(((ACE, instruction, ace.state)))

[upperalpha]
. `ace.state Kd|K(Xd), #immed7{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}` with no auxiliary input.
. `ace.state Kd|K(Xd), #immed7, Xs{nbsp}{nbsp}` with an auxiliary input in a GPR.
. `ace.state Kd|K(Xd), #immed7, Vs{nbsp}{nbsp}` with an auxiliary input in a vector register.

//

_Encoding_::
`ace.state` is an R-type instruction.
+
[wavedrom, ,svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Kd|K(Xd)' },
    { bits:  3, name: 'ace.state', attr: ['0    0    1','0    1    0','0    1    1'] },
    { bits:  5, name: 0x0 },
    { bits:  5, name: 'rs1', attr: ['—','Xs','Vs'] },
    { bits:  7, name: 'immed7' },
]}
....
+
The encodings for the three Forms are:
[upperalpha]
. `ace.state` = `0b001`.
. `ace.state` = `0b010`.
. `ace.state` = `0b011`.

//

_Description_::
The instruction is used to control the state machine of the cryptographic algorithm in CR `Kd` or `K(Xd)`.
The `#immed` operand is a constant from a set of admissible values defined for each algorithm.
The new state number, if allowed, is written into the _StateNumber_ field of the Metadata, unless the algorithm requires more than 16 states, in which case an ad hoc field must be defined in the context (for both internal representation and SCCs).
Optionally, `Xs` or `Vs` contains an auxiliary input.

_Properties_::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *NO*. +
Interruptible: *NO*. +

The state numbers used in this specification are defined in <<ACE-state-constants-fixed>> and <<ACE-state-constants-symmetric>>.

It is allowed to repeat `ace.state` instructions to the current state.
When the algorithm needs to prevent this, it will automatically transition to a different state after completing `ace.state`.

//

[[ACE-instruction-error]]
==== ace.error

_Synopsis_::
Return an error code from the ACE unit.

_Mnemonic_::
`ace.error Xd`
(((ACE, instruction, ace.error)))

_Encoding_::
The operations is a CSR read operation.

_Description_::
The ACE Unit may be in an error state due to the previous operation.
`ace.error` is implemented as a read from CSR `aceerror`, which may cause the hart to wait if the error code is not yet available (<<ACE-CSR-ace-error>>).
The error code is written into GPR `Xd`.
The architected error codes are given in <<ACE-error-codes>>.

_Properties_::
Possibly modifies state: *NO*. +
Usage-controlled: *NO*. +
Trappable: *NO*. +
Interruptible: *NO*. +

//

[[ACE-instruction-size]]
==== ace.size

_Synopsis_::
Return the size of a CC.

_Mnemonics_::
There are four Forms of the `ace.size` instruction:
(((ACE, instruction, ace.size)))

[upperalpha]
. `ace.size Xd, Ks|K(Xs)` - Size from a context.
. `ace.size Xd, Xs` - Size from Metadata Header.
. `ace.size.internal Xd, Xs` - Internal capacity estimate for a CR.
. `ace.size.iobuf Xd, Xs` - Internal capacity estimate for the ACEIOBUF.

// Without this comment, the next part is not properly formatted...

_Encoding_::
The encoding shares `func3` with `ace.exec`, however with bit 25 (the lsb of `func7`) equal to 1 and the two msbs of `func7` equal to 0.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x0, attr: ['ace.exec'] },
    { bits:  5, name: 'Ks/K(Xs)/Xs' },
    { bits:  5, name: 0x0 },
    { bits:  1, name: 0x1 },
    { bits:  1, name: 'r' },
    { bits:  1, name: 0x0 },
    { bits:  2, name: 'F' },
    { bits:  2, name: 0x0, attr: ['func2'] },
]}
....
+
The `F` field and the `r` bit may assume the following values:

* `F` = `0b00`, `r` = `0` {implies} Form A: Size from a context given as `Ks`.
* `F` = `0b00`, `r` = `1` {implies} Form A: Size from a context given indirectly as `K(Xs)`.
* `F` = `0b01`, `r` = `0` {implies} Form B: Size from Metadata Header.
* `F` = `0b10`, `r` = `0` {implies} Form C: Internal capacity of a CR.
* `F` = `0b11`, `r` = `0` {implies} Form D: Internal capacity of the ACEIOBUF.

_Description_:: {empty}

* Form A `ace.size` returns the total size (in bytes) of the memory buffer that would be necessary to store the exported SCC.
Knowing this size is necessary for any feature that relies on `ace.export`, including context switching.
The instruction returns 0 if the CR is unconfigured.

* Form B `ace.size` returns the total size (in bytes) of an SCC having the Metadata section given in `Xn` into GPR `Xd`, and 0 if the algorithm is not supported.
+
On RV32, `Xs` contains bits [31:0] of the Metadata.  This suffices since they contain all fields required to determine the size of the SCC.

* Form C `ace.size` returns the amount of internal CRF capacity used by a CR with Metadata section matching `Xn` on the _Algorithm_, _SCProtection_, and _KeyType_ Metadata fields. In this case, all other bits must be zero.
If the combination of _Algorithm_, _SCProtection_, and _KeyType_ fields is not supported, `ace.size` returns 0.
If, instead, only the _StateNumber_ is non-zero and its value is 15, resp., 14, `ace.size` returns the total, resp., the remaining internal capacity of the CRF. +
All the values returned by the instruction are expressed in terms of implementation-dependent units, and in principle cannot be compared across different implementations.
+
On RV32, `Xs` contains bits [31:0] of the Metadata (as for the Metadata type instruction).

* Form D: The source register contains the desired byte length of the buffer to be allocated, and the destination register contains the size of the buffer in the ACE unit.

NOTE: In general. no correlation may be assumed between the size of a PI, the corresponding CR's usage of internal resources, and the size of the SCC.
// The size of the SCC can differ significantly from the internal resource usage to store the CC's data in a CR.
// On one hand, there is an overhead due to the SIV.
// On the other hand, in case of threshold implementations, where keys are exported in reconstructed form, or in modes where some derived keys are not exported, the SCC may be smaller than the internal resource usage.

_Properties_::
Possibly modifies state: *NO*. +
Usage-controlled: *NO*. +
Trappable: *NO*. +
Interruptible: *NO*. +

//

[[ACE-instruction-available]]
==== ace.avail

_Synopsis_::
Verify whether an algorithm is supported.

_Mnemonic_::
`ace.avail Xd, Xs`
(((ACE, instruction, ace.avail)))

_Encoding_::
`ace.avail` is an alias to Form B of `ace.size`, as the latter returns 0 if the algorithm is not supported.

_Properties_::
Same as `ace.size`.

//

[[ACE-instruction-restrict]]
==== ace.restrict

_Synopsis_::
Restrict the policies encoded in a CC in a CR.

_Mnemonic_::
`ace.restrict{nbsp}{nbsp}Kd|K(Xd), Xs1`
// `ace.restrict{nbsp}{nbsp}Kd|K(Xd), Xs1, Xs2`
(((ACE, instruction, ace.restrict)))

// Without this comment, the next part is not properly formatted...
_Encoding_::
The encoding shares `func3` with `ace.exec`, however with bit 25 equal to 1 and `func2` equal to 1.
It is thus an R-type instruction.
The source register field encodes a GPR and not a vector register.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Kd|K(Xd)' },
    { bits:  3, name: 0x0, attr: ['ace.exec'] },
    { bits:  5, name: 0x0 },
    { bits:  5, name: 'Xs1' },
    { bits:  1, name: 0x1 },
    { bits:  1, name: 'r' },
    { bits:  3, name: 0x0 },
    { bits:  2, name: 0x1, attr: ['func2'] },
]}
....
+
Bit r (i.e., bit 26) takes the value 0 if the context is encoded as an immediate in Bits [11:7], and it takes the value 1 if a
GPR (also encoded in [11:7]) is used to reference it.

// comment

_Description_::
+
--
This instruction can be used to:

* Activate the side-channel protection of the CC or increase it;
* Restrict the use of encryption or decryption in a CC that allows both;
* Restrict the usage of a CC (as stored in a CR) to specific modes or to a specified Filter; and
* Add a Locality.

Let `M` be the Metadata field of the CC in the destination CR.

On RV64, the semantics of the instruction are:

* `Xs` inherits its format from the first 64-bit block of the Metadata section.
Only the fields _AlgorithmPolicy_, _SCProtection_, _Locality_, _UsagePolicy_, and _ExpirationDate_ may be defined.
All other fields must be 0, else ACE error ace_err_invalid_value is raised.

* `Xs`._AlgorithmPolicy_ is used to set the new _AlgorithmPolicy_ of the CR.
No operation may be enabled, any attempt to do so raises ACE error ace_err_invalid_value.
In some cases, a zero value is not permitted, such as disabling both encryption and decryption.

* `Xs`._SCProtection_ is used to turn on side-channel protection or raise its level, if such protection is implemented.
Attempting to remove or downgrade side channel protection, or to set a non-implemented level raises ACE error ace_err_invalid_value.

* If `Xs`._Locality_ is non-zero, then it can be used to restrict the Locality. Then, when the CR is exported as a CR, it will use the new tweak in the AEAD mode. Generalizing the Locality is not permitted. Attempting to do so raises ACE error ace_err_invalid_value.

* A zero in any of the three bits `Xs`._UsagePolicy_ means that the corresponding policy is _not_ changed.

* A one in any of the three bits `Xs`._UsagePolicy_ means that usage by the corresponding mode is not allowed, and the corresponding bit in the Metadata of the destination CC is set to 1.

* If `Xs`._ExpirationDate_ is zero, the corresponding policy in `M`._ExpirationDate_ is _not_ changed.

* A non-zero value in `Xs`._ExpirationDate_ will be copied to `M`._ExpirationDate_, but only if that policy was not already programmed, otherwise error ACE error ace_err_invalid_value is raised.
--
+
On RV32:

* `s` must be even, the register pair `X[s]` and `X[s+1]` are read, and `(X[s+1] @ X[s])` replaces `Xs` in the RV64 description.

_Properties_::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *NO*. +
Interruptible: *NO*. +

//

[NOTE]
====
This instruction enables several practical use cases:

*   Enabling side-channel protection when supported by the microarchitecture, even if the original CC was not configured with it.
*   Allowing privileged code to give a CC to several processes in a fine-grained manner.
This can be achieved by cloning the CR and customizing the Filter for each clone to an authorized process, or by exporting it with a per-process _SSecret_ Locality.
*   Similarly, enabling privileged code to split a CC capable of both encryption and decryption into two CCs, one only capable of encryption and the other only capable of decryption, thereby creating a one-way channel between processes.

The ability to perform such customizations saves both time and computational resources by avoiding additional round-trips to trusted environments.
====

//

[[ACE-instruction-clone]]
==== ace.clone

_Synopsis_::
Copy a CR into another CR.

_Mnemonic_::
`ace.clone Kd|K(Xd), Ks|K(Xs)`
(((ACE, instruction, ace.clone)))

_Encoding_::
The encoding shares `func3` with `ace.exec`, however with bit 25 equal to 1 and `func2` equal to 2.
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Kd|K(Xd)' },
    { bits:  3, name: 0x0, attr: ['ace.exec'] },
    { bits:  5, name: 'Ks|K(Xs)' },
    { bits:  5, name: 0x0 },
    { bits:  1, name: 0x1 },
    { bits:  2, name: 'R' },
    { bits:  2, name: 0x0 },
    { bits:  2, name: 0x2, attr: ['func2'] },
]}
....
+
Bits [27:26], i.e., field `R`, take the following values depending on how the CRs are given:
+
[upperalpha]
. `00`{nbsp}{nbsp} if the source and the output CRs are both encoded as immediate values.
. `01`{nbsp}{nbsp} if the source CR is encoded as immediate and the output CR is selected using a GPR.
. `10`{nbsp}{nbsp} if the source CR is selected using a GPR and the output CR is encoded as an immediate value.
. `11`{nbsp}{nbsp} if the source and the output CRs are both selected using the values of GPRs.

// Comment to ensure proper indentation in the next Description

_Properties_::
Possibly modifies state: *YES*. +
Usage-controlled: *NO*. +
Trappable: *YES*, it can be implemented as an export followed by an import in a handler. +
Interruptible: *NO*. +

_Description_::
Clones source CR `Ks` (or the CR indexed by `Xs`) into destination CR `Kd` (or the CR indexed by `Xd`).

//

////

[[ACE-instruction-derive]]
==== ace.derive

_Synopsis_::
Derive a CR from a source CR, such as a key derivation.

_Mnemonic_::
The `ace.derive` instruction admits three Forms, namely
(((ACE, instruction, ace.derive)))
[upperalpha]
. `ace.derive Kd|K(Xd), Ks1|K(Xs1) {fournbsp}{nbsp}{nbsp}{nbsp}` with no auxiliary input.
. `ace.derive Kd|K(Xd), Ks1|K(Xs1), Xs2{nbsp}{nbsp}` with an auxiliary input in a GPR.
. `ace.derive Kd|K(Xd), Ks1|K(Xs1), Vs2{nbsp}{nbsp}` with an auxiliary input in a vector register.

//

_Encoding_::
The encoding shares `func3` with `ace.exec`, however with bit 25 equal to 1 and `func2` equal to 3.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x6b, attr: ['custom-2'] },
    { bits:  5, name: 'Kd|K(Xd)' },
    { bits:  3, name: 0x0, attr: ['ace.exec'] },
    { bits:  5, name: 'Ks1|K(Xs1)' },
    { bits:  5, name: 'rs2'},
    { bits:  1, name: 0x1 },
    { bits:  2, name: 'R' },
    { bits:  1, name: 'v' },
    { bits:  1, name: 'g' },
    { bits:  2, name: 0x3, attr: ['func2'] },
]}
....
+
This encoding differs from Form A `ace.exec` by having bit 25 set to 1.
Bits [27:26], i.e., field `R`, is encoded exactly as for `ace.clone` (<<ACE-instruction-clone>>).
Bit 28 determines whether a vector register (or register group) is used to pass an auxiliary parameter to the key derivation mechanism or not.
Bit `v` (i.e., bit 28) is 0 for Forms A and B and 1 for Form C. +
Bit `g` (i.e., bit 29) is used to distinguish Form A, with `g` = 0, from Form B, with `g` = 1. +
The value (`g`,`v`) = (1,1) is currently an illegal instruction and reserved for future use.

_Description_::
Derive a new context from an existing one, with its own opaque key material, for instance using a key derivation mechanism.
The behavior of the instruction is not expected to be deterministic.
It can be used multiple times, to generate multiple derived contexts.

_Properties_::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *NO*. +
Interruptible: *NO*. +

////

//

[[ACE-instruction-input]]
==== ace.input

_Synopsis_::
Load data into the ACEIOBUF.

_Mnemonic_::
`ace.input %offset(Xs), Xl`
(((ACE, instruction, ace.input)))

_Encoding_::
`ace.input` is an S-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'immed[4:0]' },
    { bits:  3, name: 0x4, attr: ['ace.input'] },
    { bits:  5, name: 'Xl' },
    { bits:  5, name: 'Xs' },
    { bits:  7, name: 'immed[11:5]' },
]}
....

_Description_::
In all cases where the vector registers are not sufficiently long, or not implemented, inputs can be read directly from memory and written directly to memory.
For this reason, the architecture defines `ace.input` and `ace.output` (cf. next section).
`ace.input` reads `Xl` bytes from memory starting at address `%offset(Xs)` and copies them to the input buffer, starting at offset `acestart`.
+
If `Xl` == 0, the operation is a NOP.
+
`Xl` may not be greater than `aceiobuftop` - `acestart`.
+
If `Xl` is greater than `aceiobuftop` - `acestart`, ACE error ace_err_invalid_value is raised.
+
The intended usage of `ace.input` and `ace.output` is explained in detail in <<ACE-usage-input-output>>.

`ace.output` (see below) and `ace.input` can be used to save and restore the contents of the ACEIOBUF freely as long as ``aceactivecr``'s value is 32, for instance by
context switching code. Also, these operations start at the offset specified in `acestart`, so the state of the buffer can easily be saved and restored with the same approach used for vectors.

_Properties_::
Possibly modifies state: *YES*. +
Usage-controlled: *YES* +
Trappable: *YES*. +
Interruptible: *YES*. +

//

[[ACE-instruction-output]]
==== ace.output

_Synopsis_::
Save the contents of the ACEIOBUF to memory.

_Mnemonic_::
`ace.output %offset(Xd), Xl`
(((ACE, instruction, ace.output)))

_Encoding_::
`ace.output` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-0'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x4, attr: ['ace.output'] },
    { bits:  5, name: 'Xl' },
    { bits: 12, name: 'immed' },
]}
....

_Description_::
This is the output operation corresponding to `ace.input`.
`ace.output` writes the contents of the input buffer, starting at offset `acestart`, to memory starting at address `%offset(Xs)`.
+
If `Xl` == 0, the operation is a NOP.
+
`Xl` may not be greater than `aceiobuftop` - `acestart`.
+
If `Xl` is greater than `aceiobuftop` - `acestart`, ACE error ace_err_invalid_value is raised.

_Properties_::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *YES*. +
Interruptible: *YES*. +

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-provisioning-export-import]]
=== Provisioning, Export and Import of Cryptographic Contexts

The length of a PI must be a multiple of 8 bytes.
The first 8 bytes contain the Metadata Header, as defined in <<ACE-Metadata>>.
The subsequent data contain the *Content*, key material and any algorithm-specific data used to initialize the CR.
The Content's format is entirely determined by the _Algorithm_ and _KeyType_ fields within the Metadata, and is specified in <<ACE-algorithms>> for each architected algorithm.

Format of Provisioning Input:::
`bytes{nbsp}[{nbsp}{nbsp}0 .. {nbsp}7{nbsp}]{nbsp}{nbsp}` Metadata Header. +
`bytes{nbsp}[{nbsp}{nbsp}8 .. {nbsp}{nbsp}{nbsp}]{nbsp}{nbsp}` PI Content: Keys and other secrets. +

{empty}
(((Cryptographic Context, Sealed)))
The SCC format is used when exporting a CC from a CR and also to re-import the CC into a CR.
Its size must be a multiple of 8 bytes.
The first 8 bytes contain the Metadata Header, as defined in <<ACE-Metadata>>.
The format and length of the exported Content are algorithm-specific (<<ACE-algorithms>>) and, excluding the Additional Data of length `mh`._AdditionalData_,
are determined solely by the _Algorithm_, _KeyType_, and _AlgorithmPolicy_ fields in the Metadata.

Format of Sealed Cryptographic Context:::
`bytes{nbsp}[{nbsp}{nbsp}0 .. {nbsp}7{nbsp}]{nbsp}{nbsp}` Metadata Header, not encrypted. +
`bytes{nbsp}[{nbsp}{nbsp}8 .. 23{nbsp}]{nbsp}{nbsp}` SIV produced by the encryption method (128 bits). +
`bytes{nbsp}[{nbsp}24 .. {fournbsp}]{nbsp}{nbsp}` Encrypted Serialized Content of the CR. +

The entire Metadata and Content are authenticated, but only the Content is encrypted.
The AEAD method used for this purpose is described in <<ACE-SCC-AEAD>>.

The Serialized Content section under Data Structures in an algorithm specification (<<ACE-algorithms>>) defines the structure of the `content[]` array.
Architecturally, `content[]` is the serialization of the content of a CR for export as an SCC.

[NOTE]
--
While `content[]` provides a view of (certain fields of) the content of a CR that matches the serialized SCC format, it need not be converted to and from the internal representation and explicitly stored in the ACE unit's memory before export and after import.

`content[]` is a virtual representation: its byte ordering does not imply physical contiguity within the CR, nor is there a direct byte-for-byte correspondence. Changes to `content[]` are reflected in the underlying CR representation (except for excluded fields), and vice versa.

In a threshold implementation, a single key byte in `content[]` may correspond to multiple bytes across the key shares within the CR. Reading that byte may return the XOR of the corresponding bytes in the shares; writing to it may distribute the value across the corresponding bytes in the shares such that their XOR equals the input. These operations may be deferred until the end of an provisioning or import instruction: writing to `context[]` may initially write only to the first share of a key, and at the end of the provisioning or import instruction, the other shares would be generated.
--

//

[[ACE-system-keys]]
==== System Keys

System Keys are given by an index into an internal, system-specific System Keys Table (SKT), and therefore, in a PI or in a SCC, in place of the key value itself, a 64-bit field is used to store the index.

For threshold implementations of system keys, ACE may copy the key material from the SKT into the CR and expand it into multiple shares.
However, the key must be still be exported as a single index.

It is permissible to include some of the shares of a system key in a threshold implementation in the optional Additional Data of the content in order to accelerate share reconstruction, provided that the key cannot be reconstructed from these shares.

//

[[ACE-size-functions]]
==== Size Functions

Let `mh` denote a Metadata Header.
In order to determine the total lengths of the PI and of the SCC,
the implementation provides the following functions or an equivalent mechanism:{empty}

. ``MH_size(mh)`` returns the byte length of the Metadata Header.
In the current specification, it is always 8.

. ``PI_content_size(mh)`` returns the byte length of the content section of a PI.
   It depends only on `mh`._Algorithm_, `mh`._AlgorithmPolicy_, and `mh`._KeyType_.

. ``SCC_content_size(mh)`` returns the byte length of the fixed part of the content section of an SCC.
   It depends only on  `mh`._Algorithm_, `mh`._AlgorithmPolicy_, and `mh`._KeyType_.
   It does not include the length of the variable part of the content of length _AdditionalData_ * 8 bytes.

The total size in bytes of a PI is therefore

`{fournbsp}{fournbsp} MH_size(mh)` + `PI_content_size(mh)`,

and the total size in bytes of an SCC is

`{fournbsp}{fournbsp} MH_size(mh)` + 16 + `SCC_content_size(mh)` + _AdditionalData_ * 8.

[[ACE-interruption-points]]
==== Interruption Points

Memory read or write operations are the only admissible points of interruption the provisioning, export and import operations.
The instructions may be interrupted because of a memory exception, and any other type of interrupt must wait for the next memory read or write.
They may resume from the point of interruption only if the control flow is returned to them immediately after the interrupt handler has completed.
The privileged interrupt handler must ensure that the instruction is restarted only in this situation, and in any other circumstance, including context switching, the instruction must be restarted, in which case if the instruction is `ace.prov` or `ace.import` it must also clear the CR.
The implementation will also restart any operation if the internal state of the CR is not in a valid interrupted state.

[WARNING]
====
The initial cryptographic phase of `ace.export` is currently architected to be uninterruptible.
Even if this phase is executed concurrently with other operations, an interrupt handler may need to wait for it to complete before proceeding with any access to the CR.
A very long such phase could become a performance bottleneck for very long SCCs, or cause timing issues. To address this, we could allow the SIV computation to be interrupted and use odd, or negative, values in `acestart` to denote this.
====

//

[[ACE-provisioning]]
==== Provisioning

We start with the algorithm performed by `ace.prov`, which reads a PI and uses it to provision a CR.

[[ACE-provisioning-listing]]
.Provisioning a CR with Metadata and content
[]
----
M : array of bytes // in memory

// PREEMPTIBLE WITH `acestart` IN [0 .. 7]
Metadata : bits(64) = M[0 .. 7]
z ← PI_content_size(Metadata[31:0]);

if (z == 0) { error ace_err_unimpl; }
if (there is not enough memory for the algorithm encoded in the Metadata) then
   { error ace_err_memory; }
if (Metadata is inconsistent) { error ace_err_invalid_value; }

- Complete Metadata parsing.
// NEXT OPERATION PREEMPTIBLE WITH `acestart` IN [8 .. Z+7]
- Sequentially read and parse the z bytes at M+8.
----

[[ACE-SCC-AEAD]]
==== Export and Import

To export and import CRs we use AES-GCM-SIV cite:[DBLP-journals-iacr-GueronLL17,RFC8452].

[WARNING]
AES-GCM-SIV has been chosen because it only required single passes of data in main memory, reducing the number of external memory accesses.
GCM uses also a single pass but requires separate nonce and tag values, increasing the size of the exported data by one block.

We define the Key Derivation (<<ACE-SCC-RFC8452-derivation>>) function first.
The generation of an SCC from a CR (<<ACE-SCC-export>>) and the import of an SCC into a CR (<<ACE-SCC-import>>) are defined next.

[[ACE-SCC-RFC8452-derivation]]
.RFC8452 Key Derivation
[]
----
function RFC8452_KeyDeriv(key : bits(256)) = {
  struct {
    AESE256(key, (zeros(125) @ 0b101))[63:0] @ AESE256(key, (zeros(125) @ 0b100))[63:0] @
    AESE256(key, (zeros(125) @ 0b011))[63:0] @ AESE256(key, (zeros(125) @ 0b010))[63:0],
    AESE256(key, (zeros(125) @ 0b001))[63:0] @ AESE256(key, (zeros(125) @ 0b000))[63:0]
  }
}
----

NOTE: Due to the computational cost of the derivation functions, implementations may cache recently used derived keys indexed by Locality.

For a Metadata Header `mh`, `get_localities(mh)` returns a variable length array with zero or more Locality Secrets, corresponding to the active localities, ordered by increasing index value, as defined in <<ACE-Localities>>.
//These are used as a variable length prefix to the POLYVAL computation, to create unique SIV values. Using these as a prefix allows some degree of pre-computation.
During SCC export and import, these Locality Secrets are prepended, in ascending index order, to the input of the AEAD tag computation.
If the _Locality_ field is zero, no Locality Secrets are prepended.

The export operation maintains a per-CR flag indicating that an export is in progress.
The reason is that operations that modify the internal state may be performed on a CR with an interrupted export operation pending.
In this case, resuming the export operation may use an incorrect SIV for the remaining SCC data, causing a subsequent import to fail authentication.
Therefore, any operations that modifies the internal state of the CR will also unset this flag.
If an export operation resumes with this flag cleared, it is restarted instead.

[[ACE-SCC-export]]
.Generation of an SCC from a CR
[]
----
& mh : bits(64) = CR.Metadata_header;         // from the CR
CR.exporting : bool;                          // "hidden" per-CR ACE unit state
local SIV, tmp : bits(128);
local enc_key : bits(256);
local auth_key : bits(128);

// CR.exporting is always false except during export.
CR.exporting = true;

// Note: CR.content[] includes the optional extra content at the end

z : int ← SCC_content_size(mh);
z ← z + mh.AdditionalData * 8;
CR.content : array[z] of bytes;

// In external memory: Metadata Header, then SIV, then Content
M : array[MH_size(mh) + 16 + z] of bytes;
let last_block_fractional : Boolean ← z % 16 != 0;
let num_blocks : int ← ceil(z / 16);

{enc_key, auth_key} ← RFC8452_KeyDeriv(CSK);
L : list ← {} if (mh.Locality == 0) else get_localities(mh.Locality);

// Include Locality "prefix" (zero or more 128-bit blocks)
tmp ← POLYVAL(auth_key, L @ zeros(64) @ mh @ CR.content[]);
SIV ← AESE(enc_key, 0 @ tmp[126:0]);

// FOLLOWING MEMORY WRITE PREEMPTIBLE, `acestart` FROM 0 TO 7
M[0 .. 7] ← mh;

// FOLLOWING MEMORY WRITE PREEMPTIBLE, `acestart` FROM 8 TO 23
M[8 .. 23] ← SIV;

foreach(i from 0 to num_blocks - 1) {
  if ((i == num_blocks - 1) and last_block_fractional)
    // FOLLOWING MEMORY WRITE PREEMPTIBLE, `acestart` FROM 24+i*16 TO 31+i*16
    M[24+i*16 .. 31+i*16]
      ← CR.content[i*16 .. 7+i*16]
      xor AESE(enc_key, 1 @ SIV[126:32] @ (SIV[31:0]+bin(i,32) % 2**32)[63:0];
  else
    // FOLLOWING MEMORY WRITE PREEMPTIBLE, `acestart` FROM 24+i*16 TO 39+i*16
    M[24+i*16 .. 39+i*16]
      ← CR.content[i*16 .. 15+i*16]
      xor AESE(enc_key, 1 @ SIV[126:32] @ (SIV[31:0]+bin(i,32) % 2**32);
}

CR.exporting ← false;
----

The import algorithm needs some special care:

* The first block read from memory by the operation is the Metadata Header `mh`:
 ** If strictly fewer than 4 bytes are read before the instruction is interrupted, ACE leaves `acestart` at 0, and the instruction will be restarted upon resumption.
 ** If 4 bytes or more have been read, the value of `mh.StateNumber` in the SCC is known. In this case, the instruction may be restarted with `acestart` {ge} 4 recording the amount of data read.

* During the import operation, the hardware saves the `StateNumber` value in the metadata and sets
`mh.StateNumber <- ace_state_invalid` instead until the end of the import operation, where `mh.StateNumber` is set to the correct value.
// ** The flag is also used by the implementation to raise error ace_err_unconf_CR instead of ace_err_invalid_CR upon an attempt to use the partially imported CR.
** Since context switching code cannot export a partially imported CR when saving the state, it will clear the CR instead, forcing the hardware to restart the import operation.
** Exceptions that immediately return to the interrupted operation, such as memory exceptions, may cause the hardware to resume the operation instead, if the CR was touched.

// *** The hardware will only resume the import operation if the flag is set, otherwise it will restart the operation.
// CR.importing is always false except during import.
// During import, the original StateNumber is saved and temporarily replaced in the CR
// with ace_state_invalid to prevent any USAGE operations.  Any operation that writes
// to the CR will set CR.importing to false: this allows context switching code to reuse
// the CR and, upon returning to the interrupted import, the hardware will detect
// CR.importing == false and restart the import instead of resume it.  OTOH, if the
// interrupt was caused by a memory exception, the instruction can be resumed.

[[ACE-SCC-import]]
.Importing an SCC into a CR
[]
----
M : array of bytes;         // from memory
CR.saved_SN : bits(4);      // this is a "hidden" per-CR ACE unit state

local enc_key : bits(256);
local auth_key : bits(128);
local SIV, tmp : bits(128);

// FOLLOWING MEMORY READ PREEMPTIBLE, `acestart` FROM 0 TO 7
tmp[63:0] ← M[0 .. 7]; // read Metadata Header

CR.saved_SN : bits(4) ← tmp[63:0].StateNumber;
CR.Metadata_header ← tmp[63:0];
CR.Metadata_header.StateNumber ← ace_state_invalid;

& mh = CR.Metadata_header;

z ← SCC_content_size(mh);
z ← z + mh.AdditionalData * 8;

if (z == 0) { error ace_err_unimpl; }
if (there is not enough memory for the algorithm encoded in the Metadata) then
    error ace_err_memory;

num_blocks ← ceil(z / 16);
last_block_fractional : Boolean ← (z % 16 != 0);

{enc_key, auth_key} ← RFC8452_KeyDeriv(CSK);

// Absorb Locality "prefix" (zero or more 128-bit blocks)
tmp ← zeros(128);
L : list ← {} if (mh.Locality == 0) else get_localities(mh.Locality);
foreach(i from 0 to length(L)-1) {
  tmp ← tmp xor L[i];
  tmp ← Montmul(tmp, auth_key);
}

// FOLLOWING MEMORY READ PREEMPTIBLE, `acestart` FROM 8 TO 23
SIV ← M[8 .. 23];
tmp ← tmp xor (zeros(64) @ mh);
tmp ← Montmul(tmp, auth_key);

foreach(i from 0 to num_blocks - 1) {
  if ((i == num_blocks - 1) and last_block_fractional) {
    // FOLLOWING MEMORY READ PREEMPTIBLE, `acestart` FROM 24+i*16 TO 31+i*16
    content[i*16 .. 7+i*16] ← M[24+i*16 .. 31+i*16]
      xor AESE(enc_key, 1 @ SIV[126:32] @ (SIV[31:0]+bin(i,32) % 2**32)[63:0];
    tmp[63:0] ← tmp[63:0] xor content[i*16 .. 7+i*16];
  } else {
    // FOLLOWING MEMORY READ PREEMPTIBLE, `acestart` FROM 24+i*16 TO 39+i*16
    content[i*16 .. 15+i*16] ← M[24+i*16 .. 39+i*16]
      xor AESE(enc_key, 1 @ SIV[126:32] @ (SIV[31:0]+bin(i,32) % 2**32);
    tmp ← tmp xor content[i*16 .. 15+i*16];
  }
  tmp ← Montmul(tmp, auth_key);
}
tmp ← AESE(enc_key, 0 @ tmp[126:0]);

if (tmp != SIV) { error ace_err_import_auth; }

- Now the content can be deserialized.
- This includes computing any derived values not saved as part of the SCC,
- as well as creating shares for threshold implementations.

// FINALLY, restore the StateNumber from the SCC
mh.StateNumber ← CR.saved_SN;
----

//

[[ACE-invalidation]]
=== Invalid Inputs and Operations, CR Invalidation

{empty}
(((ACE, algorithm, invalid state)))
(((Cryptographic Register, invalidation)))
In certain cases where an invalid input is provided to any ACE instruction, or an instruction that is not explicitly allowed in a given state is executed, while processing the algorithm in CR, say, `Kn`, then `Kn` is *invalidated*. This means that the following happens:

* `Kn` is put into State _invalid_;
* For instructions that refer to `Kn`:
 ** `ace.prov`, `ace.clear` (thus also `ace.reset`), `ace.import`, `ace.export`, `ace.size` and `ace.avail` work normally.
 ** `ace.exec`, `ace.clone`, and `ace.restrict` raise an ACE error ace_err_invalid_CR;
 ** `ace.input` and `ace.output` raise an ACE error ace_err_invalid_CR when `aceactivecr` is `Kn`;
 ** `ace.state` raises an ACE error ace_err_invalid_CR, unless it is used to return to State _initial_;
 ** `ace.error` always returns error ace_err_invalid_CR after any operation involving the CR except for `ace.import` and `ace.export`, `ace.clear`, `ace.prov`, and `ace.size`, which all work normally, and using `ace.state` to return to State _initial_.
* The current instruction is terminated.

In State _completed_, only `ace.prov`, `ace.export`, `ace.import`, `ace.clear`, and `ace.error` are permitted.

//

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-horizontal-exception-handling]]
=== Exception Handling via Horizontal Traps

_This section is currently informative and non-normative._

// [WARNING]
// [.red]#Optional (need more discussion): ACE error code __i__ corresponds to bit number __i__ in a mask CSR (or more than one) that determines whether the error traps instead of being handled directly by the software by checking# `[.red]#ace.error#`[.red]#. This may be also a horizontal trap (see <<ACE-horizontal-exception-handling>>).#

ACE has been architected so that in properly written code, the most common executed instructions, namely `ace.exec` and `ace.state`, rarely have to deal with errors.
Errors should occur mostly with configuration operations, caused by insufficient CRF capacity or while authenticating SCCs.

However, revocation of localities or reached expiration dates may cause a CR to suddenly become invalid just before executing an `ace.exec` or `ace.state` instruction.
Requiring software to check for errors after each operation would impose significant burden on the software and possibly degrade performance.

Such horizontal traps can be used to implement a try/catch mechanism:
At the start of a subroutine that performs a cryptographic protocol, the address of the “catch” code is written in CSR `acehtrapvector` (<<ACE-CSR-acehtrapvector>>) and the mask with the error types to catch is loaded in CSRs `acehtrapmask` (<<ACE-CSR-acehtrapmask>>).
When exiting the routine, the two CSRs are cleared.

NOTE: The main application of such code is when revocation or expiration cause a CR to become invalid.
In such contexts, it is not the duty of the cryptographic subroutine to resolve the issue, but of the code that makes use of the latter, as the keys may have to be renegotiated, and this may need user intervention.

////
. At the start of a subroutine that performs a cryptographic protocol, the address of the “catch” code is written in CSR `acehtrapvector` (<<ACE-CSR-acehtrapvector>>) and the mask with the error types to catch is loaded in CSRs `acehtrapmask` (<<ACE-CSR-acehtrapmask>>).

. The code does not directly handle the exceptions to be caught, usually only ace_err_invalid or ace_err_expired.
. If the code runs without such errors, then the two CSRs are cleared at the end of the routine before returning.
. If, say, an ace_err_invalid_CR or ace_err_expired_CR error is raised, the horizontal trap diverts the control flow to the catch code, which usually cleans up, and returns to the caller of the subroutine, not to the routine itself, with an error code.
////

[WARNING]
If our definition of horizontal traps is not allowed, we may have to follow the development of the HFI extension or implement a solution that traps to S-mode first and then immediately returns to the catch code. We will discuss this with the ARC.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-algorithms]]
=== Algorithms

_This section is normative._

This section specifies the behavior of the ACE instructions for the supported cryptographic algorithms.
Some specifications define algorithm families that can be instantiated with any primitive meeting the required properties, typically the block size `b` and the key size `k`—such as GCM or GCM-SIV, which are well defined not only with AES but also with other block ciphers, such as SM4.
By contrast, the specifications for other algorithm suites are specific to certain primitives, for instance, Ascon.

==== Definition of an Algorithm in ACE

Each algorithm is fully defined by the following information:

Parameters:::
+
--
These include:

* The _block size_ `b`, which is the size of the basic unit of information processed by the algorithm, usually the block size of the main underlying primitive;
* The _key size_ `k`, for keyed algorithms; and
* Any other parameter (for instance, counter size) that is necessary to instantiate the algorithm with compatible primitives.
--
+

Data Structures:::
+
--
These include:

. *Provisioning Input* (Content):
The data following the Metadata Header in the PI, such as keys and other required secrets.
The fields are listed in the order they appear in the PI, each with its length.

. *Internal State* (Content):
Information that must be maintained in the internal state of a CC, besides the information provided by the metadata.
The ordering of the fields is not given, and their lengths may differ from those listed, for example for threshold or fault-tolerant implementations.

. *Serialized Content*:
The data that follows the Metadata Header in the plaintext portion of an SCC.
The fields are listed in the order they appear in an SCC, each with its length.
--
+

Algorithm-Specific Functions:::
Any other function that is specific to the algorithm.

State Machine:::
+
--
This includes:

. A list of *states* in which the internal state machine of the logic is executed, together with their representation, either as a number in the range [0..15] or by more complex structures. The values for the architected algorithms conform to <<ACE-state-constants-fixed>> and <<ACE-state-constants-symmetric>>.
. A complete list of the *allowed state transitions*, including the conditions under which each transition is allowed.
. The enumeration of the *allowed instructions* at each state and their *behavior*.
--
+

//

The instructions permitted in each algorithm state are typically `ace.exec` and `ace.state`, though this is not a general rule.
For `ace.exec`, only one of its forms (see <<ACE-instruction-exec>>) is allowed per state, along with the corresponding replacement sequence defined in <<ACE-replacement-instructions>>.
If a Form of `ace.exec`, or `ace.state` not explicitly allowed in the current algorithm state is used, then an illegal instruction exception is raised.

If a non-allowed state transition is requested in `ace.state`, including requesting encryption or decryption from a CC not allowing it, an ACE error ace_err_unimpl is raised.  This also invalidates the CR.

Pseudocode is provided to illustrate the software implementation of ACE-supported algorithms using the ACE ISA.
For clarity, the pseudocode generally uses fixed parameters and omits the `ace.exec` Forms A-C replacement sequences.
The examples are non-normative.

[NOTE]
====
In many algorithms, an `ace.exec` or `ace.state` operation could logically imply a state change.
For example, after setting an IV or nonce in an AEAD mode, the instruction might naturally transition to a subsequent state.
Deviations from this behavior may be necessary to avoid security issues.
An example is given by the automatic transitions from hash finalization to verification, or from hash verification to the _completed_ state (<<ACE-algorithms>>).
====

//

[[ACE-generic-rules]]
==== Generic Rules

[[ACE-usage-input-output]]
===== Usage of `ace.input` and `ace.output` to Replace Vector Inputs and Outputs

Whenever ACEIOBUF is implemented, in all algorithms the following applies:
any occurrence of the “Original Instructions” in <<ACE-replacement-instructions>> may be substituted by the corresponding “Replacement Sequence” where `ace.input` and `ace.output` instructions are used in place of the vector register inputs and outputs, even if we do not explicitly write it each time.

//

[[ACE-replacement-instructions]]
.Replacement sequences for `ace.exec` and `ace.state` using `ace.input` and `ace.output`
[float="center",align="center",width="100%",cols="<21%,<41%,<38%",options="header"]
|===
| Instruction and Form | Original Instruction          | Replacement Sequence
| `ace.exec`, Form A   | `ace.exec{nbsp}{nbsp}{nbsp}Vd, Kn\|K(Xn), Vs` | `1: ace.input{nbsp}{nbsp}Xl, Vs` +
`2: ace.exec{nbsp}{nbsp}{nbsp}Kn\|K(Xn)` +
`3: ace.output{nbsp}Vd,  Xl`
| `ace.exec`, Form B   | `ace.exec{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}Kn\|K(Xn), Vs`     | `1: ace.input{nbsp}{nbsp}Xl, Vs` +
`2: ace.exec{nbsp}{nbsp}{nbsp}Kn\|K(Xn)`
| `ace.exec`, Form C   | `ace.exec{nbsp}{nbsp}{nbsp}Vd, Kn\|K(Xn)`     | `1: ace.exec{nbsp}{nbsp}{nbsp}Kn\|K(Xn)` +
`2: ace.output{nbsp}Vd,  Xl`
| `ace.state`, Form C  | `ace.state{nbsp}{nbsp}Kd\|K(Xd), #immed, Vs` | `1: ace.input{nbsp}{nbsp}Xl, Vs` +
`2: ace.state{nbsp}{nbsp}Kd\|K(Xd), #immed`
// | `ace.derive`, Form C | `ace.derive Kd\|K(Xd), Ks1\|K(Xs1), Vs2` | `1: ace.input{nbsp}{nbsp}Xl, Vs2` +
`2: ace.derive{nbsp}Kd\|K(Xd), Ks1\|K(Xs1)`
|===

The only operations performed by `ace.input` and `ace.output` is to provide the inputs and read out the output of the operations.
The entirety of the computations and internal state changes of the `ace.exec` and `ace.state` operations remains in the `ace.exec` and `ace.state` operations

`ace.input` and `ace.output` may be used if enabled and `aceiobuflen` is non-zero, otherwise an ACE error ace_err_unconf_buf is raised.
If `aceiobuflen` is non-zero, and the range size `aceiobuftop` - `acestart` is zero or an invalid size for the algorithm, the `ace.exec` operation is not performed and ACE error ace_err_invalid_value is raised.

In all cases, the `ace.input` and `ace.output` instructions must be temporarily tied to a specific context in order to properly determine the allowed sequences.
This is done by setting the `aceactivecr` CSR (<<ACE-CSR-aceactivecr>>) first. The user must not forget to set it back to 32 after the sequence is completed.

The architecture uses the `acesequence` CSR to track the progress of the replacement sequences.
The initial value of `acesequence` is 0. It remains zero while we are using the forms of `ace.exec` and `ace.state` specified in the algorithm.
As soon as one of the following events happens:

. An `ace.input` is completed in place of a Form A or B `ace.exec`, or Form C `ace.state`; or
. A Form D `ace.exec` is completed in place of a Form C `ace.exec`,

then `acesequence` is set to 1, to denote that the first instruction in the replacement sequence has completed.
Then, `acesequence` keeps track of how many instructions of the replacement sequence have been completed.
At the end of the replacement sequence, `acesequence` is reset to 0.

The ordering of the instructions in a replacement sequence is enforced by the architecture according to the value of `acesequence` and the state number of the CR configured in `aceactivecr`.
Not following the instruction ordering raises an illegal instruction exception and invalidates the CR.

`acesequence` can be freely read and written in all modes.
In particular, `acesequence` may be saved and restored by privileged code at context switch together with `acestart`.
This may also allow to repeat `ace.exec` or `ace.state` instructions, but it will not allow the user to manipulate the internal state of the algorithms in a way to compromise it, provided that the algorithm is correctly designed.

//

[[ACE-interruptibility]]
===== Interruptibility

Except for exceptions caused by memory accesses or the interruption of vector accesses, most ACE operations are uninterruptible.

//Operations performed by `ace.state` are uninterruptible, except when reading vector inputs, where the vector read operation may be interrupted and resumed.

The operation of `ace.exec` on a basic processing unit, in any state of any algorithm, is uninterruptible, unless explicitly allowed by the algorithm.
When `ace.exec` operates iteratively on an inputs who length is an integer multiple of the basic processing unit, each block is processed uninterruptibly, but the instruction may be interrupted between blocks; the hardware sets `acestart` to the interruption point.

An implementation must wait before accessing a CR that is still asynchronously being written to.

//

[[ACE-notation]]
===== Notation in the Algorithm Descriptions

* `INPUT`: The input data to be processed by `ace.exec` or `ace.state`.
   This can be the input vector register, or the ACEIOBUF, as described in <<ACE-usage-input-output>>.

* `OUTPUT`: The output data produced by `ace.exec`.
   This can be the output vector register, or the ACEIOBUF, as described in <<ACE-usage-input-output>>.

* `IOLEN`: Either `VL*SEW` or the length `aceiobuftop` of the ACEIOBUF in bytes, depending on whether vector registers are used or the ACEIOBUF is used.

//

[[ACE-rules-threshold-implementations]]
===== Single-Share Key Export Rule for Threshold implementations

Any CC with its algorithm implemented as a threshold implementation will always provision, import and export _all_ its keys and secrets as _single_, _reconstructed_ _shares_.

The PI and SCC Formats will be the same as for the non-threshold implementation variants of the same algorithm, with the only difference being the value of the Side Channel Protection bits in the Metadata.

For the purpose of architecture specification, all values are also always represented as a single share in this document.
Threshold implementations are simply implementation variants of the exact same algorithm.
(((ACE, algorithm, threshold variants)))

NOTE: This rule assumes that reconstructing or re-randomizing a key is a fast operation, such as an ``xor`` with random values.
This requires the ACE execution unit to have access to a random number generator.
Besides ensuring the compactness of an SCC, this rule also guarantees key portability across architectures
that implement side-channel protection in different ways.

//

[[ACE-rules-system-keys]]
===== Representation of System Keys in the Data Structures

System Keys will change all the algorithms described here in the following way:

. In a PI and in an SCC, the key field will contain the index of the key in the SKT in place of the value.
. This field is reduced from the original key size to a 64-bit value. This saves space in an SCC and allows for faster export and import operations.
. For algorithms that require more than one key, such as XEX/XTS, a single index is still used to refer to an entry in the SKT that contains multiple keys—and thus a single 64-bit value in the PI and SCC.

//

==== States for Symmetric Algorithms

The following table, together with <<ACE-state-constants-fixed>>, defines the state names and numbers used by the symmetric algorithms in this specification.

[[ACE-state-constants-symmetric]]
.Constants defining CC states for symmetric algorithms
[float="center",align="center",width="100%",cols="^6%,<26%,<16%,<52%",options="header"]
|===
| Value | Mnemonic for the Constant       | State Name          | Description
.2+| 1  |  ace_state_operate              |  _operate_          |Generic operational state.
<|  ace_state_hash_absorb                 | _hash_absorb_       | Start and initialize a hash function of the tag/MAC part of an algorithm and start absorbing blocks of data (in the case of an AEAD algorithm, this usually is the associated data).
|   2   |  ace_state_hash_last_block      | _hash_last_block_   | In this state additional data may be absorbed, such as partial blocks and lengths, if the hash/tag algorithm processes the last block of its input or of the associated data part of its input in a different way from the other blocks.
|   3   |  ace_state_hash_finalize        | _hash_finalize_     | Finalize the internal state of a hash/tag function.
|   4   |  ace_state_hash_verify          | _hash_verify_       | Compare the internal hash/tag value to the provided one.
|   5   |  ace_state_hash_output          | _hash_output_       | Enter the hash output phase of a hash/tag function.
|   6   |  ace_state_encrypt              | _encrypt_           | In this state encryption is performed, and an update to the tag computation if part of the algorithm.
|   7   |  ace_state_decrypt              | _decrypt_           | In this state decryption is performed, and an update to the tag computation if part of the algorithm.
|   8   |  ace_state_enc_last_block       | _enc_last_block_    | For the encryption path of authenticated encryption modes of operation to process the last block separately.
|   9   |  ace_state_dec_last_block       | _dec_last_block_    | For the decryption path of authenticated encryption modes of operation to process the last block separately.
|  10   |  ace_state_enc_tag_finalize     | _enc_tag_finalize_  | Finalize the tag computation for AE mode encryption.
|  11   |  ace_state_dec_tag_finalize     | _dec_tag_finalize_  | Finalize internal tag computation for AE mode decryption, verify the value.
|  12   |  ace_state_set_aux_value        | _set_aux_value_     | Set a public/auxiliary value in an algorithm.
|===

The value of 1 may indicate both states _operate_ and _hash_absorb_.

NOTE: The `ace.state` instruction used to transition to states _hash_absorb_, _encrypt_, or _decrypt_ often also sets a public value.
For algorithms requiring multiple public values or additional parameters (e.g., tag length), these can be set by transitioning to State _set_aux_value_ using a Form of `ace.state` with an auxiliary argument, i.e., Form B or C.

Algorithms that differ substantially from those described in <<ACE-algorithms>> and are not meant to be handled by the same code may reuse the state values in [1..12] with their own mnemonics and names for their states.

//

[[ACE-ECB-mode]]
===== Electronic Codebook Modes (Direct Encryption/Decryption)

ECB mode cite:[nist-SP-800-38A-1] is the simplest way to use a block cipher.
(((ACE, algorithm, ECB)))

Parameters:::

* `b` = block size (8|`b`). `IOLEN` must be a multiple of `b` (including `b`).
* `k` = key size (8|`k`).

Data Structures:::
* *Provisioning Input* (Content):
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | `k`/8 or 8      | Key or System Key index
|===
--
+

 * *Internal State* (Content):
 ** `key`: `k` bits.

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
|  Pos. | Size in Bytes   | Field
|   i   | `k`/8 or 8      | Key or System Key index
|===
--
+

Algorithm-Specific Functions:::
* `enc_blk(K,p) -> c` encrypts plaintext block `p` using the key `K`, and returns the ciphertext result `c`.
* `dec_blk(K,c) -> p` decrypts ciphertext block `c` using the key `K`, and returns the plaintext result `p`.

State Machine:::

* *States:*
 ** _initial_: The CC is ready.
 ** _encrypt_: Encrypting blocks of input.
 ** _decrypt_: Decrypting blocks of input.

* *Allowed State Transitions:*
 ** From any valid state to _encrypt_, if encryption is allowed.
 ** From any valid state to _decrypt_, if decryption is allowed.

* *Behavior:*
 ** In State _initial_, no `ace.exec` instruction is allowed.
 ** In States _encrypt_ or _decrypt_, we can only issue Form A `ace.exec` instructions, i.e., +
     “`ace.exec OUTPUT, Kn|K(Xn), INPUT`.”
  *** If the state is _encrypt_, then `OUTPUT <- enc_blk(key, INPUT)`.
  *** If the state is _decrypt_, then `OUTPUT <- dec_blk(key, INPUT)`.
  *** If `IOLEN` > `b`, then “`ace.exec OUTPUT, Kn|K(Xn), INPUT`” encrypts/decrypts block-by-block.
      Here, and in the rest of this document, this means from the blocks in the least significant positions to the most significant positions:
      . `foreach(i from 0 to IOLEN-b by b)` {
      ..   `OUTPUT[i+b-1:i] <- enc_blk(key, INPUT[i+b-1:i])` }

//

[NOTE]
====
Supporting vector lengths smaller than a cipher's block size would not only complicate both the architecture and its implementation, but it would also burden the software using the feature. Therefore, in this case either the user suitably reconfigures the vector lengths, or uses the `ace.input` and `ace.output` instructions.
====

In <<ACE-pseudocode-ECB-encryption>> we illustrates how to use an ECB CC to encrypt a block of data.

//

[[ACE-chaining]]
===== Chaining/Feedback Modes

There is no need to explicitly architect the behavior of chaining modes, such as Cipher Block Chaining (CBC), Cipher Feedback (CFB) and Output Feedback (OFB) (all defined in cite:[nist-SP-800-38A-1]) as they are easily in software implemented on top of the ECB, with no intermediate value requiring confidentiality.

//

[[ACE-keystream-modes]]
===== CTR/LFSR/XCTR/XLFSR Keystream Generation

In the “non-X” modes, i.e., CTR mode and its analog with an LFSR replacing the arithmetic counter, the sum of the lengths of IV and counter/LFSR equals the block size of the underlying keyed PRP or PRF. IV and counter/LFSR are concatenated to form the input to the latter.
(((ACE, algorithm, keystream generation)))

In the “X” modes, both IV and counter/LFSR have the same size as the block size of the underlying keyed PRP or PRF.
IV and counter/LFSR are ``xor``ed together to form the input to the keyed PRP or PRF.

Parameters:::
* `b` = block size (8|`b`). For this algorithm `IOLEN` must be a multiple of `b`.
* `k` = key size (8|`k`).
* `j` = counter size (8|`j`).
* `n` = IV size (8|`n`).
* If the mode is CTR or LFSR, it is `b = n + j`, else it is `b = n = j`.

Data Structures:::
* *Provisioning Input* (Content):
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | `k`/8 or 8      | `key` or System Key index
|===
--
+

* *Internal State* (Content):
 ** `key`: `k` bits.
 ** `IV`: `n` bits.
 ** `ctr`: `j` bits.

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
|  Pos. | Size in Bytes   | Field
|    i  | `k`/8 or 8      | `key` or System Key index
|   ii  | `n`/8           | `IV`
|  iii  | `j`/8           | `ctr`
|===
--
+

Algorithm-Specific Functions:::
* `keystream_block(p) -> c` -- usually an encryption function.
* `tick_ctr()` -- updates the `ctr` (either by a modular increment or a LFSR).

State Machine:::
* *States:*
  ** _initial_: The CC is ready.
  ** _operate_: In this state the CC will produce a keystream.

* *Allowed State Transitions:* any.

* *Behavior:*
 ** In State _initial_, the `ctr` and `IV` fields are set to 0 (`ctr` is set to 1 if the algorithm is LFSR-based).

 ** To transition to State _operate_, a Form C ``ace.state`` instruction must be issued.
  *** This sets the value of `IV` to `INPUT`.
  *** If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.

  ** In State _operate_, only Form C ``ace.exec`` instructions are allowed. +
     “```ace.exec OUTPUT, Kn|K(Xn)```” performs:
+
--
  . If in a CTR or LFSR mode then `tmp ← keystream_block(IV @ ctr)`, +
    else (i.e., if in a XCTR or XLFSR mode) `tmp ← keystream_block(IV xor ctr)`,
  . `tick_ctr()`, and
  . `OUTPUT ← tmp`.
--
+
If `IOLEN` is a multiple of `b`, the above three commands are applied to each of the `IOLEN/b` `b`-bit blocks of `INPUT`, producing the corresponding `b`-bit block of `OUTPUT` each time.
// If the number `x` of blocks to be processed in an entire run of the algorithm is not a multiple of `IOLEN`/`b`, `VL` can be set to the remainder of the division of `x` by `IOLEN`/`b` for the last instruction.

Note that if `ace.state` is issued to return to State _initial_, the CC can be reused with a new IV.

Example pseudocode is given in <<ACE-pseudocode-keystream-modes>> (for the case `b` = `IOLEN` = 128).

//

[[ACE-XEX-XTS-modes]]
===== XEX/XTS modes (one or two keys)

The XTS mode was designed for storage confidentiality cite:[DBLP-journals-ieeesp-Martin10]
and made into a Recommendation by NIST in 2010 cite:[nist-SP-800-38E].
XTS is based on the XEX construction, formalized by Phillip Rogaway cite:[DBLP-conf-asiacrypt-Rogaway04], to design _Tweakable Block Ciphers_ cite:[DBLP-conf-crypto-LiskovRW02].
A Tweakable Block Cipher (TBC) is a block cipher which, besides the key and the plaintext or ciphertext, also takes a tweak as input.
The tweak is used together with the key to select the permutation computed by the block cipher.

The XEX construction builds a TBC `Ẽ` from a block cipher `E`, with key `K`, tweak `T`, and plaintext `P`,  as follows: +
 +
`{fournbsp}{fournbsp}`
`Ẽ(K, T, P) = E(K, P xor M) xor M` `{nbsp}{nbsp}` where `{nbsp}{nbsp}` `M = E(K, T)` `{nbsp}{nbsp}` is called a _mask_. +
 +
In XEX mode, once a mask is computed, it is then updated by using a Galois Multiplication for any successive block instead of updating the tweak and encrypting it again.

The NIST standard uses two different keys, one for the data encryption path and one for the encryption of the tweak.
The use of a single key or two independently sampled keys is determined by the algorithm, and it is not a configuration parameter for the algorithm.
We first define XEX mode functionality.
(((ACE, algorithm, XEX)))

Parameters:::

* `b` = block size (8|`b`). For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = key size (8|`k`).

Data Structures:::

* *Provisioning Input* (Content):
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
|  Pos. | Size in Bytes   | Field
|   i   | `k`/8 or 8      | `key1` or System Key index
|  ii   | `k`/8 or 0      | `key2` or System Key index for `key1` given
|===
--
+

* *Internal State* (Content):
 ** `key1`: `k` bits.
 ** `key2`: `k` bits -- omitted if only one key is used or if both keys come from an entry in the SKT.
 ** `mask`: `b` bits.

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | `k`/8 or 8      | `key1` or System Key index
|  ii  | `k`/8 or 0      | `key2` or System Key index for `key1` given
| iii  | `b`/8           | `mask`
|===
--
+

Algorithm-Specific Functions:::

* `enc_blk(K, p) -> c` encrypts block `p` using the key `K`, and returns the result `c`.
* `dec_blk(K, c) -> p` decrypts block `c` using the key `K`, and returns the result `p`.
* `update_mask(mask) -> mask` updates the mask by a Galois Field multiplication in GF(2^b^).

State Machine:::

* *States:* _initial_, _encrypt_, and _decrypt_ (defined as before, cf. <<ACE-ECB-mode>>).

* *Allowed State Transitions:*
 ** _initial_ -> _encrypt_, if encryption is allowed.
 ** _initial_ -> _decrypt_, if decryption is allowed.
 ** _encrypt_, _decrypt_ -> _initial_.

* *Behavior:*
 ** In State _initial_:
  *** The `mask` field is set to zero.
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
 ** The ``ace.state`` instruction to transition to either _encrypt_ or _decrypt_ must be of Form C. +
    It sets the tweak, and the `mask` field is used to store it: `mask <- INPUT`.
  *** If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.
  *** Then, the following operations are performed:
  . if two independent keys are used then
  .. `mask <- enc_blk(key2, mask)`
  . else
  ..  `mask <- enc_blk(key1, mask)`
  ..  `mask <- update_mask(mask)`.

  ** In States _encrypt_ and _decrypt_, only ``ace.exec`` instructions of Form A are allowed. +
    “```ace.exec OUTPUT, Kn|K(Xn), INPUT```” performs the following operations:
+
--
  . In State _encrypt_, it computes `OUTPUT = mask xor enc_blk(key1, INPUT xor mask)`. +
    In State _decrypt_, it computes `OUTPUT = mask xor dec_blk(key1, INPUT xor mask)`.
  . `mask <- update_mask(mask)`.
--
+
If `IOLEN` is a multiple of `b`, the above commands are executed `IOLEN/b` times, processing each `b`-bit block of `INPUT` into a `b`-bit block of `OUTPUT`.

//

Note that if `ace.state` is issued to return to State _initial_, the CC can be reused with a new tweak.

Encryption pseudocode is provided in  <<ACE-pseudocode-basic-IV-mode>>, decryption is similar

//

[[ACE-tweakable]]
===== Generic Tweakable Block Ciphers

The specification of a generic tweakable block cipher is similar to that of a non-tweakable block cipher in ECB mode.
Since `ace.exec` does not admit variants with two inputs, and we have a single input buffer, we set the tweak with a separate instruction.
If block and tweak sizes are different, a reconfiguration of the vector length may be required between operations, unless the tweak is shorter than the block size, in which case the instruction setting the tweak will only consider the necessary bits.

Some commonly used TBCs are `Deoxys` cite:[Deoxys-141], `Skinny` cite:[DBLP-conf-crypto-BeierleJKL0PSSS16], `QARMA` cite:[DBLP-journals-tosc-Avanzi17], and ```QARMA```{empty}```v2``` cite:[DBLP-journals-tosc-AvanziBDEGNR23].

Parameters:::

* `b` = block size (8|`b`). For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = key size (8|`k`).
* `t` = tweak size (8|`k`).

Data Structures:::

* *Provisioning Input* (Content):
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|  i   | `k`/8 or 8      | `key` or System Key index
|===
--
+

* *Internal State* (Content):
 ** `key`: `k` bits.
 ** `tweak`: `t` bits.

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | `k`/8 or 8      | `key` or System Key index
|  ii  | `t`/8           | `tweak`
|===
--
+

State Machine:::

* *States:*
 ** _initial_, _encrypt_, and _decrypt_ defined as before.
 ** _set_aux_value_, for setting the tweak value in the next encryption or decryption operation.

* *Allowed State Transitions:*.
 ** _initial_ -> _set_aux_value_
 ** _set_aux_value_ -> _encrypt_, if encryption is allowed.
 ** _set_aux_value_ -> _decrypt_, if decryption is allowed.

 * *Behavior:*
  ** In State _initial_:
   *** Upon entering the state, the `tweak` field is cleared.
  ** In each state, we can issue Form C `ace.state` instructions, which perform:
   . `tweak` <- `INPUT`, and
   . _Instead of transitioning to state set_aux_value, the state remains unchanged (can be initial, encrypt, or decrypt)._
  ** In State _encrypt_, respectively, _decrypt_, besides Form C `ace.state` instructions, only ``ace.exec`` instructions of Form A are allowed, where
     “```ace.exec OUTPUT, Kn|K(Xn), INPUT```” encrypts, respectively, decrypts `INPUT` into `OUTPUT`.

This algorithm does not automatically update the tweak value.

[[ACE-GCM-mode]]
===== GCM Mode

The GCM mode was designed by David McGrew and John Viega cite:[DBLP-conf-indocrypt-McGrewV04]
and was made into a NIST Recommendation in 2007 cite:[nist-SP-800-38D].
(((ACE, algorithm, GCM)))

Parameters:::

* `k` = key size (8|`k`).
* `b` = block size (8|`b`). For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `c` = counter size (8|`b`). It must be `c < b`.

Data Structures:::

* *Provisioning Input* (Content):
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | `k`/8 or 8      | `key` or System Key index
|===
--
+

* *Internal State* (Content):
 ** `key`: `k` bits.
 ** `ctr`:  ``c`` bits.
 ** `IV`:  `b`-`c` bits.
 ** `auth_key`, `tag`: `b` bits.

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
|  Pos. | Size in Bytes   | Field
|   i   | `k`/8 or 8      | `key` or System Key index
|  ii   | ``c``/8         | `ctr`
| iii   | (``b``-``c``)/8 | `IV`
|  iv   | `b`/8           | `tag`
|===
--
+

NOTE: There are no fields for the lengths of the AD and of the plaintext, as they are maintained by the calling software.
Also, `hash_key` is not serialized, and thus it is recomputed upon `ace.import`.

Algorithm-Specific Functions:::

* `enc_blk(key, p) -> c` encrypts block `p` using the key, and returns the result `c`.

* `absorb(data)` absorbs data into the hash function by performing:
  . `tag <- tag xor INPUT`.
  . `tag <- Galoismul(tag, hash_key)`.

State Machine:::

* *States:*
 ** _initial_: The CC is ready.
 ** _hash_absorb_: Process Associated Data (AD) into the tag.
 ** _encrypt_: Encrypt the plaintext and absorb the ciphertext into the tag.
 ** _enc_tag_finalize_: Finalize the encryption tag, prepare to return its value.
 ** _decrypt_: Absorb the ciphertext into the tag and decrypt it.
 ** _dec_tag_finalize_: Finalize the encryption tag and keep it internally.
 ** _hash_verify_: Compare the tag against a user supplied value.
 ** _completed_: The algorithm has completed its operation correctly.

* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_.
 ** _hash_absorb_ -> _encrypt_, if encryption is allowed.
 ** _hash_absorb_ -> _decrypt_, if decryption is allowed.
 ** _encrypt_ -> _enc_tag_finalize_ -> _completed_.
 ** _decrypt_ -> _dec_tag_finalize_ -> _hash_verify_ -> _completed_.

* *Behavior:*
 ** In State _initial_ :
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
  *** The following initialization operations are performed:
   . `hash_key <- enc_blk(key, zeros(b))`,
   . `tag <- zeros(b)`,
   . `ctr <- zeros(c-1) @ 1`, and
   . `IV <- zeros(b)`.

 ** To transition to State _hash_absorb_:
 the ``ace.state`` instruction must be a Form C to set the IV, i.e., the fixed part of the counter.
 Then:
   . `IV <- INPUT[b-c-1:0]`.
  *** If the ``ace.state`` instruction is repeated, it will just update the counter again.

 ** If the AD is empty, the transition to State _hash_absorb_ is necessary to initialize the counter.

 ** In State _hash_absorb_, only Form B of ``ace.exec`` is allowed.
 “```ace.exec Kn|K(Xn), INPUT```” absorbs a data block in `tag`, i.e.:
+
--
 . `absorb(INPUT)`.
--
+
If `IOLEN` > `b`, the above operation is executed `IOLEN/b` times.

** In State _encrypt_, only ``ace.exec`` instructions of Form A are allowed.
   “```ace.exec OUTPUT, Kn|K(Xn), INPUT```” encrypts `INPUT` into `OUTPUT`, and absorbs `OUTPUT` into the `tag`, namely:
+
--
  . If `ctr == ones(c-1)`, then
  ..  the CR is *invalidated*.
  . else
  .. `tmp <- INPUT xor enc_blk(key, IV @ ctr)`.
  .. `absorb(tmp)`.
  .. `ctr <- ctr + 1 % 2^c^`.
  .. `OUTPUT <- tmp`.
--
+
If `IOLEN` is a multiple of `b`, the above operations are executed `IOLEN/b` times, encrypting each `b`-bit block of `INPUT` into the corresponding `b`-bit block of `OUTPUT`.

** To transition to State _enc_tag_finalize_, a Form C `ace.state` instruction must be used to provide
the following value, which must be set by the software:
+
--
[none]
* `INPUT <- bin(bit_length(AD), b/2) @ bin(bit_length(plaintext), b/2){nbsp}` .

The authentication tag is computed as follows:

. `absorb(INPUT)`.
  . `tag <- tag xor enc_blk(key, IV @ zeros(c))`.

Finally, `tag` is returned in `OUTPUT`, and the state is changed to _completed_. +
If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.
--
+

** In State _enc_tag_finalize_, only ``ace.exec`` instructions of Form C are allowed. +
  “```ace.exec OUTPUT, Kn|K(Xn)```” writes the `tag` to `OUTPUT`, and the state transitions to _completed_.

** In State _decrypt_, only  ``ace.exec`` instructions of Form A are allowed. +
 ```ace.exec OUTPUT, Kn|K(Xn), INPUT``` absorbs the ciphertext `INPUT` into the `tag`, then decrypts `INPUT` into `OUTPUT`, namely:
+
--
  . If `ctr == ones(c-1)`, then
  .. the CR is *invalidated*.
  . else
  .. `absorb(INPUT)`.
  .. `OUTPUT  <- INPUT xor enc_blk(key, IV @ ctr)`.
  .. `ctr <- ctr + 1 % 2^c^`.
--
+
If `IOLEN` is a multiple of `b`, the same behavior applies as in State _encrypt_, namely
the above operations are executed `IOLEN/b` times, decrypting each `b`-bit block of `INPUT` into the corresponding `b`-bit block of `OUTPUT`.

** To transition to State _dec_tag_finalize_, a Form C ``ace.state`` instruction must be used to provide
the following value, which must be set by the software:
+
--
[none]
* `INPUT <- bin(bit_length(AD), b/2) @ bin(bit_length(plaintext), b/2)`

The authentication tag is computed as follows:

. `absorb(INPUT)`.
  . `tag <- tag xor enc_blk(key, ctr[b-1,c] @ zeros(c))`.
--
+
If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.

** To transition to State _hash_verify_, a Form C ``ace.state`` instruction must be used to provide
the value against which the internally computed tag must be compared:
   If the values match, then `aceerror` is set to ace_err_no_error,
   else an ACE error ace_err_auth is raised.
   The state transitions to _completed_.

** Upon completion of `ace.import`, the ACE unit recomputes `hash_key`, i.e.:
  . `hash_key <- enc_blk(key, zeros(b))`.

//

<<ACE-pseudocode-GCM-encryption>> and <<ACE-pseudocode-GCM-decryption>> provide pseudocode for GCM encryption and decryption.

//

[NOTE]
====
GCM security is not compromised if `H` is revealed.
Consequently, an implementation of GCM based on an ECB mode CC would be acceptable, for instance as in <<ACE-pseudocode-GCM-encryption-alternate>>.
However, this significantly increases code size and requires support for carry-less multiplication, which may not be available in all hardware.

Furthermore, a GCM implementation is necessary to support the use case where the IV is also set in advance and not modifiable by the user.
Thus, we need to be able to configure a GCM CC with both secret key and the IV.
This is described in the next section.
====

//

[[ACE-GCM-with-IV-mode]]
===== GCM with Set IV

The mode of operation “GCM with a Set IV” is a variant of the GCM mode where the initialization vector (IV) is predefined and not generated randomly.
This variant _cannot_ be emulated with an ECB CC because it would reveal the internal data.

A key difference between GCM and GCM with Set IV is in the format of the Provisioning Input:

* *Provisioning Input* (Content):
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
|  Pos. | Size in Bytes   | Field
|   i   | `k`/8 or 8      | `key` or System Key index
|  ii   | (``b``-``c``)/8 | `IV`
|  iii  | (Padding)       | Zero padding
|===
--
+

* *Internal State* (Content): {empty} +
Same as for GCM.

* *Serialized Content*: {empty} +
Same as for GCM.

* *States and Allowed Transitions:* {empty} +
Same as for GCM.

* *State Machine Behavior:* {empty} +
The differences with respect to GCM are:

 ** To transition to State _hash_absorb_:
 The ``ace.state`` instruction shall be of Form A, i.e., _without any additional inputs_, since the IV is already included in the PI.
 ** When transitioning back to State _hash_initial_:
 The CR's `IV` field is _not_ reset to zero.

NOTE: For all the following IV- or nonce-based modes, versions with a set IV or nonce (such as for GCM-SIV) can also be similarly defined.
For instance, for GCM-SIV (<<ACE-GCM-SIV-mode>>), `nonce` would be included in the PI exactly as `IV` is included in the PI for GCM, and the transition to _hash_absorb_ would also use a Form A ``ace.state``.
All other semantics would be unchanged.

//

[[ACE-GCM-SIV-mode]]
===== GCM-SIV Mode

The GCM-SIV mode is described in cite:[DBLP-journals-iacr-GueronLL17] and cite:[RFC8452].
While GCM-SIV's decryption state machine is similar to the GCM's, the encryption state machine is different:

* During encryption, the _hash_absorb_ state absorbs the entire associated data and plaintext. The _enc_tag_finalize_ state then absorbs the lengths and produces the SIV/tag. Finally, the _encrypt_ state performs a second pass to encrypt the plaintext using the SIV/tag as the initialization vector.
* During decryption, the _hash_absorb_ state absorbs only the associated data. The _decrypt_ state decrypts the ciphertext and simultaneously absorbs the plaintext into the hash. Finally, the _dec_tag_finalize_ state absorbs the lengths, produces the SIV/tag, and internally compares it to the provided SIV/tag.

//

Parameters:::

* `k` = key size (64|`k`).
* `b` = block size, (64|`b`). For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* It must be `k = b` or `k = 2b`.
* It must be established by the algorithm whether the authentication tag is `b` or `3b/4` bits long.
//* `c` = counter size (8|`b`). It must be `c < b`.

Data Structures:::

* *Provisioning Input* (Content):
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | `k`/8 or 8      | `key` or System Key index
|===
--
+

* *Internal State* (Content):
 ** `key`, `enc_key`: `k` bits.
 ** `auth_key`: `b` bits.
 ** `nonce`: `3b/4` bits.
 ** `ctr`: `b/4` bits.
 ** `tag`: `b` bits.
 ** `SIV`: `b` or `3b/4` bits.
+
A `b`-bit `SIV` is computed by clearing the most significant bit of `tag` and encrypting it. +
For a `3b/4`-bit `SIV`, a full `b`-bit `tag` value is kept while absorbing data.
The public `SIV` value is computed by clearing the most significant bit of `tag`, encrypting it, and then removing the `b/4` least significant bits.

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
|  Pos. | Size in Bytes   | Field
|    i  | `k`/8 or 8      | `key` or System Key index
|   ii  | 3``b``/32       | `nonce`
|  iii  | `b`/32          | `ctr`
|   iv  | `b`/8           | `tag`
|    v  | `b`/8           | `SIV`
|===
--
+

NOTE: The internal state fields `enc_key` and `auth_key` are not serialized, and must be recomputed upon each `ace.import`.

//

Algorithm-Specific Functions:::

* `enc_blk(key, p) -> c` encrypts block `p` using the key, and returns the result `c`.
* `absorb(data)` absorbs data into the hash function by performing a step of (a variant of) GHASH or POLYVAL as specified by the algorithm
   (for instance, AES-GCM-SIV uses POLYVAL):
  . `tag <- tag xor INPUT`.
  . `tag <- Montmul(tag, hash_key)` or `Galoismul(tag, hash_key)`, depending on the algorithm.

State Machine:::
* *States:*
 ** _initial_: The CC is ready.
 ** _set_aux_value:_ Set the value of `nonce`.
 ** _hash_absorb_: Set the SIV and process AD and, if encrypting, also the plaintext into the tag.
 ** _encrypt_: Encrypt the plaintext.
 ** _enc_tag_finalize_: Finalize the tag with the AD and PT lengths, prepare to return its value.
 ** _decrypt_: Absorb the ciphertext into the tag and decrypt it.
 ** _dec_tag_finalize_: Finalize the tag with the AD and CT lengths, then compare it against the `SIV`.
 ** _completed_: The algorithm has completed its operation.

* *Allowed State Transitions:*
 ** _initial_ -> _set_aux_value_ -> _hash_absorb_.
 ** For encryption: _hash_absorb_ -> _enc_tag_finalize_ -> _encrypt_.
 ** For decryption: _hash_absorb_ -> _decrypt_ -> _dec_tag_finalize_ -> _completed_.
 ** Transition to _encrypt_ possible only if encryption is allowed.
 ** Transition to _decrypt_ possible only if decryption is allowed.

* *Behavior:*
 ** In State _initial_ :
  *** Upon entering the state, the following initialization operations are performed:
   . (`enc_key`, `auth_key`) `<-` `RFC8452_RFC8452_KeyDeriv(key)`,
   . `nonce`, `ctr`, `tag`, `SIV <- 0`.
 *** No {nbsp}``ace.exec``{nbsp} operation is allowed.

 *** Upon issuing a Form C ```ace.state Kn|K(Xn), #ace_state_set_aux_value, INPUT``` :
  *** The value of `nonce` is set to `INPUT`.
  *** (If the instruction is repeated, there is no harm, since it just overwrites the `nonce` before any other operation is performed.)

  ** In State _set_aux_value:
*** Upon issuing a Form C ```ace.state Kn|K(Xn), #ace_state_hash_absorb, INPUT```:
+
--
**** The value of `SIV` is set to `INPUT`.
--
+
NOTE: This version of the instruction is meant to be used during decryption.
      It is harmless to invoke it during encryption, however, as the `SIV` field will be overwritten later with the correct synthetic value.

*** Upon issuing a Form A ```ace.state Kn|K(Xn), #ace_state_hash_absorb```:
+
--
**** The `SIV` is not modified (it is assumed to be already zero).
--
+
NOTE: This version of the instruction is meant to be used during encryption.
      If used during decryption, by leaving the `SIV` to zero it will most likely lead to an authentication error.

 ** In State _hash_absorb_, only Form B of ``ace.exec`` is allowed.
   This instruction absorbs its `INPUT` in the `tag`, i.e., it performs `absorb(INPUT)`. +
   If `IOLEN` is a multiple of `b`, `absorb()` is executed on each of the `IOLEN/b` blocks in `INPUT`.

** In State _enc_tag_finalize_, only an {nbsp}``ace.exec``{nbsp} instruction of Form A is allowed.
The value
+
--
[none]
  *** `INPUT <- bin(bit_length(AD), b/2) @ bin(bit_length(plaintext), b/2)`,
--
+
is set by the user.
Then, “```ace.exec```” finalizes the SIV/tag computation by performing:
+
--
  . `absorb(INPUT)`.
  . `tmp <- enc_blk(enc_key, 0 @ (tag xor N)[b-2:0])`
  . If tag length is `b` bits, then
   .. `SIV <- tmp` and `OUTPUT <- tmp`,
  . else (tag length is `3b/4` bits)
   .. `SIV <- tmp[b-1:b/4]` and `OUTPUT <- (tmp >> b/4)`.
--
+

If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.

 ** In State _encrypt_, only Form A of ``ace.exec`` is allowed, namely “```ace.exec OUTPUT, Kn|K(Xn), INPUT```,” to encrypt `INPUT` into `OUTPUT` as follows:
+
--
. If `ctr == 0`, then the CR is *invalidated*.
   . If the `SIV` is `b`-bits long, then
     .. ``OUTPUT <- INPUT `` +
        ``{fournbsp}{fournbsp}xor enc_blk(enc_key, 1 @ SIV[b-2:b/4] @ (SIV[b/4-1:0] + ctr % 2^b/4^)),``
   . else (the `SIV` is `3b/4`-bits long)
      .. ``OUTPUT <- INPUT xor enc_blk(enc_key, 1 @ SIV[3b/4-2:0] @ ctr)``.
   . `ctr <- ctr + 1`.
--
+
If `IOLEN` > `b`, the above operations are applied to each of the `IOLEN/b` blocks in `INPUT`.

 ** In State _decrypt_,  only Form A of ``ace.exec`` is allowed. “```ace.exec OUTPUT, Kn|K(Xn), INPUT```” decrypts `INPUT` into `OUTPUT` and then absorbs the plaintext `OUTPUT` into the `tag`:
+
--
     . If `ctr == 0`, then the CR is *invalidated*.
     . If the `SIV` is `b`-bits long, then +
       .. ``OUTPUT <- INPUT `` +
          ``{fournbsp}{fournbsp}xor enc_blk(enc_key, 1 @ SIV[b-2:b/4] @ (SIV[b/4-1:0] + ctr % 2^b/4^))``,
     . else (it is `3b/4`-bits long) +
       .. ``OUTPUT <- INPUT xor enc_blk(enc_key, 1 @ SIV[3b/4-2:0] @ ctr``.
     . `absorb(OUTPUT)`.
     . `ctr <- ctr + 1`.
--
+
If `IOLEN` > `b`, the above operations are applied to each of the `IOLEN/b` blocks in `INPUT`.

 ** In State _dec_tag_finalize_,
   only an ``ace.exec`` instruction of Form B, is allowed,
   namely “```ace.exec Kn|K(Xn), INPUT```,” where it is the responsibility of the user to set
+
--
[none]
  ***  `INPUT <- bin(bit_length(AD), b/2) @ bin(bit_length(plaintext), b/2)`.
--
+
``ace.exec`` then performs the following operations:
+
--
  . `absorb(INPUT)` (which modifies `tag`).
  . `tmp <- enc_blk(enc_key, 0 @ (tag xor N)[b-2:0])`.
  . If tag length is `b` bits, then
     .. `tag <- tmp`,
  . else (tag length is `3b/4` bits)
     .. `tag <- tmp[3b/4-1:0] @ zeros(b/4)`.
     .. If `tag` and `SIV` match, then
     ... `aceerror` <- ace_err_no_error,
     .. else
     ... `aceerror` <- ace_err_auth.
  . The state transitions to _completed_.
--
+
If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.

 ** Upon completion of `ace.import`, the ACE unit recomputes `enc_key` and `auth_key`, i.e.:
  . (`enc_key`, `auth_key`) <- `RFC8452_RFC8452_KeyDeriv(key)`.

//

Encryption and decryption pseudocode is found in <<ACE-GCM-SIV-mode-examples>>.

//

[[ACE-OCB-mode]]
===== OCB Mode

We only architect the OCB3 variant of OCB as specified in RFC{nbsp}7253 cite:[RFC7253] and cite:[DBLP-journals-joc-KrovetzR21].
While this algorithm is asymptotically more efficient than GCM and GCM-SIV, it has a much heavier setup and its exported state requires significantly more memory than the other modes.
On the other hand, since it uses only a single key and no derived keys, with ciphers with an expensive key expansion
like the AES it may use fewer internal resources.

The state machine of this algorithm closely follows RFC{nbsp}7253 (except for the numbering of the bit fields, which is big endian in the RFC).
The algorithm is identical to the RFC for 128-bit-wide block ciphers, with a straightforward generalization to other widths according to the security proof of the original algorithm and a lower bound on nonce length following cite:[cryptoeprint-2023-326].

Parameters:::
+
--
* `b` = block size. `b` is a power of two, and {ge} 64. For OCB, we require `IOLEN` to be an integer multiple of `b`.
* `k` = key size, `b`|`k`.
--
+
Also, define `g` = `log_2(b)`.

Data Structures:::

* *Provisioning Input* (Content):
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | `k`/8 or 8      | `key` or System Key index
|===
--
+

* *Internal State* (Content):
 ** `key`: `k` bits.
 ** `N`: `u+1` bits (at most `u` bits are all used).
 ** `L`, `offset`, `hash_A`, `hash_P` : `b` bits.
 ** `N_len`, `tag_len`, `last_blk_len`: `g` bits.

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
|  Pos. | Size in Bytes          | Field
|    i  | `k`/8 or 8             | `key` or System Key index
|   ii  |  `b`/8                 | `N`
|  iii  |  `b`/8                 | `L` (only `u+1` bits used)
|   iv  |  `b`/8                 | `offset`
|    v  |  `b`/8                 | `hash_A`
|   vi  |  `b`/8                 | `hash_P`
|  vii  |  `2`                   | `tag_len`
| viii  |  `2`                   | `last_blk_len`
|   ix  |  `2`                   | `N_len`
|    x  |  `2`                   | Padding
|===
--
+

//

Algorithm-Specific Functions:::

* `enc_blk(K,p) -> c` encrypts block `p` using the key `K` and returns the result `c`.
* `dec_blk(K,c) -> p` decrypts block `c` using the key `K` and returns the result `p`.
* `double(S)`:
Let `C` be  `0x1B` for `b` = 64, `0x87` for `b` = 128, and `0x425` for `b` = 256, then:
+
[none]
** If S[`b`-1] == 0, then { `double(S)` <- `S << 1` } else { `double(S)` <- `(S << 1) xor C` } .

State Machine:::
* *States:*
 ** _initial_: The CC is ready.
 ** _set_aux_value:_ Set the length and the value of the nonce.
 ** _hash_absorb_: Set the tag length, and process the AD.
 ** _hash_finalize_: Set the length of the final block of the AD and process it.
 ** _encrypt_: Process the plaintext by absorbing it into the tag and encrypting it.
 ** _enc_last_block_: Provide the last block of the plaintext, then process it.
 ** _enc_tag_finalize_: Return the tag.
 ** _decrypt_: Process the ciphertext by decrypting it and absorbing the plaintext into the tag.
 ** _dec_last_block_: Provide the last block of the ciphertext, then process it.
 ** _hash_verify_: Compare a user-provided value with the internally computed tag.
 ** _completed_: The algorithm has completed its operation.

* *Allowed State Transitions:*
 ** _initial_ -> _set_aux_value_ -> _hash_absorb_ -> _hash_finalize_
 ** _hash_finalize_ -> _encrypt_, if encryption is allowed.
 ** _hash_finalize_ -> _decrypt_, if decryption is allowed.
 ** _encrypt_ -> _enc_last_block_ -> _enc_tag_finalize_ -> _completed_.
 ** _decrypt_ -> _dec_last_block_ -> _hash_verify_ -> _completed_.

* *Behavior:*
** In State _initial_ :
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
  *** The following initialization operations are performed:
   . `N <- 1 @ zeros(u)`.
   . `hash_A <- zeros(b)`
   . `hash_P <- zeros(b)`

** To move to _set_aux_value_, a Form B `ace.state` must be used, where the auxiliary argument `Xs` sets the nonce length `N_len`.
 `N_len` must be at least `g-1`. If not, ACE error ace_err_invalid_value is raised, and the CR is *invalidated*.

** In State _set_aux_value_, only  ``ace.exec`` instructions of Form B, “```ace.exec Kn|K(Xn), INPUT```”, are allowed, whereby `N` is set to `INPUT`, namely
     `N <- zeros(u-N_len) @ INPUT[N_len-1:0]`
  *** If “```ace.exec Kn|K(Xn), INPUT```,” is repeated, it will rewrite `N`.
  *** If no such `ace.exec` is issued, `N` is not changed, which means that its most significant bit is 1.
      This condition results in an error when transitioning to _hash_absorb_.

** To move to _hash_absorb_, a Form B `ace.state` must be used, where the auxiliary argument `Xs` sets the tag length `tag_len`.
  *** If this argument (interpreted as an unsigned value) is larger than `b` or is equal to `0` (the latter occurs also if `X0` is passed as the auxiliary argument), an ace_err_invalid_value error is raised, and the CR is *invalidated*.
  *** If `N[u] == 1`, this means that `N` was not set in State _set_aux_value_. We do not allow code that skips nonce setting, as this mode is not secure under nonce reuse, therefore in this case ACE error ace_err_invalid_value is raised, and the CR is *invalidated*.
  *** Following operations are performed:
  . `tag_len` <- `Xs`.
  . `offset <- zeros(b)`
  . `L <- enc_blk(key, zeros(b))`
  . `L <- double(double(L))`

** In State _hash_absorb_, only  ``ace.exec`` instructions of Form B are allowed:
  “```ace.exec Kn|K(Xn), INPUT```” absorbs a data block in `tag`, i.e.:
+
--
    . `L <- double(L)`
    . `offset <- offset xor L`
    . `hash_A <- hash_A xor enc_blk(key, INPUT xor offset)`
--
+
If `IOLEN` > `b`, the above operation is executed `IOLEN/b` times.

** To move to _hash_finalize_, a Form B `ace.state` operation sets the length of the final block of the AD in `last_blk_len`.

** In State _hash_finalize_, only one `ace.exec` instruction of Form B is allowed if `last_blk_len` != `0`.
 “```ace.exec Kn|K(Xn), INPUT```” which absorbs the last data block in `tag`, i.e.:
+
--
  * `tmp : bits(b)`

[]
  . `offset <- offset xor enc_blk(key, zeros(b))`
  . `tmp <- (zeros(b-last_blk_len-1) @ 1 @ INPUT[last_blk_len-1:0]) xor offset`
  . `hash_A <- hash_A xor enc_blk(K, tmp)`
--
+
If `last_blk_len` == 0, however, no `ace.exec` can be executed, and only an `ace.state` instruction is allowed to enter State _encrypt_ or _decrypt_.

** Upon entering states `_encrypt_` or `_decrypt_`, the “setup” and “init” stages of the OCB algorithm are performed:
+
--
 * `N_ext : bits(b)` (`N_ext` means “N, extended”)
 * `Stretch : bits(3b/2)`
 * `bot : bits(g-1)`
 * `Ktop : bits(b)`

[]
 . `offset <- zeros(b)`
 . `L <- enc_blk(key, zeros(b))`
 . `L <- double(double(L))`
 . `N_ext <- N[N_len-1:0] @ 1 @ zeros(b-g-1-N_len) @ bin(tag_len,g)`
 . `bottom <- int(N_ext[b-1:b-g+1])`  // Rogaway numbers the bits in the opposite order.
 . `Ktop <- enc_blk(key, zeros(g-1) @ N_ext[b-g:0])`
 . `Stretch <- (Ktop[b/2-1:0] xor Ktop[b/2+7:8]) @ Ktop`
 . `offset <- Stretch[b+bottom:bottom]`
--
+
** In State _encrypt_, only ``ace.exec`` instructions of Form A are allowed:
   “```ace.exec OUTPUT, Kn|K(Xn), INPUT```” absorbs the plaintext `INPUT` into the `tag` and encrypts `INPUT` into `OUTPUT`, namely:
+
--
 . `L <- double(L)`
 . `offset <- offset xor L`
 . `hash_P <- hash_P xor INPUT`
 . `OUTPUT <- offset xor enc_blk(key, INPUT xor offset)`
--
+
If `IOLEN > b`, the above operation sequence is executed `IOLEN/b` times, encrypting each `b`-bit block of `INPUT` into the corresponding `b`-bit block of `OUTPUT`.

** To move to _enc_last_block_, a Form B `ace.state` instruction must be used to set the bit length of the final block of the plaintext in `last_blk_len`.

** In State _enc_last_block_, only an ``ace.exec`` instruction of Form A “```ace.exec OUTPUT, Kn|K(Xn), INPUT```,” is allowed if `last_blk_len` is nonzero.
In this case, following operations are performed:
+
--
 * `tmp : bits(last_blk_len)`
 * `tmp2 : bits(b)`
 * `aux : bits(b)`

[]
 . `aux <- enc_blk(key, zeros(b))`
 . `offset <- offset xor aux`
 . `tmp <- enc_blk(key, offset)[last_blk_len-1:0]`
 . `tmp <- INPUT[last_blk_len-1:0] xor tmp`
 . `OUTPUT <- zeros(b-last_blk_len) @ tmp`
 . `tmp2 <- (zeros(b-last_blk_len-1) @ 1 @ tmp) xor offset`
 . `aux <- double(aux)`
 . `hash_P <- enc_blk(key, hash_P xor tmp2 xor offset xor aux) xor hash_A`
--
+
On the other hand, if `last_blk_len` is zero, only an ``ace.exec`` instruction of Form D, “```ace.exec Kn|K(Xn)```,” is allowed, which performs:
+
--
* `aux : bits(b)`

[]
  . `aux <- enc_blk(key, zeros(b))`
  . `aux <- double(aux)`
  . `hash_P <- enc_blk(key, hash_P xor offset xor aux) xor hash_A`
--
+
In both cases the state then transitions to _enc_tag_finalize_.

** In State _enc_tag_finalize_, only an ``ace.exec`` instruction of Form C, “```ace.exec OUTPUT,Kn|K(Xn)```,” is allowed, which
performs `OUTPUT <- zeros(b-tag_len) @ hash_P[tag_len-1:0]`.

** In State _decrypt_, only ``ace.exec`` instructions of Form A are allowed.
    Such an ``ace.exec`` decrypts `INPUT` into `OUTPUT`, and absorbs the plaintext `OUTPUT` into the `tag`, namely:
+
--
  * `tmp : bits(b)`

[]
  . `L <- double(L)`
  . `offset <- offset xor L`
  . `tmp <- offset xor enc_blk(key, INPUT xor offset)`
  . `hash_P <- hash_P xor tmp`
  . `OUTPUT <- tmp`
--
+
If `IOLEN` > `b`, the same behavior applies as in State _encrypt_.

** To move to State _dec_last_block_, a Form B `ace.state` operation must be used to also contextually set the bit length of the final block of the ciphertext in `last_blk_len`.

** In State _dec_last_block_, only an ``ace.exec`` instruction of Form A “```ace.exec OUTPUT, Kn|K(Xn), INPUT```,” is allowed if `last_blk_len` is nonzero.
In this case, the same operations as in State _enc_last_block_ are performed except for Line 6, which is instead
+
--
[start=6]
. `tmp2 <- (zeros(b-last_blk_len-1) @ 1 @ INPUT[last_blk_len-1:0]) xor offset`
--
+
and the state is changed to _hash_verify_.
+
If `last_blk_len` is zero, only an ``ace.exec`` instruction of Form D, “```ace.exec Kn|K(Xn)```,” is allowed, which performs the same operations as in State _enc_last_block_, except for the final state transition, which also in this case is to _hash_verify_.

** To complete the algorithm in the decryption branch, a Form C ``ace.state`` operation must be used to (confirm the)
transition to State _hash_verify_ and compare the `tag_len` least significant bits of `INPUT` with the `tag_len` least significant bits of `hash_P`:
+
--
  . If the values match, then `aceerror` is set to ace_err_no_error,
  . else `aceerror` is set to ace_err_auth.
  . The state transitions to _completed_.
--
+

//

Pseudocode for OCB encryption is given in <<ACE-OCB-mode-examples>>.

//

[[ACE-CMAC-mode]]
===== CMAC Functions

{empty}
(((ACE, algorithm, CMAC)))
CMAC is an algorithm for message authentication codes constructed from a block cipher.
It was designed by Tetsu Iwata and Kaoru Kurosawa and became a NIST Recommendation in May 2005 cite:[nist-SP-800-38B].

Parameters:::

* `b` = block size (8|`b`).  For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = key size (8|`k`).

Data Structures:::

* *Provisioning Input* (Content):
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | `k`/8 or 8      | `key` or System Key index
|===
--
+

* *Internal State* (Content):
 ** `key`: `k` bits.
 ** `hash`: `b` bits.
 ** `last_block_len`: 64 bits.

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
|  Pos. | Size in Bytes   | Field
|    i  | `k`/8 or 8      | `key` or System Key index
|   ii  | `b`/8           | `hash`
|  iii  | `8`             | `last_block_len`
|===
--
+

//

Algorithm-Specific Functions:::

* `enc_blk(key, p) -> c` encrypts block `p` using the key `key`, and returns the result `c`.
* `gen_subkeys(K) -> (K1,K2)` generates subkeys `K1` and `K2` from the master key `K` as follows: +
Let `C` be `0x1B` for `b` = 64, `0x87` for `b` = 128, and `0x425` for `b` = 256, then

 . `L <- enc_blk(K, zeros(b))`
 . if (`msb(L){nbsp}{nbsp}== 0`) then
   { `K1 <- L{nbsp}{nbsp}<< 1` }
   else
   { `K1 <- (L{nbsp}{nbsp}<< 1) xor C` }.
 . if (`msb(K1){nbsp}== 0`) then
   { `K2 <- K1{nbsp}<< 1` }
   else
   { `K2 <- (K1{nbsp}<< 1) xor C` }.
 . return ```(K1, K2)```.

State Machine:::

* *States:*
 ** _initial_: The CC is ready.
 ** _hash_absorb_: Absorb data into the CMAC function.
 ** _hash_last_block_: Set the length of the last block to absorb, then absorb it.
 ** _hash_output_: Output the CMAC.
 ** _completed_: The CC has completed the CMAC operation.

* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_ -> _hash_last_block_ -> _hash_output_ -> _completed_.
 ** From any valid state to State _initial_.
* *Behavior:*
 ** In State _initial_:
  *** `last_block_len <- zeros(64)`
  *** `hash <- zeros(b)`
  *** No {nbsp}```ace.exec```{nbsp} operation is allowed.

 ** In State _hash_absorb_, we can only issue ``ace.exec`` instructions of Form B. +
 “```ace.exec Kn|K(Xn), INPUT```,” absorbs the data block `INPUT` into the hash as follows:
+
--
   . `hash <- enc_blk(key, hash xor INPUT)`.
--
+
If `IOLEN` > `b`, then the above operations are applied to each `b`-bit block of `INPUT`.

 ** Upon issuing a Form B “```ace.state Kn|K(Xn), #ace_state_hash_last_block, Xs```” where `Xs` contains the bit length of the last block, the following happens:
   . if `last_block_len` != 0, then the CR is *invalidated*. (The previous block is not complete.)
   . if `Xs > b` then the CR is *invalidated*.
   . `last_block_len <- Xs`.

 ** In State _hash_last_block_,  we can only issue a single ``ace.exec`` instruction of Form B, i.e., “```ace.exec Kn|K(Xn), INPUT```”, to absorb the data block `INPUT`. If `IOLEN` > `b`, only the least significant `b` bits of `INPUT` are considered.
+
--
  . `(K1, K2) <- gen_subkeys(key)`.
  . if `last_block_len` == `b`, then {
    .. `tmp <- hash xor INPUT xor K1`
  . } else {
    .. `tmp <- INPUT`
    .. Remove the `b` - `last_block_len` most significant bits of `tmp` and pad the resulting value with a `1` and sufficiently many `0` bits to make it `b` bits long.
    .. `tmp <- hash xor tmp xor K2` }
  . `hash <- enc_blk(key, tmp)`
  . The state is changed to _hash_output_.
--
+

** In State _hash_output_, we can issue one ``ace.exec`` instruction of Form C, i.e., “```ace.exec OUTPUT, Kn|K(Xn)```”, to output the hash into `OUTPUT`.
   If `IOLEN` > `b`, only the bits of `OUTPUT` beyond the `b`-th are cleared.
   Upon issuing that instruction, the CC transitions to State _completed_ with no error.

//

Pseudocode is given in <<ACE-CMAC-mode-example>>.

//

[[ACE-hash-functions]]
===== Hash and MAC Functions, and XOFs

{empty}
(((ACE, algorithm, general hashing)))
(((ACE, algorithm, MAC functions)))
(((ACE, algorithm, XOF)))
This section defines an interface for hash and MAC functions.
A completely general interface cannot be defined because of the variety of constructions.
However, the one given here is sufficiently general to allow describing most common functions, such as, for instance, the SHA2 cite:[nist-fips-180-4], SHA3 and SHAKE cite:[nist-fips-202], as well as HMAC cite:[nist-fips-198-1].

Parameters:::

* `b` = block size (8|`b`). This is the size of an absorbed block and may be different from the size of the internal state that is kept by the function. For a sponge function, this value is the _rate_.
* `t` = tag len (8|`t`). This is the size of the digest, or of the block that is output each time in a XOF. The present description assumes `t` {le} `b`.
* `n` = size of the internal state that is kept by the function (8|`n`).  For a sponge function, `n-b` is the _capacity_ of the function.
Either the block size is an integer multiple of the vector length or the vector length is an integer multiple of the block size.
* `k` = key size (8|`k`). Present only if keyed, i.e., a MAC.

Data Structures:::

* *Provisioning Input* (Content):
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes            | Field
|   i  | If keyed: `k`/8 or 8     | `key` or System Key index
|===
--
+

* *Internal State* (Content):
 ** `key`: `k` bits. Present only if keyed, i.e., a MAC.
 ** `state`: `n` bits.
 ** `last_block_len`: int. Present only if this Hash/MAC provides special treatment for a last block that goes beyond padding and appending the length.
  The latter must be handled by user software instead.
 ** `input_base`: int. Offset within input/output to read from/write to.
 ** `block_base`: int. Length of absorbed data so far for the current block. Only if needed by the algorithm.
 ** `cumul_len`: int. Cumulative length of data absorbed so far (if the algorithm must process and incorporate it in the hash on its own).
 ** `block`: `b` bits.  Included only if a partial block must be maintained—for instance when the inputs are not directly absorbed into `state`.

* *Serialized Content*:
+
--
[cols="^6%,^19%,<25%,<50%",options="header"]
|===
|  Pos. | Size in Bytes            | Field                       | Notes
|    i  | If keyed: `k`/8 or 8     | `key` or System Key index   | --
|   ii  | `n`/8                    | `state`                     | --
|  iii  | `2`                      | `last_block_len`            | Only if this Hash/MAC has special internal treatment for a fractional last block that goes beyond padding and appending the length, which are handled by user software. Otherwise, this is zero.
|   iv  | `2`                      | `block_base`                | Amount of data stored so far into `block`.  Only if used by the algorithm, else zero padding.
|    v  | `4`                      | `cumul_len`                 | Cumulative length of all data absorbed so far. Only if the algorithm must process and incorporate it in the hash on its own, else zero padding.
|   vi  | `b`/8                    | `block`                     | It is included it the SCC only if there is a partial block, and the block must be stored separately from the `state`, and exclude it when not.
We reuse the most significant bit of the `state` field to store this information.
(In theory, we could include only the part filled so far, but this would complicate the parsing of an SCC.)
|===
--
+

//

NOTE: Regarding the `last_block_len`/`block_base`/`cumul_len` group: if any of these fields is not used, it is replaced by a corresponding padding block.
If all three are not used by the hashing algorithm, then the 64-bit block is omitted, and `block` (if included) follows immediately `state`.

Algorithm-Specific Functions:::

* `absorb()`: Process `block` into the hash or MAC.
* `absorb_last_block()`: Process `block` into the hash or MAC, using a function for the last block.
* `finalize()`: Process the `state` into the digest value. We assume this either re-uses `block` (the entire digest, or a unit of XOF output should not be bigger than that) or the digest will be part of `state`.
* `update()`: Updates the `state` during the digest output stage.

State Machine:::

* *States:* _initial_, _hash_absorb_, _hash_last_block_, _hash_output_ and _completed_.

 ** _initial_: The CC is ready.
 ** _hash_absorb_: Absorb data into the hash function.
 ** _hash_last_block_: Set the length of the last block to absorb, then absorb it.
 ** _hash_output_: Output the hash.
 ** _completed_: The CC has completed the operation (XOFs do not have this state).

* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_ -> _hash_last_block_ -> _hash_output_ -> _completed_.
 ** From any valid state to State _initial_.

* *Behavior:*
 ** In State _initial_:
  *** `last_block_len`, `block_base` and `block` are set to zero.
  *** `state`: the initial value is set as specified by the algorithm.
  *** Any `ace.exec` will result in the CR being *invalidated*.

 ** In State _hash_absorb_, we can only issue ``ace.exec`` instructions of Form B, i.e., +
 “```ace.exec Kn|K(Xn), INPUT```”, to absorb the data block `INPUT` into the hash as follows.
+
--
  . `input_base <- 0` // or `acestart` upon resumption
  . while `(input_base < IOLEN)` do { // as long as we have input to process
  .. `amount <- min(IOLEN-input_base, b-block_base)`
  .. ``block[block_base + amount - 1 : block_base] <-`` +
      ``{nbsp}{nbsp}{nbsp}{nbsp} <- INPUT[input_base + amount - 1 : input_base]`` +
        ``{nbsp}{nbsp}``(If there is no `block` field, could also be something like +
        ``{fournbsp}state[block_base + amount - 1 : block_base] <- `` +
        ``{fournbsp}{fournbsp}{nbsp}<- state[block_base + amount - 1 : block_base] + `` +
        ``{fournbsp}{fournbsp}{nbsp}+ INPUT[input_base + amount - 1 : input_base]`` , +
        ``{nbsp}{nbsp}{nbsp}``it could directly replace part of `state`, or some other function.)
  .. `input_base <- input_base + amount`
  .. `block_base <- block_base + amount`
  .. if (`block_base` == `b`) then { // it's time to absorb the block
  ... `absorb()`
  ... `block_base <- 0`
  ... *Here* the instruction may be interrupted, with `acestart <- input_base`.

[none]
  . }``{nbsp}{nbsp}`` }
--
+

//
 ** Upon issuing a Form B “`ace.state Kn|K(Xn), #ace_state_hash_last_block, Xs`” where `Xs` contains the length of the last block, the following happens:
+
--
 . if `block_base` != 0, then the CR is *invalidated*. (The previous block is not complete.)
 . if `Xs > b`, then the CR is *invalidated*.
 . if `Xs == 0`, then the CR is *invalidated*.
 . `last_block_len <- Xs`.
--
+
Then, state transitions to _hash_last_block_ as expected.

 ** State _hash_last_block_ is very similar to _hash_absorb_, the differences being:
  *** `last_block_len` is used in place of `b` throughout.
  *** `absorb_last_block()` is called instead of `absorb()` in Step 3.d.i.
  *** The instruction is terminated after `absorb_last_block()`—only one block is absorbed—and the state transitions to _hash_output_.

 ** In State _hash_output_ we have two possible situations: we are in a hash function or a XOF.
  *** Upon entering the state, the following operations are first performed:
  . `block[t - 1 : 0] <- finalize()`
  . `block_base <- 0`
 *** For each Form C `ace.exec` instruction “`ace.exec OUTPUT, Kn|K(Xn)`”, the following operations are performed:
+
--
    * `amount : int`, `{nbsp}` amount of data to copy from `block` to `OUTPUT`
    * `#define output_base input_base`

[]
   . `output_base <- 0` // or `acestart` upon resumption
    . while (`output_base` < `IOLEN`) do { // as long as there is room in the OUTPUT
     .. `amount` <- `min(IOLEN - output_base, t - block_base)`
     .. ``OUTPUT[output_base + amount - 1 : output_base] <- `` +
           ``{fournbsp}{fournbsp}<- block[block_base + amount - 1 : block_base + amount]``
     .. `output_base <- output_base + amount`
     .. `block_base <- block_base + amount`
     .. if (`block_base` == `t`) then {
      ... if we are in a Hash function, transition to _completed_, and return.
      ... `update()`
      ... `block_base <- 0`
      ... *Here* the instruction can be interrupted, with `acestart <- output_base`.

[none]
      . }``{nbsp}{nbsp}`` }
--
+

//

[[ACE-HMAC]]
===== HMAC

Hash function acceleration is sufficient to compute HMACs, and no dedicated algorithms are needed for either performance or security reasons.

//

[[ACE-SHA-3]]
===== SHA-3 Family Specific Rules

{empty}
(((ACE, algorithm, SHA-3)))
We describe here the algorithms for the primitives in the SHA-3 family, which currently includes SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128 and SHAKE256.
These primitives are designed around a special parameter choice of KECCAK cite:[DBLP-conf-eurocrypt-BertoniDPA13] standardized by NIST cite:[nist-fips-202].
These are instantiations of the algorithm specified in <<ACE-hash-functions>>, and we need to
describe only the differences with respect to the behavior described there.

Parameters:::

* `b` = rate (8|`b`). It can be 1600 - `c` with `c` = 448, 512, 768, or 1024 being the capacity.
* `n` = 1600
* `t` = `c/2`

Data Structures:::

* *Provisioning Input* (Content): Empty.

//

* *Internal State* (Content):
 ** `state`: `n` bits.
 ** `last_block_len`: int.
 ** `input_base`: int.
 ** `block_base`: int.

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | 200             | `state`
|  ii  | 2               | `last_block_len`
| iii  | 2               | `block_base`
|  iv  | 4               | Padding
|===
--
+

//

Algorithm-Specific Functions:::
 * `P()`: computes `KECCAK-p[1600, 24]` on `state`.
 * `absorb()`: in this case there is no explicit operation to copy data into `state`, as the inputs will be directly XORed into it, however `absorb` applies `P()` to the state.
 * `absorb_last_block()`: this is a NOP.
 * `finalize()`: this is a NOP.
 * `update()`: updates the `state` during the digest output stage.  It applies `P()` to the state.

State Machine:::
* *States:* _initial_, _hash_absorb_, _hash_last_block_, _hash_finalize_, _hash_output_ and _completed_.

* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_ -> _hash_last_block_ -> _hash_finalize_ -> _hash_output_ -> _completed_.
 ** From any valid state to State _initial_.

* *Behavior:*
 ** In State _initial_, `state` is zeroed.
 ** In State _hash_absorb_, the input data is directly XORed to `state`.
 ** In State _hash_last_block_, the input data is directly XORed to `state`.
 ** Upon transitioning to State _hash_output_:
  . The suffix and padding string `S` is generated.
  . If the bit length of `S` is `b-block_base`:
   .. `S` is directly XORed to rate part of the state, and
   .. `P()` is applied.
  . If the bit length of `S` is `2b-block_base`:
   .. The first `b-block_base` bits are XORed to the rate part of the state,
   .. `P()` is applied,
   .. the remaining `b` bits are XORed to the rate part of the state, and
   .. `P()` is applied again.

The rest of the algorithm follows <<ACE-hash-functions>>.

//

[[ACE-Ascon-AEAD128]]
===== Ascon-AEAD128

{empty}
(((ACE, algorithm, Ascon)))
Ascon is a public permutation cite:[DBLP-journals-joc-DobraunigEMS21] standardized by the NIST cite:[nist-SP-800-232] together with various cryptographic algorithms designed around it.

[WARNING]
====
In all ASCON algorithms, the ordering of the bits must be verified!
====

Ascon-AEAD128 is an AEAD algorithm.
In Ascon-AEAD128, it is the responsibility of the user to apply proper padding to the AD and plaintext.
The inputs are therefore assumed to be properly padded.
Similarly, it is the responsibility of the user to remove the padding from the decryption of the ciphertext to recover the original plaintext.

Parameters:::

* `b` = 128. For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = 128.

Data Structures:::

* *Provisioning Input* (Content):
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | 16 or 8         | `key` or System Key index
|===
--
+

* *Internal State* (Content):
 ** `key`: 128 bits, or 64 bits if it is a System Key index.
 ** `state[0 .. 4]`: five 64-bit words, i.e., 320 bits.
 ** `tag_len`: 8 bits as int.
 ** `last_block_len`: 9 bits as int.
 ** `AD_empty`: Boolean;

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|    i | 16 or 8         | `key` or System Key index
|   ii | 8               | `state`[0]
|  iii | 8               | `state`[1]
|   iv | 8               | `state`[2]
|    v | 8               | `state`[3]
|   vi | 8               | `state`[4]
|  vii | 2               | `last_block_len`
| viii | 2               | `tag_len`
|   ix | 4               | Padding
|===
--
+

Algorithm-Specific Functions:::

* `ASCON(p)` applies `p` rounds of ASCON to the `state`.

State Machine:::

* *States:*
 ** _initial_: The CC is ready.
 ** _hash_absorb_: Set the nonce, and process the AD.

 ** _encrypt_: Encrypt the plaintext.
 ** _enc_last_block_: Encrypt the last block of the plaintext.
 ** _hash_output_: Return the tag.

 ** _decrypt_: Decrypt the ciphertext.
 ** _dec_last_block_: Decrypt the last block of the ciphertext.
 ** _hash_verify_: Compare a user-provided value with the internally computed tag.

 ** _completed_: The algorithm has completed its operation.

* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_.
 **  _hash_absorb_ -> _encrypt_, if encryption is allowed.
 **  _hash_absorb_ -> _decrypt_, if decryption is allowed.
 ** _encrypt_ -> _enc_last_block_ -> _hash_output_ -> _completed_.
 ** _decrypt_ -> _dec_last_block_ -> _hash_verify_ -> _completed_.

* *Behavior:*
** In State _initial_ :
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
  *** The following initialization operations are performed:
   . `state[0] <- 0x00001000808c0001`
   . `state[1] <- key[63:0]`
   . `state[2] <- key[127:64]`
   . `state[3] <- zeros(64)`
   . `state[4] <- zeros(64)`
   . `tag_len <- 128`
   . `AD_empty` <- `true`

** To transition to State _hash_absorb_, a Form C ``ace.state`` must be used, whose `INPUT` sets the nonce of the algorithm as follows:
+
--
  . `state[3] <- INPUT[63:0]`
    . `state[4] <- INPUT[127:64]`
    . `ASCON(12)`
    . `state[3] <- state[3] xor key[63:0]`
    . `state[4] <- state[4] xor key[127:64]`
--
+
If `IOLEN` > 128, only the 128 least significant bits of `INPUT` are considered.

** In State _hash_absorb_, only  ``ace.exec`` instructions of Form B are allowed.
 “```ace.exec Kn|K(Xn), INPUT```” absorbs a data block into the state, i.e.:
+
--
 . `AD_empty` <- `false`
 . `ASCON(8)`
 . `state[0] <- state[0] xor INPUT[63:0]`
 . `state[1] <- state[1] xor INPUT[127:64]`
--
+
If `IOLEN` > 128, this sequence of four operations is executed `IOLEN/128` times, once for each 128-bit block of `INPUT`.
** Upon entering State _encrypt_ or _decrypt_, the following domain separation operation is performed:
 . `lsb(state[4]) <- lsb(state[4]) xor 1`

** In State _encrypt_, only ``ace.exec`` instructions of Form A are allowed.
   “```ace.exec OUTPUT, Kn|K(Xn), INPUT```” encrypts `INPUT` into `OUTPUT`, namely:
+
--
 . `state[0] <- state[0] xor INPUT[63:0]`
 . `state[1] <- state[1] xor INPUT[127:64]`
 . `OUTPUT <- state[1] @ state[0]`
 . `ASCON(8)`
--
+
If `IOLEN` is a multiple of 128, these operations are executed `IOLEN/128` times, encrypting each 128-bit block of `INPUT` into the corresponding 128-bit block of `OUTPUT`.

** In State _enc_last_block_, only one ``ace.exec`` instruction of Form A, to encrypt the last block is allowed.
“```ace.exec OUTPUT, Kn|K(Xn), INPUT```”  performs
+
--
 . `state[0] <- state[0] xor INPUT[63:0]`
 . `state[1] <- state[1] xor INPUT[127:64]`
 . `OUTPUT <- state[1] @ state[0]` // only the 128 lsbs of `OUTPUT` are written to.
 .  The state machine then transitions to State _hash_output_.
--
+
In this state only one 128-bit block is processed. +
The differences between the operation of `ace.exec` in this state and in State _encrypt_ are the absence of the final `ASCON(8)` and the automatic transition to State _hash_output_.

** In State _hash_output_, only one ``ace.exec`` instruction of Form C is allowed, to compute the tag.
“```ace.exec OUTPUT, Kn|K(Xn)```”  performs
+
--
 . `state[2] <- state[2] xor key[63:0]`
 . `state[3] <- state[3] xor key[127:64]`
 . `ASCON(12)`
 . `state[3] <- state[3] xor key[63:0]`
 . `state[4] <- state[4] xor key[127:64]`
 . `OUTPUT <- state[4] @ state[3]` // only the 128 lsbs of `OUTPUT` are written to.
 . The state machine then transitions to State _completed_.
--
+
In this state only one 128-bit block is processed.

** In State _decrypt_, only  ``ace.exec`` instructions of Form A are allowed, i.e.,
 `ace.exec OUTPUT,Kn|K(Xn),INPUT`. This operation performs:
+
--
* `tmp : bits(128)`

[]
. `tmp <- (state[0] xor INPUT[63:0]) @ (state[1] xor INPUT[127:64])`
. `state[0] <- INPUT[63:0]`
. `state[1] <- INPUT[127:64]`
. `ASCON(8)`
. `OUTPUT <- tmp`
--
+
If `IOLEN` is a multiple of 128, these operations are executed `IOLEN/128` times, decrypting each 128-bit block of `INPUT` into the corresponding 128-bit block of `OUTPUT`.

** In State _dec_last_block_, only a Form A ``ace.exec`` instruction is allowed.
“```ace.exec OUTPUT, Kn|K(Xn), INPUT```” performs:
+
--
* `tmp : bits(128)`

[]
. `tmp <- (state[1] xor INPUT[127:64]) @ (state[0] xor INPUT[63:0])`
. `state[0] <- INPUT[63:0]`
. `state[1] <- INPUT[127:64]`
. The state machine transitions to State _hash_verify_
. `OUTPUT <- tmp`
--
+

** In State _dec_tag_finalize_, a Form B `ace.state Kn|K(Xn), #ace_state_dec_tag_finalize, Xs` instruction may be executed, setting
the tag len `tag_len` to the value of `Xs`, provided it is not smaller than 32 and not larger than 128.
If the value is out of bounds, the instruction raises ACE error ace_err_invalid_value and the CR is *invalidated*.

** In State _hash_verify_, only one ``ace.exec`` instruction of Form D is allowed, to verify the tag.
“```ace.exec Kn|K(Xn), INPUT```” performs
+
--
. `state[2] <- state[2] xor key[63:0]`
. `state[3] <- state[3] xor key[127:64]`
. `ASCON(12)`
. `state[3] <- state[3] xor key[63:0]`
. `state[4] <- state[4] xor key[127:64]`
. `INPUT[tag_len-1:0]` is compared to `(state[4] @ state[3])[tag_len-1:0]`.
. If the values match, then `aceerror` is set to ace_err_no_error,
  else ACE error ace_err_auth is raised. The state is changed to _completed_.
--
+

//

[[ACE-Ascon-AEAD128-wsn]]
===== Ascon-AEAD128 with set Nonce

Similarly to GCM with Set IV, Ascon-AEAD128 can also be made into a version with a set nonce.
In this case the State _set_aux_value_ is skipped, and the PI has the following form.

* *Provisioning Input* (Content):
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | 16 or 8         | `key` or System Key index
|  ii  | 16              | `nonce`
|===
--
+

In State _initial_, words 3 and 4 of `state` are initialized thus:

. `state[3] <- nonce[63:0]`
. `state[4] <- nonce[127:64]`

Once in State _completed_, the CC cannot be brought back to State _initial_.

//

[[ACE-Ascon-AEAD128-N-masking]]
===== Ascon-AEAD128 with Nonce Masking

The NIST specification also describes a version of Ascon-AEAD128 with _Nonce Masking_.
This variant is described as follows:

* *Provisioning Input* (Content):
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | 16 or 8         | `K1` or System Key index
|  ii  | 16 or 0         | `K2` or System Key index in `K1`
|===
--
+

* *Internal State* (Content):
 . `K1`: 128 bits, or 64 bits if it is a System Key index.
 . `K2`: 128 bits, omitted if a System Key is used.
 ** `state[0 .. 4]`: five 64-bit words, i.e., 320 bits.
 ** `tag_len`: 8 bits.

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
|  Pos. | Size in Bytes   | Field
|    i  | 16 or 8         | `K1` or System Key index
|   ii  | 16 or 0         | `K2` or System Key index in `K1`
|  iii  | 8               | `state`[0]
|   iv  | 8               | `state`[1]
|    v  | 8               | `state`[2]
|   vi  | 8               | `state`[3]
|  vii  | 8               | `state`[4]
| viii  | 2               | `tag_len`
|   ix  | 6               | Padding
|===
--
+

The algorithm has the same states as Ascon-AEAD128 as described in <<ACE-Ascon-AEAD128>>, with the key `key` equal to `K1` and the nonce `N` replaced throughout by `N xor K2`.

For encryption and decryption with both nonce masking and a set nonce, the algorithm described in <<ACE-Ascon-AEAD128-wsn>> is used, giving `K1` as the key `key` and providing `N xor K2` as the nonce value.

[[ACE-Ascon-Hash256]]
===== Ascon-Hash256

In this mode it is the responsibility of the user to apply proper padding to the inputs.

Parameters:::

* `b` = 64. For this algorithm we require `IOLEN` to be an integer multiple of `b`.

Data Structures:::

* *Provisioning Input* (Content): Empty.

* *Internal State* (Content):
 ** `state[0 .. 4]`: five 64-bit words, i.e., 320 bits.
 ** `countdown` : integer going from 3 down to 0.

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
|  Pos. | Size in Bytes   | Field
|    i  | 8               | `state`[0]
|   ii  | 8               | `state`[1]
|  iii  | 8               | `state`[2]
|   iv  | 8               | `state`[3]
|    v  | 8               | `state`[4]
|   vi  | 1               | `countdown` (from 3 down to 0)
|  vii  | 7               | Padding
|===
--
+

Algorithm-Specific Functions:::

* `ASCON(p)` applies `p` rounds of ASCON to the `state`.

State Machine:::

* *States:* _initial_, _hash_absorb_, _hash_finalize_, and _completed_.

* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_ -> _hash_finalize_ -> _completed_.

* *Behavior:*
 ** In State _initial_ :
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
  *** The following initialization operations are performed:
   . `state[0] <- 0x0000080100cc0002`
   . `state[1] <- zeros(64)`
   . `state[2] <- zeros(64)`
   . `state[3] <- zeros(64)`
   . `state[4] <- zeros(64)`
   . `ASCON(12)`

  ** In State _hash_absorb_, only  ``ace.exec`` instructions of Form B are allowed.
 “```ace.exec Kn|K(Xn), INPUT```” absorbs a data block into the state, i.e.:
+
--
 . `state[0] <- state[0] xor INPUT`
 . `ASCON(12)`
--
+
If `IOLEN` > `64`, these operations are executed `IOLEN/64` times, once for each `64`-bit block of `INPUT`.

** Upon entering _hash_finalize_, `countdown` is set to 3.

** In State _hash_finalize_, at most four ``ace.exec`` instructions of Form C are allowed.
To compute the tag, “```ace.exec OUTPUT, Kn|K(Xn)```”  performs
+
--
. `ASCON(12)`
. `OUTPUT <- state[0]`
. if `countdown == 0` then transition to State _completed_.
. `countdown <- countdown - 1`
--
+
If `IOLEN` {ge} `128`, these operations are executed `IOLEN/64` times, writing to `OUTPUT`[63:0] the first time,
then `OUTPUT`[127:64], `OUTPUT`[191:128] and `OUTPUT`[255:192].
If more than one ``ace.exec`` instructions are required, writing restarts from `OUTPUT`[63:0].
If `countdown` reaches zero before the entire output registers is written to, the state of the unwritten bits is undefined: for instance
this may occur if `IOLEN` = `192` or `IOLEN` > `256`.
This is usually not a problem, since the output vectors will be usually configured for 64-bit, 128-bit, or 256-bit blocks, in which case
four, two, or one ``ace.exec`` instructions are required, respectively.

//

NOTE: There is no need to provide “keyed” versions of this algorithm.
This can be done by a trusted entity by providing a CC after absorbing some secret content in it first.

===== Ascon-XOF128

The algorithm is the same as Ascon-Hash256 (<<ACE-Ascon-Hash256>>) with the following differences:

. The IV written to `state[0]` in State _initial_ is `0x0000080100cc0002`.
. There is no `countdown` field (and therefore also no padding: the last 8 bytes of the serialized content of Ascon-Hash256 are not present).
. As much output as desired can be produced in State _hash_finalize_, and the algorithm never transitions to State _completed_.

===== Ascon-CXOF128

Ascon-CXOF128 differs from Ascon-XOF128 in that the message is prepended with the customization string.
Except for the initialization of the state, Ascon-CXOF128 is identical to Ascon-XOF128 with customization string and message concatenated.
The IV for Ascon-CXOF128 is `0x0000080000cc0004` (in place of `0x0000080000cc0003`), and it is set by the algorithm.
The states and their semantics are otherwise identical to Ascon-XOF128, and the management of the customization string is left to the user.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-ECC]]
==== Elliptic Curve Asymmetric Algorithms

[WARNING]
This section needs finalization.
Currently, we only define scalar multiplication with known and unknown base point and ECDSA/EdDSA sign/verify for the NIST curves.
The Edwards curves ed25519 and ed448 are missing (same for Brainpool and SM2).
ECC based KEMs are also missing, or at least instructions on how to implement them with the basic functionality offered.
Further curves and algorithms can be defined later.

Parameters:::

* For secp256r1 (NIST P-256) the size `b` of the main fields (coordinates, signature R and S fields, scalars) is 256 bits.
The length `h` of the hash used in the signature scheme is 256 bits.
The random number (the nonce in signature generation) is a `h`-bit string as well.

* For secp384r1 (NIST P-384), `b` is 384 bits, and `h` is 384 bits.

* For secp521r1 (NIST P-521), `b` is 576 bits, of which only 521 are used, and `h` is 512 bits.

Data Structures:::

* *Provisioning Input* (Content): Empty.

NOTE: In the Metadata, Algorithm only defines a curve.
AlgorithmPolicy enables signature generation (bit 12) and verification (bit 13), where all four combinations are admissible.

* *Internal State* (Content):
 ** `HasGenerator`: Bool.
 ** `HasSecondPoint`: Bool.
 ** `HasScalar`: Bool.
 ** `HasPublicKey`: Bool.
 ** `HasSignature`: Bool.
 ** `HasHash`: Bool.
 ** `HasRandomNumber`: Bool.
 ** `OutputType`: Bool.
 ** `Progress`: integer.
 ** `block_base`: integer.
 ** `Generator` (X, {Y}): one or two `b`-bit strings representing the X {and Y} coordinate{s}.
 ** `SecondPoint` (X, {Y}): one or two `b`-bit strings representing the X {and Y} coordinate{s}.
 ** `Scalar`: `b`-bit string.
 ** If signature generation or verification is allowed:
  *** `PublicKey` (X, {Y}): one or two `b`-bit strings representing the X {and Y} coordinate{s}}.
  *** `Signature` (R,S): two `b`-bit strings representing the `R` and `S` components.
  *** `Hash`: a `h`-bit string representing the hash.
  ** If signature generation is allowed:
  *** `RandomNumber`: a `h`-bit string representing the random number.
 ** Additional data, for instance precomputed multiples of the Generator.

* *Serialized Content*:
+
--
[cols="^7%,<31%,<31,<31",width="100%",options="header"]
|===
|  Pos. | Size in Bytes   2+| Field
.4+|   i   .4+| 2           | Bit 0: `HasGenerator`     | Bit 1: `HasSecondPoint`
                           <| Bit 2: `HasScalar`       <| Bit 3: `HasPublicKey`
                           <| Bit 4: `HasSignature`    <| Bit 5: `HasHash`
                           <| Bit 6: `HasRandomNumber` <| Bit 7: `OutputType`
|   ii  | 2               2+| `Progress`
|  iii  | 4               2+| Padding
|   iv  | 2``b``/8        2+| `Generator`, X coordinate
|    v  | 2``b``/8        2+| `Generator`, Y coordinate
|   vi  | `b`/8           2+| `Scalar`: `b`-bit string. Can be the private key.
|===

`SCC_content_size()` returns only the length of the content from Position i to Position vi.

The size of the following fields is included in the _AdditionalData_ field of the Metadata Header.

[cols="^7%,<31%,<62",width="100%",options="header"]
|===
|  Pos. | Size in Bytes                             | Field
|  vii  | If `mh`._AdditionalData_ != 0: 8, else: 0 |  `acemarchid`
| viii  | If `HasSecondPoint`: `b`/8, else: 0       | `SecondPoint`, X coordinate.
|   ix  | If `HasSecondPoint`: `b`/8, else: 0       | `SecondPoint`, Y coordinate. Does not exist if Edwards Curve.
|    x  | If `HasPublicKey`: `b`/8, else: 0         | `PublicKey`, X coordinate.
|   xi  | If `HasPublicKey`: `b`/8, else: 0         | `PublicKey`, Y coordinate. Does not exist if Edwards Curve.
|  xii  | If `HasSignature`: `b`/8, else: 0         | `Signature`, R value.
| xiii  | If `HasSignature`: `b`/8, else: 0         | `Signature`, S value.
|  xiv  | If `HasHash`: `h`/8, else: 0              | `Hash`: a `h`-bit string representing the hash.
|   xv  | If `HasRandomNumber`: `h`/8, else: 0      | `RandomNumber`.
|  xvi  | (variable)                                | Additional data from the *Internal State* (Content)..
|===

The `HasRandomNumber` flag is set and the `RandomNumber` field is used only during signature generation.
`RandomNumber` is exported only if the signature operation is interrupted.

The size in bytes of Fields vii to xv is:

`{fournbsp}{fournbsp}` `varlen` <- 8 + (`HasPublicKey` != 0) {interpunct} 2``b``/8 + (`HasSignature` != 0) {interpunct} 2``b``/8 + +
`{fournbsp}{fournbsp}{fournbsp}{fournbsp}{fournbsp}{fournbsp}{fournbsp}` + (`HasHash` != 0) {interpunct} ``h``/8 + (`HasRandomNumber` != 0) {interpunct} ``h``/8.

If _AdditionalData_ > `varlen`, Position xvi contains the microarchitectural dependent part.
--
+

State Machine::: {empty}
+
--
* *States:*
Beside
_initial_ (0),
_invalid_ (14), and
_completed_ (15), ECC algorithms define:
 ** _set_generator_ (1)
 ** _set_scalar_ (2)
 ** _gen_rnd_scalar_ (3)
 ** _point_mul_ (4)
 ** _sign_generate_ (5)
 ** _sign_verify_ (6)
 ** _set_hash_ (7)
 ** _set_publickey_ (8)
 ** _set_signature_ (9)
 ** _output_ (10)
--
+

+
--
* *Allowed State Transitions:*

 ** _initial_ -> _set_generator_, _set_scalar_, _set_hash_, _set_publickey_, _sign_generate_, _set_signature_.
 ** One can freely transition between _set_generator_, _set_scalar_, _set_hash_, and _set_publickey_.
 ** From any of _initial_, _set_generator_, _set_scalar_, _set_hash_, _set_publickey_ ->
 *** _point_mul_ only if `HasGenerator` and `HasScalar`;
 *** _sign_generate_ only if `HasGenerator`, `HasPublicKey`, and `HasHash`;
 *** _sign_verify_ only if `HasGenerator`, `HasScalar`, `HasPublicKey`, `HasHash`, and `HasSignature`.
 ** _point_mul_ -> _output_ -> _completed_.
 ** _sign_generate_ -> _output_ -> _completed_.
 ** _sign_verify_ -> _completed_.

[none]
* In State _set_generator_ we can set a group generator, or a default one.
* In State _set_scalar_ we can either set a scalar for scalar multiplication or private key.
* For each __Var__ {in} {`Generator`, `Scalar`, `Hash`, `PublicKey`, `Signature`},
the Boolean variable ``Has``__Var__ is set when all operations required in State _set_Var_ have been successfully executed.
--
+

* *Behavior:*

 ** All the “set” and “output” operations work like the input and output of blocks in the Hash functions, in other words, they use `Progress` (just as the Hash/MAC functions use `block_base`) to track how much information has been read in or written out.

 ** `Progress` can be used by instructions such as Point Multiplication, Signature Generation or Verification, to track the progress of the operations in case they are interrupted. In this case, if the CR is exported, in the Metadata, _AdditionalData_ must be non-zero, to allow `acemarchid` to be compared, and then the Additional Data must also contain sufficient information to allow resumption.
 If there is a `acemarchid` mismatch, both `RandomNumber` (Position xv, if present) and the additional data at Position xvi are discarded, and the operation is restarted.

 ** To transition to State _set_generator_, a Form A or B `ace.state` is used.

 *** If no parameter is given, or the value of the GPR used in the Form B `ace.state` is zero:
  . The default generator of the curve is set.
  . A state change operation can be issued, including to states that require a set `Generator`.

 *** Otherwise:
  . If `Generator` contains a value, it is erased and `HasGenerator` is set to False.
  . `Progress` <- 0.
  . A value for `Generator` is loaded, using one or more Form B `ace.exec` operations, each one increasing `Progress` by the amount of data provided by `ace.exec`.
  . Once `Progress` has reached the length of the generator point (excess data in the last `ace.exec` is ignored):
   **** `HasGenerator` is set to True.
   **** No further `ace.exec` instructions may be issued.
   **** A state change operation can be issued, including to states that require a set `Generator`. This state change also clears `Progress`.

 ** To transition to any of the States _set_scalar_, _set_hash_, _set_publickey_, or _set_signature_ a Form A `ace.state` is used.
 . If there is a current value in the corresponding field _X_ = `Scalar`, `Hash`, `PublicKey`, or `Signature`,
     it is erased, and the Boolean ``Has``_X_ is set to False.
 . `Progress` <- 0, and a value for Field _X_ is loaded, using one o more Form B `ace.exec` operations (similarly to `Generator`).
 . Once the values `Progress` has reached the length of field _X_  (excess data in the last `ace.exec` is ignored):
  *** The corresponding Boolean ``Has``_X_ is set to True.
  *** No further `ace.exec` instructions may be issued.
  *** A state change operation can be issued, including to states that require a value for _X_ to be set. This state change also clears `Progress`.

 ** It is allowed to transition to _set_scalar_ also using a Form B `ace.state` with a non-zero value in the GPR.
    In this case, a random value is set, and `HasScalar` is set to true.

 ** When the operations in states _point_mul_ and _sign_generate_ are completed:
   . If the output is a point, then `OutputType` <- False, and if the output is a signature, then `OutputType` <- True.
     This allows the ACE implementation to determine not only which output must be written out, but also its length.
     *** If `OutputType` == False, the output is in `SecondPoint`.
     *** If `OutputType` == True,  the output is in `Signature`.
   . `Progress` <- 0.
   . One or more Form C `ace.exec` instructions may be issued to export segments of the result to memory, each time increasing `Progress` by the length of the output of `ace.exec`.
     . Data beyond the length of the output is replaced with zeros in the last exported part.
     . Once `Progress` has reached the length of the output, the state transitions automatically to _completed_.

 ** Upon returning to State _initial_:
  *** If a Form B `ace.state` is used, the parameter `Xs` will determine whether the fields
 `Generator`, `Scalar`, and `PublicKey` are reset/erased or kept for further operations.
 This is determined by Bits 0, 1, 2, and 3 of `Xs` as follows:
   **** If Bit 0, 1, 3, resp., 3 is set, then `Generator`, `SecondPoint`, `Scalar`, resp., `PublicKey` is erased, and the corresponding Boolean flags `HasGenerator`, `HasScalar`, resp., `HasPublicKey` is unset as well.
   **** If Bit 4 is set, then `Generator` is copied onto `SecondPoint`. If Bit 0 is set, then `Generator` is erased afterwards.
   **** If Bit 5 is set, then `SecondPoint` is copied onto `Generator`. If Bit 1 is set, then `SecondPoint` is erased afterwards and `HasSecondPoint` is set to False.
  *** A Form A `ace.state` does not modify these states.
  *** `Signature` and the corresponding Boolean `HasSignature` are always reset.

EdDSA formats are similar, but, for instance, the public key is represented as a single `b`-bit string.
Depending on the algorithm, in states _set_generator_ or _set_publickey_ we may input non-compressed or compressed points.

// ///////////////////////////////////////////////////////////////////////////////////////////

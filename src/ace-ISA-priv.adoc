[[ACE-priv]]
== Privileged Architecture

[[ACE-dependencies-priv]]
==== Dependencies on Other Extensions

The ACE Privileged Architecture depends on the Indirect CSR Access mechanism defined in Smcsrind/Sscsrind.

=== CSRs

The ACE Privileged Architecture consists only of CSRs.

ACE extends `*status` and `misa`, and provides up to 4 direct and up to 28 indirect CSRs.

[[ACE-CSRs-priv]]
.ACE Privileged CSRs.
[cols="^12%,^12%,<28%,<48%"]
[float="center",align="center",options="header"]
|===
| 0xXXX       | SRW        | `scrdirty`                  | Per-CR dirtiness tracking
| 0xXXX       | HRW        | `vscrdirty`                 | Per-CR dirtiness tracking
| 0xXXX       | MRW        | `mcrdirty`                  | Per-CR dirtiness tracking
| 0xXXX       | SRW        | `sacetrapmask`              | (TBD) Mask that determines which ACE exceptions vertically trap
| (Indirect)  | MRW (RZ)   | `macecsk{0..7}`             | ACE Context Sealing Key
| (Indirect)  | MRW (RZ)   | `macePhysBootSecret{0..3}`  | Locality: Physical Boot Session Secret
| (Indirect)  | HRW (RZ)   | `haceVirtBootSecret{0..3}`  | Locality: Virtual Boot Session Secret
| (Indirect)  | MRW (RZ)   | `maceLocality{0..3}`        | Locality: Mutually isolate processes below M-mode
| (Indirect)  | SRW (RZ)   | `haceLocality{0..3}`        | Locality: Mutually isolate processes below H-mode
| (Indirect)  | HRW (RZ)   | `saceLocality{0..3}`        | Locality: Mutually isolate U-mode processes
|===

[[ACE-ACE-field-in-misa]]
==== ACE field in `misa`

{empty}
(((CSR, ACE field in `misa`)))
Bit `L` (11) of `misa` indicates that the ACE extension is present. If ACE is implemented, this bit shall not be read-only zero.

[[ACE-ACES-field-in-mstatus]]
==== ACE Context Status in `mstatus` and `sstatus`

{empty}
(((CSR,ACES field in mstatus)))
(((CSR,ACES field in sstatus)))
The ACES field is added to `mstatus`[26:25] and shadowed in `sstatus`[26:25] (see <<ACE-CSR-mcrdirty>>).
ACES is defined analogously to the floating-point context status field FS and the vector context status field VS.
It tracks the dirtiness of the ACE state, including CRs, ACEIOBUF, and all ACE-specific CSRs.
If ACE is implemented, ACES shall not be read-only zero.
Encodings are given in <<ACE-aces-encoding>>.

[[ACE-aces-encoding]]
.Encoding of the ACES field
[float="center",align="center",width="100%",cols="^8%,<8%,<84%",options="header"]
|===
|Value |Name |Meaning
|   0   | Off     | ACE disabled. The ACE state is inaccessible. Executing any ACE instruction raises an illegal instruction exception.
|   1   | Initial | ACE enabled.
|   2   | Clean   | ACE enabled. At least one CR or ACEIOBUF is configured; state matches the last context swap.
|   3   | Dirty   | ACE enabled. At least one CR, ACEIOBUF, or ACE-specific CSR may have changed since the last context swap. Unconfigured CRs that were previously configured also cause Dirty, since context-switching code must erase any stale saved state.
|===

ACES state transitions follow the same rules as FS, VS, and XS (see cite:[RISCV-ISA-Priv]).

NOTE: Precise management of `mstatus.ACES` is an optimization that software may use to reduce context-switch overhead.

When `mstatus.ACES` is Initial or Clean, any instruction that modifies ACE state sets `mstatus.ACES` to Dirty. Implementations may also set `mstatus.ACES` to Dirty from Initial or Clean at any time, even in the absence of a state change.

When `mstatus.ACES` (resp. `sstatus.ACES`) is Dirty, `mstatus.SD` (resp. `sstatus.SD`) is 1; otherwise, `mstatus.SD` is set per existing specifications.

Writes to ACES do not modify any other ACE state. Setting ACES to Off, Initial, or Clean does not clear CRs or ACEIOBUF; any state reset must be explicit and must precede such a write.

In implementations with a writable `misa.L`, the `mstatus.ACES` field may be present even when `misa.L` is clear, analogously to `mstatus.FS` and `mstatus.VS`.

//

[[ACE-ACES-field-H]]
==== ACE Context Status in `vsstatus`

{empty}
(((CSR,ACES field in vsstatus)))
When the H extension is present, an ACES field is added to `vsstatus`[26:25], defined analogously to `mstatus.FS` and `mstatus.VS`, and tracking the dirtiness of CRs, ACEIOBUF, and all ACE-specific CSRs.

When V=1:

* Both `vsstatus.ACES` and `mstatus.ACES` are in effect.
* Any ACE instruction raises an illegal instruction exception if either field is Off.
* If neither field is Off, any instruction that modifies ACE state sets both `mstatus.ACES` and `vsstatus.ACES` to Dirty.
* Implementations may set either field to Dirty from Initial or Clean at any time, even without a state change.
* When `vsstatus.ACES` is Dirty, `vsstatus.SD` is 1; otherwise, `vsstatus.SD` is set per existing specifications.

In implementations with a writable `misa.L`, `vsstatus.ACES` may be present even when `misa.L` is clear.

[[ACE-CSR-acemarchid]]
==== `acemarchid`

{empty}
(((CSR, `acemarchid`)))
`acemarchid` identifies the microarchitectural version of the ACE unit, analogously to `marchid` for the hart.

[[ACE-CSR-scrdirty]]
==== `scrdirty`

{empty}
(((CSR, `scrdirty`)))
The SXLEN-bit register `scrdirty` tracks per-CR dirtiness.
`scrdirty[__i__]` encodes Clean (0) or Dirty (1) for CR #__i__.
Bits [SXLEN-1:32] are WPRI.

When the privilege mode is S, VS, or U:

* Any instruction that modifies CR #__i__ sets `scrdirty[__i__]` to Dirty.
* Implementations may set `scrdirty[__i__]` to Dirty from Clean at any time, even without a state change.
// The main reason for allowing this is to permit implementations that do not
// track the state and make fields read-only Dirty, but we could also require
// precise tracking and hide the CSRs behind an extension, so implementations
// that don't want to do it just don't implement the extension.

NOTE: Context-switching code observes only Clean or Dirty. To determine whether a CR is configured, software may execute `ace.size` (<<ACE-instruction-size>>) on it; a return value of zero indicates an unconfigured CR, and any stale saved state for it shall be erased and released.

NOTE: `scrdirty` is independent of the S extension. In an M-U system, M-mode may use it to optimize U-mode context switches.

NOTE: `sstatus.ACES` is also in effect.

[[ACE-CSR-vscrdirty]]
==== `vscrdirty`

{empty}
(((CSR, `vscrdirty`)))
The VSXLEN-bit register `vscrdirty` tracks per-CR dirtiness for virtualized contexts.
`vscrdirty[__i__]` encodes Clean (0) or Dirty (1) for CR #__i__.
Bits [VSXLEN-1:32] are WPRI.

`vscrdirty` exists only when the H extension is implemented.

When the privilege mode is VS or VU:

* `vscrdirty` shadows `scrdirty`; accesses that would target `scrdirty` instead access `vscrdirty`.
* Any instruction that modifies CR #__i__ sets `vscrdirty[__i__]` to Dirty.
* Implementations may set `vscrdirty[__i__]` to Dirty from Clean at any time, even without a state change.

NOTE: `sstatus.ACES`, `vsstatus.ACES`, and `scrdirty` are also in effect when V=1.

[#ACE-CSR-mcrdirty,discrete]
==== `mcrdirty`

[WARNING]
====
(((CSR, `mcrdirty`)))
A `mcrdirty` register may be defined, _mutatis mutandis_, in the same manner as `scrdirty` and `vscrdirty`, to allow M-mode to optimize context switches across Supervisor domains. In such a case, the `ACES` field in `sstatus` shall be unshadowed and be independent instead.

(A `ucrdirty` may become useful if the HFI extension is ratified, together with corresponding fields in a `ustatus` CSR.)
====

//

==== Propagation of `*crdirty` Dirtiness Values

Per-CR dirtiness propagates from less-privileged to more-privileged modes, analogously to the FS, VS, and ACES fields in `*status`, but with only two states: Clean and Dirty. Any instruction that sets bit #__i__ of `vscrdirty` (resp. `scrdirty`) to Dirty also sets the corresponding bit of `scrdirty` and `mcrdirty` (resp. `mcrdirty`). The ACES fields of `*status` are also set accordingly.

//

==== `sacetrapmask`

{empty}
(((CSR, `sacetrapmask`)))
Mask that determines which ACE exceptions vertically trap.
Bit __i__ of this CSR is set if ACE error __i__+1 causes a vertical trap.

[[ACE-CSR-macecsk]]
==== `macecsk` Group

{empty}
(((CSR, `macecsk`)))
The optional `macecsk` group consists of XLEN-bit M-mode WARZ CSRs: eight in RV32, four in RV64.
A write to the __i__-th CSR sets bits [(_i_+1)·XLEN−1 : _i_·XLEN] of the CSK. Access outside M-mode raises an illegal instruction exception.

[NOTE]
====
M-mode firmware must be aware of whether the CSK is configurable, ephemeral, or fixed.
Persistence mechanisms for configurable CSKs are implementation-specific.

Transferring a CSK to another endpoint—such as the M-mode firmware of another device, a local TPM (for instance to preserve a CSK upon suspension or host hibernation), or a cloud-based HSM—requires an authenticated public-key key-wrapping mechanism.

Alternative reconfiguration mechanisms (e.g., a Caliptra-style cite:[caliptra] secure IP block) are permitted.
====

//

[[ACE-CSR-macePhysBootSecret]]
==== `macePhysBootSecret` Group

{empty}
(((CSR, `macePhysBootSecret`)))
The `macePhysBootSecret` group consists of M-mode WARZ XLEN-bit CSRs, accessed via Indirect CSR Access: four in RV32, two in RV64.
A write to the __i__-th CSR sets bits [(_i_+1)XLEN−1 : _i_·XLEN] of `BootSecret`. Access outside M-mode or Debug mode raises an illegal instruction exception.

//

[[ACE-CSR-haceVirtBootSecret]]
==== `haceVirtBootSecret` Group

{empty}
(((CSR, `haceVirtBootSecret`)))
The `haceVirtBootSecret` group consists of H- and VS-mode WARZ XLEN-bit CSRs, accessed via Indirect CSR Access: four in RV32, two in RV64.
A write to the __i__-th CSR sets bits [(_i_+1)XLEN−1 : _i_·XLEN] of `haceVirtBootSecret`. Access below VS-mode raises an illegal instruction exception.

[NOTE]
====
`haceVirtBootSecret` must be reconfigurable to support VM reboots independently of the physical host boot cycle.
====

//

[[ACE-CSR-maceLocality]]
==== `maceLocality` Group

{empty}
(((CSR, `maceLocality`)))
The `maceLocality` group consists of M-mode WARZ XLEN-bit CSRs, accessed via Indirect CSR Access: four in RV32, two in RV64.
A write to the __i__-th CSR sets bits [(_i_+1)XLEN−1 : _i_·XLEN] of `maceLocality`. Access outside M-mode and Debug mode raises an illegal instruction exception.

//

[[ACE-CSR-haceLocality]]
==== `haceLocality` Group

{empty}
(((CSR, `haceLocality`)))
The `haceLocality` group consists of H-mode WARZ XLEN-bit CSRs, accessed via Indirect CSR Access: four in RV32, two in RV64.
A write to the __i__-th CSR sets bits [(_i_+1)XLEN−1 : _i_·XLEN] of `haceLocality`. This group shall be implemented whenever the H extension is implemented. Access below H-mode raises an illegal instruction exception.

//

[[ACE-CSR-saceLocality]]
==== `saceLocality` Group

{empty}
(((CSR, `saceLocality`)))
The `saceLocality` group consists of (V)S-mode WARZ XLEN-bit CSRs, accessed via Indirect CSR Access: four in RV32, two in RV64.
A write to the __i__-th CSR sets bits [(_i_+1)XLEN−1 : _i_·XLEN] of `saceLocality`. The group is accessible in S/HS-mode, VS-mode, M-mode, and Debug mode; access from any other mode raises an illegal instruction exception.

[[ACE-trappable-insns-support]]
=== Trappable (Emulated) Operations

_This section is currently non-normative._

Instructions `ace.prov`, `ace.export`, `ace.import`, `ace.input`, and `ace.output` support long inputs and outputs.
To reduce hardware complexity, these operations can be trapped and emulated in software.
(((ACE, trappable instruction)))
Upon a trap, the handler identifies the trapped instruction and uses `ace.size` on the Metadata to determine the size of the data to be transferred.
Then, the emulation uses custom instructions to move data between the ACE unit and the CPU.
Three types of supporting operations are required:

 * An “`ace.mv`” instruction that loads a specified number of bytes from a GPR or vector register into the state of a CR or in the input buffer within the ACE unit.
   Initially, `ace.size` returns the total payload length to transfer.
   After each move, this value is updated to reflect the remaining bytes.
   The instruction also updates the `acestart` CSR to follow the internal progress.
 * A corresponding “`ace.mv`” instruction that exports a specified number of bytes from a CR or from the input buffer to a GPR or vector register.
   The behavior of `ace.size` will be similar to that of the `ace.mv` instruction, but it will count the number of bytes to be exported.
 * An “`ace.close`” instruction to suspend or finalize the procedure.
   If executed before all bytes are transferred, the CR state matches that of an interrupted monolithic instruction, including any special value of the _StateNumber_ Metadata field and the value of `acestart`. If executed after all bytes are transferred, it also performs any final cryptographic operations, such as authenticating the CR.

All three instructions can be implemented as CSR RW instructions, for instance:

 * `acedest`, XLEN bits wide, determines what architectural state we are transferring to or from: 0..31 for the CRs and, say, 32 for the ACEIOBUF.
 * `acestart`, XLEN bits wide, holds the offset within the CR's virtually serialized `content[]` or the ACEIOBUF.
 * `acecontent`, XLEN bits wide, to which we write the content of the CR or the ACEIOBUF or from which we read the current content.
  A write to `acecontent` increases `acestart` by XLEN/8.

// Interrupting the firmware implementation of `ace.prov`, `ace.export`, `ace.import`, `ace.input`, or `ace.output` must leave the architectural state indistinguishable from the state expected from interrupting a monolithic implementation of the instructions.
// In particular, they need to respect the value of `acestart` and update it in accordance with the expected architected behavior of the emulated instructions.
// The supporting instructions themselves must be uninterruptible.

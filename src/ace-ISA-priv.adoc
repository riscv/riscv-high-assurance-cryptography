[[ACE-priv]]
== Privileged Architecture

The ACE Privileged Architecture consists of CSRs and of optional custom instructions to implement parts of the unprivileged ISA.

// ////////////////////////////////////////////////////////////////////

[[ACE-extensions-overview-priv]]
=== Extensions Overview

[WARNING]
[.red]#This list is an early draft.#

* If `Zlv` or `Zlio` are implemented: `misa` must implement the `L` bit, `*status` must implement `ACES`.
* `SmaceCSK` {implies} Defines the Context Sealing Key CSRs (`macecsk{0..7}`).
* `Smacepbootscrt` {implies} Defines the ACE OS Secret CSRs (`macePhysBootScrt{0..3}`).
* `Smacevbootscrt` {implies} Defines the ACE Boot Secret CSRs (`haceVirtBootScrt0{0..3}`).
* `Smacestatus` {implies} Defines the ACES per CCRCSRs (`scrstatus`, `vscrstatus`, `mcrstatus`).
* `Smacell` {implies} Defines the high bits of the ACES per CCRCSRs (`scrstatus`, `vscrstatus`, `mcrstatus`) to support lazy loading.
* `Smacelclt` {implies} Defines the software binding locality CSRs (`maceLocality`, `haceLocality`, `saceLocality`).

// ////////////////////////////////////////////////////////////////////

[[ACE-dependencies-priv]]
=== Dependencies on Other Extensions

The ACE Privileged Architecture depends on the Indirect CSR Access mechanism defined in Smcsrind/Sscsrind.

=== CSRs

ACE extends `*status` and `misa`, and provides up to 4 direct and up to 28 indirect CSRs.

[[ACE-CSRs-priv]]
.ACE Privileged CSRs.
[cols="^12%,^12%,<26%,<50%"]
[float="center",align="center",options="header"]
|===
| Address     | Privilege  | Field                    | Description
| 0xXXX       | SRW        | `scrstatus`               | Per-CR dirtiness and laziness tracking
| 0xXXX       | HRW        | `vscrstatus`              | Per-CR dirtiness and laziness tracking
| 0xXXX       | MRW        | `mcrstatus`               | Per-CR dirtiness and laziness tracking
| 0xXXX       | SRW        | `sacetrapmask`            | [.red]#{warn}:# Mask to determine which ACE exceptions vertically trap from U (V=0) or VS (V=1) to S
| 0xXXX       | MRW        | `vsacetrapmask`           | [.red]#{warn}:# Mask to determine which ACE exceptions vertically trap from U (V=1) to VS
| 0xXXX       | SRW        | `macetrapmask`            | [.red]#{warn}:# Mask to determine which ACE exceptions vertically trap from S/HS to M
| (Indirect)  | MRW (RZ)   | `macecsk{0..7}`           | ACE Context Sealing Key
| (Indirect)  | MRW (RZ)   | `macePhysBootScrt{0..3}`  | Locality: Physical (host) Boot Session Secret
| (Indirect)  | HRW (RZ)   | `haceVirtBootScrt{0..3}`  | Locality: Virtual (guest) Boot Session Secret
| (Indirect)  | MRW (RZ)   | `maceLocality{0..3}`      | Locality: Mutually isolate processes below M-mode
| (Indirect)  | SRW (RZ)   | `haceLocality{0..3}`      | Locality: Mutually isolate processes below H-mode
| (Indirect)  | HRW (RZ)   | `saceLocality{0..3}`      | Locality: Mutually isolate U-mode processes
|===

// ////////////////////////////////////////////////////////////////////

[[ACE-ACE-field-in-misa]]
==== ACE field in `misa`

{empty}
(((CSR, ACE field in `misa`)))
Bit `L` (11) of `misa` indicates that the ACE extension is present.
If ACE is implemented, this bit shall not be read-only zero.

// ////////////////////////////////////////////////////////////////////

[[ACE-ACES-field-in-mstatus]]
==== ACE Context Status in `mstatus` and `sstatus`

{empty}
(((CSR,ACES field in mstatus)))
(((CSR,ACES field in sstatus)))
The ACES field is added to `mstatus`[26:25] and shadowed in `sstatus`[26:25] (see <<ACE-CSR-mcrstatus>>).
ACES is defined analogously to the floating-point context status field FS and the vector context status field VS.
It tracks the dirtiness of the entire ACE state, including CRs, ACEIOBUF, and all ACE-specific CSRs.
If ACE is implemented, ACES shall not be read-only zero.
Encodings are given in <<ACE-aces-encoding>>.

[[ACE-aces-encoding]]
.Encoding of the ACES field
[float="center",align="center",width="100%",cols="^8%,<8%,<84%",options="header"]
|===
|Value |Name |Meaning
|   0   | Off     | ACE disabled. The ACE state is inaccessible. Executing any ACE instruction raises an illegal instruction exception.
|   1   | Initial | ACE enabled.
|   2   | Clean   | ACE enabled. At least one CR or ACEIOBUF is configured; state matches the last context swap.
|   3   | Dirty   | ACE enabled. At least one CR, ACEIOBUF, or ACE-specific CSR may have changed since the last context swap. Unconfigured CRs that were previously configured also cause Dirty, since context-switching code must erase any stale saved state.
|===

ACES state transitions follow the same rules as FS, VS, and XS (see cite:[RISCV-ISA-Priv]).

NOTE: Precise management of `mstatus.ACES` is an optimization that software may use to reduce context-switch overhead.

When `mstatus.ACES` is Initial or Clean, any instruction that modifies ACE state sets `mstatus.ACES` to Dirty. Implementations may also set `mstatus.ACES` to Dirty from Initial or Clean at any time, even in the absence of a state change.

When `mstatus.ACES` (resp. `sstatus.ACES`) is Dirty, `mstatus.SD` (resp. `sstatus.SD`) is 1; otherwise, `mstatus.SD` is set per existing specifications.

Writes to ACES do not modify any other ACE state. Setting ACES to Off, Initial, or Clean does not clear CRs or ACEIOBUF; any state reset must be explicit and must precede such a write.

In implementations with a writable `misa.L`, the `mstatus.ACES` field may be present even when `misa.L` is clear, analogously to `mstatus.FS` and `mstatus.VS`.

// ////////////////////////////////////////////////////////////////////

[[ACE-ACES-field-H]]
==== ACE Context Status in `vsstatus`

{empty}
(((CSR,ACES field in vsstatus)))
When the H extension is present, an ACES field is added to `vsstatus`[26:25], defined analogously to `mstatus.FS` and `mstatus.VS`, and tracking the dirtiness of CRs, ACEIOBUF, and all ACE-specific CSRs.

When V=1:

* Both `vsstatus.ACES` and `mstatus.ACES` are in effect.
* Any ACE instruction raises an illegal instruction exception if either field is Off.
* If neither field is Off, any instruction that modifies ACE state sets both `mstatus.ACES` and `vsstatus.ACES` to Dirty.
* Implementations may set `ACES`` to Dirty from Initial or Clean at any time, even without a state change.
* When `vsstatus.ACES` is Dirty, `vsstatus.SD` is 1; else, `vsstatus.SD` is set per existing specifications.

In implementations with a writable `misa.L`, `vsstatus.ACES` may be present even when `misa.L` is clear.

// ////////////////////////////////////////////////////////////////////

[[ACE-CSR-scrstatus]]
==== `scrstatus` for Dirtiness Tracking

{empty}
(((CSR, `scrstatus`)))
The 64-bit register `scrstatus` tracks per-CR dirtiness.

`scrstatus`[__i__] encodes Clean (0) or Dirty (1) for ``K(``__i__``)``.

Bits [63:32] are WPRI.

When the privilege mode is S, VS, or U:

* Any instruction that modifies ``K(``__i__``)`` sets `scrstatus`[__i__] to Dirty.
* Implementations may set `scrstatus`[__i__] to Dirty from Clean at any time, even without a state change.
// The main reason for allowing this is to permit implementations that do not
// track the state and make fields read-only Dirty, but we could also require
// precise tracking and hide the CSRs behind an extension, so implementations
// that don't want to do it just don't implement the extension.

NOTE: Context-switching code observes only Clean or Dirty. To determine whether a CR is configured, software may execute `ace.size` (<<ACE-instruction-size>>) on it; a return value of zero indicates an unconfigured CR, and any stale saved state for it shall be erased and released.

NOTE: `scrstatus` is independent of the S extension. In an M-U system, M-mode may use it to optimize U-mode context switches.

NOTE: `sstatus.ACES` is also in effect.

// ////////////////////////////////////////////////////////////////////

[[ACE-CSR-vscrstatus]]
==== `vscrstatus` for Dirtiness Tracking

{empty}
(((CSR, `vscrstatus`)))
The 64-bit register `vscrstatus` tracks per-CR dirtiness for virtualized contexts.

`vscrstatus`[__i__] encodes Clean (0) or Dirty (1) for ``K(``__i__``)``.
Bits [63:32] are WPRI.

`vscrstatus` exists only when the H extension is implemented.

When the privilege mode is VS or VU:

* `vscrstatus` shadows `scrstatus`; accesses that would target `scrstatus` instead access `vscrstatus`.
* Any instruction that modifies ``K(``__i__``)`` sets `vscrstatus`[__i__] to Dirty.
* Implementations may set `vscrstatus`[__i__] to Dirty from Clean at any time, even without a state change.

NOTE: `sstatus.ACES`, `vsstatus.ACES`, and `scrstatus` are also in effect when V=1.

// ////////////////////////////////////////////////////////////////////

[#ACE-CSR-mcrstatus,discrete]
==== `mcrstatus` for Dirtiness Tracking

[WARNING]
====
(((CSR, `mcrstatus`)))
A `mcrstatus` register may be defined, _mutatis mutandis_, in the same manner as `scrstatus` and `vscrstatus`, to allow M-mode to optimize context switches across Supervisor domains. In such a case, the `ACES` field in `sstatus` shall be unshadowed and be independent instead.
====

// ////////////////////////////////////////////////////////////////////

[[ACE-lazy-loading]]
==== Extension of `*crstatus` for Lazy Context Switching

_Lazy Context Switching_ defers the restoration of a CR from its saved SCC at context restore.
Instead, the CR is marked as “lazy”.
Any subsequent access to that CR—including export, but not operations that would overwrite it (such as clear, provisioning, or import)—causes a trap to the environment that holds the authoritative SCC: that environment will then import the SCC and return to the initial requester.
The trap handler checks whether the associated SCC can be imported and, if not, it must select another configured CR first, export it, free it and mark it instead as “lazy”.
The selection of which CR to free is delegated to software or to an implementation defined mechanism.

// may be performed by software (for example, via a random choice) or may be assisted by an implementation‑defined hardware implementation of a least-recently-used algorithm.
// We consider a model where M-mode always saves and restores the entire configured context, whereas the context switch handlers at H and (V)S may implement lazy loading.

Since a processes can be interrupted by any one of the higher-privileged modes, U-mode processes may be interrupted for the purpose of context switching by handles at VS-, H-, or even M-mode. VS-node software may be interrupted by H-, or even M-mode.
Therefore, upon resuming a process, it is important to know _which_ environment has been the last one to export the authoritative value of a given CR.

To support lazy loading of CR values, `scrstatus` and `vscrstatus` are extended to XLEN=64 bits.
On RV32, 32-bit CSRs `scrstatush` and `vscrstatush` shadow, respectively, bits [63:32] of `scrstatus` and `vscrstatus`.

_X_``crstatus``[__i__+32] encodes Normal (0) or Lazy (1) for ``K(``__i__``)``.

// When _X_``crstatus``[__i__+32] is set to Lazy (1), the semantics of bit _X_``crstatus``[__i__] change as follows:
//
// ** _X_``crstatus``[__i__] is 0 if the authoritative value of ``K(``__i__``)`` has been saved in S when V=0, or in VS when V=1.
// ** _X_``crstatus``[__i__] is 1 if the authoritative value of ``K(``__i__``)`` has been saved in HS and V=1.
//
// In other words, with lazy loading enabled, CRs can have four states.
// Beside (_X_``crstatus``[__i__+32], _X_``crstatus``[__i__]) =
// (0,0) and (0,1), i.e., Clean and Dirty,
// there are also (1,0) and (1,1), which we call Lazy-S and Lazy-H.

Let us associate numbers to the modes, with 0 denoting U-mode up to 3 for M-mode, but the range can be extended in case we have one or more levels of nested virtualization.

When a mode A saves CR ``K(``__i__``)`` for a process in mode B < A, and then lazy restores it, it sets the _X_``crstatus``[__i__+32] for all modes from A down to B+1.
It suffices for A to set this value only at B+1 since the values propagate.
In a second moment, when the handler at mode A unconfigures ``K(``__i__``)``, the hardware implicitly clears _X_``crstatus``[__i__+32] and sets _X_``crstatus``[i]= Dirty for all modes above A.
The important thing is that when the process in mode B is resumed and accesses ``K(``__i__``)``, the authoritative SCC is found in the first mode that has the `crstatus` for the ``K(``__i__``)`` not Lazy. (If it is Dirty, it means just that it is more recent than the value stored in some even higher-privileged mode).

[WARNING]
This means that the software must support a call to the parent to get the SCC for the __i__-th CR, and it is a good idea to standardize the trap, even make it into an instruction.

Using these extensions to _X_``crstatus``, when a context switching handler does not restore a CR at context restore, it instead sets _X_``crstatus``[__i__+32]
and _X_``crstatus``[__i__] accordingly.
When _X_``crstatus``[__i__+32] is set, accessing ``K(``__i__``)`` causes a trap and allows the authoritative value of ``K(``__i__``)`` to be restored.

NOTE: This feature is not only a context switching optimization, but it necessary to provide enhanced support VM migration, where it may happen that a VM is migrated to a target device where the CRF capacity is insufficient to import all the SCCs saved by the hypervisor.

[NOTE]
(At this point we may return to the two bits, and define the states as Off, Clean, Dirty, Lazy?)

// [WARNING]
// ====
// We recommend to define two CSRs: one to set the ad-hoc handler for lazy loading, and one to store the number of the CR to lazy-load.
// ====

// ////////////////////////////////////////////////////////////////////

==== Propagation of `*crstatus` Status Values

The per-CR status in `vscrstatus` (resp. `scrstatus`) propagates from less-privileged to more-privileged modes, analogously to the FS, VS, and ACES fields in `*status`,
when it is changed by hardware. If it is set by software, there is no propagation, to allow software to cover all situations that mzy occur when a process is interrupted by different modes.

The LAZY statuses are never created by hardware.

Any instruction that sets bit #__i__ of `vscrstatus` (resp. `scrstatus`) to Dirty also sets the corresponding bit of `scrstatus` (resp. `mcrstatus`).
The ACES fields of `*status` are also set accordingly.

// ////////////////////////////////////////////////////////////////////

// ==== U-mode Status for HFI
//
// _This section is not normative._
//
// A `ucrstatus` in the Unprivileged specification may become useful if the HFI extension is ratified, together with corresponding fields in a `ustatus` CSR.
// This may require the addition of another 32 bits worth of status to signal that the authoritative value of a CR is instead keep by U-mode itself, if such a mechanism is required.

// ////////////////////////////////////////////////////////////////////

==== `sacetrapmask`, `vsacetrapmask`, and `macetrapmask`

{empty}
(((CSR, `sacetrapmask`)))(((CSR, `vsacetrapmask`)))(((CSR, `macetrapmask`)))
Mask to determine which ACE exceptions vertically trap from the less-privileged modes.
Bit __i__ set makes ACE error __i__+1 cause a trap.

To handle these traps, we use the architectural `*vec`, `*epc`, `*cause`, and `*tval` CSRs.

// ////////////////////////////////////////////////////////////////////

[[ACE-CSR-macecsk]]
==== `macecsk` Group

{empty}
(((CSR, `macecsk`)))
The optional `macecsk` group consists of XLEN-bit M-mode WARZ CSRs: eight in RV32, four in RV64.

A write to the __i__-th CSR sets bits [(_i_+1)·XLEN−1 : _i_·XLEN] of the CSK.

Access outside M-mode raises an illegal instruction exception.

[NOTE]
====
M-mode firmware must be aware of whether the CSK is configurable, ephemeral, or fixed.
Persistence mechanisms for configurable CSKs are implementation-specific.
Transferring a CSK to another endpoint—such as the M-mode firmware of another device, a local TPM (for instance to preserve a CSK upon suspension or host hibernation), or a cloud-based HSM—requires an authenticated public-key key-wrapping mechanism.

Alternative reconfiguration mechanisms (e.g., a Caliptra-style cite:[caliptra] secure IP block) are permitted.
====

// ////////////////////////////////////////////////////////////////////

[[ACE-CSR-macePhysBootScrt]]
==== `macePhysBootScrt` Group

{empty}
(((CSR, `macePhysBootScrt`)))
The `macePhysBootScrt` group consists of M-mode WARZ XLEN-bit CSRs, accessed via Indirect CSR Access: four in RV32, two in RV64.

A write to the __i__-th CSR sets bits [(_i_+1)XLEN−1 : _i_·XLEN] of the Locality Secret PhysBootScrt (<<ACE-locality-indexes>>).

Access outside M-mode or Debug mode raises an illegal instruction exception.

// ////////////////////////////////////////////////////////////////////

[[ACE-CSR-haceVirtBootScrt]]
==== `haceVirtBootScrt` Group

{empty}
(((CSR, `haceVirtBootScrt`)))
The `haceVirtBootScrt` group consists of H- and VS-mode WARZ XLEN-bit CSRs, accessed via Indirect CSR Access: four in RV32, two in RV64.

A write to the __i__-th CSR sets bits [(_i_+1)XLEN−1 : _i_·XLEN] of the Locality Secret VirtBootScrt (<<ACE-locality-indexes>>).

Access below VS-mode raises an illegal instruction exception.

// ////////////////////////////////////////////////////////////////////

[[ACE-CSR-maceLocality]]
==== `maceLocality` Group

{empty}
(((CSR, `maceLocality`)))
The `maceLocality` group consists of M-mode WARZ XLEN-bit CSRs, accessed via Indirect CSR Access: four in RV32, two in RV64.

A write to the __i__-th CSR sets bits [(_i_+1)XLEN−1 : _i_·XLEN] of the Locality Secret MLocality (<<ACE-locality-indexes>>).

Access outside M-mode and Debug mode raises an illegal instruction exception.

// ////////////////////////////////////////////////////////////////////

[[ACE-CSR-haceLocality]]
==== `haceLocality` Group

{empty}
(((CSR, `haceLocality`)))
The `haceLocality` group consists of H-mode WARZ XLEN-bit CSRs, accessed via Indirect CSR Access: four in RV32, two in RV64.

A write to the __i__-th CSR sets bits [(_i_+1)XLEN−1 : _i_·XLEN] of the Locality Secret HLocality (<<ACE-locality-indexes>>).

This group shall be implemented whenever the H extension is implemented. Access below H-mode raises an illegal instruction exception.

// ////////////////////////////////////////////////////////////////////

[[ACE-CSR-saceLocality]]
==== `saceLocality` Group

{empty}
(((CSR, `saceLocality`)))
The `saceLocality` group consists of (V)S-mode WARZ XLEN-bit CSRs, accessed via Indirect CSR Access: four in RV32, two in RV64.

A write to the __i__-th CSR sets bits [(_i_+1)XLEN−1 : _i_·XLEN] of the Locality Secret SLocality (<<ACE-locality-indexes>>).

The group is accessible in S/HS-mode, VS-mode, M-mode, and Debug mode; access from any other mode raises an illegal instruction exception.

// ////////////////////////////////////////////////////////////////////

[[ACE-trappable-insns-support]]
=== Trappable (Emulated) Operations

_This section is currently non-normative._

Instructions `ace.prov`, `ace.export`, `ace.import`, `ace.input`, and `ace.output` support long inputs and outputs.
To reduce hardware complexity, these operations can be trapped and emulated in software.
(((ACE, trappable instruction)))
Upon a trap, the handler identifies the trapped instruction and uses `ace.size` on the Metadata to determine the size of the data to be transferred.
Then, the emulation uses custom instructions to move data between the ACE unit and the CPU.
Three types of supporting operations are required:

 * An “`ace.mv`” instruction that loads a specified number of bytes from a GPR or vector register into the state of a CR or in the input buffer within the ACE unit.
   Initially, `ace.size` returns the total payload length to transfer.
   After each move, this value is updated to reflect the remaining bytes.
   The instruction also updates the `acestart` CSR to follow the internal progress.
 * A corresponding “`ace.mv`” instruction that exports a specified number of bytes from a CR or from the input buffer to a GPR or vector register.
   The behavior of `ace.size` will be similar to that of the `ace.mv` instruction, but it will count the number of bytes to be exported.
 * An “`ace.close`” instruction to suspend or finalize the procedure.
   If executed before all bytes are transferred, the CR state matches that of an interrupted monolithic instruction, including any special value of the _StateNumber_ Metadata field and the value of `acestart`. If executed after all bytes are transferred, it also performs any final cryptographic operations, such as authenticating the CR.

All three instructions can be implemented as CSR RW instructions, for instance:

 * `aceactivecr`, XLEN bits wide, determines what architectural state we are transferring to or from: 0..31 for the CRs and, say, 33 for the ACEIOBUF.
 * `acestart`, XLEN bits wide, holds the offset within the CR's virtually serialized `content[]` or the ACEIOBUF.
 * `acecontent` (new), XLEN bits wide, to which we write the content of the CR or the ACEIOBUF or from which we read the current content.
  A write to `acecontent` increases `acestart` by XLEN/8.

Interrupting the firmware implementation of `ace.prov`, `ace.export`, `ace.import`, `ace.input`, or `ace.output` must leave the architectural state indistinguishable from the state expected from interrupting a monolithic implementation of the instructions.
The supporting instructions themselves must be uninterruptible.

// ////////////////////////////////////////////////////////////////////

[[ACE-trappable-insns-support]]
=== Support for Trappable Operations

Instructions `ace.init`, `ace.export`, `ace.import`, `ace.input`, and `ace.output` support arbitrarily long inputs and outputs.
To reduce hardware complexity, these operations can be trapped and emulated in software using custom instructions.

Upon a trap, the handler identifies the trapped instruction and uses the Algorithm field of the metadata block
`ace.size` to determine the size of the data to be transferred.

In order to support interrupts of the emulation libraries, such instructions need to respect the value of `ccstart` and update it in accordance with the expected architected behavior the trapped instructions.  We provide here non-normative definition for such a set of instructions in <<ACE-trappable-insns-support>>.
Three types of supporting operations are required:

* A `mv` instruction that loads a specified number of bytes from a GPR or vector register into a CC within the ACE unit.
  Initially, `ace.size` returns the total payload length to transfer.
  After each move, this value is updated to reflect the remaining bytes.
  The instruction also updates the `ccstart` CSR to follow the internal progress.
* A corresponding `mv` instruction that exports a specified number of bytes from a CC to a GPR or vector register.
  The behavior of `ace.size` will be similar to that of the move instruction, but it will count the number of bytes to be exported.
* A “`close`” instruction to suspend or finalize the procedure.
  If executed before all bytes are transferred, the CC state matches that of an interrupted monolithic instruction, including the Completion metadata field and the `ccstart` value. If executed after all bytes are transferred, it also performs any final cryptographic operations, such as authenticating the CC, if needed.

These instructions must be non-interruptible.

The initial cryptographic step of `ace.export` and the authentication step of `ace.import` are assumed to be non-interruptible.
Even if these parts are executed concurrently with other operations, the handler may need to wait for these steps to complete before proceeding with memory operations.
These instructions are not explicitly defined in the architecture. They just need to be supported by to implementation-specific firmware.
Interrupting the execution of this firmware between instructions must leave the architectural state indistinguishable from interrupting a monolithic instruction, as specified in this document.

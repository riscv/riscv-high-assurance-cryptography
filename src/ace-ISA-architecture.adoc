[[ACE-architecture]]
== Architecture

ACE is a complex architecture and relies on certain fundamental concepts, which we first introduce together in a short section.
While this leads to some repetitions, we believe that it also brings better clarity to the presentation of the architecture.

// the clarity gained from this approach outweighs the potential drawbacks.

[[ACE-concepts]]
=== Fundamental Concepts

Cryptographic Context:::
(((Cryptographic Context)))
The _Cryptographic Context_ (CC) is the fundamental concept in ACE.
All cryptographic operations performed by ACE execute within the constraints defined by a CC—an indivisible data structure comprising a *metadata* section and a *content* section.
The metadata's format is fixed, and it specifies the cryptographic algorithm associated to the CC and optional usage control policies.
(((Cryptographic Context, metadata)))
The content's format is algorithm-specific, and it holds sensitive material such as keys and internal algorithm state.
(((Cryptographic Context, content)))
Metadata requires integrity;
part of the metadata and the content require both confidentiality and integrity.
These requirements are architecturally guaranteed by ACE.

Cryptographic Register:::
(((Cryptographic Register)))
Cryptographic Contexts are realized architecturally using _Cryptographic Registers_ (CRs).
CRs are architectural, i.e., per-hart, containers that safeguard CCs.
A CR is _initialized_ by writing metadata and content into it: this operation also binds the metadata and the content to form a CC.
A CC can be used for cryptographic operations only while resident in a CR.
Only the ACE unit may access or modify CC contents, in accordance with the architecture and the programmed algorithm.
CR content cannot be extracted in a manner that compromises its confidentiality.

Sealed Cryptographic Context:::
(((Cryptographic Context, sealed)))
To support context switching while protecting CCs outside architectural state, a CC may be exported from a CR as a _Sealed Cryptographic Context_ (SCC).
An SCC is an encrypted and authenticated representation of a CC that can later be reimported into a CR.
SCC import and export use _Context Sealing Keys_ (CSKs), which may be programmable by M-mode and may depend on _Localities_ (see below).
A CC sealed with a given CSK cannot be reimported using a different CSK, enabling cryptographic domain separation across spatial and temporal
domains.

Object-Orientation:::
CCs act as _objects_ exposing a uniform interface across algorithms.
A CC encapsulates algorithm-specific behavior, enabling interchangeable use of different primitives (e.g., AES-128, AES-256, Калина-128, Калина-256, Кузнечик, SM4, and so on) in identical modes (e.g., ECB, GCM-SIV, XEX/XTS) without requiring changes to compiled code.
Side-channel-resistant variants are supported transparently.

Usage Control Policy:::
(((Cryptographic Context, Usage Control)))
ACE distinguishes between CR management (e.g., import/export) and CC usage (cryptographic operations).
To prevent denial of service scenarios, CR management operations must always be permitted.
Accordingly, the optional _Usage Control_ policies restrict only cryptographic operations and state modifications, not CR or SCC management.
For this reason, the term Usage Control is used instead of Access Control.

Locality:::
(((Cryptographic Context, Locality)))
Finally, ACE can bind CCs to a _Locality_, i.e., restrict usage to specific devices, device classes, software or hardware configurations, or boot cycles.
This binding uses metadata when a CC is in a CR, and a _Derived Context Sealing Key_ (DCSK) derived from the _Root Context Sealing Key_ (RCSK) and a Locality-specific secret as the CSK for import and export.
// The system maintains a _Locality Secrets Table_ (LST) with fixed, hardware-configured, and MM-programmable values.
// Metadata stores the Locality as an index into this table (cf.{nbsp}<<ACE-Localities>>).

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-extensions-overview]]
=== Extensions Overview

[WARNING]
This list is an early draft.

==== Unprivileged

* `Zlio` => Support for `ace.input`/`ace.output` operations
* `Zleaes128p` => Support for AES-128 encryption and decryption (all applicable modes)-the `p` at the end denotes a primitive
* `Zleaes192p` => Support for AES-192 encryption and decryption (all applicable modes)
* `Zleaes256p` => Support for AES-256 encryption and decryption (all applicable modes)
* `Zlsm4p` => Support for SM-4 encryption and decryption (all applicable modes)
* `Zlctrm` => Support for counter mode-the `m` at the end denotes a mode
* `Zlxctrm` => Support for XCTR mode
* `Zlgcmm` => Support for GCM mode
* `Zlgcmsivm` => Support for GCM-SIV mode
* `Zlxexm` => Support for XEX and XTS modes
* `Zlocbm` => Support for OCB mode
* `Zlcmacm` => Support for CMAC
* `Zlesha2h` => Support for SHA-2 (all applicable modes)-the `h` at the end denotes a hash function
* `Zlesha3h` => Support for SHA-3 (all applicable modes)
* `Zlsm3h` => Support for SM-3 hash function (all applicable modes)
* `Zlhmacm` => Support for HMAC
* `Zlascon` => Support for the ASCON suite
* `Zlkned` => NIST Suite: AES Block Cipher. Depends on `Zleaes128` and `Zleaes256`.
* `Zlkn` => NIST Algorithm Suite. Depends on `Zlkned` and `Zlesha2`.
* `Zlacev` => Must support for the following CSRs: `aceerror` and `acestart` (this is a dependency for Zicsr); must support the following instructions: `ace.init`, all four forms of `ace.exec`, `ace.clear`, `ace.export`, `ace.import`, and `ace.size`; must support `Zleaes128` and `Zleaes256` in ECB and GCM-SIV modes.
* `Zlaceio` => Must support for the following CSRs: `aceerror`, `acestart` (this is a dependency for Zicsr), `aceiobuflen` and `aceiobuftop`; must support the following instructions: `ace.init`, Form D of `ace.exec`, `ace.input` and `aceoutput`, `ace.clear`, `ace.export`, `ace.import`, and `ace.size`; must support `Zleaes128` and `Zleaes256` in ECB and GCM-SIV modes.

==== Privileged

* If `Zlace` is implemented: `misa` must implement the `L` bit, and `*status` must implement `ACES`.
* `SmaceCSK` => Defines the Root Context Sealing Key CSRs (`macercsk{0..7}`), which are all MRO.
* `SmaceCSKw` => ACE Root Context Sealing Key CSRs are MRW. Depends on `SmaceCSK`
* `Smaceosscrt` => Defines the ACE OS Secret CSRs (`maceOSSecret{0..3}`)
* `Smacebootscrt` => Defines the ACE Boot Secret CSRs (`maceBootSecret0{0..3}`)
* `Smacestatus` => Defines the ACES per CC CSRs (`macecrstatus`)

// ///////////////////////////////////////////////////////////////////////////////////////////

=== Programmer-Visible Architectural State

The recommended way to implement ACE is to implement the V extension, or at least a certain subset of it, as defined in <<ACE-V-dependency>>, which we call RVV-mini.

It is allowed to implement ACE without V or RVV-mini, by exclusively using the instructions `ace.input` and `ace.output` to provide input data and a buffer for output to and from the instructions that may use vectors.
These are, currently, `ace.exec` (cf.{nbsp}<<ACE-instruction-exec>>) and `ace.derive` (cf.{nbsp}<<ACE-instruction-derive>>).

[comment]
--
[[ACE-instructions-overview]]
==== Instructions Overview

ACE provides a number of unprivileged instructions, some implemented as CSR read/write operations.
The notation `K[Xd]`, for a GPR `Xd`, refers to the CR whose number is contained in `Xd`,
and `Kn|K[Xn]` means that there are two different encodings for when the CR number is passed as an immediate (`Kn`) or in `Xn`.

.The ACE instructions
[width="100%",cols="17%,27%,56%",options="header",subs="+macros"]
|===
| Instruction         | Operands                          |  Description
| `ace.init`          | `Kd\|K[Xd], %offset(Xs)`          |  Sets a CR's metadata and content.
| `ace.clear`         | `Kd\|K[Xd]`                       |  Clears a CR and marks it as no longer in use and clean.
| `ace.reset`         |                                   |  Resets ACE.
| `ace.export`        | `%offset(Xn) ,Ks\|K[Xs]`          |  Securely exports the content of a CR to memory.
| `ace.import{.S}`    | `Kd\|K[Xd], %offset(Xn)`          |  Authenticates and imports an SCC from memory. +
 `ace.import.S` provides optional support for system-defined formats.
| `ace.exec`
| A. {nbsp}{nbsp} `Vd, Kn\|K[Xn], Vs` +
  B. {nbsp}{nbsp} `{nbsp}{nbsp}{nbsp}{nbsp}Kn\|K[Xn], Vs` +
  C. {nbsp}{nbsp} `Vd, Kn\|K[Xn]` +
  D. {nbsp}{nbsp} `{nbsp}{nbsp}{nbsp}{nbsp}Kn\|K[Xn]`
| Performs a cryptographic operation. These instructions may modify CC state. This instruction admits four _Forms_, depending on whether it accepts an input or not, and whether it produces an output or not.
| `ace.size`
| `Xd, Ks\|K[Xs]` +
`Xd, Xs` .2+|  Returns the SCC size in bytes for CR `Ks`/`K[Xs]` or for an algorithm with metadata `Xs`.
Returns zero if the algorithm is unsupported.
`ace.available` is an alias for `ace.size`.
| `ace.available`     | `Xd, Xs`
| `ace.size{nbsp}{nbsp}\` +
`{nbsp}{nbsp}{nbsp}{nbsp}.internal`
| `Xd, Xs` |  Returns the internal capacity occupation for an algorithm with metadata `Xs`.
Returns zero if the algorithm is unsupported.
| `ace.clone`         | `Kd\|K[Xd], Ks\|K[Xs]`            |  Clones a source CR to a destination CR.
| `ace.derive`        | `Kd\|K[Xd], Ks\|K[Xs]` +
`Kd\|K[Xd], Ks\|K[Xs], Vs2` +
|  Optional. Configures destination CR using source CR (e.g., the source CR could hold a KEM, and derive symmetric keys).
| `ace.state`
| `Kd\|K[Xd], #immed` +
`Kd\|K[Xd], #immed, Xs` +
`Kd\|K[Xd], #immed, Vs`  |  Modifies algorithm state (e.g., phase transitions).
| `ace.restrict`      | `Kd\|K[Xd], Xs`                   |  Narrows Usage Policies and enables/increases side-channel protection.
   Weakening Usage Policies and SCA protection is not permitted.
| `ace.input`         | `Kd\|K[Xd], %offset(Xs)`          |  Optional. Provides input to the algorithm.
| `ace.output`        | `%offset(Xd), Ks\|K[Xs]`          |  Optional. Writes output from the algorithm.
| `ace.error`         | `Xd`                              |  Writes the ACE unit error code to GPR `Xd`.
|===
--
// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-cryptographic-registers]]
==== Cryptographic Registers

{empty}
(((Cryptographic Context)))
ACE defines 32 Cryptographic Registers (CRs), identified by numbers from 0 to 31, and called `K0`, ... , `K31`.

{empty}
(((Cryptographic Register File)))
CRs reside in a dedicated _CR file_ (CRF), accessible only by the ACE implementation.

CRs differ from conventional register in several ways:

* In place of load and store instructions, CRs can be *initialized* with clear data, but only *exported* using an AEAD algorithm, for later re-**import**.
  These actions correspond to the three instructions
  `ace.init` (cf.{nbsp}<<ACE-instruction-init>>),
  `ace.export` (cf.{nbsp}<<ACE-instruction-export>>), and
  `ace.import` (cf.{nbsp}<<ACE-instruction-import>>).
  In brief:
** `ace.init` is a load-type instruction that reads clear text into a CR, but there is no corresponding “store” instruction, i.e.,
    we can write clear data into a CR but not retrieve it as such;
** `ace.export` uses a random nonce, so repeated export of the same content may result in different ciphertexts; and
** `ace.import` may fail if the authentication tag cannot be verified.
* Unlike conventional registers, which always contain a value, CRs can be _unconfigured_, meaning they may hold no information.
  This is achieved by using the `ace.clear` instruction (cf.{nbsp}<<ACE-instruction-clear>>).
* The amount of the capacity of the CRF used by a CR depends on the configured algorithm.
  Two CRs can use different amounts of capacity.
* ACE instructions can refer to CRs directly, i.e., with a 5-bit immediate in the instruction encoding, but also indirectly, i.e., through a value in the range [0 .. 31] in a GPR.
* There are very few instructions that can use and possibly change the contents of the CRs.
  The most important ones are:
  ** `ace.exec`, used to perform cryptographic operations on data blocks according to the algorithm configured in a CR; and
  ** `ace.state`, used to determine whether a CR is used for encryption or decryption and move between the different stages of modes of operations and hash functions.

Insufficient residual CRF capacity may prevent the execution of an instruction that configures a CR, such as `ace.init` or `ace.import`,
but also `ace.clone` (cf.{nbsp}<<ACE-instruction-clone>>) or `ace.derive` (cf.{nbsp}<<ACE-instruction-derive>>).
In this case, ACE returns _ace_err_memory_, and software must free capacity by exporting the contents of another CR (if needed) and then clearing it.

Indirectly accessing a CR that is outside the defined [0 .. 31] range raises a _ace_err_unconfigured_ error.

[NOTE]
====
CRF capacity is implementation-defined, but implementations must provide sufficient capacity to allow execution of all operations defined by the architecture.
The CRF must hold at least an instance of the largest possible CR or the largest CR pair for CR cloning or derivation.
An optional, possibly approximated, and implementation dependent mechanism to estimate the required capacity is defined in <<ACE-instruction-size-internal>>.
====

[NOTE]
====
The fact that CRs can be addressed indirectly two major implications:

. Adding renaming to CRs would add significant complexity to the microarchitecture.
  However, CRs are much less often redefined than integer or floating-point registers, except for internal implied changes, hence CRs can be renamed without performance issues.
. An additional bit in the instruction encoding determines whether a CR number is given by a 5-bit immediate or by the value in a GPR.
====

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-metadata]]
==== Metadata Format

For software portability and interoperability, ACE defines two external formats for CCs:
an _Initialization Input_ format, which is loaded into a CR to create a CC,
and an encrypted, authenticated format used when exporting a CR to memory for later re-import:
the Sealed Cryptographic Context (SCC) (cf.{nbsp}<<ACE-format-SCC>>).
Both formats rely on the same metadata section format, which is described here.
The formats of the Initialization Input and of the SCC are described in <<ACE-format-configuration>> and <<ACE-format-SCC>>, respectively.

{empty}
(((Cryptographic Context,metadata,format)))
The metadata section is 64 bits long and its format is described in <<ACE-metadata-standard>>.
The metadata section is used as the header of the data formats used in CR initialization, and SCC export and import functions.

[[ACE-metadata-standard]]
.Format of the Metadata Section
[width="100%",cols="^9%,^7%,17%,67%",options="header"]
|===
.>|   Field .>| Width +
(bits) .>| Name                  .>| Description
|   [0:0] |   1  | Format                 | Value is 0 for the current metadata format. +
Future format will have a 1 in this position and may be longer than 64 bits.
|   [4:1] |   4  | Locality               | A field which is either all ones (15) or an index into the Locality Secrets Table.
|   [5:5] |   1  | Reserved               | Zero.
|  [15:6] |  10  | Algorithm              | Algorithm (such as primitive or mode). 0 means the CC is invalid.
| [17:16] |   2  | SC_Protection          | Level of Side Channel Protection, encoded as per <<ACE-SC-protection-levels>>.
| [19:18] |   2  | Direction_Policy       | Determines whether the CC may be used for encryption (bit 12 set), decryption (bit 13 set), or both (bits 12 and 13 set). Valid only for encryption/decryption primitives or modes, and ignored, for instance, for hash functions.
| [21:20] |   2  | Key_Type               | Key given by explicit value / System Key (index) / Internally generated.
| [25:22] |   4  | State_Number           | Encoding the current state of the state machine of the algorithm as a number.
| [29:26] |   4  | UC_Policy              | “UC Policy” means “Usage Control Policy”. If bit 26, 27, 28, resp. 29 is set, it disallows the _usage_ of this CC in User, (V)S-mode, H-mode, resp. M-mode.
| [31:30] |   2  | Reserved               | Zero.
| [34:32] |   3  | Filter-Mode            | Mode at which to apply the filter: 0 = none; 1 = U; 2 = (V)S; 3 = H; +
4 = time stamp ([.red]#minutes since January 1^st^, 2027?#).
| [59:35] |  25  | Filter                 | Value to match against the `*acefilter` CSRs (see <<ACE-CSR-filters>> for details) or against the internal secure timer.
| [63:60] |   4  | Reserved               | Zero.
|===

Confidentiality:::
Bits [31:0] are not confidential and will not be encrypted upon export as SCC. +
Bits [63:32] are confidential and will be encrypted upon export as SCC.

Algorithm field:::
Algorithms are encoded in a 10-bit field.
Algorithm numbers 0-895 are architecture-defined and the list of such encodings is maintained by RVI.
cf.{nbsp}<<ACE-algorithms>> for the currently encoded algorithms.

SC_Protection field::: {empty}
+
--
Certain minimal Side-Channel protection levels are defined by the architecture.
[[ACE-SC-protection-levels]]
.Encoding of Side-Channel Protection levels
[float="center",align="center",width="76%",cols="^8%,<68%",options="header"]
|===
| Value | Description
|   0   | No protection.
|   1   | Data-independent timing, first-order threshold implementation.
|   2   | Data-independent timing, first-order threshold, fault-tolerant implementation.
|   3   | Custom, algorithm dependent.
|===

Custom algorithms may offer stronger side channel protection guarantees than those specified in the encoding values 0 to 2.
In such a case, the value of the SC_Protection field must be set to 3.
--
+

Key_Type field::: {empty}
+
--
ACE supports keys provided by software, as well as system keys and keys computed with a system “recipe”.
These key types are encoded as follows:
[[ACE-key-type]]
.Encoding of Key_Type
[float="center",align="center",width="76%",cols="^8%,<68%",options="header"]
|===
| Value | Description
|   0   | Explicit value.
|   1   | The key comes from an internal, system specific System Keys Table (SKT). For each algorithm as specified in <<ACE-algorithms>>, the part of the content that normally contains the key(s) is replaced by a 64-bit value which is an index into the (SKT)-for both Initialization Input and the SCCs. The actual value of the key is never included in exported content. For threshold implementations, ACE may copy the key material from the SKT into the CR and expand it into multiple shares.
|   2   | Internally generated key.  System specific.  In the Initialization Input, the part of the content that normally contains the key(s) is replaced by a “recipe” in a system-specific format. The format is not specified by the ISA and may not be portable to other systems. Once the key material has been internally generated, the value is included in the SCC as part of the content—not the “recipe”—as for any other key(s) for the same specified algorithm.  The Key_Type field of the metadata in all representations of the CC, will keep the value 2.
|   3   | Invalid.
|===
--
+

//
State_Number field::: {empty}
+
--
The value of the State_Number Field must be zero in the initialization data.
Three values are defined for *all* algorithms: 0, 14, and 15, for the states _initial_, _invalidated_, and _completed_.
These states denote CCs that are ready to perform operations, that have been put into an invalid state, or that have completed their operations.

If the algorithm encoded in the CC has at most 16 states (including _initial_, _completed_, and _invalidated_), then this number is stored in this field, otherwise an algorithm-specific representation is used in the content, and this field only admits the values 0, 14, 15, and 1, the latter being a placeholder for any other operational state. The values used in the algorithms defined in this specification are listed in <<ACE-state-constants>>.
--
+

Usage Control Policy::: {empty}
* Bits 26, 27, resp 28 must be set to 1 if U-mode, S-mode, resp. H-mode is not supported/enabled.

//

[[ACE-Localities]]
==== Localities

Internally, ACE keeps a table of 128-bit Locality Secrets (LS), the Locality Secrets Table (LST).
Some entries of the LST are fixed or configurable only using an implementation—specific authenticated hardware procedure, and these are
global and shared across all ACE units in the same system or in the same SoC.
A few entries may be programmed by M-mode and are architectural, i.e., per hart.

If the Locality Field of a CC is all ones (15), then the RCSK is used.
Otherwise, this value is used as an index _i_ in the LST, and the actual CSK is derived from the RCSK and LST[_i_].

<<ACE-locality-indexes>> lists the architected Localities and whether M-mode can configure them.
The domain of each Locality Secret is specified, i.e., whether the value is chip-wide
(i.e., the same across all chiplets in the same SoC),
device-wide, or OS-wide.

[[ACE-locality-indexes]]
.Architected Locality Values
[width="100%",cols="23%,45%,^9%,^14%,^9%",options="header"]
|===
.>| Name .>| Description .>| Domain | M-mode +
Configurable .>| Value +
(Index)
| (No Locality binding)     | No CSK derivation. CC bound to Root CSK only. | -- | -- | 15
| ChipManufacturerSecret    | Identifies the manufacturer of the SoC. Permanent. | SoC | N | 0
| ChipModelSecret           | Identifies specific chip model/family. Permanent. | SoC | N | 1
| ChipUniqueSecret          | Unique for each SoC. Permanent. | SoC | N | 2
| OEMSecret                 | Provisioned by OEM to differentiate their products from the competition.
                              Can be permanent, or optionally reconfigurable by impdef HW authenticated mechanisms. | Device | N | 3
| ProductSecret             | Identifies device/system type/model (product). Not necessarily permanent. Reconfigurable like OEMSecret. | Device | N | 4
| DeviceSecret              | Unique device (entire system) secret (_not_ the device ID such as a serial number). Shared across all harts in a SoC and shareable across multiple SoKs in a single device. Sharing mechanism impdef, i.e., not architected. Reconfigurable like OEMSecret. | Device | N | 5
| OSSecret                  | Identifies Operating System (or System Stack).
                              Not permanent, must be configured at (virtual) boot. | OS | Allowed | 6
| BootSecret                | Regenerated at each (virtual) boot. | OS | Allowed | 7
| Reserved                  | Reserved for future use (RZ if not defined). | Impdef | Impdef | 8-14
|===

The constant Localities_MAX is the maximum number of Localities supported by the system.

NOTE: M-mode is responsible for virtualizing the OSSecret and BootSecret Locality Secrets.

*Example*: _If a key's metadata specifies a Locality field value of 2, the import/export key is derived from the RCSK and the OEM Secret. An SCC created on one device will fail authentication when imported on another device if their OEM Secrets differ._

NOTE: A CC may reference a key via an index into the System Key Table (SKT).
A device-specific SKT entry may correspond to a different key on another device.
Using the latter may lead to unspecified behavior.
Implementations of the SKT *must* provide a suitable Locality to the ACE unit during CR configuration, and set usage policies that are at least as strict as the key's own.

[[ACE-format-definition]]
==== Initialization Inputs

The Initialization Input configures a Cryptographic Register (CR) to create a Cryptographic Context (CC).
Its total length must be a multiple of 8 bytes.
The first 8 bytes constitute the metadata section, as defined in <<ACE-metadata>>.
The subsequent bytes form the *content*—the key material and any algorithm-specific data—whose format and length are specified in <<ACE-algorithms>> for all architected algorithms. The content's structure and size are entirely determined by the Algorithm and Key_Type fields within the metadata.

[[ACE-format-SCC]]
==== Sealed Cryptographic Contexts

The format of the SCCs is used when exporting a CC from a CR and is used also to reimport the CC into a CR.
It is dependent on the algorithm being used.
Its size must be a multiple of 8 bytes.

Format of SCC:::
(((Cryptographic Context, SCC plaintext)))
`bytes{nbsp}[{nbsp}{nbsp}0 .. 3{nbsp}{nbsp}{nbsp}{nbsp}]{nbsp}{nbsp}` Metadata, non-encrypted part (includes Algorithm and Key_Type). +
`bytes{nbsp}[{nbsp}{nbsp}4 .. 7{nbsp}{nbsp}{nbsp}{nbsp}]{nbsp}{nbsp}` Metadata, encrypted part. +
`bytes{nbsp}[{nbsp}{nbsp}8 .. 19{nbsp}{nbsp}{nbsp}]{nbsp}{nbsp}` Nonce used in the encryption (96 bits). +
`bytes{nbsp}[{nbsp}20 .. 31{nbsp}{nbsp}{nbsp}]{nbsp}{nbsp}` Tag produced by the encryption method (96 bits). +
`bytes{nbsp}[{nbsp}32 .. u+31{nbsp}]{nbsp}{nbsp}` Encrypted serialized content of the CR, with a byte length of `u`.

Both metadata and the serialization of the content are authenticated, but only the latter is encrypted (the method is described in <<ACE-SCC-AEAD>>).

The metadata section of an SCC follows the same fixed architectural format as for the corresponding section of the Initialization Input.
The content format—and consequently its length—is algorithm-specific (cf.{nbsp}<<ACE-algorithms>>) and is determined solely by the Algorithm and Key_Type fields in the metadata as well, but in general differs from the content section of the Initialization Input.

[[ACE-CSR]]
==== CSRs

ACE extends `*status` and `misa`, and adds up to 26 new CSRs to manage its execution environment.
They are listed in <<ACE-CSRs-table>>.

[[ACE-CSRs-table]]
.New ACE CSRs
[cols="<16%,^11%,<24%,<49%"]
[float="center",align="center",options="header"]
|===
| Address        | Privilege | Name                     | Description
| 0xXXX          | URW       | `aceerror`               | Error code of the last ACE instruction
| 0xXXX          | URO       | `acecrstatus`            | Array of two-bit fields (similar to ACES state, but per CR)
| 0xXXX          | URW       | `acestart`               | ACE start byte index (see warning below)
| 0xXXX          | URW       | `aceiobuflen`            | ACE I/O buffer length
| 0xXXX          | URW       | `aceiobuftop`            | ACE I/O buffer limit for current transfers
| 0xXXX          | URO       | `acesequence`            | Sequence number of the last ACE instruction
| 0xXXX          | URW       | `aceactivecr`            | Active CR for `ace.input`/`ace.output`
| 0xXXX          | SRW       | `sacefilter`             | Filter that applies to U-mode
| 0xXXX          | HRW       | `vacecrstatus`           | Array of two-bit fields (similar to ACES state, but per CR)
| 0xXXX          | MRW       | `macefilter`             | Filter that applies to (V)S/H-mode
| 0xXXX--0xXXX   | MRW (RZ)  | `macercsk{0..7}`         | ACE Root Context Sealing Key
| 0xXXX--0xXXX   | MRW (RZ)  | `maceOSSecret{0..3}`     | ACE OS Secret
| 0xXXX--0xXXX   | MRW (RZ)  | `maceBootSecret0{0..3}`  | ACE Boot Secret
|===

[WARNING]
`acestart` may be overloaded with `vstart`, regardless of the presence of the V extension.
If a vector instruction is interrupted, the register would follow the `vstart` semantics (i.e., it would count the number of `SEW`-bit long elements processed), whereas if an ACE instruction is interrupted, the register would follow the `acestart` semantics (i.e., it would count the number of bytes processed).

==== Extension to existing CSRs

[[ACE-ACE-field-in-misa]]
===== ACE field in `misa`

{empty}
(((CSR, ACE field in `misa`)))
Bit `L` (11) in `misa` indicates that ACE is present.

[[ACE-ACES-field-in-status]]
===== ACES field in `*status`

{empty}
(((CSR,ACES field in *status)))
The ACES field (bits 26:25) is added to `mstatus` and shadowed in `sstatus` and `vsstatus` (if the hypervisor extension is present).
Similarly to the FS and VS fields, it is used to optimize context switching.
If ACE is implemented, ACES shall not be read-only zero.
Its possible values are given in <<ACE-aces-encoding>>.

[[ACE-aces-encoding]]
.Encoding of ACES status field
[float="center",align="center",width="100%",cols="^8%,<8%,<84%",options="header"]
|===
|Status |Name |Meaning
|   0   | Off                | ACE disabled. CRs are inaccessible. The hart will trap if the user requests to enable the feature.
|   1   | Initial            | ACE enabled. No CR is configured.
|   2   | Clean              | ACE enabled. The state matches the last context swap (Clean).
|   3   | Dirty              | ACE enabled. Some CRs may have been modified since last Clean.
|===

Writes to ACES do not affect CR contents.
Clearing state is not performed by setting ACES to Off, Initial, or Clean, and it must be explicitly done by privileged code before changing ACES.

In <<fsxsstates-copy>> we describe the transitions between states.

[WARNING]
<<fsxsstates-copy>> is a copy of Table “FS, VS, and XS state transitions” of cite:[RISCV-ISA-Priv]
and it will be removed from this document once the extension is ratified.

//

[[fsxsstates-copy]]
.ACES state transitions
[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
|Current State |Off |Initial |Clean |Dirty
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|At context save in privileged code

|Save state? +
Next state
|No +
Off
|No +
Initial
|No +
Clean
|Yes +
Clean
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|At context restore in privileged code

|Restore state? +
Next state
|No +
Off
|Yes, to initial +
Initial
|Yes, from memory +
Clean
|N/A +
N/A
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^| Execute instruction to read state

|Action? +
Next state
|Exception +
Off
|Execute +
Initial
|Execute +
Clean
|Execute +
Dirty
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|Execute instruction that possibly modifies state

|Action? +
Next state
|Exception +
Off
|Execute +
Dirty
|Execute +
Dirty
|Execute +
Dirty
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|Execute instruction to unconfigure unit

|Action? +
Next state
|Exception +
Off
|Execute +
Initial
|Execute +
Initial
|Execute +
Initial
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|Execute instruction to disable unit

|Action? +
Next state
|Execute +
Off
|Execute +
Off
|Execute +
Off
|Execute +
Off
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|Execute instruction to enable unit

|Action? +
Next state
|Execute +
Initial
|Execute +
Initial
|Execute +
Initial
|Execute +
Initial
|===

==== New Unprivileged CSRs

The new unprivileged CSRs introduced by ACE are defined here.

[[ACE-CSR-ace-error]]
===== `aceerror`

The 8-bit `aceerror` CSR records the error code from the most recent ACE instruction.
Reading it may stall the hart until the operation completes.
It is writable for context switching.

Error codes 0–127 are reserved for RVI, and codes 128–255 are reserved for custom algorithms.
The standard error codes are:

[[ACE-error-codes]]
.Error codes and their meanings
[float="center",align="center",width="100%",cols="^6%,<23%,<71%",options="header"]
|===
|Value | Mnemonic                | Examples (((ACE, error codes)))
|  0   | ace_err_ok              | No error.
|  1   | ace_err_authentication  | Authentication failure (`ace.import` or `ace.exec`).
|  2   | ace_err_privilege       | Access control failure (`ace.exec`, `ace.state`, etc.).
|  3   | ace_err_invalid         | Invalid input/operation.
Examples:
invalid metadata passed to `ace.init` is invalid;
encryption, resp., decryption is requested from a CC only configured for decryption, resp., encryption;
a Form of `ace.exec` that is not permitted in the current algorithm state is used;
the requested change of state in `ace.state` is not permitted;
the change in usage policies in `ace.restrict` is not permitted;
software tried to use an incomplete CC in a CR as a source in an `ace.exec`, `ace.state`, `ace.input`, `ace.output`, `ace.clone`, `ace.derive`, or `ace.restrict` operation.
|  4   | ace_err_unimplemented   | Algorithm or algorithm variant not implemented.
|  5   | ace_err_memory          | Insufficient CRF memory to perform `ace.init`, `ace.exec`, `ace.clone`, or `ace.derive`.
|  6   | ace_err_unconfigured    | Usage of unconfigured CR in `ace.exec`, `ace.state`, `ace.input`, `ace.output`, `ace.clone`, `ace.derive`, or `ace.restrict`. May trigger lazy reload.
|===

<<<

[[norm:ace_exc_priority]]
.ACE error priority in decreasing priority order.
[float="center",align="center",width="100%",cols="^9%,>7%,<84%",options="header"]
|===
.>|Priority   .>|Error +
Code        .>|Description
.>|_Highest_  |6               |Unconfigured CR
|           .>|3             .>|Invalid input/output operation with `ace.init` (invalid metadata)
|           .>|4             .>|Algorithm or algorithm variant not implemented.
|           .>|5             .>|Insufficient CRF memory
|           .>|3             .>|Invalid input/output operation with `ace.exec`, `ace.state`,
                                `ace.input`, `ace.output`, `ace.clone`, `ace.derive`,
                                or `ace.restrict` (used incomplete CC as source)
|           .>|2, 1          .>|Access Control Failure or authentication failure with `ace.import`
|           .>|1             .>|Authentication failure with `ace.exec`
|           .>|3             .>|Invalid input/output operation with `ace.exec`
                                (form not allowed in current algorithm),
                                `ace.state` (state change not allowed),
                                or `ace.restrict` (change of usage policy is not allowed)
.>|_Lowest_ .>|0             .>|No error
|===

If executing an `ace.init`, `ace.import`, `ace.export`, `ace.input`, or `ace.output` triggers a
trap, as specified in the privileged architecture, `aceerror` remains unchanged.

//

===== `acecrstatus`

The CSR `acecrstatus` tracks the configuration and dirtiness of CRs on a per-CR basis, so that privileged context switching code needs to save only the dirty CRs, and restore only the configured ones, unless the latter are lazy-loaded:

. For RV64, `acecrstatus` has a size of 64 bits,
``acecrstatus[``2__i__+1,2__i__``]`` can take the values Off, Init, Clean, Dirty as defined for `*status.ACES` for CR #__i__.
. For RV32, there are two 32-bit registers `acecrstatush` and `acecrstatusl` (collectively referred to as `acecrstatus` in the following)
where
``acecrstatus[``2__i__+1,2__i__``]`` can take the values Off, Init, Clean, Dirty as defined for `*status.ACES` for CR #__i__
and
``acecrstatus[``2__i__+1,2__i__``]`` for CR #__i__+16.

This section defines the semantics of the `acecrstatus` bitfields:

* *INITIAL* (value: 1).
+
--
 ** *State*: Unconfigured.
 ** *Permitted operations*: None.
 ** *Usage*: Raises _ace_err_unconfigured_. No trap is generated.
 ** *Configuration*: Does not trap. Transitions to *DIRTY*.
--
+

* *LAZY* (value: 0).
+
--
 ** *State*: Unconfigured. A value is saved for lazy loading.
 ** *Permitted operations*: Export and usage trigger a trap to the operating system for lazy loading. Execution resumes from state *CLEAN*.
 ** *Configuration*: Works as expected; sets status to *DIRTY*.
--
+

* *CLEAN* (value: 2).
+
--
 ** *State*: The CR configured and loaded. Its state has not changed since the last switch.
 ** *Permitted operations*: Unrestricted; modification sets status to *DIRTY*.
 ** *Configuration*: Works as expected; sets status to *DIRTY*.
--
+

* *DIRTY* (value: 3).
+
--
 ** *State*: The CR configured and loaded. Its state has potentially changed since the last switch.
 ** *Permitted operations*: Unrestricted.
 ** *Configuration*: Works as expected; status unchanged.
--
+

//

NOTE: The *LAZY* status reuses the FS/VS/ACES encoding for “OFF”, this does not indicate that the ISE is inactive, nor that the ISE cannot use that CR.
Whether the ISE is active is encoded exclusively in ```*status```. The use of the **OFF** encoding in the per-CR fields of `acecrstatus` is a natural choice to denote an unavailable state that requires lazy loading to be made available.
If all CRs were either unconfigured or to be lazy-loaded, the ACES field would be set to **CLEAN** and not to **OFF**.

//

[[ACE-CSR-acestart]]
===== `acestart`

`acestart` is an XLEN-bit RW CSR, similar to `vstart`, tracking progress of long-running interruptible instructions such as `ace.init`, `ace.import`, `ace.export`, `ace.input`, and `ace.output`.
(((CSR, acestart)))

Unlike the vector extension’s `vstart`, which tracks element indices, ACE has no notion equivalent to that of vector elements:
`acestart` therefore records a byte offset.
For a load-type instruction (e.g., `ace.init`, `ace.import`, `ace.input`), this offset indicates how many bytes of input have already been read and processed.
For a store-type instruction (e.g., `ace.export`, `ace.output`), it indicates how many bytes of output have already been computed and written.
The value includes all payload bytes (metadata, content, nonce, tag) and accommodates piecewise execution via traps (cf.{nbsp}<<ACE-trappable-insns-support>>).

This register is typically written by hardware.
Software may safely write 0 to fully restart an operation, and the register can be saved and restored during context switches.
However, software must not write arbitrary nonzero values to it, as this may result in an illegal-instruction exception, as the hardware or a trapped implementation are not required to support all possible values.
Only the instructions explicitly mentioned above support non-zero `acestart` values; other ACE instructions ignore this register, and will be restarted.

Initialization, import, and export operations may be interrupted and resumed if no context switch occurs,
as indicated by the value in the `acestart` CSR.  If a context switch occurs, they must be restarted.

[NOTE]
====
_A single `acestart` value suffices due to the way the init/import/export instructions operate:_

* `_ace.init_` _and_ `_ace.import_` _use a single pass: all blocks are processed sequentially._
* `_ace.export_` _uses two passes. However, the first pass to compute the SIV is purely internal, and never accesses memory, so page faults cannot occur.
This first pass is uninterruptible.
The second pass writes metadata, nonce, SIV, then encrypted content to memory.
Only the second pass can cause page faults and may require resumption._

This design obviates the need to separate data transfer from cryptographic processing during import and export operations. A separate transfer phase would require buffering the entire input within the ACE unit before processing, increasing internal resource requirements, whereas the current architecture can process data inline and is loaded with minimal overhead.
====

A different situation arises when an `ace.exec` instruction operates on long vectors containing multiple elements, in which case, usually, `VL*SEW` is a multiple of the basic processing unit usually denoted by `b` (such as a block size).
In the algorithm description we explicitly mention that a block of operations is repeated for each block in the vector:
the execution of these iterative `ace.exec` instructions may be interrupted and resumed.
Regardless of whether the operations are on vectors or on the input/output buffer, `acestart` reflects the number of bytes processed so far.

The semantics and use of `acestart` are described in <<ACE-format-configuration>>.

The two CSRs described next may be used to optimize saving and restoring the input/output buffer.

[[ACE-CSR-aceiobuflen]]
===== `aceiobuflen`

`aceiobuflen` is an XLEN-bit RW CSR.

`aceiobuflen` is used to program the size of the input/output buffer for the `ace.input` and `ace.output` instructions.

Reconfiguring `aceiobuflen` will invalidate the buffer contents.

If the size is zero, `ace.input` and `ace.output` will raise an invalid instruction exception.

[[ACE-CSR-aceiobuftop]]
===== `aceiobuftop`

`aceiobuftop` is an XLEN-bit RW CSR.

`aceiobuftop` is used to program the top end of a transfer operation to and from the input/output buffer for the `ace.input` and `ace.output` instructions.
In conjunction with `acestart` it defines the range of buffer.

Reconfiguring `aceiobuftop` will not invalidate the buffer contents.

Reconfiguring `aceiobuflen` will initially set `aceiobuftop` to the same value.

If `aceiobuftop` is zero, `ace.input` and `ace.output` will raise an invalid instruction exception.

[[ACE-CSR-acesequence]]
===== `acesequence`

This is an XLEN-bit URO CSR (2 bits defined).

It takes the value zero if we are using vector registers for the current `ace.exec` or `ace.derive`.
It may take non-zero values only if using `ace.input`/`ace.output` in place of vector registers.

Details in <<ACE-usage-input-output>>.

[[ACE-CSR-aceactivecr]]
===== `aceactivecr`

This is an XLEN-bit URW CSR (5 bits defined).

It serves to tie `ace.input`,  `ace.output`, `ace.exec`, and `ace.derive` instructions to the state of a specific CR.
It can take values 0 to 31, or 32 to disable the tie.

It can only be changed if `acesequence` is zero.

If the value is not 32, the CR in `ace.exec` and the source CR in `ace.derive` can only have this value, otherwise an invalid instruction exception is raised.
This serves to make sure that the instructions are issued in the correct order.

==== New Privileged CSRs

The new privileged CSRs introduced by ACE are defined here.

===== `vacecrstatus`

The CSR `vacecrstatus` exists only if H-mode is implemented, and it is HRW.

It is similar to `acecrstatus`, however it works to track the status of the CRs at the VS-mode.

. For RV64, `vacecrstatus` has a size of 64 bits,
`vacecrstatus[``2__i__+1,2__i__``]`` can take the values Off, Init, Clean, Dirty as defined for `*status.ACES` for CR #__i__.
. For RV32, there are two 32-bit registers `vacecrstatush` and `vacecrstatusl` (collectively referred to as `vacecrstatus` in the following)
where
``vacecrstatus[``2__i__+1,2__i__``]`` can take the values Off, Init, Clean, Dirty as defined for `*status.ACES` for CR #__i__
and
``vacecrstatus[``2__i__+1,2__i__``]`` for CR #__i__+16.

The semantics of the bitfields of `vacecrstatus` are the same as those of `acecrstatus`.

[comment]
--
Any change to `acecrstatus` is reflected in `vacecrstatus` as follows:

* If an operation in U-mode changes a field of `acecrstatus` to *DIRTY*, the corresponding field in `vacecrstatus` is set to *DIRTY*.
* If an operation in U-mode changes a field of `acecrstatus` to *CLEAN* from a different state, the corresponding field in `vacecrstatus` is set to *DIRTY*.
* If an operation in U-mode changes a field of `acecrstatus` to *INIT*, the corresponding field in `vacecrstatus` is set to *INIT*.
* If an operation in U-mode changes a field of `acecrstatus` to *LAZY*, the corresponding field in `vacecrstatus` is set to ?.
* An operation in VS-mode changes `vacecrstatus` in the same way as the corresponding operation in U-mode would change `acecrstatus`.
* If S-mode changes a field of `acecrstatus` to *CLEAN*, the corresponding field in `vacecrstatus` is set to *CLEAN*.
* If S-mode changes a field of `acecrstatus` to *DIRTY*, the corresponding field in `vacecrstatus` is set to *DIRTY*.
* If S-mode changes a field of `acecrstatus` to *INIT*, the corresponding field in `vacecrstatus` is set to *INIT*.
* If S-mode changes a field of `acecrstatus` to *LAZY*, the corresponding field in `vacecrstatus` is set to *CLEAN*.
--

//

[[ACE-CSR-macercsk]]
===== `macercsk` group

This is a group of M-Mode WARZ XLEN-bit CSRs.

Eight CSRs may be defined in RV32 and four in RV64 to configure `macercsk`:
(((CSR, `macercsk`)))

* In RV32 these are `macercsk0`, `macercsk!`, ... `macercsk7`.
* In RV64 these are `macercsk0`, `macercsk1`, `macercsk2`, and `macercsk3`

A write to `macercsk{i}` set Bits [(_i_+1) XLEN - 1 : _i_ XLEN] of the RCSK.

Any access to the `macercsk` block outside of M-mode will cause an illegal instruction exception.

NOTE: We assume that M-mode firmware knows if RCSK is configurable, ephemeral, or fixed.
RCSK cannot be assumed to be preserved across power cycles, unless it is fixed.
If the RCSK is reconfigurable, mechanisms for RCSK persistence and cross-device transfer to assist VM migration are system-specific and belong to M-mode firmware.
Cross-device RCSK migration must use a public-key key wrapping mechanism.
Since M-mode FW cannot just trust any external entity claiming to be a trusted device:
all receiving end points, whether they are the M-mode FW of another trusted device, a TPM for temporary storage of a VM's CSK during device hibernation, or an HSM for intermediate CSK storage, must authenticate themselves.

The values written to the `macercsk` block must follow the value update rules defined in <<ACE-CSR-group-update-policy>>.

[[ACE-CSR-group-update-policy]]
===== Value update policy for CSR groups

The implementation must keep track of which CSRs in the group have been written to and which CSRs have not,
and only change the key when the entire group has been written to.

This can be done using a bitmap with one bit per CSR in the group.
The bitmap is cleared upon entering M-mode.
When the __i__-th CSR in the group is written to, the __i__-th bit of the bitmap is set.
When the bitmap is all ones, the key is set with the values written to all CSRs in the group, and the bitmap is cleared.

===== `maceOSSecret` group

This is a group of M-Mode WARZ XLEN-bit CSRs.

Four CSRs may be defined in RV32 and two in RV64 to configure `maceOSSecret`:
(((CSR, `maceOSSecret*`)))

* In RV32 these are `maceOSSecret0`, `maceOSSecret1`, `maceOSSecret2`, and `maceOSSecret3`.
* In RV64 these are `maceOSSecret0` and `maceOSSecret1`.

A write to `maceOSSecret{i}` sets Bits [(_i_+1) XLEN - 1 : _i_ XLEN] of `OSSecret`.

Any access to the `macercsk` block outside of M-mode will cause an illegal instruction exception.

The values written to the `maceOSSecret` group must follow the update rules defined in <<ACE-CSR-group-update-policy>>.

===== `maceBootSecret` group

This is a group of M-Mode WARZ XLEN-bit CSRs.

Four CSRs may be defined in RV32 and two in RV64 to configure `maceeBootSecret`:
(((CSR, `maceeBootSecret*`)))

* In RV32 these are `maceeBootSecret0`, `maceeBootSecret1`, `maceeBootSecret2`, and `maceeBootSecret3`.
* In RV64 these are `maceeBootSecret0` and `maceeBootSecret1`.

A write to `maceeBootSecret{i}` sets Bits [(_i_+1) XLEN - 1 : _i_ XLEN] of `maceBootSecret`.

Any access to the `macercsk` block outside of M-mode will cause an illegal instruction exception.

The values written to the `maceeBootSecret` group must follow the update rules defined in <<ACE-CSR-group-update-policy>>.

[NOTE]
====
`maceBootSecret*` must be reconfigurable in order to support VM reboots which are independent of the boot cycles if the physical host.
====

[[ACE-CSR-filters]]
===== `sacefilter`, `macefilter`

`sacefilter` is an XLEN-bit SRW CSRs (22 bits defined).

`macefilter` is an XLEN-bit MRW CSRs (22 bits defined).

Their values are compared against the Filter field of the metadata, to determine whether an `ace.exec`, `ace.state`, or `ace.derive` instruction is allowed to execute:
* `sacefilter` is set and owned by (V)S-mode and it is used to filter CC usage in U-mode.
* `macefilter` is set and owned by M-mode and it is used to filter CC usage in (V)S/H-mode.

[WARNING]
These two registers are placeholders for a later decision on how to handle the CR filtering in different modes.
One option could be to use `scontext`/`hcontext`/`mcontext` from the Sdtrig extension.
We believe that the final decision will be better taken in accordance with the ARC.

[comment]
--
[[ACE-CSR-reuse-ASID-VMID]]
==== Reuse of `(v)satp`.ASID and `hgatp`.VMID without S/H?

ACE reuses `(v)satp`.ASID and `hgatp`.VMID to optionally restrict the usage of CCs to a specific process or virtual machine.
In the metadata section, `ASID` and `VMID` are always zero padded to the maximal lengths of 16 and 14 bits, respectively.

[WARNING]
Currently, `satp` is only defined when the Supervisor is enabled.
similararly, `hgatp` is only defined if the Hypervisor extension is enabled.
We propose to define the `ASID` and `VMID` fields of these registers also when ACE is provided in order to allow M-mode to be able to separate a main OS from a TEE, for instance, on devices that implement TEEs using mechanisms based on Sv, PMP/Smepmp cite:[RISCV-ISA-Priv]. If only U- and M-mode are available, this would allow M-mode to separate the CCs of the various U-mode processes.

NOTE: Regarding Supervisor Domains (SDs) cite:[RISC-V-SD] and Worlds cite:[RISC-V-Worlds] we observe that there is no room in the current metadata format for adding filtering by `SDID` (`mmtp.SDID`) and WID.
This is not an issue since we recommend to use separation by RCSK in combination with SDs or Worlds, which does not prevent a program running in a SD or World to provide a CC to a program running in a different SD or World. This is done by by configuring a CR and then relinquishing control to M-mode to export the CR with the RCSK used by the target software.
The same holds for any intended separation by hart ID (`mhartid`), which is facilitated by the fact that the RCSK CSR group is per-hart.

NOTE: The software in each World/Supervisor Domain is normally responsible to generate or obtain their own keys, and if a process (applet) in one World/Supervisor Domain is responsible to provide keys to other Worlds/Supervisor Domains, it is the responsibility of the M-mode formware to perform an appropriate `ace.import`/RCSK switch/`ace.export` sequence.
--

[[ACE-format-configuration]]
=== Semantics of Initialization, Export and Import of Cryptographic Contexts

In the pseudocode listings of this section, `UNINTERRUPTIBLE_BLOCK_START` marks the start of an uninterruptible code block, and `UNINTERRUPTIBLE_BLOCK_END` its end.
When an interrupted init, export or import or operation is resumed, it will resume at the point of interruption.

Anything before the first `UNINTERRUPTIBLE_BLOCK_START` consists only of type declarations and possibly information that is trivial to reconstruct.

The Data Structures of the algorithms (such as those defined in <<ACE-algorithms>>) also define the `content[]` array in the pseudocode.
`content[]` offers a _view_ of (certain fields of the) the content of a CR as if the latter were serialized as in the plaintext format of the content in an SCC, such that any change in one, except for the non-serialized fields, is reflected in the other.
As such, it is a virtual representation; its consecutive bytes do not imply physical contiguity within the CR, nor there is a 1-1 correspondence between its bytes and those in the CR.  For instance, keys may be split across shares in a threshold implementation, so that one key byte in `content[]` corresponds to two or three non-contiguous bytes in the CR.
However, any read or write to `content[]` must bijectively map to the underlying representation, in the sense that a write followed by a read must return the original data, and a read followed by a write must restore an equivalent microarchitectural state.

[[ACE-init]]
==== Initialization

We start with the algorithm that reads an initialization input and uses it to initialize a CR. The algorithm is as follows:

[[ACE-init-listing]]
.Initializing a CR with metadata and content
[]
----
M : array of bytes // from memory

// next instruction preemptible, with `acestart` from 0 to 7
UNINTERRUPTIBLE_BLOCK_START
|  metadata : bits(64) = M[0 .. 7]
|  if (there is not enough memory for the algorithm encoded in the metadata)
|     error ace_err_insufficient_memory
|  z ← size(content according to metadata);
|  content ← internal buffer for z bytes;
|  num_blocks = ceil(z / 16);
|  last_block_fractional : boolean ← (z % 16 != 0);
UNINTERRUPTIBLE_BLOCK_END

foreach(i from 0 to num_blocks - 1) {
  // next instruction preemptible, with `acestart` from 32+i*16 to 39+i*16 or 47+i*16
  UNINTERRUPTIBLE_BLOCK_START
  |  if ((i == num_blocks - 1) and last_block_fractional)
  |     content[i*16 .. 7+i*16] ← M[8+i*16 .. 15+i*16];
  |  else
  |     content[i*16 .. 15+i*16] ← M[8+i*16 .. 23+i*16];
  UNINTERRUPTIBLE_BLOCK_END
}

// if preempted here, `acestart` will be z
UNINTERRUPTIBLE_BLOCK_START
|  - Now the content can be deserialized: Keys may be converted into shares, and
|  - any derived values not given in the initialization input will be computed here.
UNINTERRUPTIBLE_BLOCK_END
----

[[ACE-SCC-AEAD]]
==== AEAD Algorithm for SCC Export and Import

The AEAD algorithm chosen to export CRs into SCCs is AES-GCM-SIV.
We follow the definition of the algorithm from cite:[DBLP-journals-iacr-GueronLL17] and cite:[RFC8452].
We first define the Key Derivation and the DCSK Derivation functions.

.RFC8452 Key Derivation
[]
----
function RFC8452_KeyDeriv(key) = {
  struct {
    AESE256(key, (zeros(125) @ 0b101))[63:0] @ AESE256(key, (zeros(125) @ 0b100))[63:0] @
    AESE256(key, (zeros(125) @ 0b011))[63:0] @ AESE256(key, (zeros(125) @ 0b010))[63:0],
    AESE256(key, (zeros(125) @ 0b001))[63:0] @ AESE256(key, (zeros(125) @ 0b000))[63:0]
  }
}
----

.Derived Key Derivation
[]
----
function DCSK_KeyDeriv(key,L) = {
    AESE256(key, L ^ (zeros(127) @ 1)) @ AESE256(key, L ^ zeros(128))
}
----

NOTE: Due to the computational cost of the derivation functions, implementations may
cache recently used derived keys for both the Root RCSK and Locality-derived keys.

The generation of the SCC from the CC in a CR (cf.{nbsp}<<ACE-SCC-export>>) and the import of a SCC into a CR (cf.{nbsp}<<ACE-SCC-import>>) are defined next.

[[ACE-SCC-export]]
.Generation of the SCC from a CR Using AES-GCM-SIV (RFC8452)
[]
----
metadata : bits(64); // from the CR
N, SIV : bits(96);
tmp : bits(128);
enc_key : bits(256);
auth_key : bits(128);
content : array[z] of bytes,      // from the CR's metadata
where z : int ← size(content);    // content is serialized, size derived from metadata
ASSERT(8 divides z);
M : array[32 + z] of bytes;       // information
let last_block_fractional : boolean ← z % 16 != 0;
let num_blocks : int ← ceil(z / 16);

UNINTERRUPTIBLE_BLOCK_START
|  N ← random(96 bits);
|
|  if (metadata.Locality == 15) then
|     CSK ← RCSK;
|  else
|     CSK ← DCSK_KeyDeriv(RCSK, LST[metadata.Locality]);
|
|  {enc_key, auth_key} = RFC8452_KeyDeriv(CSK);
|
|  - If some internal operations are needed to make the content available,
|  - such as reconstructing threshold keys/values into a single share, these
|  - must be computed at this point. Starting with the following POLYVAL operation
|  - content will refer to the resulting data as architected for non-threshold
|  - implementations.
|
|  tmp ← POLYVAL(auth_key, zeros(64) @ metadata @ content);
|  SIV ← AESE(enc_key, 0 @ (tmp[126:0] xor (zeros(31) @ N)))) >> 32;
UNINTERRUPTIBLE_BLOCK_END

// preemptible here, with `acestart` from 0 to 15
UNINTERRUPTIBLE_BLOCK_START
|   M[0 .. 15] ← N[63:0]
|                @ (metadata[63:32] xor AESE(enc_key, 1 @ SIV[94:0] @ zeros(32))[31:0])
|                @  metadata[31:0];
UNINTERRUPTIBLE_BLOCK_END

// preemptible here, with `acestart` from 16 to 31
UNINTERRUPTIBLE_BLOCK_START
|   M[16 .. 31] ← SIV[95:0] @ N[95:64];
UNINTERRUPTIBLE_BLOCK_END

foreach(i from 0 to num_blocks - 1) {
  // next instruction preemptible, with `acestart` from 32+i*16 to 39+i*16 or 47+i*16
  UNINTERRUPTIBLE_BLOCK_START
  |  if ((i == num_blocks - 1) and last_block_fractional)
  |     M[32+i*16 .. 39+i*16] ← content[i*16 .. 7+i*16]
  |                             xor AESE(enc_key, 1 @ SIV[94:0] @ bin(i+1, 32))[63:0];
  |  else
  |     M[32+i*16 .. 47+i*16] ← content[i*16 .. 15+i*16]
  |                             xor AESE(enc_key, 1 @ SIV[94:0] @ bin(i+1, 32));
  UNINTERRUPTIBLE_BLOCK_END
}
----

[[ACE-SCC-import]]
.Importing a SCC into a CR Using AES-GCM-SIV (RFC8452)
[]
----
M : array of bytes // from memory
enc_key : bits(256);
auth_key : bits(128);
N, SIV : bits(96);
tmp : bits(128);
tag : bits(96);

// next instruction preemptible, with `acestart` from 0 to 7
UNINTERRUPTIBLE_BLOCK_START
|  metadata : bits(64) ← M[0 .. 7]
|  if (there is not enough memory for the algorithm encoded in the metadata)
|     error ace_err_insufficient_memory
UNINTERRUPTIBLE_BLOCK_END

UNINTERRUPTIBLE_BLOCK_START
|  z ← size(content according to metadata);
|  content ← internal buffer for z bytes;
|  num_blocks ← ceil(z / 16);
|  last_block_fractional : boolean ← (z % 16 != 0);
|
|  if (metadata.Locality == 15) then
|     CSK ← RCSK;
|  else
|     CSK ← DCSK_KeyDeriv(RCSK, LST[metadata.Locality]);
|
|  {enc_key, auth_key} = RFC8452_KeyDeriv(CSK);
|
|  // next instruction preemptible, with `acestart` from 8 to 19
|  N ← M[8 .. 19];
UNINTERRUPTIBLE_BLOCK_END

// next instruction preemptible, with `acestart` from 20 to 31
UNINTERRUPTIBLE_BLOCK_START
|  SIV ← M[20 .. 31];
|  metadata[63:32] ← metadata[63:32]
|                    xor AESE(enc_key, 1 @ SIV[94:0] @ zeros(32))[31:0];
|  tmp ← zeros(64) @ metadata;
|  tmp ← Mont_mult(tmp, auth_key);
UNINTERRUPTIBLE_BLOCK_END

foreach(i from 0 to num_blocks - 1) {
   // next instruction preemptible, with `acestart` from 32+i*16 to 39+i*16 or 47+i*16
   UNINTERRUPTIBLE_BLOCK_START
   |  if ((i == num_blocks - 1) and last_block_fractional) {
   |     content[i*16 .. 7+i*16] ← M[32+i*16 .. 39+i*16]
   |                               xor AESE(enc_key, 1 @ SIV[94:0] @ bin(i+1, 32))[63:0];
   |     tmp[63:0] ← tmp[63:0] xor content[i*16 .. 7+i*16];
   |  } else {
   |     content[i*16 .. 15+i*16] ← M[32+i*16 .. 47+i*16]
   |                                xor AESE(enc_key, 1 @ SIV[94:0] @ bin(i+1, 32));
   |     tmp ← tmp xor content[i*16 .. 15+i*16];
   |  }
   |  tmp ← Mont_mult(tmp, auth_key);
   UNINTERRUPTIBLE_BLOCK_END
}

// if preempted here, `acestart` will be z + 32

UNINTERRUPTIBLE_BLOCK_START
|  tag ← AESE(enc_key, 0 @ (tmp[126:0] xor (zeros(31) @ N)))) >> 32;
|  if (tag != SIV) then { error ace_err_authentication; }
|  - Now the content can be deserialized.
|  - This includes computing any derived values not saved as part of the SCC,
|  - as well as creating shares for threshold implementations.
UNINTERRUPTIBLE_BLOCK_END
----

//

// ///////////////////////////////////////////////////////////////////////////////////////////

=== Supported Algorithms

[WARNING]
This list is not yet finalized. Also, at the end we must add algorithm numbers!

ACE architects support for several algorithms. The following is the minimal required subset:

* AES-128 and AES-256 encryption and decryption.
* AES-CTR, AES-GCM, AES-GCM-SIV, AES-XTS using AES-128/256.
* AES-CMAC using AES-128/256.
* SHA-2, SHA-2-HMAC.

The list of other architected algorithms is subject to change, but it includes at least:

* AES-192, alone and with the above modes.
* SM4 Block Cipher.
* The Ascon suite (Ascon-128/128a-AEAD, Ascon-Hash, Ascon-XOF, Ascon-80pq).
* SHA-3, SHA-3-HMAC.
* SM3 Secure Hash.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-instructions-detailed]]
=== Instructions

ACE provides a number of unprivileged instructions, some implemented as CSR read/write operations.
This section specifies the semantics and encodings of these instructions.

The notation `K[Xd]`, for a GPR `Xd`, refers to the CR whose number is contained in `Xd`,
and `Kn|K[Xn]` means that there are two different encodings for when the CR number is passed as a 5-bit immediate (`Kn`) or via the value of `Xn`.
When a GPR is used to index a CR, use of the zero register `X0` is reserved and results in an illegal instruction exception.

For each instruction, we specify whether

* it _possibly modifies state_,
* it is _usage-controlled_,
* it is _trappable_, i.e., can be implemented by privileged code as trap-and-emulate, and whether
* the execution of the instruction itself can be _interrupted_, for instance by context switches or page faults, to be resumed or restarted later.

NOTE: Trappability refers only on the CPU-side of the implementation and it is a distinct concept from _custom implementations of primitives within the ACE unit_.
Implementers may, for instance, incorporate a secure CPU with updatable firmware to support new primitives.
While the architecture does not prohibit this, such an approach substantially expands the attack surface of the ACE unit.

[WARNING]
The encodings presented here are just examples, and for the moment RV64-only, and may not be final.
They serve as a starting point for discussion and refinement as
well as a proof that, at the time of this writing, the ACE instruction set
can be encoded.


[[ACE-instruction-init]]
==== ace.init

`ace.init Kd|K[Xd], %offset(Xs)`
(((ACE, instruction, ace.init)))

Encoding::
`ace.init` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Ks','K[Xd]'] },
    { bits:  3, name: 'ace.init', attr: [0x4,0x5] },
    { bits:  5, name: 'Xs' },
    { bits: 12, name: 'imm', attr: ['offset'] },
]}
....

Description::
`ace.init` initializes a CR with metadata and content to create a CC.
`Kd` or `K[Xd]` denotes the CR to be initialized.
`Xs` points to the region of memory containing the metadata and the key material.

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *NO*. +
Trappable: *YES*. +
Interruptible: *YES*.

NOTE: `ace.init`, as well as `ace.import`, `ace.export`, `ace.input`, and `ace.output` as described later, perform direct memory accesses.
This does not violate the RISC-V load/store architecture principles,
since `ace.init`, `ace.import` and `ace.input` can be seen as special kinds of load instructions and
`ace.export` and `ace.output` as special store instructions.
// as ACE is architected to behave like an _attached_ unit, which may have its own interfaces.

NOTE: The operation follows the two-phases processing model defined in <<ACE-format-configuration>>.
In the first phase, the metadata block is read, which determines the length of the remaining information.
Then, in the second phase, the configuration material is read and processed.

[[ACE-instruction-clear]]
==== ace.clear/ace.reset

`ace.clear Kd|K[Xd]` +
(((ACE, instruction, ace.clear)))
`ace.reset`
(((ACE, instruction, ace.reset)))

Encoding::
`ace.clear/ace.reset` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Ks','K[Xd]'] },
    { bits:  3, name: 'ace.clear', attr: [0x6,0x7] },
    { bits:  5, name: 0x0 },
    { bits: 12, name: 0x0 },
]}
....

Description::
For `ace.clear`, `Kd` or `K[Xd]` denotes the CR to be cleared. +
`ace.reset` uses the encoding for `ace.clear` with indirect CR addressing (the `ace.clear` field is `3'b111`) and `Xd` = `X0` (the `context` field is `0`).

Properties::
`ace.clear` possibly modifies state. +
`ace.reset` unconfigures the unit. +
Usage-controlled: *NO*. +
Trappable: +
{nbsp}{nbsp}``ace.clear``: *NO*; +
{nbsp}{nbsp}``ace.reset``: *YES* (it can be implemented as a series of `ace.clear` instructions). +
Interruptible: *NO*.

[[ACE-instruction-export]]
==== ace.export

`ace.export %offset(Xd), Ks|K[Xs]`
(((ACE, instruction, ace.export)))

Encoding::
`ace.export` is an S-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'imm[4:0]' },
    { bits:  3, name: 'ace.export', attr: [0x0,0x1] },
    { bits:  5, name: 'Xd' },
    { bits:  5, name: 'context', attr: ['Ks','K[Xs]'] },
    { bits:  7, name: 'imm[11:5]' },
]}
....

Description::
Exports the CR `Ks` or `K[Xs]` to memory at address `Xd`, using the procedure described in <<ACE-format-SCC>>.
If the context is unconfigured, or `Xs` is out of range, the operation will report error ace_err_invalid.

The instruction must follow the interruptibility rules defined in <<ACE-CSR-acestart>>.
Similarly to entire-vector-register store instructions, `ace.export` appears to other harts as sequences of individual stores.

The initial cryptographic phase of `ace.export`, as well as the authentication phase of `ace.import`, must be uninterruptible.
Even if these parts are executed concurrently with other operations, an interrupt handler may need to wait for these steps to complete before proceeding with any memory accesses.

Properties::
Possibly modifies state: *NO*. +
Usage-controlled: *NO*. +
Trappable: *YES*. +
Interruptible: *YES*.


[[ACE-instruction-import]]
==== ace.import

`ace.import{nbsp}{nbsp}{nbsp}Kd|K[Xd], %offset(Xn)` +
`ace.import.S{nbsp}Kd|K[Xd], %offset(Xn)`
(((ACE, instruction, ace.import)))
(((ACE, instruction, ace.import.S)))

Encoding::
`ace.import` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Kd','K[Xd]'] },
    { bits:  3, name: 'ace.import', attr: ['0    0    S','0    1    S'] },
    { bits:  5, name: 'Xn' },
    { bits: 12, name: 'imm' },
]}
....

Description::
`Kd` or `K[Xd]` denotes the CR into which the SCC is to be imported. +
`Xn` is the GPR containing the base address of the buffer with the source SCC. +
The bit S takes the values 0 (false) or 1 (true).
It is set to true if the key is in a system defined format
(`ace.import.S`)
and not the format defined by the present architecture
(`ace.import`).

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *NO* +
Trappable: *YES*. +
Interruptible: *YES*.


The instruction must follow the interruptibility rules defined in <<ACE-CSR-acestart>>.
Similarly to entire-vector-register load instructions, `ace.import` appears to other harts as sequences of individual loads.

NOTE: The operation can be conceptually split into two phases.
In the first phase, the metadata
block is read, which determines the length of the remaining information.
Then, in the second phase, the rest of the SCC is read and processed.

NOTE: The instruction encoding includes a single bit to indicate a system-defined format. If multiple such formats are supported, the data format itself must incorporate a unique identifier to differentiate them. The system is therefore responsible for embedding these identifiers within all system-defined formats.

NOTE: The `ace.export` instruction does not have an `ace.export.S` analogue of `ace.import.S`.
This means that system-specific dynamically generated keys can be imported but not exported in the same form: they must be exported in the format architected here for ACE CCs.

[[ACE-instruction-exec]]
==== ace.exec

The `ace.exec` instruction admits four Forms, namely
(((ACE, instruction, ace.exec)))

[upperalpha]
. `ace.exec  Vd, Kn|K[Xn], Vs` {nbsp}{nbsp} takes an input vector and writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}{nbsp}Kn|K[Xn], Vs` {nbsp}{nbsp} takes an input vector but does not write to an output vector.
. `ace.exec  Vd, Kn|K[Xn]{nbsp}{nbsp}{nbsp}{nbsp}` {nbsp}{nbsp} does not take an input but writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}{nbsp}Kn|K[Xn]{nbsp}{nbsp}{nbsp}{nbsp}` {nbsp}{nbsp} does not take an input vector and does not write to an output vector.

// Without this comment, the next part is not properly formatted...

Encoding::
`ace.exec` is an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Vd' },
    { bits:  3, name: 'ace.exec' },
    { bits:  5, name: 'Kn|K[Xn]' },
    { bits:  5, name: 'Vs' },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....
+
Bit `r` (i.e., bit 27) takes the value 0 if the context is encoded as an immediate,
and it takes the value 1 if a GPR (scalar integer value) is used to reference it.
For the four Forms A-D above, the encodings are:
+
[upperalpha]
. `ACE.exec` = `0b000`.
. `ACE.exec` = `0b001` and `rs2` = `0b00000`.
. `ACE.exec` = `0b010` and `rd` = `0b00000`.
. `ACE.exec` = `0b011` and `rs2` = `rd` = `0b00000`.

NOTE: We admit variants of Forms B and D, which we call Form B', resp., Form D',
with non-zero values in `rd`, resp., `rs2`, to encode additional instructions.

// To make indent in next line correct

Description::
Performs a cryptographic operation such as an encryption or decryption, absorbing a value in a hash,
an elliptic curve point addition or scalar multiplication, etc., and possibly returning a value.
+
If the V extension register file is not implemented, only Form D of `ace.exec` is supported
(the derived Forms used to define other instructions are still supported) and `ace.input`, `ace.output` must be used to
provide inputs and extract outputs from `ace.exec`.
<<ACE-usage-input-output>> described how this is done.

NOTE: In many algorithms, performing an operation could imply a state change. For instance, setting an IV or nonce in an AEAD mode of operation might also transition to the state for absorbing associated data.  To maintain consistency, ACE mandates explicit state transitions, even when this requires additional instructions.  ACE also requires that only one form of the `ace.exec` instruction is allowed per distinct algorithm state.  Exceptions are permitted only when necessary to maintain security, such as automatic transitions from hash finalization to verification, or to the _completed_ or _invalidated_ states (cf.{nbsp}<<ACE-state-constants>> and <<ACE-algorithms>>).

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *NO*. +
Interruptible: See interruptibility rules in <<ACE-generic-rules>>.

[[ACE-instruction-size]]
==== ace.size

`ace.size` returns the size of the memory buffer that would be necessary to store the exported SCC.
(((ACE, instruction, ace.size)))
Knowing this size is necessary for any feature that relies on `ace.export`, including context switching.

Properties::
Possibly modifies state: *NO*. +
Usage-controlled: *NO*. +
Trappable: *NO*. +
Interruptible: *NO*.

//

[[ACE-instruction-size-CR]]
===== Context Variant

`ace.size Xd, Ks|K[Xs]`

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x3, attr: ['ace.exec', '(Form D\')'] },
    { bits:  5, name: 'Ks|K[Xs]' },
    { bits:  5, name: 0x1, attr: ['ace.size'] },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....
+
Bit `r` (i.e., bit 27) is 0 if the CR is encoded as an immediate, and 1 if the CR's number is given in a GPR.

Description::
Returns the size of the SCC corresponding to the source CR `Ks` or `K[Xs]`.

NOTE: The returned value can significantly differ from the internal resource usage to store the CC's data in a CR—it can be larger (for simple primitives, because of the nonce/SIV overhead) but
also smaller (for keys split into shares for threshold implementations, but saved
externally in reconstructed form).

[[ACE-instruction-size-metadata]]
===== Metadata Variant

`ace.size Xd, Xs`

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x3, attr: ['ace.exec', '(Form D\')'] },
    { bits:  5, name: 'Xs' },
    { bits:  5, name: 0x2, attr: ['ace.size'] },
    { bits:  7, name: 0x0 },
]}
....

Description::
This instruction writes the size of a SCC having the metadata section given in `Xn` into GPR `Xd`, and zero if the algorithm is not supported.
Only the Algorithm and Key_Type fields of the metadata section of a CC need to be considered to determine the size of the SCC (as per <<ACE-algorithms>>).
+
On RV32 the GPR `Xs` needs to contain only the lower 32 bits of the metadata section, since they contain the fields which are required to determine the size of the SCC.

[[ACE-instruction-size-internal]]
===== Internal Capacity Variant

`ace.size.internal Xd, Xs`

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x3, attr: ['ace.exec', '(Form D\')'] },
    { bits:  5, name: 'Xs' },
    { bits:  5, name: 0x3, attr: ['ace.size'] },
    { bits:  7, name: 0x0 },
]}
....

Description::
This instruction writes into GPR `Xd` the amount of internal capacity a CC having the metadata section given in `Xn` would occupy in terms of implementation-dependent units. Passing the value `ones(64)` into `Xs` results in the total amount of internal capacity.
Only the bits corresponding to the Algorithm, SP_Protection, Direction_Policy and Key_Type fields are considered and all other bits must be zero, except when passing `ones(64)`.
If the combination of Algorithm, SP_Protection, Direction_Policy and Key_Type fields is not supported, the instruction writes zero into `Xd`.
+
On RV32 the GPR `Xs` needs to contain only the lower 32 bits of the metadata section, since they contain the fields which are required to determine the size of the SCC.
In this case, the value of `Xs` to obtain the fill CRF capacity is `ones(32)`.


[[ACE-instruction-available]]
==== ace.available

`ace.available Xd, Xs`
(((ACE, instruction, ace.available)))

Alias to the Metadata Variant of `ace.size`, as it returns zero if the algorithm is not supported.

Properties::
Same as `ace.size`.

//

[[ACE-instruction-clone]]
==== ace.clone

`ace.clone Kd|K[Xd], Ks|K[Xs]`
(((ACE, instruction, ace.clone)))

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Kd|K[Xd]' },
    { bits:  3, name: 0x3, attr: ['ace.exec','(Form D\')'] },
    { bits:  5, name: 'Ks|K[Xs]' },
    { bits:  5, name: 0x3, attr: ['ace.clone'] },
    { bits:  1, name: 0x0 },
    { bits:  2, name: 'R' },
    { bits:  4, name: 0x0 },
]}
....
+
Bits [27:26], i.e., field `R`, take the following values depending on how the CRs are given:
+
[upperalpha]
. `00`{nbsp}{nbsp} if the source and the output CRs are both encoded as immediates.
. `01`{nbsp}{nbsp} if the source CR is selected using a GPR and the output CR is encoded as an immediate.
. `10`{nbsp}{nbsp} if the source CR is encoded as immediate and the output CR is selected using a GPR.
. `11`{nbsp}{nbsp} if the source and the output CRs are both selected using the values of GPRs.

(The first digit is bit 27 and the second digit is bit 26.)

// Comment to ensure proper indentation in the next Description

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *NO*. +
Trappable: *YES*, it can be implemented as an export followed by an import in a handler. +
Interruptible: *NO*.

Description::
Clones source CR `Ks` (or the CR indexed by `Xs`) into destination CR `Kd` (or into the CR indexed by `Xd`).

NOTE: The `ace.clone` instruction is an optimization for the sequence `ace.export` followed by `ace.import`. While reusing cryptographic state (e.g., encrypting with the same counter) can enable certain attacks, this risk cannot be eliminated by omitting `ace.clone`, as a state can be exported and re-imported multiple times.

[[ACE-instruction-derive]]
==== ace.derive (optional)

`ace.derive Kd|K[Xd], Ks1|K[Xs1]` +
`ace.derive Kd|K[Xd], Ks1|K[Xs1], Vs2`
(((ACE, instruction, ace.derive)))

Encoding::
The encoding is a variant of Form A `ace.exec` encoding, and is thus an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Kd|K[Xd]' },
    { bits:  3, name: 0x0, attr: ['ace.exec (Form A)'] },
    { bits:  5, name: 'Ks1|K[Xs1]' },
    { bits:  5, name: 'Vs2', attr: ['use for additional input','no additional input (zero field)'] },
    { bits:  1, name: 0x1 },
    { bits:  2, name: 'R' },
    { bits:  1, name: 'z', attr: [0x1,0x0] },
    { bits:  3, name: 0x0 },
]}
....
+
This encoding differs from Form A `ace.exec` by having bit 25 set to 1.
Bits [27:26], i.e., field `R`, is encoded exactly as for `ace.clone` (cf.{nbsp}<<ACE-instruction-clone>>).
Bit 28 determines whether an additional vector register (or register group) is used to pass a parameter to the key derivation mechanism or not.

Description::
The instruction is used to derive a new context from an existing one, with its own opaque key material.
It is similar to `ace.clone`, but the derived context is not a copy of the source context,
rather, it is a new context that is derived from it, for instance, through a key derivation mechanism.
This instruction can be used multiple times, to generate multiple derived contexts.
+
The first variant of `ace.derive` has the same semantics of the second variant if the input/output buffer is not empty
(cf.{nbsp}<<ACE-usage-input-output>>).


Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *NO*. +
Interruptible: *NO*.

[[ACE-instruction-state]]
==== ace.state

`ace.state Kd|K[Xd], #immed7` +
`ace.state Kd|K[Xd], #immed7, Xs` +
`ace.state Kd|K[Xd], #immed7, Vs`
(((ACE, instruction, ace.state)))

Encoding::
`ace.state` is an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Kd|K[Xd]' },
    { bits:  3, name: 0x4, attr: ['ace.state'] },
    { bits:  1, name: 'r', attr: ['0','1'] },
    { bits:  1, name: 'v' },
    { bits:  3, name: 0x0 },
    { bits:  5, name: 'rs1', attr: ['Xd','Vd'] },
    { bits:  7, name: 'immed7' },
]}
....
+
Bit `r` (i.e., bit 15) is 0 if the context is encoded as an immediate, and 1 if a GPR is used to reference it. +
Bit `v` (i.e., bit 16) is 0 if the additional input comes from a GPR and 1 if it comes from a vector register.

Description::
`Kd` or `K[Xd]` is the CR whose state is to be set. +
The `#immed` operand is a constant from the set of admissible values defined for each algorithm, used to manage the algorithm's internal state machine when additional states are required. +
The new state number, if allowed, is written into the State_Number field of the metadata, unless the algorithm requires more than 16 states, in which case an ad-hoc field must be defined in the context (for both internal representation and SCCs). +
`Xs` or `Vs` is a register that contains an optional additional parameter for the state machine.
Note that `X0` is used to encode the version without additional parameter when no additional parameter is expected, otherwise it provides zero as the additional parameter, and `V0` is a valid input.


Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *NO*. +
Interruptible: *NO*.

The state numbers used in this specification are defined in <<ACE-state-constants>>.

It is always allowed to repeat `ace.state` instructions to the current state, provided that the correct form of the instruction is used.

[[ACE-instruction-restrict]]
==== ace.restrict

`ace.restrict{nbsp}{nbsp}Kd|K[Xd], Xs`
(((ACE, instruction, ace.restrict)))

// Without this comment, the next part is not properly formatted...
Encoding::
The encoding uses `ace.exec` Form B', with bit 7 (which is in the `rd` field) set.
It is thus a variant of an R-type instruction.
The source register field encodes a GPR and not a vector register.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 0x1 },
    { bits:  3, name: 0x1, attr: ['ace.exec', '(Form B\')'] },
    { bits:  5, name: 'Kd|K[Xd]' },
    { bits:  5, name: 'Xs' },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....
+
If bit `r` (i.e., bit 27) is 0, the 5-bit destination field [11:7] contains the destination context number,
else it determines the GPR that contains the context number.

// comment

Description::
+
--
This instruction can be used to:

* Restrict the usage of a CC (as stored in a CR) to specific modes or to a specified Filter;
* Restrict the use of encryption or decryption in a CC that allows both; and
* Activate the side-channel protection of the CC or increase it.

Let `m` be the metadata field of the CC in the destination CR. +
On RV64, the instruction works as follows:

* `Xs`[15:0] and `Xs`[25:20] must be zero
* `Xs`[19:16] and `Xs`[63:32] must have the same format as the corresponding bits of the metadata.
* `Xs`[17:16] can be used to turn on or increase the level of the side-channel protection of the algorithm in the CC, if the microarchitecture supports the corresponding implementation. The levels are defined in <<ACE-SC-protection-levels>>. Downgrading side-channel protection is not permitted, and attempting to do so will result in error _ace_err_invalid_ (cf.{nbsp}<<ACE-error-codes>>).
* `Xs`[19:18] can be used to deactivate encryption or decryption in a CC that allows both, otherwise it is ignored. Writing to them cannot be used to deactivate both encryption and decryption simultaneously, nor to activate encryption, resp., decryption in a CC that did not allow it.  In particular, if `m`[19:18] = `2'b11`, then this case at least one bit of `Xs`[19:18] must be set to 1. In all other cases, either `Xs`[19:18] = `m`[19:18] or zero, in which case it is ignored.
* A zero in any of the four bits `Xs`[29:26] means that the corresponding policy is _not_ changed.
* A one in any of the four bits `Xs`[29:26] means that usage by the corresponding mode is forbidden, and the corresponding bit in the metadata of the destination CC is set to 1.
* `Xs`[33:32] can be non-zero only if `m`[33:32] is zero, in which case  `m`[55:34] <- `Xs`[55:34], else `aceerror` is set to ace_error_invalid.

// * A zero in any of the six bits `Xs`[31:26] means that the corresponding policy is _not_ changed.
// * A one in any of the four bits `Xs`[29:26] means that usage by the corresponding mode is forbidden, and the corresponding bit in the metadata of the destination CC is set to 1.
// * If `Xs`[30] is set and `m`[30] is NOT set, then UC_Policy_3, i.e., `m`[47:32], is set to `Xs`[47:32].
// * If `Xs`[31] is set and `m`[31] is NOT set, then UC_Policy_4, i.e., `m`[63:48], is set to `Xs`[63:48].
// * If `Xs`[30] and `m`[30] are both set and `Xs`[47:32] != `m`[47:32], then `aceerror` is set to ace_error_invalid.
// * If `Xs`[31] and `m`[31] are both set and `Xs`[63:48] != `m`[63:48], then `aceerror` is set to ace_error_invalid.

On RV32, `s` must be even and register pair `X[s]` and `X[s+1]` is read, where
`X[s]` corresponds to bits [31:0] and `X[s+1]` to bits [63:32] of the metadata.
In other words, `Xs` is replaced by `(X[s+1] @ X[s])` in the above description.
--
+

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *NO*. +
Interruptible: *NO*.

//

[NOTE]
====
This instruction enables several practical use cases:

*   Enabling side-channel protection when supported by the microarchitecture, even if the original CC was not configured with it.
*   Allowing privileged code to give a CC to several processes by first cloning it and setting the Filter in each copy to the target process's Filter, thereby restricting usage of this CC only to authorized processes.
*   Similarly, enabling privileged code to split a CC capable of both encryption and decryption into two CCs, one only capable of encryption and the other only capable of decryption, thereby creating a one-way channel between processes.

The ability to perform such customizations saves both time and computational resources by avoiding additional round-trips to trusted environments.
====

//

[[ACE-instruction-error]]
==== ace.error

`ace.error Xd`
(((ACE, instruction, ace.error)))

Description::
The ACE Unit may be in an error state due to the previous operation.
The corresponding error code is written into GPR `Xd`.
This is implemented as a read from CSR `aceerror`, which may cause the hart to wait if the error code is not yet available (cf.{nbsp}<<ACE-CSR-ace-error>>).
The error code list is architected and given in <<ACE-error-codes>>.

Properties::
Possibly modifies state: *NO*. +
Usage-controlled: *NO*. +
Trappable: *NO*. +
Interruptible: *NO*.

//

[[ACE-instruction-input]]
==== ace.input (optional)

`ace.input %offset(Xs), Xl`
(((ACE, instruction, ace.input)))

Encoding::
`ace.input` is an S-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'imm[4:0]' },
    { bits:  3, name: 'ace.input', attr: [0x4] },
    { bits:  5, name: 'Xl' },
    { bits:  5, name: 'Xs' },
    { bits:  7, name: 'imm[11:5]' },
]}
....

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *YES* +
Trappable: *YES*. +
Interruptible: *YES*.

Description::
In all cases where the vector registers are not sufficiently long, or not implemented, inputs can be read directly from memory and written directly to memory.
For this reason, the architecture defines `ace.input` and `ace.output` (cf. next section).
Their usage is explained in <<ACE-usage-input-output>>.

//

[[ACE-instruction-output]]
==== ace.output (optional)

`ace.output %offset(Xd), Xl`
(((ACE, instruction, ace.output)))

Encoding::
`ace.output` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 'ace.output', attr: [0x4] },
    { bits:  5, name: 'Xl' },
    { bits: 12, name: 'imm' },
]}
....

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *YES*. +
Interruptible: *YES*.


// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-trappable-insns-support]]
==== Support for Trappable (Emulated) Operations

[WARNING]
This section is currently non-normative. There are ongoing discussions on whether to formalize it completely and make it normative.

Instructions `ace.init`, `ace.export`, `ace.import`, `ace.input`, and `ace.output` support long inputs and outputs.
To reduce hardware complexity, these operations can be trapped and emulated in software.
(((ACE, trappable instruction)))
Upon a trap, the handler identifies the trapped instruction and uses `ace.size` on the metadata to determine the size of the data to be transferred.
Then, the emulation uses custom instructions to move data between the ACE unit and the CPU.
Three types of supporting operations are required:

 * An “`ace.mv`” instruction that loads a specified number of bytes from a GPR or vector register into the state of a CR or in the input buffer within the ACE unit.
   Initially, `ace.size` returns the total payload length to transfer.
   After each move, this value is updated to reflect the remaining bytes.
   The instruction also updates the `acestart` CSR to follow the internal progress.
 * A corresponding “`ace.mv`” instruction that exports a specified number of bytes from a CR or from the input buffer to a GPR or vector register.
   The behavior of `ace.size` will be similar to that of the `ace.mv` instruction, but it will count the number of bytes to be exported.
 * An “`ace.close`” instruction to suspend or finalize the procedure.
   If executed before all bytes are transferred, the CR state matches that of an interrupted monolithic instruction, including the Incomplete metadata field and the `acestart` value. If executed after all bytes are transferred, it also performs any final cryptographic operations, such as authenticating the CR, if needed.

All three instructions can be implemented as CSR RW instructions, for instance:

 * `acedest`, XLEN bits wide, determines what architectural state we are transferring to or from: 0..31 for the CRs and, say, 32 for the input/output buffer.
 * `acestart`, XLEN bits wide, holds the offset within the CR's virtually serialized `content[]` or the input/output buffer.
 * `acecontent`, XLEN bits wide, to which we write the content of the CR or the input/output buffer or from which we read the current content.
  A write to `acecontent` would also increase `acestart` by XLEN/8.

Interrupting the firmware implementation of `ace.init`, `ace.export`, `ace.import`, `ace.input`, or `ace.output` must leave the architectural state indistinguishable from the state expected from interrupting a monolithic implementation of the instructions.
In particular, they need to respect the value of `acestart` and update it in accordance with the expected architected behavior of the emulated instructions.

The supporting instructions themselves must be uninterruptible.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-algorithms]]
=== Algorithms

In this section we specify the behavior of Cryptographic Contexts for the supported cryptographic algorithms.
Some specifications are generic: they define algorithm families that can be instantiated with any primitive meeting the required properties, typically parameterized only by block size `b` and key size `k`.
For example, GCM-SIV is well defined not only with AES but also with alternative block ciphers, such as SM4-GCM-SIV, when used with the same hash function.
By contrast, the specifications for other algorithm suites are specific to certain primitives, for instance, Ascon.

This section is normative.

Each algorithm is fully defined by the following information:

Parameters:::
These include:
* The _block size_ `b`, which is the size of the basic unit of information processed by the algorithm, usually the block size of the main underlying primitive;
* The _key size_ `k`, for keyed algorithms; and
* Any other parameter (for instance, counter size) that is necessary to instantiate the algorithm with compatible primitives.

Important: In this section, all field lengths are specified in bits except where otherwise noted.

Data Structures:::
These include:

. *Initialization Input*:
The data following the metadata block in the initialization input to `ace.init`, such as keys and other required secrets.
Fields are listed in the order they appear in the initialization input, each with its length.

. *Internal State*:
Information that must be maintained in the internal state of a CC.
The fields are unordered and their lengths may differ from those listed, for example in threshold or fault-tolerant implementations where redundancy is added.

. *Serialized Content*:
The data that follows the metadata block in the plaintext portion of the SCC.
The fields are listed in the order they appear in the SCC, each with its length.

Algorithm-Specific Functions:::
Any other function that is specific to the algorithm.

State Machine:::
This includes:

. A list of *states* in which the internal state machine of the logic is executed, together with their representation, either as a number in the range [0..15] or by more complex structures. The values for the architected algorithms conform to <<ACE-state-constants>>.
. A complete list of the *allowed state transitions*, including the conditions under which each transition is allowed.
. The enumeration of the *allowed instructions* at each state and their *behavior*.

[WARNING]
When defining an algorithm, the structure and size of the content of the Initialization Input and of the serialized content *must* be determinable solely from the Algorithm and Key_Type fields in the metadata.

The instructions allowed at each state of an algorithm are usually only `ace.exec` and `ace.state`, but this is not mandated.
Regarding `ace.exec`, only a single form of `ace.exec` may be allowed (cf.{nbsp}<<ACE-instruction-exec>>), together with a suitable replacement sequence as described in <<ACE-replacement-instructions>>.

We provide pseudocode to clarify how the algorithms supported by an ACE unit are implemented in software using the ACE ISA.
For simplicity's sake, pseudocode is usually restricted to set parameters and does not use the `ace.exec` Forms A-C replacement instruction sequences.
Pseudocode examples are naturally non-normative.

The following table defines the state numbers used by the algorithms defined in this specification.

[[ACE-state-constants]]
.Constants defining CC states
[float="center",align="center",width="100%",cols="^6%,<29%,<65%",options="header"]
|===
| Value | Mnemonic                      | Examples
|   0   | ace_state_initial             | The context is initialized and ready for operation.
.2+| 1  | ace_state_hash_absorb         | Start and initialize a hash/tag function of an algorithm and start absorbing blocks of data.
<| ace_state_operate                    | Generic operational state.
|   2   | ace_state_hash_last_block     | In this state additional data may be absorbed, such as partial blocks and lengths, if the hash/tag algorithm processes the last block of its input or of the associated data part of its input in a different way from the other blocks.
|   3   | ace_state_hash_finalize       | Finalize the internal state of a hash/tag function and possibly prepare it for outputting the result.
|   4   | ace_state_hash_verify         | Compare the internal state of a hash/tag function to the provided value.
|   5   | ace_state_hash_output         | Enter the hash output phase of a hash/tag function.
|   6   | ace_state_enc_last_block      | For the encryption path of authenticated encryption modes of operation to process the last block separately.
|   7   | ace_state_dec_last_block      | For the decryption path of authenticated encryption modes of operation to process the last block separately.
|   8   | ace_state_enc_tag_finalize    | Finalize the internal state of a tag computation function for the encryption algorithm of an authenticated encryption mode of operation and possibly prepare it for outputting the result.
|   9   | ace_state_dec_tag_finalize    | Finalize the internal state of a tag computation function for the decryption algorithm of an authenticated decryption mode of operation.
|  10   | ace_state_encrypt             | In this state encryption is performed, and also absorption in a tag computation function if part of the algorithm.
|  11   | ace_state_decrypt             | In this state decryption is performed, and also absorption in a tag computation function if part of the algorithm.
.2+| 12 | ace_state_set_public_value    | Set a public value (like a nonce or an IV) in an algorithm. Some algorithms require more than one public value (for instance, they may admit a re-useable hash of some associated data and a unique nonce), in which case the second public value can be set using the next message.
<| ace_state_input_for_derive   | Tells the CC to expect additional information for feeding the `ace.derive` instruction. Can also provide it directly in a GPR or vector register.
|  13   | ace_state_set_public_value_2  | Set the second public value in an algorithm.
|  14   | ace_state_invalidated         | The algorithm has abnormally terminated. `ace.error` will always return error code _ace_err_invalid_.
|  15   | ace_state_completed           | The algorithm has correctly completed.
|===

Algorithms that significantly differ from those we describe in <<ACE-algorithms>> and therefore cannot share the same software for their usage,
may reuse the same values in [1..13] with new constant mnemonics to define their own states.

The state number is stored either in the metadata or in the content section of the CC/SCC, as described in <<ACE-metadata>>, with the provision that the State_Number
must always take one of the values 0, 14, 15, and 1.

// If the algorithm encoded in the CC has at most 16 states (including _initial_, _completed_, and _invalidated_), then this number is stored in this field, otherwise an algorithm-specific representation is used in the content, and this field only admits the values 0, 14, 15, and 1, the latter being a placeholder for any other operational state. The values used in the algorithms defined in this specification are listed in <<ACE-state-constants>>.
// If the number of states of the algorithm is at most 16 (including _initial_, _completed_, and _invalidated_), the `state` of the metadata is used to store this value.
// Otherwise, the specification of the algorithm must include a suitable field in the content section of the CC/SCC.

In what follows, “state _name_” refers to the state with number _ace_state_name_ in <<ACE-state-constants>>.

[[ACE-generic-rules]]
==== Generic Rules

===== Invalid Inputs and Operations, CR Invalidation

{empty}
(((ACE, algorithm, invalid state)))
(((Cryptographic Register, invalidated)))
If an invalid input is provided to any ACE instruction, or an instruction that is not explicitly allowed in a given state is executed, while processing the algorithm in CR, say, `Kn`, the `Kn` is *invalidated*, namely, the following happens:

* `Kn` is put into state _invalidated_;
* For instructions that refer to `Kn`:
 ** any Form of `ace.exec`, `ace.clone, `ace.derive`, and `ace.restrict` raise an invalid instruction error;
 ** `ace.input` and `ace.output` raise an invalid instruction error when `aceactivecr` is `Kn`;
 ** `ace.state` raises an invalid instruction error unless it is used to return to state _initial_;
 ** `ace.error` always returns error _ace_err_invalid_ after any operation involving the CR except for
    `ace.import` and `ace.export`, `ace.clean`, `ace.init`, and `ace.size`, which all work normally, and using `ace.state` to return to state _initial_.
* The current instruction is terminated.

In state _completed_, only `ace.init`, `ace.export`, `ace.import`, `ace.clear`, and `ace.error` are permitted.

//

===== Interruptibility

Operations performed by `ace.state` are uninterruptible.

The operation of `ace.exec` on a basic processing unit, in any state of any algorithm, is uninterruptible, even when described as a sequence of instructions.
If the operation accepts an input that is an integer multiple of the basic processing unit, each block is processed uninterruptibly, but the instruction may be interrupted between blocks; the hardware sets `acestart` to the resumption point.

An implementation must wait before accessing a CR that is still being written to asynchronously.

//

[[ACE-usage-input-output]]
===== Usage of `ace.input` and `ace.output` to Replace Vector Inputs and Outputs

The `ace.input` and `ace.output` instructions can replace the inputs and outputs to Forms A-C of `ace.exec` and the input of `ace.derive` in any algorithm, to the point that an implementation of ACE without the V extension or a subset thereof is possible.

These two instructions can be used if enabled and the size in CSR `aceiobuflen` is non-zero and is a valid size (for instance, divisible by the block size `b), otherwise an invalid instruction error is raised.

If `aceiobuflen` is non-zero, Forms A, B, and C of `ace.exec`, as well as `ace.derive` or `ace.state`, can be replaced as follows:

[[ACE-replacement-instructions]]
.Replacement sequences for `ace.exec` and `ace.derive` using `ace.input` and `ace.output`
[float="center",align="center",width="80%",cols="<42%,<38%",options="header"]
|===
| Original Instruction          | Replacement Sequence
| `ace.exec{nbsp}{nbsp}{nbsp}Vd, Kn\|K[Xn], Vs` | `ace.input{nbsp}{nbsp}Xl, Vs` +
`ace.exec{nbsp}{nbsp}{nbsp}Kn\|K[Xn]` +
`ace.output{nbsp}Vd,  Xl`
| `ace.exec{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}Kn\|K[Xn], Vs`     | `ace.input{nbsp}{nbsp}Xl, Vs` +
`ace.exec{nbsp}{nbsp}{nbsp}Kn\|K[Xn]`
| `ace.exec{nbsp}{nbsp}{nbsp}Vd, Kn\|K[Xn]`     | `ace.exec{nbsp}{nbsp}{nbsp}Kn\|K[Xn]` +
`ace.output{nbsp}Vd,  Xl`
| `ace.derive Kd\|K[Xd], Ks1\|K[Xs1], Vs2` | `ace.input{nbsp}{nbsp}Xl, Vs2` +
`ace.derive{nbsp}Kd\|K[Xd], Ks1\|K[Xs1]`
| `ace.state{nbsp}{nbsp}Kd\|K[Xd], #immed, Vs` | `ace.input{nbsp}{nbsp}Xl, Vs` +
`ace.state{nbsp}{nbsp}Kd\|K[Xd], #immed`
|===

In all cases, the `ace.input` and `ace.output` instructions must be temporarily tied to a specific context in order to properly determine the allowed sequences.
This is done by setting the `aceactivecr` CSR (cf.{nbsp}<<ACE-CSR-aceactivecr>>) first. The user must not forget to set it back to 32 after the sequence is completed.

We use the `acesequence` CSR to indicate whether we are using the input/output buffer or the vector registers to provide the inputs and outputs to ACE instructions, and to track the instruction sequence.
The initial value of `acesequence` is zero.
As soon as an `ace.input` is completed in place of a Form A or B `ace.exec` or `ace.derive`, or a Form D `ace.exec` is completed in place of a Form C `ace.exec`, `acesequence` is set to 1.
In this case, `acesequence` remains 1 until the end of the second instruction of the replacement sequence, and-if there is a third instruction in the sequence-then set to 2 until the end of the third instruction of the sequence.
At the end of the sequence, `acesequence` is reset to 0.
The ordering of the instructions in a replacement sequence is enforced by the architecture according to the value of `acesequence` and the state number of the CR configured in `meta`.
Not properly following the instruction ordering raises an invalid instruction exception.
`acesequence` can be saved and restored by privileged code together with `acestart`.

The internal input/output buffer is not part of any CR. It is architectural, i.e., per-hart.
In fact, `ace.output` can be used to save the contents of the buffer, and `ace.input` can be used to restore it freely as long as `aceactivecr` takes the value 32.
Also, these operations start at the offset specified in `acestart`, so the state of the buffer can easily be saved and restored with the same approach used for vectors.

//

[[ACE-notation]]
===== Notation in the Algorithm Descriptions

* `INPUT`: The input data to be processed by the following instructions: `ace.exec`, `ace.state`, `ace.derive`.
   This can be the input vector register, or the input/output buffer, according to the semantics presented in <<ACE-usage-input-output>>.

* `OUTPUT`: The output data produced by `ace.exec`.
   This can be the output vector register, or the input/output buffer, according to the semantics presented in <<ACE-usage-input-output>>.

* `IOLEN`: Either `VL*SEW` or the length `aceiobuflen` of the input/output buffer in bytes, depending on whether vector registers are used or the input/output buffer is used.

* In all algorithms, whenever a Form A-C `ace.exec`, `ace.state` with the optional additional parameter in a vector register, or `ace.derive` occurs, it can be replaced with an instruction sequence.


NOTE: This mechanism is one of the reasons, besides keeping the state machines simple, that in a given state of an algorithm, in each state only one Form of `ace.exec` instruction is allowed.

// zzz

[[ACE-rules-threshold-implementations]]
===== Single-Share Key Export Rule for Threshold implementations

Any CC with its algorithms implemented as threshold implementation will always initialize, import and export _all_ its keys and secrets as _single_, _reconstructed_ _shares_.
The Configuration and SCC Formats will be the same as for the non-threshold implementation variants of the same algorithm, with the only difference being the value of the Side Channel Protection bits in the metadata.
For the purpose of architecture specification, all values are also always represented as a single share in this document.
Threshold implementations are simply implementation variants of the exact same algorithm.
(((ACE, algorithm, threshold variants)))

NOTE: This rule assumes that reconstructing a key or re-randomizing it are fast operations, such as ``xor``s with random values.
This in turn implies that ACE execution unit must have access to a source of randomness, or at least a PRNG that is seeded at hardware boot.

NOTE: The rule not only  ensures the compactness of a SCC, but also that the key can be ported across architectures.
In fact, some threshold implementations may have a different number of shares even if they claim the same order of side-channel protection.

//

[[ACE-rules-system-keys]]
===== Representation of System Keys in the Data Structures

System keys that are referred to by an index will cause the following changes in all the algorithms described in what follows:

. In the initialization input and in the SCC, the key/main key field will contain the index of the key in the SKT in place of a key value.
. This field is always a 64-bit value, even if the key itself is larger. This saves space in the SCC and allows for faster export and import operations.
. For algorithms that require more than one key, such as XEX/XTS, ALL the keys are referred to by a single index, i.e., a single 64-bit value in the initialization input and the SCC.
. Accordingly, the SCC generation functions will support System Keys by producing and reading the shorter fields with the indexes in place of the longer fields that would be required when the key values are explicitly provided.

NOTE: Internally, the ACE unit may use the value from the SKT, or copy it to the internal state of the CR.
The architecture does not restrict the choice of the implementation.
On the other hand, keys generated from a system block, using a custom “recipe”, are always represented by their values and once generated have the exact same behavior as any other key that does not come from the SKT.

//

[[ACE-ECB-mode]]
==== Electronic Codebook Modes (Direct Encryption/Decryption)

While listing the rules for the ECB mode
cite:[nist-SP-800-38A-1]
is in principle easy, it does display all the rules that are required to describe an arbitrarily complex mode.
(((ACE, algorithm, ECB)))

===== Specification

Parameters:::

* `b` = block size (8|`b`). `IOLEN` must be a multiple of `b`.
* `k` = key size (8|`k`).

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.

* *Internal State*:
 ** `key`: `k` bits.

* *Serialized Content*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.

Algorithm-Specific Functions:::

* `enc_blk(K,p) -> c` encrypts plaintext block `p` using the key `K`, and returns the ciphertext result `c`.
* `dec_blk(K,c) -> p` decrypts ciphertext block `c` using the key `K`, and returns the plaintext result `p`.

State Machine:::

* *States:* _initial_, _encrypt_, and _decrypt_
* *Allowed State Transitions:*
 ** From any state to state _encrypt_, if metadata allows encryption, else the CR is *invalidated*.
 ** From any state to state _decrypt_, if metadata allows decryption, else the CR is *invalidated*.
* *Behavior:*
 ** In state _initial_, no `ace.exec` instruction is allowed.
 ** In states _encrypt_ or _decrypt_, we can only issue Form A `ace.exec` instructions, i.e., of the Form “`ace.exec OUTPUT, Kn|K[Xn], INPUT`.”
  *** If the state is _encrypt_, then `OUTPUT = enc_blk(key, INPUT)`.
  *** If the state is _decrypt_, then `OUTPUT = dec_blk(key, INPUT)`.
  *** If `IOLEN` > `b`, then “`ace.exec OUTPUT, Kn|K[Xn], INPUT`” encrypts/decrypts block-by-block.

//

[NOTE]
====
Supporting vector lengths smaller than a cipher's block size would not only complicate both the architecture and its implementation, but it would also burden the software using the feature. Therefore, in this case either the user suitably reconfigures the vector lengths, or uses the `ace.input` and `ace.output` instructions.
====

===== Usage

The following pseudocode illustrates how to use an ECB CC to encrypt a block of data using a block cipher with a width of 128 bits (`IOLEN` is also 128).

[[ACE-pseudocode-ECB-encryption]]
.Simple Pseudocode Example: Encryption with no Authentication
----
- Call OS API to get the necessary SCC. Assume X5 points to the SCC.
- Allocate memory for ciphertext buffer.

vsetvli zero, 4, e32, m1, ta, ma           // Use 128-bit vectors
ace.import K0, (X5)                        // Import the SCC into CR K0
ace.error X1                               // Read error from a CSR
if (X1 != 0) then { handle error }         // ACE may fail to validate SCC, algorithm may
                                           // be not supported, or CRF memory may be full
ace.state K0, #ace_state_encrypt           // Configure CR for encryption
ace.error X1                               // Read error from a CSR
if (X1 != 0) then { handle error }         // Error if encryption not allowed

foreach(i from 0 to len_in_bytes(plaintext)/16-1) { // assume plaintext in whole blocks
   V0 ← plaintext[16*i .. 16*i+15]
   ace.exec V0, K0, V0                     // Encrypt one block of the plaintext
   ciphertext[16*i .. 16*i+15] ← V0
}
----

// vle32.v  V0, (plaintext)              // load V0 from address plaintext+16*i
//                                       // assume plaintext is in a register
// ace.exec V0, K0, V                    // Encrypt one block of the plaintext
// vse32.v  V0, (ciphertext)             // store V0 at address ciphertext+16*i
// add plaintext, plaintext, 16          // advance plaintext pointer
// add ciphertext, ciphertext, 16        // advance ciphertext pointer

[[ACE-chaining]]
==== Chaining/Feedback Modes

There is no need to explicitly architect the behavior of chaining modes, such as Cipher Block Chaining (CBC), Cipher Feedback (CFB) and Output Feedback (OFB) (all defined in cite:[nist-SP-800-38A-1]) as they are easily in software implemented on top of the ECB, with no intermediate value requiring confidentiality.

//

[[ACE-keystream-modes]]
==== CTR/LFSR/XCTR/XLFSR Keystream Generation

In the “non-X” modes, i.e., CTR mode and its analogue with an LFSR replacing the arithmetic counter, the sum of the lengths of IV and counter/LFSR equals the block size of the underlying keyed PRP or PRF. IV and counter/LFSR are concatenated to form the input to the latter.
(((ACE, algorithm, keystream generation)))

In the “X” modes, both IV and counter/LFSR have the same size as the block size of the underlying keyed PRP or PRF.
IV and counter/LFSR are ``xor``ed together to form the input to the keyed PRP or PRF.

===== Specification

Parameters:::
* `b` = block size (8|`b`). For this algorithm `IOLEN` must be a multiple of `b`.
* `k` = key size (8|`k`).
* `j` = counter size (8|`j`).
* `n` = IV size (8|`n`).
* If the mode is CTR or LFSR, it is `b = n + j`.
* If the mode is an “X” mode, it is `b = n = j`.

Data Structures:::
* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.

* *Internal State*:
 ** `key`: `k` bits.
 ** `IV`: `n` bits.
 ** `ctr`: `j` bits.

* *Serialized Content*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.
 . `IV`: `n` bits.
 . `ctr`: `j` bits.

Algorithm-Specific Functions:::
* `keystream_block(p) -> c` -- usually an encryption function.
* `tick_ctr()` -- updates the `ctr` (either by a modular increment or a LFSR).

State Machine:::
* *States:* _initial_, _set_public_value_, _operate_.
* *Allowed State Transitions:*
 ** _initial_ -> _set_public_value_ -> _operate_.
 ** All states to _initial_.
* *Behavior:*
 ** In state _initial_, the `ctr` and `IV` fields are set to 0 (`ctr` is set to 1 if the algorithm is LFSR-based).
 ** In state _set_public_value_, only ``ace.exec`` instructions of Form B or their replacement sequences are allowed.
     “```ace.exec Kn|K[Xn], INPUT```” sets the value of `IV` to `INPUT`.
  *** If no such instruction is issued, `IV` remains zero.
  *** If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.
  *** If such operations are issued more times, they will just update `IV` again.
  Since this can be done only before any encryption or decryption operation, this does not represent a security issue.
 ** In state _operate_, only ``ace.exec`` instructions of Form C or their replacement sequences are allowed.
     “```ace.exec OUTPUT, Kn|K[Xn]```” performs:
+
--
  . If in a CTR or LFSR mode then `tmp ← keystream_block(IV @ ctr)`, +
    else (i.e., if in a XCTR or XLFSR mode) `tmp ← keystream_block(IV xor ctr)`,
  . `tick_ctr()`, and
  . `OUTPUT ← tmp`.
--
+
If `IOLEN` is a multiple of `b`, the above three commands are applied to each of the `IOLEN/b` `b`-bit blocks of `INPUT`, producing each time the corresponding `b`-bit block of `OUTPUT`.
If the number `x` of blocks to be processed in an entire run of the algorithm is not a multiple of `IOLEN`/`b`, `VL` can be set to the remainder of the division of `x` by `IOLEN`/`b` for the last instruction.

Note that if `ace.state` is issued to return to state _initial_, the CC can be reused with a new `IV`.

===== Usage

Example pseudocode is given in <<ACE-pseudocode-keystream-modes>> (for the case `b` = `IOLEN` = 128).

[[ACE-pseudocode-keystream-modes]]
.Encrypt with Keystream Generation
----
// Acquire payload, initialize
- Info: plaintext = *PT
- Process gets a Keystream Generation CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)

// The next operations set the nonce (and the derived Authentication Key).
ace.state K0, #ace_state_set_public_value
V0 ← nonce
ace.exec K0, V0

// Compute keystream, use it to encrypt plaintext
foreach(i from 0 to len_in_bytes(PT)/16-1) {
   V0 ← PT[16*i .. 16*i+15]
   ace.exec V1, K0
   V1 ← V1 xor V0
   CT[16*i .. 16*i+15] ← V1
}
----

[[ACE-XEX-XTS-modes]]
==== XEX/XTS modes (one or two keys)

The XTS mode was designed for storage confidentiality cite:[DBLP-journals-ieeesp-Martin10]
and made into a Recommendation by NIST in 2010 cite:[nist-SP-800-38E].
XTS is based on the XEX construction, formalized by Phillip Rogaway cite:[DBLP-conf-asiacrypt-Rogaway04], to design _Tweakable Block Ciphers_ cite:[DBLP-conf-crypto-LiskovRW02].
A Tweakable Block Cipher (TBC) is a block cipher which, besides the key and the plaintext or ciphertext, also takes a tweak as input.
The tweak is used together with the key to select the permutation computed by the block cipher.

The XEX construction builds a TBC `Ẽ` from a block cipher `E`, with key `K`, tweak `T`, and plaintext `P`,  as follows: +
 +
`{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}`
`Ẽ(K, T, P) = E(K, P xor M) xor M` `{nbsp}{nbsp}` where `{nbsp}{nbsp}` `M = E(K, T)` `{nbsp}{nbsp}` is called a _mask_. +
 +
In XEX mode, once a mask is computed, it is then updated by using a Galois Multiplication for any successive block instead of updating the tweak and encrypting it again.

The NIST standard uses two different keys, one on the data encryption path and one for the encryption of the tweak.
The use of a single key or two independently sampled keys is determined by the algorithm, and it is not a configuration parameter for the algorithm.
We first define XEX mode functionality.
(((ACE, algorithm, XEX)))

===== Specification

Parameters:::

* `b` = block size (8|`b`). For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = key size (8|`k`).

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key1`: `k` bits, or 64 bits if a System Key index.
 . `key2`: `k` bits -- omitted if only one key is used or if both keys come from an entry in the SKT.

* *Internal State*:
 ** `key1`: `k` bits.
 ** `key2`: `k` bits -- omitted if only one key is used or if both keys come from an entry in the SKT.
 ** `mask`: `b` bits.

* *Serialized Content*:
[lowerroman]
 . `key1`: `k` bits, or 64 bits if a System Key index.
 . `key2`: `k` bits, omitted if only one key is used or if both keys come from an entry in the SKT.
 . `mask`: `b` bits.

Algorithm-Specific Functions:::

* `enc_blk(K, p) -> c` encrypts block `p` using the key `K`, and returns the result `c`.
* `dec_blk(K, c) -> p` decrypts block `c` using the key `K`, and returns the result `p`.
* `update_mask(mask) -> mask` updates the mask by a Galois Field multiplication in GF(2^b^).

State Machine:::

* *States:* _initial_, _set_public_value_, _encrypt_, and _decrypt_.

* *Allowed State Transitions:*
 ** _initial_ -> _set_public_value_.
 ** _set_public_value_ -> _initial_.
 ** _set_public_value_ -> _encrypt_, if metadata allows encryption, else the CR is *invalidated*.
 ** _set_public_value_ -> _decrypt_, if metadata allows decryption, else the CR is *invalidated*.
 ** _encrypt_, _decrypt_ -> _initial_.

* *Behavior:*
 ** In state _initial_:
  *** The `mask` field is set to zero.
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
 ** In state _set_public_value_, only ``ace.exec`` instructions of Form B or their replacement sequence are allowed.
 “```ace.exec Kn|K[Xn], INPUT```” sets the _tweak_. The `mask` field is used to store the tweak: `mask <- INPUT`.
  *** If no such instruction is issued, the value of the tweak will remain zero.
  *** If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.
  *** If “```ace.exec Kn|K[Xn], INPUT```” is repeated, it will just re-write the mask.
 ** When transitioning from _set_public_value_ to either _encrypt_ or _decrypt_, the following operations are performed:
  . if two independent keys are used then
  .. `mask <- enc_blk(key2, mask)`
  . else
  ..  `mask <- enc_blk(key1, mask)`
  ..  `mask <- update_mask(mask)`.
 ** In states _encrypt_ and _decrypt_, only ``ace.exec`` instructions of Form A or their replacement sequence are allowed.
    “```ace.exec OUTPUT, Kn|K[Xn], INPUT```” performs the following operations:
+
--
  . in state _encrypt_, it computes `OUTPUT = mask xor enc_blk(key1, INPUT xor mask)` ... +
    in state _decrypt_, it computes `OUTPUT = mask xor dec_blk(key1, INPUT xor mask)` ...
  . ... and updates the mask: `mask <- update_mask(mask)`.
--
+
If `IOLEN` is a multiple of `b`, the above commands are executed `IOLEN/b` times, processing each `b`-bit block of `INPUT` into a `b`-bit block of `OUTPUT`. This operation is clearly parallelizable. If the number `x` of blocks to process is not a multiple of `IOLEN`/`b`, `VL` can be set to the remainder of the division of `x` by `IOLEN`/`b` for the last instruction.

//

Note that if `ace.state` is issued to return to state _initial_, the CC can be reused with a new tweak.

===== Usage

Using XEX mode is very easy. We include pseudocode for encryption only, decryption is entirely similar
(this example is also assuming `b` = `IOLEN` = 128).

[[ACE-pseudocode-basic-IV-mode]]
.Pseudocode for encryption in any IV-based non-authenticated mode without associated data
----
// Acquire payload
- Info: plaintext = *PT
- Call an API to get the corresponding key from a key management applet or HW block.
- The API returns the SCC. Assume X5 is the pointer to it.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma             // Use 128-bit vectors
ace.import K0, (X5)

ace.state K0, #const_set_public_value        // this can be an IV or a nonce.
V0 ← IV
ace.exec K0, V0

ace.state K0, #ace_state_encrypt             // Configure CR for encryption
foreach(i from 0 to ceil(len_in_bytes(PT)/16)-1) {
   V0 ← PT[16*i .. 16*i+15]
   ace.exec V0, K0, V0                      // Encrypt one block of the plaintext
   CT[16*i .. 16*i+15] ← V0
}
----

To implement the XTS mode, the ciphertext stealing part is easy to realize using the XEX algorithm together with vector masking and shifting operations.
(((ACE, algorithm, XTS)))

// N.B. another ace.state K0, #const_set_public_value would reset the internal state and allow to begin another decryption with a new IV.

[[ACE-tweakable]]
==== Generic Tweakable Blocks Ciphers

The specification of a generic tweakable block cipher is similar to that of a non-tweakable block cipher in ECB mode.
However, since `ace.exec` does not admit variants with two inputs, and we have a single input buffer, we need to set the tweak with a separate instruction.
If block and tweak sizes are different, a reconfiguration of the vector length may be required between operations.

Some commonly used TBCs are `Deoxys` cite:[Deoxys-141], `Skinny` cite:[DBLP-conf-crypto-BeierleJKL0PSSS16], `QARMA` cite:[DBLP-journals-tosc-Avanzi17], and `QARMAv2` cite:[DBLP-journals-tosc-AvanziBDEGNR23].

===== Specification

Parameters:::

* `b` = block size (8|`b`). For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = key size (8|`k`).
* `t` = tweak size (8|`k`).

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.

* *Internal State*:
 ** `key`: `k` bits.
 ** `tweak`: `t` bits.

* *Serialized Content*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.
 . `tweak`: `t` bits.

State Machine:::

* *States:* _initial_, _set_public_value_, _encrypt_, _decrypt_.

* *Allowed State Transitions:*
 ** From all states to _initial_.
 ** _initial_ -> _set_public_value_
 ** _set_public_value_ -> _encrypt_ -- if metadata allows encryption, else the CR is *invalidated*.
 ** _set_public_value_ -> _decrypt_ -- if metadata allows decryption, else the CR is *invalidated*.

 * *Behavior:*
  ** In state _initial_:
   *** Upon entering the state, the `tweak` field is cleared.
   *** Only `ace.state` operations are allowed.
  ** Upon issuing ```ace.state Kn|K[Xn], #ace_state_set_public_value, INPUT``` (or the replacement sequence):
   . `tweak` <- `INPUT`, and
   . Instead of transitioning to state _set_public_value_, the state remains unchanged (can be _initial_, _encrypt_, or _decrypt_).
  ** In state _encrypt_, resp., _decrypt_, only ``ace.exec`` instructions of Form A or their replacement sequences are allowed.
     “```ace.exec OUTPUT, Kn|K[Xn], INPUT```” encrypts, resp., decrypts `INPUT` into `OUTPUT`.

No automatic update of the tweak value is provided by this algorithm.

[[ACE-GCM-mode]]
==== GCM Mode

The GCM mode was designed by David McGrew and John Viega cite:[DBLP-conf-indocrypt-McGrewV04]
and became a NIST Recommendation in 2007 cite:[nist-SP-800-38D].
(((ACE, algorithm, GCM)))

===== Specification

Parameters:::

* `b` = block size (8|`b`). For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = key size (8|`k`).

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.

* *Internal State*:
 ** `key`: `k` bits.
 ** `ctr`:  `b` bits.
 ** `auth_key`, `tag`: `b` bits.

* *Serialized Content*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.
 . `ctr`: `b` bits.
 . `tag`: `b` bits.

NOTE: There are no fields for the lengths of the AD and of the plaintext, as they are maintained by the calling software.
Also, `hash_key` is not serialized, and thus it is recomputed upon `ace.import`.

Algorithm-Specific Functions:::

* `enc_blk(key, p) -> c` encrypts block `p` using the key, and returns the result `c`.

* `absorb(data)` absorbs data into the hash function by performing:
  . `tag <- tag xor INPUT`.
  . `tag <- Galois_mult(tag, hash_key)`.

State Machine:::

* *States:* _initial_, _set_public_value_, _hash_absorb_, _encrypt_, _enc_tag_finalize_, _decrypt_, _dec_tag_finalize_, and _hash_verify_, _completed_.

* *Allowed State Transitions:*
 ** From all states to _initial_.
 ** _initial_ -> _set_public_value_ -> _hash_absorb_.
 ** _hash_absorb_ -> _encrypt_ -- if metadata allows encryption, else the CR is *invalidated*.
 ** _hash_absorb_ -> _decrypt_ -- if metadata allows decryption, else the CR is *invalidated*.
 ** _encrypt_ -> _enc_tag_finalize_ -> _completed_.
 ** _decrypt_ -> _dec_tag_finalize_ -> _hash_verify_ -> _completed_.

* *Behavior:*
 ** In state _initial_ :
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
  *** The following initialization operations are performed:
   . `hash_key <- enc_blk(key, zeros(b))`,
   . `tag <- zeros(b)`, and
   . `ctr <- zeros(b)`.
 ** In state _set_public_value_:
  *** Only  ``ace.exec`` instructions of Form B or their replacement sequences are allowed.
  “```ace.exec Kn|K[Xn], INPUT```” sets
   . `ctr <- INPUT @ (b/4-1)b'0 @ 1`, i.e., the `b/4` most significant bits of `INPUT` are ignored, and the `b/4` least significant bits of `ctr` represent the integer 1.
  *** If “```ace.exec Kn|K[Xn], INPUT```,” is repeated, it will just re-write the IV.
  *** If no such `ace.exec` to set the IV is issued, `ctr` remains zero.
  *** If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.

 ** In state _hash_absorb_, only  ``ace.exec`` instructions of Form B or their replacement sequences are allowed.
 “```ace.exec Kn|K[Xn], INPUT```” absorbs a data block in `tag`, i.e.:
+
--
 . `absorb(INPUT)`.
--
+
If `IOLEN` > `b`, the above operation is executed `IOLEN/b` times.

** In state _encrypt_, only ``ace.exec`` instructions of Form A or their replacement sequences are allowed.
   “```ace.exec OUTPUT, Kn|K[Xn], INPUT```” encrypts `INPUT` into `OUTPUT`, and absorbs the ciphertext `OUTPUT` into the `tag`, namely:
+
--
  . If `ctr[b/4-1:0] = 0`, then
  ..  the CR is *invalidated*.
  . else
  .. `tmp <- INPUT xor enc_blk(key, ctr)`.
  .. `absorb(tmp)`.
  .. `ctr[b/4-1:0] <- ctr[b/4-1:0] + 1 % 2^b/4^`.
  .. `OUTPUT <- tmp`.
--
+
If `IOLEN` is a multiple of `b`, the above operations are executed `IOLEN/b` times, encrypting each `b`-bit block of `INPUT` into the corresponding `b`-bit block of `OUTPUT`. There is significant potential for parallelization, including in the `absorb` function. If the number `x` of blocks to encrypt is not a multiple of `IOLEN`/`b`, `VL` can be set to the remainder of the division of `x` by `IOLEN`/`b` for the last instruction.

** In state _enc_tag_finalize_, only ``ace.exec`` instructions of Form A or their replacement sequences are allowed. The value
+
--
*** `INPUT <- bin(bit_length(AD), b/2) @ bin(bit_length(plaintext), b/2)`
--
+

must be set by the software, then,
  “```ace.exec OUTPUT, Kn|K[Xn], INPUT```”
  computes the authentication tag and completes the algorithm as follows:
+
--
  . `absorb(OUTPUT)`.
  . `tag <- tag xor enc_blk(key, ctr[b-1,b/4] @ 0[b/4-1,0])`.
  . Finally, `tag` is returned in `OUTPUT`, and the state is changed to _completed_.
--
+
If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.

** In state _decrypt_, only  ``ace.exec`` instructions of Form A or their replacement sequences are allowed.
 ```ace.exec OUTPUT, Kn|K[Xn], INPUT```
   absorbs the ciphertext `INPUT` into the `tag`, then decrypts `INPUT` into `OUTPUT`, namely
+
--
  . If `ctr[b/4-1:0] == 0`, then
  .. the CR is *invalidated*.
  . else
  .. `absorb(INPUT)`.
  .. `OUTPUT  <- INPUT xor enc_blk(key, ctr)`.
  .. `ctr[b/4-1:0] <- ctr[b/4-1:0] + 1`.
--
+
If `IOLEN` is a multiple of `b`, the same behavior applies as in state _encrypt_, namely
the above operations are executed `IOLEN/b` times, decrypting each `b`-bit block of `INPUT` into the corresponding `b`-bit block of `OUTPUT`.

** In state _dec_tag_finalize_, only a Form A ``ace.exec`` instruction, or its replacement sequence, are allowed.
The value +
 +
 `{nbsp}{nbsp}{nbsp}INPUT <- bin(bit_length(AD), b/2) @ bin(bit_length(plaintext), b/2)` +
 +
must be set by the software, then “```ace.exec OUTPUT, Kn|K[Xn], INPUT```” computes the authentication tag as follows:
+
--
  . `absorb(INPUT)`.
  . `tag <- tag xor enc_blk(key, ctr[b-1,b/4] @ zeros(b/4))`.
--
+
If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.

** In state _hash_verify_, only an ``ace.exec`` instruction of Form B, i.e., “```ace.exec Kn|K[Xn], INPUT```”, or its replacement sequence, are allowed.
    It compares `INPUT` with `tag`:
+
--
  . If the values match, then the state is changed to _completed_, and `ace.error` returns no error,
  . else the state is changed to _completed_, and `ace.error` returns `ace_err_authentication`.
--
+
If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are compared to `tag`.

** Upon completion of `ace.import`, the ACE unit recomputes `hash_key`, i.e.:
  . `hash_key <- enc_blk(key, zeros(b))`.

//

===== Usage

In <<ACE-pseudocode-GCM-encryption>> we show pseudocode for GCM encryption (again with `b` = `IOLEN` = 128).
The code assumes that both AD and plaintext (or the ciphertext for the decryption) are zero-padded to a multiple of `b` bits, in this case 128 bits.

[[ACE-pseudocode-GCM-encryption]]
.GCM Encryption
----
// Acquire payload, initialize
- Info: authenticated data = *AD, plaintext = *PT
- Process gets a GCM encryption CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)     //  Import, and compute the derived Authentication Key.

// The next operations set the nonce
ace.state K0, #ace_state_set_public_value
V0 ← nonce
ace.exec K0, V0

// Compute AD contribution to Auth Data
ace.state K0, #ace_state_hash_absorb
foreach(i from 0 to len_in_bytes(AD)/16-1) {
   V0 ← AD[16*i .. 16*i+15]
   ace.exec K0, V0                              // Absorb it into hash
}

// Encrypt plaintext and continue computation of tag
ace.state K0, #ace_state_encrypt
foreach(i from 0 to len_in_bytes(PT)/16-1) {
   V0 ← PT[16*i .. 16*i+15]
   ace.exec V1, K0, V0
   CT[16*i .. 16*i+15] ← V1
}

// Finally, we absorb the lengths into tag, finalize it, and output it
ace.state K0, #ace_state_enc_tag_finalize
V1 ← bin(len_in_bits(AD), 64) @ bin(len_in_bits(PT), 64)
ace.exec V2, K0, V1                             // V2 contains the finalized hash
----

GCM decryption differs from encryption as follows:
the roles of `PT` and `CT` are reversed,
states _encrypt_ and _enc_tag_finalize_ are replaced by states _decrypt_ and _dec_tag_finalize_,
and the last lines are as follows:

[[ACE-pseudocode-GCM-decryption-difference]]
.GCM Decryption
----
// Finally, we absorb the lengths into tag, finalize it, and verify it
ace.state K0, #ace_state_dec_tag_finalize
V1 ← bin(len_in_bits(AD), 64) @ bin(len_in_bits(CT), 64)
ace.exec V2, K0, V1                             // V2 contains the finalized hash

ace.state K0, #ace_state_hash_verify
V1 ← tag_from_payload
ace.exec K0, V1                                 // V1 contains the tag from the input
ace.error X1
if (X1 != 0) then { handle error }       // do not use the plaintext if error occurred
----

//

===== Alternative Examples

GCM security is not compromised if `H` is revealed.
Consequently, an implementation based on a simpler ECB mode CC is possible,
as shown below (for encryption only -- decryption is similar).
However, this significantly increases code size and requires implementing `Galois_mult(V4, V3)`.
Adding a dedicated mode to the ACE unit is a minor effort, and it allows internal logic to optimize execution
beyond the capabilities of, for instance, a compiler on an in-order CPU. It also means that the CPU
does not have to implement the carryless multiplication (cf.{nbsp}<<ACE-V-dependency>>),
and only a shared ACE unit has to,
which saves hardware costs when several small cores share a single ACE unit.

[[ACE-pseudocode-GCM-encryption-alternate]]
.Implementing GCM encryption using an ECB CC
----
// Acquire payload, initialize
- Info: authenticated data = *AD, plaintext = *PT
- Process gets a GCM encryption CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)                              // Imports SCC into CR K0
V5[127:32] ← IV
V5[31:0] ← bin(1, 32)

V3 ← zeros(b)                                    // “Auth Data 1”
ace.exec V4, K0, V3                              // compute H
foreach(i from 0 to ceil(len_in_bytes(AD)/16)-1) {
   V1 ← AD[16*i .. 16*i+15]
   V3 ← V3 xor V1                                // Horner scheme add
   V3 ← Galois_mult(V4, V3)                      // Horner scheme mult
}

counter ← 1                                      // a 32-bit integer value
foreach(i from 0 to ceil(len_in_bytes(PT)/16)-1) {
   V5[32:0] ← counter
   V1 ← PT[16*i .. 16*i+15]
   ace.exec V2, K0, V5                           // create mask by encrypting the counter
   V1 ← V1 xor V2                                // CTR encrypt
   V3 ← V3 xor V1                                // Horner scheme add
   V3 ← Galois_mult(V4, V3)                      // Horner scheme mult
   CT[16*i .. 16*i+15] ← V1
   counter ← counter + 1
}

V3 ← V3 xor (len_in_bits(AD) @ len_in_bits(PT))  // Horner scheme add
V3 ← Galois_mult(V4, V3)                         // Horner scheme mult
V5[31:0] ← bin(1, 32)                            // Prepare IV @ 1 for tag encryption
ace.exec V2, K0, V5
tag ← V3 xor V2                                  // Last Horner scheme add
----

[[ACE-GCM-with-IV-mode]]
==== GCM-with-set-IV

The mode of operation “GCM with a set IV” is a variant of the GCM mode where the initialization vector (IV) is predefined and not generated randomly.

The differences between GCM and GCM-with-set-IV start with the format of the Initialization Input:

* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.
 . `IV`: `3b/4` bits.
 . Padding: `b/4` bits, unless 256 divides `b`, in which case the Initialization Input's length is already a multiple of 64 bits without this field.

The state _set_public_value_ is missing, therefore the transition sequence

* _initial_ -> _set_public_value_ -> _hash_absorb_

is replaced by

* _initial_ -> _hash_absorb_.

Finally, once in state _completed_, the CC with this algorithm *cannot* be brought back to state _initial_.

This does not prevent cloning the CR at the beginning and reusing it, but, for decryption, it can only be used with the intended ciphertext.

This mode _cannot_ be emulated with an ECB CC because it would reveal the internal data.

For all the following IV- or nonce-based modes, versions with a set IV or nonce (such as for GCM-SIV) can also be similarly defined.
For instance, for GCM-SIV (cf.{nbsp}<<ACE-GCM-SIV-mode??), `nonce` would be included in the Initialization Input exactly as `IV` is included in the Initialization Input for GCM, and state _set_public_value_ would be skipped, going directly to _hash_absorb_, with unchanged semantics.


[[ACE-GCM-SIV-mode]]
==== GCM-SIV mode

// [.red]#*TODO*: Add version with full# ```[.red]#b#```[.red]#-bits nonce?#

The GCM-SIV mode is described in cite:[DBLP-journals-iacr-GueronLL17] and cite:[RFC8452].

The GCM-SIV mode's main differences with GCM are that:

. Both encryption and authentication keys are derived from the main key, whereas in GCM the main key is used also for encryption;
. It is a MAC-then-Encrypt mode, whereas GCM is an Encrypt-then-MAC mode, therefore GCM-SIV is more amenable to Release of Unencrypted Plaintext (RUP) attacks;
. Encryption requires two passes over the plaintext, since the tag computed on the AD and plaintext is used also as the initialization vector for the CTR encryption.
(((ACE, algorithm, GCM-SIV)))

The third difference affects the state machine. While GCM-SIV's decryption state machine is similar to the GCM's, the encryption state machine is different:

* During encryption, the _hash_absorb_ state absorbs the entire associated data and plaintext. The _enc_tag_finalize_ state then absorbs the lengths and produces the SIV/tag. Finally, the _encrypt_ state performs a second pass to encrypt the plaintext using the SIV/tag as the initialization vector.
* During decryption, the _hash_absorb_ state absorbs only the associated data. The _decrypt_ state decrypts the ciphertext and simultaneously absorbs the plaintext into the hash. Finally, the _dec_tag_finalize_ state absorbs the lengths, produces the SIV/tag, and internally compares it to the provided SIV/tag.

===== Specification

Parameters:::

* `b` = block size, (8|`b`). For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = key size (8|`k`).
* It must be `k = b` or `k = 2b`.
* It must be established by the algorithm whether the authentication tag is `b` or `3b/4` bits long.
  In other words, there can be two variants.

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.

* *Internal State*:
 ** `key`, `enc_key`: `k` bits.
 ** `auth_key`: `b` bits.
 ** `nonce`: `3b/4` bits.
 ** `ctr`: `b/4` bits.
 ** `tag`: `b` bits.
 ** `SIV`: `b` or `3b/4` bits.
+
A `b`-bit `SIV` is computed by clearing the most significant bit of `tag` and encrypting it. +
For a `3b/4`-bit `SIV`, a full `b`-bit `tag` value is kept while absorbing data.
The public `SIV` value is computed by clearing the most significant bit of `tag`, encrypting it, and then removing the `b/4` least significant bits.

* *Serialized Content*:
[lowerroman]
 . `key`: `k` bits.
 . `nonce`, `3b/4` bits.
 . `ctr`, `b/4` bits.
 . `tag`, `b` bits.
 . `SIV`, `b` bits.

NOTE: The internal state fields `hash_key` and `auth_key` are not serialized, and must be recomputed upon each `ace.import`. +
The `SIV` field is actually only needed for decryption, since it must be maintained separately from the `tag` field, which changes with each processed block as it is computed, whereas for encryption it is first computed completely and then used in the encryption process. However, since the same CC could be configured to support both encryption and decryption, the `SIV` field always present in the internal state (even if not used) and in the exported state.

//

Algorithm-Specific Functions:::

* `enc_blk(key, p) -> c` encrypts block `p` using the key, and returns the result `c`.
* `absorb(data)` absorbs data into the hash function by performing a step of (a variant of) GHASH or POLYVAL as specified by the algorithm
   (for instance, AES-GCM-SIV uses POLYVAL):
  . `tag <- tag xor INPUT`.
  . `tag <- Mont_mult(tag, hash_key)` or `tag <- Galois_mult(tag, hash_key)`, depending on the algorithm.
State Machine:::
* *States:* _initial_, _set_public_value_, _hash_absorb_, _enc_tag_finalize_, _dec_tag_finalize_, _encrypt_, _decrypt_, and _completed_.

* *Allowed State Transitions:*
 ** From all states to _initial_.
 ** For encryption:
    _initial_ -> _set_public_value_ -> _hash_absorb_ -> _enc_tag_finalize_ -> _encrypt_.
 ** For decryption:
    _initial_ -> _set_public_value_ -> _hash_absorb_ -> _decrypt_ -> _dec_tag_finalize_.
 ** Transition to _encrypt_ possible only if metadata allows encryption, else the CR is *invalidated*.
 ** Transition to _decrypt_ possible only if metadata allows decryption, else the CR is *invalidated*.

* *Behavior:*
 ** In state _initial_ :
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
  *** The following initialization operations are performed:
   . (`enc_key`, `auth_key`) `<-` `RFC8452_KeyDeriv(key)`,
   . `nonce`, `ctr`, `tag`, `SIV <- 0`.

** Upon issuing ```ace.state Kn|K[Xn], #ace_state_set_public_value, INPUT``` with a vector additional parameter, or its replacement sequence:
  *** The values of `nonce` is set to `INPUT`.

** Upon issuing ```ace.state Kn|K[Xn], #ace_state_set_public_value``` with a GPR additional parameter or none.
  *** An invalid instruction error is raised and the CR is *invalidated*.

** Upon issuing ```ace.state Kn|K[Xn], #ace_state_hash_absorb, INPUT``` with a vector additional parameter, or its replacement sequence:
  *** The values of `SIV` is set to `INPUT`.
  *** This version of the instruction is to be used during decryption.

 ** Upon issuing ```ace.state Kn|K[Xn], #ace_state_hash_absorb, Xm``` with a GPR additional parameter.
  *** An invalid instruction error is raised and the CR is *invalidated*.

 ** Upon issuing ```ace.state Kn|K[Xn], #ace_state_hash_absorb``` with no additional parameter.
  *** The `SIV` is not modified (it is assumed to be already zero).
  *** This version of the instruction is to be used during encryption.

 ** In state _hash_absorb_:
+
--
   *** Only ``ace.exec`` instructions of the Form “```ace.exec Kn|K[Xn], INPUT```” are allowed, or their replacement sequences.
   This accumulates a value in the `tag`, i.e., it performs `absorb(INPUT)`.
--
+
If `IOLEN` is a multiple of `b`, `absorb()` is executed on each of the `IOLEN/b` blocks in `INPUT`.

** In state _enc_tag_finalize_, only an {nbsp}``ace.exec``{nbsp} instruction of Form A, or its replacement sequence, are allowed.
The value
+
--
  *** `INPUT <- bin(bit_length(AD), b/2) @ bin(bit_length(plaintext), b/2)`,
--
+
must be set by the user.
Then, “```ace.exec OUTPUT, Kn|K[Xn], INPUT```” finalizes the computation of the SIV/tag, by performing:
+
--
    . `absorb(INPUT)`.
    . `tmp <- enc_blk(enc_key, 0 @ (tag xor N)[b-2:0])`
    . If tag length is `b` bits, then
     .. `SIV <- tmp` and `OUTPUT <- tmp`,
    . else (tag length is `3b/4` bits)
     .. `SIV <- tmp[b-1:b/4]` and `OUTPUT <- (tmp >> b/4)`.
--
+

If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.

 ** In state _encrypt_, only  ``ace.exec`` instructions of the Form A or their replacement sequences are allowed, namely “```ace.exec OUTPUT, Kn|K[Xn], INPUT```,” to encrypt `INPUT` into `OUTPUT` as follows:
+
--
. If `ctr == 0`, then the CR is *invalidated*.
   . If the `SIV` is `b`-bits long, then
     .. ``OUTPUT <- INPUT `` +
        ``       xor enc_blk(enc_key, 1 @ SIV[b-2:b/4] @ (SIV[b/4-1:0] + ctr % 2^b/4^)),``
   . else (the `SIV` is `3b/4`-bits long)
      .. ``OUTPUT <- INPUT xor enc_blk(enc_key, 1 @ SIV[3b/4-2:0] @ ctr``.
   . `ctr <- ctr + 1`.
--
+
If `IOLEN` > `b`, the above operations are applied to each of the `IOLEN/b` blocks in `INPUT`.

 ** In state _decrypt_,  only  ``ace.exec`` instructions of the Form A or their replacement sequences are allowed, namely “```ace.exec OUTPUT, Kn|K[Xn], INPUT```,” to decrypt `INPUT` into `OUTPUT` and then absorb the plaintext `INPUT` into the `tag`:
+
--
     . If `ctr == 0`, then the CR is *invalidated*.
     . If the `SIV` is `b`-bits long, then +
       .. ``OUTPUT <- INPUT `` +
          ``       xor enc_blk(enc_key, 1 @ SIV[b-2:b/4] @ (SIV[b/4-1:0] + ctr % 2^b/4^))``,
     . else (it is `3b/4`-bits long) +
       .. ``OUTPUT <- INPUT xor enc_blk(enc_key, 1 @ SIV[3b/4-2:0] @ ctr``.
     . `absorb(INPUT)`.
     . `ctr <- ctr + 1`.
--
+
If `IOLEN` > `b`, the above operations are applied to each of the `IOLEN/b` blocks in `INPUT`.

 ** In state _dec_tag_finalize_,
   only an ``ace.exec`` instruction of Form B, or its replacement sequence, are allowed,
   namely “```ace.exec Kn|K[Xn], INPUT```,” where it is the responsibility of the user to set
+
--
  ***  `INPUT <- bin(bit_length(AD), b/2) @ bin(bit_length(plaintext), b/2)`.
--
+
``ace.exec`` thus performs the following operations:
+
--
  . `absorb(INPUT)` (which modifies `tag`).
  . `tmp <- enc_blk(enc_key, 0 @ (tag xor N)[b-2:0])`.
  . If tag length is `b` bits, then
     .. `tag <- tmp`,
  . else (tag length is `3b/4` bits)
     .. `tag <- tmp[b-1:0] @ (b/4)b0`.
  . Finally, `tag` and `SIV` are compared:
     .. If the values match, the state transitions to _completed_ and `ace.error` returns no error,
  else the state transitions to _completed_ and `ace.error` returns `ace_err_authentication`.
--
+
If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.

 ** Upon completion of `ace.import`, the ACE unit recomputes `enc_key` and `auth_key`, i.e.:
  . (`enc_key`, `auth_key`) <- `RFC8452_KeyDeriv(key)`.

//

===== Usage

We show in <<ACE-pseudocode-GCM-SIV-encryption>> how to perform AEAD encryption with a GCM-SIV CC (with `b` = `IOLEN` = 128).
<<ACE-pseudocode-GCM-SIV-decryption>> is the corresponding pseudocode for decryption.

[[ACE-pseudocode-GCM-SIV-encryption]]
.GCM-SIV Encryption
----
// Acquire payload, initialize
- Info: authenticated data = *AD
- Info: plaintext = *PT
- Call an API to get the corresponding key from a key management applet or HW block.
- The API returns the SCC. Assume X5 is the pointer to it.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)

// Set the nonce (and the derived Authentication Key).
ace.state K0, #ace_state_set_public_value
V0 ← nonce
ace.exec K0, V0

foreach(i from 0 to len_in_bytes(AD)/16-1) {
   V0 ← AD[16*i .. 16*i+15]                      // Load a block of associated data
   ace.exec K0, V0                               // Absorb it into hash
}

foreach(i from 0 to len_in_bytes(PT)/16-1) {
   V0 ← PT[16*i .. 16*i+15]                      // Load a block of plaintext
   ace.exec K0, V0                               // Absorb it into hash
}

V0 ← bin(len_in_bits(AD), 64) @ bin(len_in_bits(PT), 64)
ace.exec K0, V0                                  // Absorb lengths into hash

// Finalize the SIV computation, set and return it
ace.state K0, #ace_state_enc_tag_finalize
ace.exec V2,K0
tag ← V2

// Encrypt the plaintext
ace.state K0, #ace_state_encrypt
foreach(i from 0 to len_in_bytes(PT)/16-1) {
   V0 ← PT[16*i .. 16*i+15]                      // Load a block of plaintext
   ace.exec V1, K0, V0                           // Encrypt the block
   CT[16*i .. 16*i+15] ← V1                      // Store a block of ciphertext
}
----

[[ACE-pseudocode-GCM-SIV-decryption]]
.GCM-SIV Decryption
----
// Acquire payload, initialize
- Info: authenticated data = *AD
- Info: ciphertext = *CT
- Call an API to get the corresponding key from a key management applet or HW block.
- The API returns the SCC. Assume X5 is the pointer to it.
- Allocate memory for plaintext buffer PT (if not same as CT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)

// The next operations set the nonce and SIV.
ace.state K0, #ace_state_set_public_value
V0 ← nonce
ace.exec K0, V0
ace.state K0, #ace_state_set_public_value_2
V0 ← SIV
ace.exec K0, V0

// Compute AD contribution to Auth Data
ace.state K0, #ace_state_hash_absorb
foreach(i from 0 to len_in_bytes(AD)/16-1) {
   V0 ← AD[16*i .. 16*i+15]
   ace.exec K0, V0                               // Absorb it into hash
}

// Decrypt ciphertext and continue computation of tag
foreach(i from 0 to len_in_bytes(CT)/16-1) {
   V0 ← CT[16*i .. 16*i+15]
   ace.exec V1, K0, V0
   PT[16*i .. 16*i+15] ← V1
}

// Finally, we absorb the lengths of AD and plaintext into tag AND verify
ace.state K0, #ace_state_enc_tag_finalize
V0 ← bin(len_in_bits(AD), 64) @ bin(len_in_bits(PT), 64)
ace.exec K0, V0
ace.error X1
if (X1 != 0) then { handle error }     // do not use the plaintext if error occurred
----

[[ACE-OCB-mode]]
==== OCB Mode

We only architect the OCB3 variant of OCB as specified in RFC{nbsp}7253 cite:[RFC7253] and cite:[DBLP-journals-joc-KrovetzR21].
While this algorithm is asymptotically more efficient than GCM and GCM-SIV, it has a much heavier setup and
its exported state, requires significantly more memory than the other modes.
On the other hand, since it uses only a single key and no derived keys, with ciphers with an expensive key expansion
like the AES it may use fewer internal resources.

The state machine of this algorithm closely follows RFC{nbsp}7253 (except for the ordering and numbering of the bit fields).
The algorithm and is of course identical to the RFC's for 128-bit-wide block ciphers, with the generalisation to other widths being straightforward and according the security proof of the original algorithm and a lower bound on nonce length following cite:[cryptoeprint-2023-326].

===== Specification

Parameters:::
+
--
* `b` = block size. `b` is a power of two, at least 64. For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = key size, `b`|`k`.
--
+
Also, define `g` = `log_2(b)`.

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.

* *Internal State*:
 ** `key`: `k` bits.
 ** `N`: `u+1` bits (at most `u` bits are all used).
 ** `L`, `offset`, `hash_A`, `hash_P` : `b` bits.
 ** `N_len`, `tag_len`, `last_blk_len`: `g` bits.

* *Serialized Content*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.
 . `N`: `b` bits, but only `u+1` bits defined.
 . `L`: `b` bits.
 . `offset`: `b` bits.
 . `hash_A`: `b` bits.
 . `hash_P`: `b` bits.
 . `tag_len`: 16 bits
 . `last_blk_len`: 16 bits
 . `N_len` : 16 bits
 . padding : 16 bits

Algorithm-Specific Functions:::

* `enc_blk(K,p) -> c` encrypts block `p` using the key `K` and returns the result `c`.
* `dec_blk(K,c) -> p` decrypts block `c` using the key `K` and returns the result `p`.
* `double(S)`:
Let `C` be  `0x1B` for `b` = 64, `0x87` for `b` = 128, and `0x425` for `b` = 256, then: +
If S[`b`-1] == 0, then { `double(S)` <- `S << 1` } else { `double(S)` <- `(S << 1) xor C` } .

State Machine:::

* *States:* _initial_, _set_public_value_, _set_public_value_2_, _hash_absorb_, _encrypt_, _enc_last_block_, _enc_tag_finalize_, _decrypt_, _dec_last_block_, _dec_tag_finalize_, _hash_verify_, and _completed_.

* *Allowed State Transitions:*
 ** From all states to _initial_.
 ** _initial_ -> _set_public_value_ -> _set_public_value_2_ -> _hash_absorb_ -> _hash_finalize_
 ** _hash_finalize_ -> _encrypt_ -- if metadata allows encryption, else the CR is *invalidated*.
 ** _hash_finalize_ -> _decrypt_ -- if metadata allows decryption, else the CR is *invalidated*.
 ** _encrypt_ -> _enc_last_block_ -> _enc_tag_finalize_ -> _hash_output_ -> _completed_.
 ** _decrypt_ -> _dec_last_block_ -> _hash_verify_ -> _completed_.

* *Behavior:*
** In state _initial_ :
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
  *** The following initialization operations are performed:
   . `N <- 1 @ zeros(u)`.
   . `hash_A <- zeros(b)`
   . `hash_P <- zeros(b)`

** To move to _set_public_value_, the `ace.state` operation must use the additional argument, which sets the nonce length `N_len`.
 `N_len` must be at least `g-1`. If not, an invalid instruction error is raised, and the CR is *invalidated*.

** In state _set_public_value_, only  ``ace.exec`` instructions of Form B, “```ace.exec Kn|K[Xn], INPUT```”, or their replacement sequences, are allowed, whereby `N` is set to `INPUT`, namely
     `N <- zeros(u-N_len) @ INPUT[N_len-1:0]`
  *** If “```ace.exec Kn|K[Xn], INPUT```,” is repeated, it will rewrite `N`.
  *** If no such `ace.exec` is issued, `N` remains zero. This condition results in an error at a later state transition.

** To move to _set_public_value_2_, the `ace.state` operation must have the additional argument, which sets the tag length `tag_len`.
   If this argument (interpreted as an unsigned value) is larger than `b` or `0` (the latter occurs also
   if `X0` is passed as the additional argument), an invalid instruction error is raised, and the CR is *invalidated*.
  *** If `N[u] == 1`, this means that `N` was not set in state _set_public_value_. We do not allow code that skips nonce setting, as this mode is not secure under nonce reuse, therefore in this case an invalid instruction error is raised, and the CR is *invalidated*.
  *** The following operation must be an `ace.state` to move to _hash_absorb_

** Upon entering state _hash_absorb_,  following operations are performed:

  . `offset <- zeros(b)`
  . `L <- enc_blk(key, zeros(b))`
  . `L <- double(double(L))`

** In state _hash_absorb_, only  ``ace.exec`` instructions of Form B or their replacement sequences are allowed:
  “```ace.exec Kn|K[Xn], INPUT```” absorbs a data block in `tag`, i.e.:
+
--
    . `L <- double(L)`
    . `offset <- offset xor L`
    . `hash_A <- hash_A xor enc_blk(key, INPUT xor offset)`
--
+
If `IOLEN` > `b`, the above operation is executed `IOLEN/b` times.

  *** If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.

** To move to _hash_finalize_, the `ace.state` operation must have the additional argument, which sets the length of the final block of the AD in `last_blk_len`.

** In state _hash_finalize_, only one `ace.exec` instructions of Form B or its replacement sequence is allowed if `last_blk_len` != `0`.
 “```ace.exec Kn|K[Xn], INPUT```” which absorbs the last data block in `tag`, i.e.:
+
--
  * `tmp : bits(b)`

[]
  . `offset <- offset xor enc_blk(key, zeros(b))`
  . `tmp <- (zeros(b-last_blk_len-1) @ 1 @ INPUT[last_blk_len-1:0]) xor offset`
  . `hash_A <- hash_A xor enc_blk(K, tmp)`
--
+
If `last_blk_len` == 0, however, no `ace.exec` can be executed, and only an `ace.state` instruction is allowed to enter state _encrypt_ or _decrypt_.

** Upon entering states `_encrypt_` or `_decrypt_`, the _setup_ and _init_ stages is performed:
+
--
 * `N_ext : bits(b)` (`N_ext` means “N, extended”)
 * `Stretch : bits(3b/2)`
 * `bot : bits(g-1)`
 * `Ktop : bits(b)`

[]
 . `offset <- zeros(b)`
 . `L <- enc_blk(key, zeros(b))`
 . `L <- double(double(L))`
 . `N_ext <- N[N_len-1:0] @ 1 @ zeros(b-g-1-N_len) @ numtobits(tag_len,g)`
 . `bottom <- int(N_ext[b-1:b-g+1])` // Rogaway's paper number bits in opposite order
 . `Ktop <- enc_blk(key, zeros(g-1) @ N_ext[b-g:0])`
 . `Stretch <- (Ktop[b/2-1:0] xor Ktop[b/2+7:8]) @ Ktop`
 . `offset <- Stretch[b+bottom:bottom]`
--
+
** In state _encrypt_, only ``ace.exec`` instructions of Form A or their replacement sequences are allowed:
   “```ace.exec OUTPUT, Kn|K[Xn], INPUT```” absorbs the plaintext `INPUT` into the `tag` an encrypts `INPUT` into `OUTPUT`, namely:
+
--
 . `L <- double(L)`
 . `offset <- offset xor L`
 . `hash_P <- hash_P xor INPUT`
 . `OUTPUT <- offset xor enc_blk(key, INPUT xor offset)`
--
+
If `IOLEN > b`, the above operation sequence is executed `IOLEN/b` times, encrypting each `b`-bit block of `INPUT` into the corresponding `b`-bit block of `OUTPUT`.

** To move to _enc_last_block_, the `ace.state` operation must have the additional argument, which sets the bit length of the final block of the plaintext in `last_blk_len`.

** In state _enc_last_block_, only an ``ace.exec`` instruction of Form A “```ace.exec OUTPUT, Kn|K[Xn], INPUT```,” or its replacement sequence,
are allowed if `last_blk_len` is nonzero.
In this case, following operations are performed:
+
--
 * `tmp : bits(last_blk_len)`
 * `tmp2 : bits(b)`
 * `aux : bits(b)`

[]
 . `aux <- enc_blk(key, zeros(b))`
 . `offset <- offset xor aux`
 . `tmp <- enc_blk(key, offset)[last_blk_len-1:0]`
 . `tmp <- INPUT[last_blk_len-1:0] xor tmp`
 . `OUTPUT <- zeros(b-last_blk_len) @ tmp`
 . `tmp2 <- (zeros(b-last_blk_len-1) @ 1 @ tmp) xor offset`
 . `aux <- double(aux)`
 . `hash_P <- enc_blk(key, hash_P xor tmp2 xor offset xor aux) xor hash_A`
--
+
On the other hand, if `last_blk_len` is zero, only an ``ace.exec`` instruction of Form D, “```ace.exec Kn|K[Xn]```,” is allowed, which performs:
+
--
* `aux : bits(b)`

[]
  . `aux <- enc_blk(key, zeros(b))`
  . `aux <- double(aux)`
  . `hash_P <- enc_blk(key, hash_P xor offset xor aux) xor hash_A`
--
+
In both cases the state then transitions to _enc_tag_finalize_.

** In state _enc_tag_finalize_, only an ``ace.exec`` instruction of Form C, “```ace.exec OUTPUT,Kn|K[Xn]```,” or its replacement sequence, are allowed, which
performs `OUTPUT <- zeros(b-tag_len) @ hash_P[tag_len-1:0]`.
** In state _decrypt_, only ``ace.exec`` instructions of Form A or their replacement sequences are allowed.
    “```ace.exec OUTPUT, Kn|K[Xn], INPUT```” decrypts `INPUT` into `OUTPUT`, and absorbs the plaintext `OUTPUT` into the `tag`, namely:
+
--
  * `tmp : bits(b)`

[]
  . `L <- double(L)`
  . `offset <- offset xor L`
  . `tmp <- offset xor enc_blk(key, INPUT xor offset)`
  . `hash_P <- hash_P xor tmp`
  . `OUTPUT <- tmp`
--
+
If `IOLEN` > `b`, the same behavior applies as in state _encrypt_.

** To move to _dec_last_block_, the `ace.state` operation must have the additional argument, which sets the bit length of the final block of the ciphertext in `last_blk_len`.

** In state _dec_last_block_, only an ``ace.exec`` instruction of Form A “```ace.exec OUTPUT, Kn|K[Xn], INPUT```,” is allowed if `last_blk_len` is nonzero.
In this case, the same operations as in state _enc_last_block_ are performed except for line 6., that reads instead
+
--
[start=6]
. `tmp2 <- (zeros(b-last_blk_len-1) @ 1 @ INPUT[last_blk_len-1:0]) xor offset`
--
+
If `last_blk_len` is zero, only an ``ace.exec`` instruction of Form D, “```ace.exec Kn|K[Xn]```,” is allowed, which performs the same operations as in state _enc_last_block_.
+
For any value of `last_blk_len`, the state is changed to _hash_verify_.

** In state _hash_verify_, only an ``ace.exec`` instruction of Form B, i.e., “```ace.exec Kn|K[Xn], INPUT```”, or its replacement sequence, are allowed.
    It compares the `tag_len` least significant bits of `INPUT` with the `tag_len` least significant bits of `hash_P`:
+
--
  . If the values match, then the state is changed to _completed_, and `ace.error` returns no error,
  . else the state is changed to _completed_, and `ace.error` returns `ace_err_authentication`.
--
+

//

===== Usage

Pseudocode for OCB encryption is given in <<ACE-pseudocode-OCB-encryption>> (again with `b` = `IOLEN` = 128).

[[ACE-pseudocode-OCB-encryption]]
.OCB Encryption
----
// Acquire payload, initialize
- Info:
 - authenticated data = *AD with bit length AD_len
 - plaintext = *PT with bit length PT_len
 - nonce N with bit length N_len
 - tag length tag_len

- Process gets an OCB encryption CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero,4,e32,m1,ta,ma                      // Use 128-bit vectors
ace.import K0, (X5)

// The next operations set the nonce
X1 ← N_len
ace.state K0, #ace_state_set_public_value,X1
V0 ← N
ace.exec K0, V0

// The next operations set the tag lenth
X1 ← tag_len
ace.state K0, #ace_state_set_public_value_2, X1

// Compute AD contribution to tag
ace.state K0, #ace_state_hash_absorb

AD_fullblocks ← floor(AD_len/128)
PT_fullblocks ← floor(PT_len/128)

foreach(i from 0 to AD_fullblocks-1) {
   V0 ← AD[16*i .. 16*i+15]
   ace.exec K0, V0                                 // Absorb it into hash
}

X1 ← AD_len mod 128                                // Can be zero
ace.state K0, #ace_state_hash_finalize, X1
if (X1 mod 128 != 0) then
   V0 ← zeros(128)
   V0 ← AD[AD_fullblocks*16 .. AD_fullblocks*16+ceil(X1/8)]
   ace.exec K0, V0                                 // Absorb it into hash and encrypt

// Encrypt plaintext and continue computation of tag
ace.state K0, #ace_state_encrypt
foreach(i from 0 to PT_fullblocks-1) {
   V0 ← PT[16*i .. 16*i+15]
   ace.exec V1, K0, V0
   CT[16*i .. 16*i+15] ← V1
}

X1 ← PT_len mod 128                                // Can be zero
ace.state K0, #ace_state_enc_tag_finalize, X1
if (X1 mod 128 != 0) then
   V0 ← zeros(128)
   V0 ← PT[PT_fullblocks*16 .. PT_fullblocks*16+ceil(X1/8)]
   ace.exec V1, K0, V0                             // Absorb it into hash and encrypt
   CT[PT_fullblocks*16 .. PT_fullblocks*16+ceil(X1/8)] ← V1

ace.state K0, #ace_state_output
ace.exec V1, K0, V1                                // output tag
----

OCB decryption differs from encryption as follows:
the roles of `PT` and `CT` are reversed,
states _encrypt_ and _enc_tag_finalize_ are replaced by states _decrypt_ and _dec_tag_finalize_,
and the last lines are as follows:

[[ACE-pseudocode-OCB-decryption-difference]]
.OCB Decryption
----

ace.state K0, #ace_hash_verify
V1 ← tag
ace.exec K0, V1                          // V1 contains the tag from the input
ace.error X1
if (X1 != 0) then { handle error }       // do not use the plaintext if error occurred
----

[[ACE-CMAC-mode]]
==== CMAC Functions

{empty}
(((ACE, algorithm, CMAC)))
CMAC is an algorithm for message authentication codes constructed from a block cipher.
It was designed by Tetsu Iwata and Kaoru Kurosawa and became a NIST recommendation in May 2005 cite:[nist-SP-800-38B].

===== Specification

Parameters:::

* `b` = block size (8|`b`).  For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = key size (8|`k`).

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits.

* *Internal State*:
 ** `key`: `k` bits.
 ** `hash`: `b` bits.
 ** `last_block_len`: 64 bits.

* *Serialized Content*:
[lowerroman]
 . `key`: `k` bits.
 . `hash`: `b` bits.
 . `last_block_len`: 64 bits.

Algorithm-Specific Functions:::

* `enc_blk(key, p) -> c` encrypts block `p` using the key `key`, and returns the result `c`.
* `gen_subkeys(K) -> (K1,K2)` generates subkeys `K1` and `K2` from the master key `K` as follows: +
Let `C` be `0x1B` for `b` = 64, `0x87` for `b` = 128, and `0x425` for `b` = 256, then

 . `L <- enc_blk(K, zeros(b))`
 . if (`msb(L){nbsp}{nbsp}== 0`) then
   { `K1 <- L{nbsp}{nbsp}<< 1` }
   else
   { `K1 <- (L{nbsp}{nbsp}<< 1) xor C` }.
 . if (`msb(K1){nbsp}== 0`) then
   { `K2 <- K1{nbsp}<< 1` }
   else
   { `K2 <- (K1{nbsp}<< 1) xor C` }.
 . return ```(K1, K2)```.

State Machine:::

* *States:* _initial_ (0), _hash_absorb_, _hash_last_block_, _hash_finalize_, and _completed_.
* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_.
 ** _hash_absorb_ -> , _hash_last_block_ -> _hash_finalize_ -> _completed_.
 ** From any state to state _initial_.
* *Behavior:*
 ** In state _initial_:
  *** `last_block_len <- zeros(64)`
  *** `hash <- zeros(b)`
  *** No {nbsp}```ace.exec```{nbsp} operation is allowed.

 ** In state _hash_absorb_, we can only issue ``ace.exec`` instructions of Form B, i.e., “```ace.exec Kn|K[Xn], INPUT```,”
 or their replacement sequences,
 to absorb the data block `INPUT` into the hash. This is performed as follows:
+
--
   . `hash <- enc_blk(key, hash xor INPUT)`.
--
+
If `IOLEN` > `b`, then the above operations are applied to each `b`-bit block of `INPUT`.

 ** Upon issuing “```ace.state Kn|K[Xn], #ace_state_last_block, Xs```” where `Xs` contains the bit length of the last block, the following happens:
   . if `last_block_len` != 0, then the CR is *invalidated*. (The previous block is not complete.)
   . if `Xs > b` then the CR is *invalidated*.
   . `last_block_len <- Xs`.

 ** In state _hash_last_block_,  we can only issue a single ``ace.exec`` instruction of Form B, i.e., “```ace.exec Kn|K[Xn], INPUT```”, or its replacement sequence, to absorb the data block `INPUT`. If `IOLEN` > `b`, only the least significant `b` bits of `INPUT` are considered.
+
--
  . `(K1, K2) <- gen_subkeys(key)`.
  . if `last_block_len` == `b`, then
    .. `tmp <- hash xor INPUT xor K1`
  . else
    .. `tmp <- INPUT`
    .. Remove the `b` - `last_block_len` most significant bits of `tmp` and pad the resulting value with a `1` and sufficiently many `0` bits to make it `b` bits long.
    .. `tmp <- hash xor tmp xor K2`
  . `hash <- enc_blk(key, tmp)`
  . The state is changed to _hash_finalize_.
--
+

** In state _hash_finalize_, we can issue one ``ace.exec`` instruction of Form C, i.e., “```ace.exec OUTPUT, Kn|K[Xn]```”, or its replacement sequence, to output the hash into `OUTPUT`.
   If `IOLEN` > `b`, only the bits of `OUTPUT` beyond the `b`-th are cleared.
   Upon issuing that instruction, the CC transitions to state _completed_ with no error.

//

===== Usage

[[ACE-pseudocode-CMAC]]
.CMAC Computation
----
- Info: CMAC input = *M with bit length M_len
- Process gets a CMAC CC from an API. Assume X5 is the pointer to the CC.

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)

ace.state K0, #ace_hash_absorb
blocks = floor(M_len/128)
remainder = M_len % 128
if remainder == 0 then
   blocks ← blocks - 1
   remainder ← 128

foreach(i from 0 to blocks-1) {
   V0 ← M[16*i .. 16*i+15]
   ace.exec K0, V0
}

X1 ← remainder
ace.state K0, #ace_hash_last_block, X1
V0 ← M[16*blocks .. 16*blocks+15]
ace.exec K0, V0

ace.state K0, #ace_hash_hash_finalize
ace.exec V0, K0  // this is the value of the CMAC
----


[[ACE-hash-functions]]
==== Hash and MAC Functions, and XOFs

{empty}
(((ACE, algorithm, general hashing)))
(((ACE, algorithm, MAC functions)))
(((ACE, algorithm, XOF)))
This section defines an interface for hash and MAC functions.
Because of the vast variety of such functions, we cannot define a completely general interface.
However, the interface defined here is sufficiently general to allow to describe most commonly used and standardized functions, such as
the SHA2 cite:[nist-fips-180-4], SHA3 and SHAKE cite:[nist-fips-202], as well HMAC cite:[nist-fips-198-1] keyed constructions, and many others.

===== Specification

Parameters:::

* `b` = block size (8|`b`). This is the size of an absorbed block and may be different from the size of the internal state that is kept by the function. For a sponge function, this value is the _rate_ of the function.
* `t` = tag len (8|`t`). This is the size of the digest, or of the block that is output each time in a XOF. The present description assumes `t` {le} `b`.
* `n` = size of the internal state that is kept by the function (8|`n`).  For a sponge function, `n-b` is the _capacity_ of the function.
Either the block size is an integer multiple of the vector length or the vector length is an integer multiple of the block size.
* `k` = key size (8|`k`). Present only if keyed, i.e., a MAC.

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits. Present only if keyed, i.e., a MAC.

* *Internal State*:
 ** `key`: `k` bits. Present only if keyed, i.e., a MAC.
 ** `state`: `n` bits.
 ** `last_block_len`: int. Present only if this Hash/MAC has special internal treatment for a fractional last block that goes beyond padding and appending the length, which are handled by user software  (field size at most 16 bits).
 ** `input_base`: int. Offset within input/output to read from/write to (field size at most 16 bits).
 ** `block_base`: int. Length of absorbed data so far for the current block (field size at most 16 bits). Only if used by the algorithm.
 ** `cumul_len`: int. Cumulative length of dta absorbed so far (if the algorithm must process and incorporate it in the hash on its own).
 ** `block`: `b` bits.  We include it only if there is a partial block, i.e., for instance if the absorbed unit is larger than a normally available vector size or not a submultiple thereof, and is not directly absorbed into `state`.

* *Serialized Content*:
[lowerroman]
 . `key`: `k` bits. Present only if keyed, i.e., a MAC.
 . `state`: `n` bits.
 . `last_block_len`: 16-bit unsigned int. Only if this Hash/MAC has special internal treatment for a fractional last block that goes beyond padding and appending the length, which are handled by user software. Otherwise, this is zero.
 . `block_base`: 16-bit unsigned int. Length of filled data so far into `block`.  Only if used by the algorithm, else zero padding.
 . `cumul_len`: 32-bit unsigned int. Cumulative length of all data absorbed so far. Only if the algorithm must process and incorporate it in the hash on its own, else zero padding.
 . `block`: `b` bits.
    We include it in a SCC only if there is a partial block, and exclude it when not.
    We reuse the most significant bit of the `state` field to store this information.
    (In theory, we could include only the part filled so far, but this would complicate the parsing of a SCC.)

NOTE: Regarding the `last_block_len`/`block_base`/`cumul_len` group: if any of these fields is not used, it is replaced by a corresponding padding block.
If all three are not used by the hashing algorithm, then the 64-bit block is omitted.

Algorithm-Specific Functions:::

* `absorb()`: process `block` into the hash or MAC. This may include, for instance, state update operations.
* `absorb_last_block()`: process `block` into the hash or MAC, using the function for the last block.
* `finalize()`: process the `state` into the digest value. We assume this either re-uses `block` (the entire digest, or a unit of XOF output should not be be bigger than that) or the digest will be part of `state`
* `update()`: updates the `state` during the digest output stage.

State Machine:::

* *States:* _initial_, _hash_absorb_, _hash_last_block_, _hash_output_ and _completed_.

* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_ -> _hash_last_block_ -> _hash_output_ -> _completed_.
 ** From any state to state _initial_.

* *Behavior:*
 ** In state _initial_:
  *** `last_block_len`, `block_base` and `block` are set to zero.
  *** `state`: the initial value is set as specified by the algorithm.
  *** Any `ace.exec` will result in the CR being *invalidated*.

 ** In state _hash_absorb_, we can only issue ``ace.exec`` instructions of Form B, i.e.,
 “```ace.exec Kn|K[Xn], INPUT```”, or their replacement sequences, to absorb the data block `INPUT` into the hash as follows.
+
--
  . `input_base <- 0` // or `acestart` upon resumption
  . while `(input_base < IOLEN)` do { // as long as we have input to process
  .. `amount <- min(IOLEN-input_base, b-block_base)`
  .. ``block[block_base + amount - 1 : block_base] <-`` +
      ``{nbsp}{nbsp}{nbsp}{nbsp} <- INPUT[input_base + amount - 1 : input_base]`` +
        ``{nbsp}{nbsp}``(If there is no `block` field, could also be something like +
        ``{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}state[block_base + amount - 1 : block_base] <- `` +
        ``{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}<- state[block_base + amount - 1 : block_base] + `` +
        ``{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}+ INPUT[input_base + amount - 1 : input_base]`` , +
        ``{nbsp}{nbsp}{nbsp}``it could directly replace part of `state`, or some other function.)
  .. `input_base <- input_base + amount`
  .. `block_base <- block_base + amount`
  .. if (`block_base` == `b`) then { // it's time to absorb the block
  ... `absorb()`
  ... `block_base <- 0`
  ... *Here* the instruction may be interrupted, with `acestart <- input_base`.
  .. }
  . }
--
+

//
 ** Upon issuing “`ace.state Kn|K[Xn], #ace_state_hash_last_block, Xs`” where `Xs` contains the length of the last block, the following happens:
+
--
 . if `block_base` != 0, then the CR is *invalidated*. (The previous block is not complete.)
 . if `Xs > b`, then the CR is *invalidated*.
 . if `Xs == 0`, then the CR is *invalidated*.
 . `last_block_len <- Xs`.
--
+
Then, state transitions to _hash_last_block_ as expected.

 ** State _hash_last_block_ is very similar to _hash_absorb_, the only differences are:
  *** `last_block_len` is used in place of `b` throughout.
  *** `absorb_last_block()` is called instead of `absorb()` in Step 3.d.i.
  *** The instruction is terminated after `absorb_last_block()`–only one block is absorbed–and the state transitions to _hash_output_

 ** In state _hash_output_ we have two possible situations: we are in a hash function or in a XOF.
  *** Upon entering the state, the following operations are first performed:
  . `block[t - 1 : 0] <- finalize()`
  . `block_base <- 0`
 *** For each Form C `ace.exec` instruction “`ace.exec OUTPUT, Kn|K[Xn]`”, the following operations are performed:
+
--
    * `amount : int`, `{nbsp}` amount of data to copy from `block` to `OUTPUT`
    * `#define output_base input_base`

[]
   . `output_base <- 0` // or `acestart` upon resumption
    . while (`output_base` < `IOLEN`) do {
     .. `amount` <- `min(IOLEN - output_base, t - block_base)`
     .. ``OUTPUT[output_base + amount - 1 : output_base] <- `` +
           ``{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}<- block[block_base + amount - 1 : block_base + amount]``
     .. `output_base <- output_base + amount`
     .. `block_base <- block_base + amount`
     .. if (`block_base` == `t`) then {
      ... if we are in a Hash function, transition to _completed_, and return.
      ... `update()`
      ... `block_base <- 0`
      ... *Here* the instruction can be interrupted, with `acestart <- output_base`.
    .. }
    . }
--
+

//

[[ACE-SHA-3]]
==== SHA-3 Family Specific Rules

{empty}
(((ACE, algorithm, SHA-3)))
We describe here the algorithms for the primitives in the SHA-3 family, which currently includes SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128 and SHAKE256.
These primitives are designed around a special parameter choice of KECCAC cite:[DBLP-conf-eurocrypt-BertoniDPA13] standardized by NIST cite:[nist-fips-202].
These are instantiations of the algorithm specified in <<ACE-hash-functions>>, and we need to
describe only the differences with respect to the behavior described there.

Parameters:::

* `b` = rate (8|`b`). It can be 1600 - `c` with `c` = 448, 512, 768, or 1024 being the capacity.
* `n` = 1600
* `t` = `c/2`

Data Structures:::

* *Initialization Input*: the content is empty, i.e., there is only the metadata section.

* *Internal State*:
 ** `state`: `n` bits.
 ** `last_block_len`: int.
 ** `input_base`: int.
 ** `block_base`: int.

* *Serialized Content*:
[lowerroman]
 . `state`: `n` bits.
 . `last_block_len`: 16-bit unsigned int.
 . `block_base`: 16-bit unsigned int. Length of filled data so far into `block`.
 . padding: 32 bits.

Algorithm-Specific Functions:::
 * `P()`, computes `KECCAK-p[1600, 24]` on `state`.
 * `absorb()`: in this case there is no explicit operation to copy data into `state`, as the inputs will be directly XORed into it, however `absorb` applies `P()` to the state.
 * `absorb_last_block()`: this is a NOP.
 * `finalize()`: this is a NOP.
 * `update()`: updates the `state` during the digest output stage.  It applies `P()` to the state.

State Machine:::
* *States:* _initial_, _hash_absorb_, _hash_last_block_, _hash_finalize_, _hash_output_ and _completed_.

* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_ -> _hash_last_block_ -> _hash_finalize_ -> _hash_output_ -> _completed_.
 ** From any state to state _initial_.

* *Behavior:*
 ** In state _initial_, `state` is zeroed.
 ** In state _hash_absorb_, the input data is directly XORed to `state`.
 ** In state _hash_last_block_, the input data is directly XORed to `state`.
 ** Upon transitioning to state _hash_output_:
  . The suffix and padding string `S` is generated.
  . If the bit length of `S` is `b-block_base`:
   .. `S` is directly XORed to rate part of the state, and
   .. `P()` is applied.
  . If the bit length of `S` is `2b-block_base`:
   .. The first `b-block_base` bits are XORed to the rate part of the state,
   .. `P()` is applied,
   .. the remaining `b` bits are XORed to the rate part of the state, and
   .. `P()` is applied again.

The rest of the algorithm follows <<ACE-hash-functions>>.

//

[[ACE-Ascon]]
==== Ascon Specific Rules

{empty}
(((ACE, algorithm, Ascon)))
We now describe the state machines of the various Ascon-based cite:[DBLP-journals-joc-DobraunigEMS21] algorithms standardized by the NIST cite:[nist-SP-800-232].

[WARNING]
====
In all ASCON algorithms, the ordering of the bits must be verified!
====

[[ACE-Ascon-AEAD128]]
===== Ascon-AEAD128

In this mode it is the responsibility of the user to apply proper padding to the inputs.

Parameters:::

* `b` = 128. For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = 128.

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: 128 bits, or 64 bits if a System Key index.

* *Internal State*:
 ** `key`: 128 bits, or 64 bits if a System Key index.
 ** `state[0 .. 4]`: five 64-bit words, i.e., 320 bits.
 ** `tag_len`: 8 bits.

* *Serialized Content*:
[lowerroman]
 . `key`: 128 bits, or 64 bits if a System Key index.
 . `state[0 .. 4]`: five 64-bit words, i.e., 320 bits.
 . `tag_len`: lower 8 bits in a 64 bit field.

Algorithm-Specific Functions:::

* `ASCON(p)` applies `p` rounds of ASCON to the `state`.

State Machine:::

* *States:* _initial_, _set_public_value_, _hash_absorb_, _encrypt_, _enc_last_block_, _enc_tag_finalize_,
 _decrypt_, _dec_last_block_, _dec_tag_finalize_, _hash_verify_, and _completed_.

* *Allowed State Transitions:*
 ** From all states to _initial_.
 ** _initial_ -> _set_public_value_ -> _hash_absorb_.
 ** _hash_absorb_ -> _encrypt_ -- if metadata allows encryption, else the CR is *invalidated*.
 ** _hash_absorb_ -> _decrypt_ -- if metadata allows decryption, else the CR is *invalidated*.
 ** _encrypt_ -> _enc_last_block_ -> _enc_tag_finalize_ -> _completed_.
 ** _decrypt_ -> _dec_last_block_ -> _dec_tag_finalize_ -> _hash_verify_ -> _completed_.

* *Behavior:*
 ** In state _initial_ :
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
  *** The following initialization operations are performed:
   . `state[0] <- 0x00001000808c0001`
   . `state[1] <- key[63:0]`
   . `state[2] <- key[127:64]`
   . `state[3] <- zeros(64)`
   . `state[4] <- zeros(64)`
   . `tag_len <- 128`
 ** In state _set_public_value_:
  *** Only  ``ace.exec`` instructions of Form B or their replacement sequences are allowed.
  “```ace.exec Kn|K[Xn], INPUT```” sets
   . `state[3] <- INPUT[63:0]`
   . `state[4] <- INPUT[127:64]`
  *** If “```ace.exec Kn|K[Xn], INPUT```,” is repeated, it will just re-write the nonce.
  *** If no such `ace.exec` to set the nonce is issued, the nonce subfield of `state` remains zero.
  *** If `IOLEN` > 128, only the 128 least significant bits of `INPUT` are considered.

  ** Upon entering the state _hash_absorb_, the following is performed:
  . `ASCON(12)`
  . `state[3] <- state[3] xor key[63:0]`
  . `state[4] <- state[4] xor key[127:64]`
  ** In state _hash_absorb_, only  ``ace.exec`` instructions of Form B or their replacement sequences are allowed.
 “```ace.exec Kn|K[Xn], INPUT```” absorbs a data block into the state, i.e.:
+
--
 . `ASCON(8)`
 . `state[0] <- state[0] xor INPUT[63:0]`
 . `state[1] <- state[1] xor INPUT[127:64]`
--
+
If `IOLEN` > 128, the above group of operations is executed `IOLEN/128` times, once for each 128-bit block of `INPUT`.
 ** Upon entering state _encrypt_ or _decrypt_, the following domain separation operation is performed:
 . `lsb(state[4]) <- lsb(state[4]) xor 1`
 ** In state _encrypt_, only ``ace.exec`` instructions of Form A or their replacement sequences are allowed.
   “```ace.exec OUTPUT, Kn|K[Xn], INPUT```” encrypts `INPUT` into `OUTPUT`, namely:
+
--
. `state[0] <- state[0] xor INPUT[63:0]`
. `state[1] <- state[1] xor INPUT[127:64]`
. `OUTPUT <- state[0] @ state[1]`
. `ASCON(8)`
--
+
If `IOLEN` is a multiple of 128, the above group of operations is executed `IOLEN/128` times, encrypting each 128-bit block of `INPUT` into the corresponding 128-bit block of `OUTPUT`.

** In state _enc_last_block_, only one ``ace.exec`` instruction of Form A, to encrypt the last block is allowed.
Padding is managed by the user software.
“```ace.exec OUTPUT, Kn|K[Xn], INPUT```”  performs
+
--
. `state[0] <- state[0] xor INPUT[63:0]`
. `state[1] <- state[1] xor INPUT[127:64]`
. `OUTPUT <- state[0] @ state[1]` // only the 128 lsb's of `OUTPUT` are written to.
--
+
In this state only one 128-bit block is processed. +
The state machine then transitions to state _enc_tag_finalize_.

** In state _enc_tag_finalize_, only one ``ace.exec`` instruction of Form C, or its replacement sequence, to compute the tag, is allowed.
“```ace.exec OUTPUT, Kn|K[Xn]```”  performs
+
--
. `state[2] <- state[2] xor key[63:0]`
. `state[3] <- state[3] xor key[127:64]`
. `ASCON(12)`
. `state[3] <- state[3] xor key[63:0]`
. `state[4] <- state[4] xor key[127:64]`
. `OUTPUT <- state[3] @ state[4]` // only the 128 lsb's of `OUTPUT` are written to.
--
+
In this state only one 128-bit block is processed. +
The state machine then transitions to state _completed_.

** In state _decrypt_, only  ``ace.exec`` instructions of Form A or their replacement sequences are allowed., i.e.,
 `ace.exec OUTPUT,Kn|K[Xn],INPUT`. This operation performs:
+
--
* `tmp : bits(128)`

[]
. `tmp <- (state[0] xor INPUT[63:0]) @ (state[1] xor INPUT[127:64])`
. `state[0] <- INPUT[63:0]`
. `state[1] <- INPUT[127:64]`
. `ASCON(8)`
. `OUTPUT <- tmp`
--
+
If `IOLEN` is a multiple of 128, the above group of operations is executed `IOLEN/128` times, decrypting each 128-bit block of `INPUT` into the corresponding 128-bit block of `OUTPUT`.

** In state _dec_last_block_, only a Form A ``ace.exec`` instruction is allowed, or its replacement sequence.
“```ace.exec OUTPUT, Kn|K[Xn], INPUT```” performs:
+
--
* `tmp : bits(128)`

[]
. `tmp <- (state[0] xor INPUT[63:0]) @ (state[1] xor INPUT[127:64])`
. `state[0] <- INPUT[63:0]`
. `state[1] <- INPUT[127:64]`
. `OUTPUT <- tmp`
--
+
The state machine then transitions to state _dec_tag_finalize_.

** In state _dec_tag_finalize_, an `ace.state Kn|K[Xn], #ace_const_dec_tag_finalize, Xs` instruction may be executed, setting
the tag len `tag_len` to the value of `Xs`, provided it is not smaller than 32 and not larger that 128. If the value is out of bounds, it is simply not set and remains 128 as set in state _initial_.
The state machine then transitions to state _hash_verify_.

** In state _hash_verify_, only one ``ace.exec`` instruction of Form D, to verify the tag, is allowed, or its replacement sequence.
“```ace.exec Kn|K[Xn], INPUT```” performs
+
--
. `state[2] <- state[2] xor key[63:0]`
. `state[3] <- state[3] xor key[127:64]`
. `ASCON(12)`
. `state[3] <- state[3] xor key[63:0]`
. `state[4] <- state[4] xor key[127:64]`
. `INPUT[tag_len-1:0]` is compared to `(state[3] @ state[4])[tag_len-1:0]`
. If the values match, then the state is changed to _completed_, and `ace.error` returns no error,
  else the state is changed to _completed_, and `ace.error` returns `ace_err_authentication`.
--
+

//

[[ACE-Ascon-AEAD128-wsn]]
===== Ascon-AEAD128-with-set-nonce

Similarly to GCM-with-set-IV, also Ascon-AEAD128 can be made in a version with a set nonce.
In this case the state _set_public_value_ is skipped, and the initialisation input has the followin form

* *Initialization Input*:
[lowerroman]
 . `key`: 128 bits, or 64 bits if a System Key index.
 . `nonce`: 128 bits.

In state _initial_, words 3 and 4 of `state` are initialized thus:

. `state[3] <- nonce[63:0]`
. `state[4] <- nonce[127:64]`

Once in state _completed_, the CC cannot be brought back to state _initial_.

//

[[ACE-Ascon-AEAD128-N-masking]]
===== Ascon-AEAD128 with Nonce Masking

The NIST specification also described a version of Ascon-AEAD128 with _Nonce Masking_.
This variant is described as follows:

* *Initialization Input*:
[lowerroman]
 . `K1`: 128 bits, or 64 bits if a System Key index.
 . `K2`: 128 bits, omitted if a System Key is used.

* *Internal State*:
 . `K1`: 128 bits, or 64 bits if a System Key index.
 . `K2`: 128 bits, omitted if a System Key is used.
 ** `state[0 .. 4]`: five 64-bit words, i.e., 320 bits.
 ** `tag_len`: 8 bits.

* *Serialized Content*:
[lowerroman]
 . `K1`: 128 bits, or 64 bits if a System Key index.
 . `K2`: 128 bits, omitted if a System Key is used.
 . `state[0 .. 4]`: five 64-bit words, i.e., 320 bits.
 . `tag_len`: lower 8 bits in a 64 bit field.

The algorithm has the same states as Ascon-AEAD128 as described in <<ACE-Ascon-AEAD128>>, with the key `key` equal to `K1` and the nonce `N` replaced throughout by `N xor K2`.

For encryption and decryption with both nonce masking and a set nonce, the algorithm described in <<ACE-Ascon-AEAD128-wsn>> is used, giving `K1` as the key `key` and providing `N xor K2` as the nonce value.

[[ACE-Ascon-Hash256]]
===== Ascon-Hash256

In this mode it is the responsibility of the user to apply proper padding to the inputs.

Parameters:::

* `b` = 64. For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = 128.

Data Structures:::

* *Initialization Input*:
(no content)

* *Internal State*:
 ** `state[0 .. 4]`: five 64-bit words, i.e., 320 bits.
 ** `countdown` : integer going from 3 down to 0.

* *Serialized Content*:
[lowerroman]
 . `state[0 .. 4]`: five 64-bit words, i.e., 320 bits.
 . `countdown` : integer going from 3 down to 0. Stored in a 64-bit field.

Algorithm-Specific Functions:::

* `ASCON(p)` applies `p` rounds of ASCON to the `state`.

State Machine:::

* *States:* _initial_, _hash_absorb_, _hash_finalize_, and _completed_.

* *Allowed State Transitions:*
 ** From all states to _initial_.
 ** _initial_ -> _hash_absorb_ -> _hash_finalize_ -> _completed_.

* *Behavior:*
 ** In state _initial_ :
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
  *** The following initialization operations are performed:
   . `state[0] <- 0x0000080100cc0002`
   . `state[1] <- zeros(64)`
   . `state[2] <- zeros(64)`
   . `state[3] <- zeros(64)`
   . `state[4] <- zeros(64)`
   . `ASCON(12)`

  ** In state _hash_absorb_, only  ``ace.exec`` instructions of Form B or their replacement sequences are allowed.
 “```ace.exec Kn|K[Xn], INPUT```” absorbs a data block into the state, i.e.:
+
--
 . `state[0] <- state[0] xor INPUT`
 . `ASCON(12)`
--
+
If `IOLEN` > `64`, the above group of operations is executed `IOLEN/64` times, once for each `64`-bit block of `INPUT`.

** Upon entering _hash_finalize_, `countdown` is set to 3.

** In state _hash_finalize_, at most four ``ace.exec`` instructions of Form C or their replacement sequences are allowed.
To compute the tag, “```ace.exec OUTPUT, Kn|K[Xn]```”  performs
+
--
. `ASCON(12)`
. `OUTPUT <- state[0]`
. if `countdown == 0` then transition to state _completed_.
. `countdown <- countdown - 1`
--
+
If `IOLEN` {ge} `128`, the above group of operations is executed `IOLEN/64` times, writing to `OUTPUT[63:0]` the first time,
`OUTPUT[127:64]` the second time, if `IOLEN` {ge} `192`, `OUTPUT[191:128]` the third time, and if `IOLEN` {ge} `256`,`OUTPUT[255:192]` the fourth time.
If more than one ``ace.exec`` instructions are required, writing restarts from `OUTPUT[63:0]`.
If `countdown` reaches zero before the entire output registers is written to, the state of the unwritten bits is undefined: for instance
this may occur if `IOLEN` = `192` or `IOLEN` > `256`.
This is usually not a problem, since the output vectors will be usually configured for 64-bit, 128-bit, or 256-bit blocks, in which case
four, two, or one ``ace.exec`` instructions are required, respectively.

//

NOTE: There is no need to provide “keyed” versions of this algorithm.
If a providing, trusted entity wants to provide a CC in which some secret content has already been provisioned, there is nothing to prevent it.



===== Ascon-XOF128

The algorithm is the same as Ascon-Hash256 (<<ACE-Ascon-Hash256>>) with the following differences:

. The IV written to `state[0]` in state _initial_ is `0x0000080100cc0002`.
. There is no `countdown` field.
. As much output as desired can be produced in state _hash_finalize_ and the algorithm never transitions to state _completed_.

===== Ascon-CXOF128

Ascon-CXOF128 differs from Ascon-XOF128 in that the message is prepended with the customization string.
Except for the initialization of the state, Ascon-CXOF128 is identical to Ascon-XOF128 with customization string and message concatenated.
The IV for Ascon-CXOF128 is `0x0000080000cc0004` (in place of `0x0000080000cc0003`).
The states and their semantics are identical to Ascon-XOF128, and the management of the customization string is left to the user.

// //////////////////////////////////////////////////////////////////////////////////////////

[comment]
--
[[ACE-examples]]
=== Examples

==== Context Switching

[WARNING]
TBD

==== VM Migration

Users may migrate their virtual machines (VMs) between client devices with CPUs from different silicon providers—a practice already common when moving interrupted VMs between Intel and AMD systems.
In such a scenario, the ACE implementation on the destination device might have a Crypto Register File (CRF) with a smaller capacity (not necessarily a smaller internal memory, as the internal representation may be more redundant).
System software could then be unable to restore all Cryptographic Contexts.

To address this, the `acecrstatus` CSR can be used to enable lazy context reloading by causing the hart to trap to the parent mode if a CR being accessed is marked as “lazy”.  When this requires freeing one or more CRs first, system software decides which contexts to evict.

==== Key Management and Provisioning Applications

Software environments that implement key management operations for other domains require their own RCSK. A system may contain multiple such software environments.

A Key Management Applet (KMA) will

[arabic]
. Generate or retrieve a key matching a request.
. Configure a CR with this key and its associated metadata.
. Export this CR to a SCC in memory.
. Relinquish control to the MM.

The MM, which controls the CSK, can then

[arabic, start=5]
. Set the RCSK to the KMA’s RCSK.
. Re-import the SCC into a CR
. Change the RCSK to match the Requester domain's RCSK.
. Export the key for the Requester's use.
. Relinquish control to the Requester.

This is the most generic approach and allows each piece of software to use a CR of choice to generate CCs and import SCCs.
Furthermore, it protects the key from other SW environments that may be crossed while transferring control between the Requester process, the MM, and the Key Management application.

// Various optimizations are possible, which can be interesting for embedded environments: Steps 3., 5., and 6. can be omitted if the CR used for these operations is fixed and no intermediate SW environments modify that CR.
--

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-V-dependency]]
=== Dependency on the V Extension

[WARNING]
RVV-mini is not yet fully defined.

If ACE is implemented including the operations on vector registers-and thus not exclusively relying on `ace.input` and `ace.output`-it does not require the full V extension; it depends on a minimal subset, which we call RVV-mini. The required features are:
(((RVV-mini)))

* Support for vector registers sufficiently wide to host the block-wise operations required by the algorithms supported by ACE;
* The `vsetvli` instruction with restricted parameters (e.g., “```vsetvli zero,4,e32,m1,ta,ma```” for 128-bit-side operations); unsupported configurations must generate defined errors;
* Unit-strided vector loads and stores exclusively; and
* Vector bitwise logical operations such as `vxor`, `vand`, and `vor`.

Moreover,

* floating-point, fixed-point, and most arithmetic vector operations are not required, and
* more complex operations for some corner-case cryptographic algorithms may be performed in GPRs, with results then inserted in vector registers via `vins`/`vext`.

RVV-mini must maintain full opcode compatibility with RVV to guarantee that ACE code runs unmodified on full RVV implementations.


// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-RCSK-vs-ID]]
=== Programmable RCSKs vs. ID-based Usage Control

This section is informative and non-normative.

ACE provides two architected layers of usage control:

. At the User and Supervisor levels, CC usage can be optionally constrained by ASID and VMID.
This is a lightweight mechanism.
Because filtering by ASID is inactive when the hart is in S mode or higher, context switching can be performed without modifying the RCSK.
. At higher privilege levels, not only the usage, but even the import of CCs can be restricted by a programmable RCSK.
This offers stronger security by also preventing unauthorized `ace.import` operations, but incurs higher overhead as it typically requires an `ecall`.

The envisioned usage model employs ASID/VMID filtering at the User level, and also at the Supervisor level in high-performance systems where migration is not required (e.g., automotive applications). Cryptographic domain separation via the RCSK is intended for Virtual Machines, Supervisor Domains, Worlds, and TEEs within those contexts, as these demand stronger security guarantees.

NOTE: Although the architecture does not prevent assigning unique RCSKs to U-mode processes, doing so would impose a substantial burden on system software due to per-context-switch `ecall` overhead.
Hardware support—such as automatic RCSK switching based on ASID/VMID, could alleviate this burden.
However, such a mechanism is not currently under consideration due to its architectural complexity, inflexibility, and hardware cost.
For example, it would necessitate secure management of large RCSK tables, including saving, restoring, and potentially migrating entire RCSK blocks.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-threat-model]]
=== Threat Model

This section is informative and non-normative

The ACE threat model is straightforward.

**Assets** consist of _keys_ and any other information that could aid an adversary in recovering plaintext or forging ciphertext. This includes items such as masks in tweakable XEX modes and derived keys in AES-GCM-SIV. The critical properties of these assets are their _confidentiality_ and _integrity_.

**Adversaries** are assumed capable of compromising processes by exploiting software vulnerabilities.
They are also able to gain access to memory contents, for instance, by abusing hardware interfaces or by SoC/memory interposition.
The model does not include adversaries capable of sophisticated hardware attacks, such as using
a Focused Ion Beam/Scanning Electron Microscope (FIB/SEM) to tamper with the hardware's functionality.

Side channel attacks are addressed optionally. ACE offers interfaces to both SCA-unprotected and SCA-protected implementations of cryptographic algorithms, if these options are provided by the designer.

Threats can be addressed in four ways:

[horizontal]
**C:**:: _Control_ the threat by implementing full or partial mitigations.
**A:**:: _Accept_ the threat and its associated risks.
**T:**:: _Transfer_ the threat to another party better suited to address it.
**S:**:: _Suppress_ the features that give rise to the threat.

ACE is designed to avoid the “***A***” and “***S***” options (as much as possible). It _controls_ threats through its own mechanisms and _transfers_ residual risk—specifically, the risk of key extraction from the privileged or trusted software and hardware environments that manage keys—to those same environments. For example, trusted software environments may employ control-flow integrity, memory encryption with integrity protection, and anti-replay mechanisms, while hardware key-management blocks can be hardened to protect entrusted keys.

Direct plaintext leakage, memory corruption attacks against the ACE-using process, and Release of Unverified Plaintext (RUP) attacks on the cryptographic algorithms are considered out of scope. These threats cannot be mitigated by ACE because the processed information resides within the user execution context. Consequently, these threats are _accepted_.

// ///////////////////////////////////////////////////////////////////////////////////////////
[comment]
--

[[ACE-incomplete-contexts]]
=== Appendix: Export of Partial Cryptographic Contexts

[WARNING]
This section describes a hypothetical mechanism for exporting partially initialized or imported cryptographic contexts.
This is _Gedankenexperiment_ only and _not_ a current part of the ACE specification.

Suppose we want to save and restore a _partial_ context, i.e. a context whose initialization or import operation has been interrupted for a context switch, preventing immediate return to the original control flow.  A "Partial" bit in the metadata indicates this state.
This field applies only to `ace.init` and `ace.import` operations, because they access external memory, and not to `ace.clone` and `ace.derive` as they only operate internally.
Any cryptographic operation attempted on a CR containing an partial CC results in an error or is trapped.
(((Cryptographic Register,incomplete)))

An `ace.init` operation can be interrupted at any 8-byte boundary and resumed from that point. An `ace.import` operation can also be interrupted at an 8-byte boundary, but it will only be resumed from the 48th byte or later; otherwise, it is restarted with no state saved.

NOTE: Resuming an operation may be more costly than restarting it without saved state. A third alternative—waiting to complete the operation—could introduce unacceptable delays.

When exporting a partial CR, a Partial CR Metadata (PCREM) header is used as the first 8 bytes of the SCC, preceding the nonce, SIV, and content sections as defined in <<ACE-format-SCC>>.

[[ACE-metadata-partial]]
.Format of the partial CR Metadata (PCREM)
[width="100%",cols="^9%,^7%,17%,67%",options="header"]
|===
.>|   Field .>| Width +
(bits) .>| Name                  .>| Description
|   [0:0] |   1  | Format                 | Value is 0 for the current metadata format. +
Future format will have a 1 in this position and may be longer than 64 bits.
|   [1:1] |   1  | Incomplete             | Value is 1.
|   [2:2] |   1  | Variant                | The value is 0 if the configuration was interrupted at initialization, and
                                            the value is 1 if the configuration was interrupted while importing.
|   [7:3] |   5  | Reserved               | Reserved for future use.
|  [31:8] |  24  | Payload_Length         | Length of the payload in bytes (excluding the first 32 bytes)
| [63:32] |  16  | Reserved               | Zero for now.
|===

NOTE: Fields such as Algorithm, SC_Protection, State Number, Direction_Policy, UC_Policy_{empty}__i__ (i = 0..3), and Locality are omitted. Since partial CRs are architecturally forbidden for normal use, the space normaly used by these fields is available for other purposes. Locality violations are handled when a complete CR is used; therefore, the RCSK is always used for partial CRs. This approach can reduce the need to compute or cache DCSKs at higher privilege levels, improving performance.


The exported content format for an incomplete initialization or import matches that of a complete CR, except that it is truncated to the actual imported length (rounded up to an 8-byte multiple). This length is recorded in the Payload_Length field.

For an incompletely imported CR, the partial hash (`tmp` from <<ACE-SCC-import>>) is prepended to the content, extending it by 16 bytes.
These 16 bytes are included in the Payload_Length and are considered as part of the content, hence they are encrypted.

After a partial CR is decrypted and authenticated in privileged mode, it is marked for resumption.
Upon returning from the context-switch handler:

. The original metadata, nonce, and SIV are recovered from less-privileged memory;

(These reads may be interrupted by page faults and resumed once the target page is mapped.)

The following steps are then executed as an atomic block:

[start=2]
. Compute `z` and `num_blocks` from the original content length, using the starting value of `i` from `acestart`.
. If the interrupted operation was an import:
.. Derive the `enc_key` and `auth_key` keys.
.. Recompute the partial hash from the current CR content.

The initialization or import operation can then resume from the point of interruption.

//

[WARNING]
The TG consensus is that `init`/`import` may resume after a page fault, but on a full context switch, partial CRs are not exported. Instead, the CRs are cleared and the instruction is restarted.

Our security analysis examined various scenarios, including one where a context switch interrupts an import, forcing export and later resumption of a partially imported context. We concluded that while privileged code can replace an SCC in a saved process's context or memory, it cannot abuse the resumption mechanism to breach SCC confidentiality or integrity.

--

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-architecture]]
== Architecture

ACE is a complex architecture and relies on certain fundamental concepts, which we succinctly introduce here.
While this leads to some repetitions, we believe that it also brings better clarity to the presentation.

[[ACE-concepts]]
=== Fundamental Concepts

Cryptographic Context:::
(((Cryptographic Context)))
The _Cryptographic Context_ (CC) is the fundamental concept in ACE.
A CC an indivisible data structure comprising a *metadata* section and a *content* section, and all cryptographic operations performed by ACE execute within the constraints defined by a CC.
The metadata section's format is fixed, and it specifies the cryptographic algorithm associated to the CC and optional usage control policies.
(((Cryptographic Context, metadata)))
The content's format is algorithm-specific, and it holds sensitive material such as keys and internal algorithm state.
(((Cryptographic Context, content)))
Metadata requires integrity;
part of the metadata and the content require both confidentiality and integrity.
These requirements are architecturally guaranteed by ACE.

Cryptographic Register:::
(((Cryptographic Register)))
Cryptographic Contexts are realized using _Cryptographic Registers_ (CRs).
CRs are architectural containers that safeguard CCs.
A CR is _initialized_ by writing metadata and content into it: this operation also binds the metadata and the content to form a CC.
A CC can be used for cryptographic operations only while resident in a CR.
Only the ACE unit may access or modify CC contents, in accordance with the architecture and the programmed algorithm.
CR content cannot be extracted in a manner that compromises its confidentiality.

Sealed Cryptographic Context:::
(((Cryptographic Context, sealed)))
To support context switching while protecting CCs outside architectural state, a CC may be exported from a CR as a _Sealed Cryptographic Context_ (SCC).
An SCC is an encrypted and authenticated representation of a CC that can later be re-imported into a CR.
SCC import and export use _Context Sealing Keys_ (CSKs), which may be programmable by M-mode and may depend on _Localities_ (see below).
A CC sealed with a given CSK cannot be re-imported using a different CSK, enabling cryptographic domain separation across spatial and temporal
domains.

Object-Orientation:::
CCs act as _objects_ exposing a uniform interface across algorithms.
A CC encapsulates algorithm-specific behavior, enabling interchangeable use of different primitives (e.g., AES-128, AES-256, Калина-128, Калина-256, Кузнечик, SM4, and so on) in identical modes (e.g., ECB, GCM-SIV, XEX/XTS) without requiring changes to compiled code.
SCA-resistant variants are supported transparently.

Usage Control Policy:::
(((Cryptographic Context, Usage Control)))
ACE distinguishes between CC/CR *management* (e.g., initialization, import, export, and cloning) and CC/CR *usage* (cryptographic operations, including including key derivation, and state change). To prevent denial of service scenarios, management operations must _always_ be permitted, unless the CR is an invalid state.
Accordingly, the optional _Usage Control_ policies restrict only cryptographic operations and state modifications, not CR or SCC management.
For this reason, the term Usage Control is used instead of Access Control.

Locality:::
(((Cryptographic Context, Locality)))
Finally, ACE can bind CCs to a _Locality_, i.e., restrict usage to specific devices, device classes, software or hardware configurations, or boot cycles.
This binding uses metadata when a CC is in a CR, and a _Derived Context Sealing Key_ (DCSK) derived from the _Root Context Sealing Key_ (RCSK) and a Locality-specific secret as the CSK for import and export.
// The system maintains a _Locality Secrets Table_ (LST) with fixed, hardware-configured, and MM-programmable values.
// Metadata stores the Locality as an index into this table (<<ACE-Localities>>).

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-extensions-overview]]
=== Extensions Overview

[WARNING]
This list is an early draft.

==== Unprivileged

* `Zlio` => Support for `ace.input`/`ace.output` operations.
* `Zleaes128p` => Support for AES-128 encryption and decryption (all applicable modes)-the `p` at the end denotes a primitive.
* `Zleaes192p` => Support for AES-192 encryption and decryption (all applicable modes).
* `Zleaes256p` => Support for AES-256 encryption and decryption (all applicable modes).
* `Zlsm4p` => Support for SM-4 encryption and decryption (all applicable modes).
* `Zlctrm` => Support for counter mode-the `m` at the end denotes a mode.
* `Zlxctrm` => Support for XCTR mode.
* `Zlgcmm` => Support for GCM mode.
* `Zlgcmsivm` => Support for GCM-SIV mode.
* `Zlxexm` => Support for XEX and XTS modes.
* `Zlocbm` => Support for OCB mode.
* `Zlcmacm` => Support for CMAC.
* `Zlesha2h` => Support for SHA-2 (all applicable modes)-the `h` at the end denotes a hash function.
* `Zlesha3h` => Support for SHA-3 (all applicable modes).
* `Zlsm3h` => Support for SM-3 hash function (all applicable modes).
* `Zlhmacm` => Support for HMAC.
* `Zlascon` => Support for the ASCON suite.
* `Zlkned` => NIST Suite: AES Block Cipher. Depends on `Zleaes128` and `Zleaes256`.
* `Zlkn` => NIST Algorithm Suite. Depends on `Zlkned` and `Zlesha2`.
* `Zlacev` => Must support for the following CSRs: `aceerror` and `acestart` (this is a dependency for Zicsr); must support the following instructions: `ace.init`, all four forms of `ace.exec`, `ace.clear`, `ace.export`, `ace.import`, and `ace.size`; must support `Zleaes128` and `Zleaes256` in ECB and GCM-SIV modes.
* `Zlaceio` => Must support for the following CSRs: `aceerror`, `acestart` (this is a dependency for Zicsr), `aceiobuflen` and `aceiobuftop`; must support the following instructions: `ace.init`, Form D of `ace.exec`, `ace.input` and `ace.output`, `ace.clear`, `ace.export`, `ace.import`, and `ace.size`; must support `Zleaes128` and `Zleaes256` in ECB and GCM-SIV modes.
* At least one of (a suitable subset of) V or `Zlio` must be implemented. (Note that, currently, we are not considering a version of ACE that uses the GPRs in place of the vectors registers.)

==== Privileged

* If `Zlacev` or `Zlaceio` are implemented: `misa` must implement the `L` bit, `*status` must implement `ACES`.
* `SmaceCSK` => Defines the Root Context Sealing Key CSRs (`macercsk{0..7}`), which are all MRO.
* `SmaceCSKw` => ACE Root Context Sealing Key CSRs are MRW. Depends on `SmaceCSK`.
* `Smaceosscrt` => Defines the ACE OS Secret CSRs (`maceOSSecret{0..3}`).
* `Smacebootscrt` => Defines the ACE Boot Secret CSRs (`maceBootSecret0{0..3}`).
* `Smacestatus` => Defines the ACES per CC CSRs (`macecrstatus`).

// ///////////////////////////////////////////////////////////////////////////////////////////

=== Programmer-Visible Architectural State

The recommended way to implement ACE is to implement the V extension, or at least a certain subset of it, as defined in <<ACE-V-dependency>>, which we call RVV-mini.
It is possible to implement ACE without V or RVV-mini, by exclusively using the instructions `ace.input` and `ace.output` to provide input data and a buffer for output to and from the instructions that may use vectors, as described in <<ACE-usage-input-output>>.

[comment]
--
[[ACE-instructions-overview]]
==== Instructions Overview

ACE provides a number of unprivileged instructions, some implemented as CSR read/write operations.
The notation `K[Xd]`, for a GPR `Xd`, refers to the CR whose number is contained in `Xd`,
and `Kn|K[Xn]` means that there are two different encodings for when the CR number is passed as an immediate (`Kn`) or in `Xn`.

.The ACE instructions
[width="100%",cols="17%,27%,56%",options="header",subs="+macros"]
|===
| Instruction         | Operands                          |  Description
| `ace.init`          | `Kd\|K[Xd], %offset(Xs)`          |  Sets a CR's metadata and content.
| `ace.clear`         | `Kd\|K[Xd]`                       |  Clears a CR and marks it as no longer in use and clean.
| `ace.reset`         |                                   |  Resets ACE.
| `ace.export`        | `%offset(Xn) ,Ks\|K[Xs]`          |  Securely exports the content of a CR to memory.
| `ace.import{.S}`    | `Kd\|K[Xd], %offset(Xn)`          |  Authenticates and imports an SCC from memory. +
 `ace.import.S` provides optional support for system-defined formats.
| `ace.exec`
| A. {nbsp}{nbsp} `Vd, Kn\|K[Xn], Vs` +
  B. {nbsp}{nbsp} `{nbsp}{nbsp}{nbsp}{nbsp}Kn\|K[Xn], Vs` +
  C. {nbsp}{nbsp} `Vd, Kn\|K[Xn]` +
  D. {nbsp}{nbsp} `{nbsp}{nbsp}{nbsp}{nbsp}Kn\|K[Xn]`
| Performs a cryptographic operation. These instructions may modify CC state. This instruction admits four _Forms_, depending on whether it accepts an input or not, and whether it produces an output or not.
| `ace.size`
| `Xd, Ks\|K[Xs]` +
`Xd, Xs` .2+|  Returns the SCC size in bytes for CR `Ks`/`K[Xs]` or for an algorithm with metadata `Xs`.
Returns zero if the algorithm is unsupported.
`ace.available` is an alias for `ace.size`.
| `ace.available`     | `Xd, Xs`
| `ace.size{nbsp}{nbsp}\` +
`{nbsp}{nbsp}{nbsp}{nbsp}.internal`
| `Xd, Xs` |  Returns the internal capacity occupation for an algorithm with metadata `Xs`.
Returns zero if the algorithm is unsupported.
| `ace.clone`         | `Kd\|K[Xd], Ks\|K[Xs]`            |  Clones a source CR to a destination CR.
| `ace.derive`        | `Kd\|K[Xd], Ks\|K[Xs]` +
`Kd\|K[Xd], Ks\|K[Xs], Vs2` +
|  Optional. Configures destination CR using source CR (e.g., the source CR could hold a KEM, and derive symmetric keys).
| `ace.state`
| `Kd\|K[Xd], #immed` +
`Kd\|K[Xd], #immed, Xs` +
`Kd\|K[Xd], #immed, Vs`  |  Modifies algorithm state (e.g., phase transitions).
| `ace.restrict`      | `Kd\|K[Xd], Xs`                   |  Narrows Usage Policies and enables/increases side-channel protection.
   Weakening Usage Policies and SCA protection is not permitted.
| `ace.input`         | `Kd\|K[Xd], %offset(Xs)`          |  Optional. Provides input to the algorithm.
| `ace.output`        | `%offset(Xd), Ks\|K[Xs]`          |  Optional. Writes output from the algorithm.
| `ace.error`         | `Xd`                              |  Writes the ACE unit error code to GPR `Xd`.
|===
--
// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-cryptographic-registers]]
==== Cryptographic Registers

{empty}
(((Cryptographic Context)))
ACE defines 32 Cryptographic Registers (CRs), identified by numbers from 0 to 31, and called `K0`, ... , `K31`.
They are architectural, i.e., per-hart.
(((Cryptographic Register File)))
CRs reside in a dedicated _CR file_ (CRF), accessible only by the ACE implementation. Each hart has its own CRF.

CRs differ from conventional register in several ways:

* One can load clear data into a CR via using the `ace.init` instruction (<<ACE-instruction-init>>), but
there is no corresponding store instruction to extract a CR's entire content as it was initially loaded in it as clear text.

* A CR can be *exported* in an authenticated, encrypted format using the `ace.export` instruction (<<ACE-instruction-export>>), thereby creating a Sealed Cryptographic Context (SCC).
A SCC can be later re-*imported* into a CR using the `ace.import` instruction (<<ACE-instruction-import>>)
but the process, requiring authentication, may fail if the data in memory was altered.
Conventional registers do not provide such functionality-and do not need to.

* The external and internal representations of a CR may have different sizes.
* Whereas conventional registers always contain a value, CRs can be _unconfigured_, meaning they may hold no information.
* The amount of the capacity of the CRF used by a CR depends on the configured algorithm.
  Two CRs can use different amounts of capacity.
  Insufficient residual CRF capacity may prevent the execution of a CR *configuration* instruction, i.e. `ace.init`, `ace.import`,
   `ace.clone`, (<<ACE-instruction-clone>>) or `ace.derive` (<<ACE-instruction-derive>>).
  In this case, software must free capacity by unconfiguring other CRs.

* ACE instructions can refer to CRs directly, i.e., with a 5-bit immediate in the instruction encoding, but also indirectly, i.e., through a value in a GPR.
//* Only a few instructions can use and possibly change the contents of the CRs.
//  The most important ones are:
//  ** `ace.exec`, used to perform cryptographic operations on data blocks according to the algorithm configured in a CR; and
//  ** `ace.state`, used to move between the different stages of modes of operations and hash functions, possibly performing certain state-state initialization operations.

Accessing a CR that is outside the range [0..31] raises a invalid instruction error.

[NOTE]
====
The management operations include the *configuration* instructions (`ace.init`, `ace.import`, `ace.clone`, and `ace.derive`) and the export operation (`ace.export`).
====

[NOTE]
====
CRF capacity is implementation-defined.
Implementations must provide sufficient capacity to allow execution of all operations they support.
The CRF must hold at least an instance of the largest possible CR or the largest CR pair for CR cloning or derivation.
An optional, possibly approximated, and implementation-specific mechanism to estimate the required capacity is defined in <<ACE-instruction-size>>.
====

[NOTE]
====
The fact that CRs can be addressed indirectly two major implications:

. Adding renaming to CRs would add significant complexity to the microarchitecture.
  However, CRs are much less often redefined than integer or floating-point registers, except for internal implied changes, hence CRs can be renamed without performance issues.
. An additional bit in the instruction encoding determines whether a CR number is given by a 5-bit immediate or by the value in a GPR.
====

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-metadata]]
==== Metadata Format

For software portability and interoperability, ACE defines two external formats for CCs:
an _Initialization Input_ (II) format, which is loaded into a CR to create a CC,
and an encrypted, authenticated format used when exporting a CR to memory for later re-import:
the Sealed Cryptographic Context (SCC) (<<ACE-format-SCC>>).
Both formats rely on the same metadata section format, which is described here.
The formats of the II and of the SCC are described in <<ACE-init-export-import>> and <<ACE-format-SCC>>, respectively.

{empty}
(((Cryptographic Context,metadata,format)))
The metadata section is 64 bits long and its format is described in <<ACE-metadata-standard>>.
The metadata section is used as the header of the data formats used in CR initialization, and SCC export and import functions.

[[ACE-metadata-standard]]
.Format of the Metadata Section
[width="100%",cols="^9%,^7%,16%,68%",options="header"]
|===
.>|   Field .>| Width +
(bits) .>| Name                  .>| Description
|   [0:0] |   1  | Format                   | Value is 0 for the current metadata format. +
The value 1 is reserved for future formats with a length of 128 bits.
|  [10:1] |  10  | _Algorithm_              | Cryptographic algorithm (such as primitive, mode, or protocol).
| [11:11] |   1  |  Reserved                | Expansion for Algorithm or SC_Protection.
| [13:12] |   2  | _SC_Protection_          | Level of Side Channel Protection, encoded as per <<ACE-SC-protection-levels>>.
| [15:14] |   2  | _Direction_Policy_       | Determines whether the CC may be used for encryption (bit 14 set), decryption (bit 15 set), or both (bits 14 and 15 set). Valid only for encryption/decryption primitives or modes, and ignored, for instance, for hash functions.
| [17:16] |   2  | _Key_Type_               | Key given by explicit value / System Key (index) / Internally generated.
| [21:18] |   4  | _State_Number_           | Encoding the current state of the state machine of the algorithm as a number.
| [23:22] |   2  | _Reserved_               | Zero.
| [27:24] |   4  | _Locality_               | A field which is either all ones (15) or an index into the Locality Secrets Table.
| [31:28] |   4  | _UC_Policy_              | “UC Policy” means “Usage Control Policy”. If bit 28, 29, 30, resp. 31 is set, it disallows the _usage_ of this CC in User, (V)S-mode, H-mode, resp. M-mode.
| [34:32] |   3  | _Filter_Mode_            | Mode at which to apply the filter: 0 = none; 1 = U; 2 = (V)S; 3 = H; +
4 = expiration date ([.red]#minutes since January 1^st^, 2027?#).
| [59:35] |  25  | _Filter_                 | Value to match against the `*acefilter` CSRs (see <<ACE-CSR-filters>> for details) or to compare to an internal secure clock.
| [63:60] |   4  |  Reserved                | Zero.
|===

Some fields and their properties need further explanation. This is done in the following sections.

===== Confidentiality

Bits [31:0] are not confidential and will not be encrypted upon export as SCC. +
Bits [63:32] are confidential and will be encrypted upon export as SCC.

===== Algorithm Field

Algorithms are encoded in a 10-bit field.
Algorithm numbers 0-767 are architecture-defined and the list of such encodings is maintained by RVI.
cf.{nbsp}<<ACE-algorithms>> for the currently encoded algorithms.
The remaining values can be used to encode custom algorithms.

===== SC_Protection Field

Certain minimal Side-Channel protection levels are defined by the architecture.
[[ACE-SC-protection-levels]]
.Encoding of Side-Channel Protection levels
[%autowidth,float="center",align="center",options="header"]
|===
| Value | Description
|   0   | No protection.
|   1   | DIEL, (first-order) threshold implementation.
|   2   | DIEL, (first-order) threshold, fault-tolerant implementation.
|   3   | Custom, algorithm dependent.
|===

Custom algorithms may offer stronger side channel protection guarantees than those specified in the encoding values 0 to 2.
In such a case, the value of the SC_Protection field must be set to 3.

===== Key_Type Field

ACE supports keys provided by software, as well as system keys and keys computed with a system “recipe”.
These key types are encoded as follows:
[[ACE-key-type]]
.Encoding of Key_Type
[%autowidth,float="center",align="center",options="header"]
|===
| Value | Description
|   0   | Explicit value.
|   1   | System Key.
|   2   | Internally generated key.
|   3   | Invalid.
|===

*System Keys* are given by an index into an internal, system specific System Keys Table (SKT). For each algorithm as specified in <<ACE-algorithms>>, the part of the content that normally contains the key(s) is replaced by its index into the SKT-for both II and the SCCs. The actual value of the key is never included in exported content. For threshold implementations, ACE may copy the key material from the SKT into the CR and expand it into multiple shares.

*Internally generated keys* are also system-specific. In place of the II, the initialization operation reads a system-specific “recipe”, which is not portable. After internal key generation, the actual key value—not the recipe—is stored in the CR and SCC. The Key_Type field in the metadata remains 2.

//

===== State_Number Field

The State_Number field must be zero in the II.
Three values are architected for all algorithms: 0, 14, and 15, representing the _initial_, _invalid_, and _completed_ states, respectively.
These denote a CC that is ready to operate, is in an invalid state, or has finished its operations.

During import and init, internally the State_Number field is set to _invalid_, and only at the end of the operation is it set to _initial_.
This means, by the rules in <<ACE-invalidation>>, that a partially initialized/imported CR cannot be exported.
This state change does not apply to `ace.export`, but operations that could modify the internal state should not be performed on a CR with an interrupted export operation.
//(Privileged code should not use CCs from child processes anyway.)

[WARNING]
--
The following situation may occur:

. A process is exporting a threshold CC from a CR.
. The process is interrupted for context switching.
. The privileged code then saves the context, by exporting. The key in saved in the SCC as a single share.
. Later, the privileged code re-imports the SCC into a CR.
. This means that the key has been re-imported with a different randomization.
. When the export operation resumes, it will continue to export the key as a single share, i.e., with the same value.

This works because the actual value of the key is not changed.
However, if any value of the state (such as a counter, or a partial hash value) is altered between the interruption and resumption of an export operation, the resumed export may use an incorrect SIV for the remaining SCC data, causing a subsequent import to fail authentication. This is a general issue with CRs, since more privileged code can use them unless blocked by the UC_Policy. We do not consider this a security threat: it affects only SCC availability, not confidentiality or integrity,
and privileged code can always deny resources to user processes.
--

If an algorithm defines 16 or fewer states (including _initial_, _completed_, and _invalid_), the current state number is stored directly in this field. For algorithms with more than 16 states, an algorithm-specific representation is used in the CC content, and the State_Number field is restricted to the values 0, 1, 14, and 15, where 1 serves as a placeholder for any operational state other than the three architected ones.

The state values for algorithms defined in this specification are listed in <<ACE-state-constants>>.

All states different from _invalid_ are called valid states.

//

[[ACE-Localities]]
===== Locality Field

ACE keeps a table of 128-bit Locality Secrets (LS), the Locality Secrets Table (LST).
Some entries of the LST are fixed or configurable only using an implementation–specific authenticated hardware procedure: These are global and shared across all ACE units in the same system. Other entries may be programmed by privileged modes and are architectural, i.e., per hart.

If the Locality Field of a CC is all ones (15), then the RCSK is used.
Otherwise, this value is used as an index _i_ in the LST, and the actual CSK is derived from the RCSK and LST[_i_].
<<ACE-locality-indexes>> lists the architected Localities and whether M-mode can configure them.
The domain of each Locality Secret is specified, i.e., whether the value is chip-wide
(i.e., the same across all chiplets in the same SoC),
device-wide, or OS-wide.

[[ACE-locality-indexes]]
.Architected Locality Values
[width="100%",cols="23%,45%,^9%,^15%,^8%",options="header"]
|===
| Name                      | Description                                                                               | Domain | Configurability | Index
| (No Locality binding)     | No CSK derivation. CC bound to Root CSK only.                                                             | --  | -- | 15
| ChipManufacturerSecret    | Identifies the manufacturer of the SoC. Permanent.                                                        | SoC | No | 0
| ChipModelSecret           | Identifies specific chip model/family. Permanent.                                                         | SoC | No | 1
| ChipUniqueSecret          | Unique for each SoC. Permanent.                                                                           | SoC | No | 2
| OEMSecret                 | Provisioned by OEM to differentiate their products from the competition.
                              Can be permanent, or optionally reconfigurable by an implementation-defined HW authenticated mechanisms.  | Device | No | 3
                              | ProductSecret             | Identifies device/system type/model (product). Not necessarily permanent. Reconfigurable like OEMSecret.  | Device | No | 4
| DeviceSecret              | Unique device (entire system) secret (_not_ the device ID such as a serial number). Shared across all harts in a SoC and shareable across multiple SoKs in a single device. Sharing mechanism implementation-defined, i.e., not architected. Reconfigurable like OEMSecret.                | Device | N | 5
| OSSecret                  | Identifies Operating System (or System Stack).
                              Not permanent, must be configured at (virtual) boot.                                                      | OS | M | 6
| BootSecret                | Regenerated at each (virtual) boot.                                                                       | OS | M | 7
| SSecret                   | Can be configured by Supervisor                                                                           | OS | S | 8
| Reserved                  | Reserved for future use (RZ if not defined).                                                              | Impdef | Impdef | 9-14
|===

The constant Localities_MAX is the maximum number of Localities supported by the system.

M-Mode and S-Mode reconfigure (virtualize) BootSecret, OSSecret, and SSecret, by writing to groups of CSR which are defined in <<ACE-CSR-maceOSSecret>>, <<ACE-CSR-maceBootSecret>>, and <<ACE-CSR-saceSecret>>.

NOTE: Example: If a key's metadata specifies a Locality field value of 2, the import/export key is derived from the RCSK and the OEM Secret. An SCC created on one device will fail authentication when imported on another device if their OEM Secrets differ.

NOTE: A CC may reference a key via an index into the System Key Table (SKT).
A device-specific SKT entry may correspond to a different key on another device.
Using the latter may lead to unspecified behavior.
Implementations of the SKT *must* provide a suitable Locality to the ACE unit during CR initialization, and set usage policies that are at least as strict as the key's own.

===== UC_Policy Field

Bits 28, 29, resp 30 are ignored if U-mode, S-mode, resp. H-mode is not supported/enabled.

===== Filter_Mode and Filter Fields

The function of these fields must be finalized.

Regarding filtering by process domain, we refer to <<ACE-CSR-filters>>.

Filtering by time is simple.
The ACE Unit must have access to a secure clock, and the current time must be compared with it.
When the current time is beyond the expiration time in the metadata, the ACE Unit invalidates the CC.

A combination of both policies would be possible with an extended metadata format.

[[ACE-format-definition]]
==== Initialization Input

The length of an II must be a multiple of 8 bytes.
The first 8 bytes contain the metadata section, as defined in <<ACE-metadata>>.
The subsequent bytes form the *content*—the key material and any algorithm-specific data—whose format and length are specified in <<ACE-algorithms>> for all architected algorithms. The II content's structure and size are entirely determined by the Algorithm and Key_Type fields within the metadata.

NOTE: The actual resource usage of a CR may be larger than the size of an II.
In the simple ECB schemes (<<ACE-ECB-mode>>) not hardened against SCA, a CR need not contain more than the metadata and the key, hence their resource usage matches the size of the II (unless the key is not a multiple of 64 bits).
However, several algorithms need to compute and cache additional data once initialized, and their internal state will be larger than the size of the II.

[[ACE-format-SCC]]
==== Sealed Cryptographic Context

The format of the SCCs is used when exporting a CC from a CR and is used also to re-import the CC into a CR.
It is dependent on the algorithm being used.
Its size must be a multiple of 8 bytes.

Format of SCC:::
(((Cryptographic Context, SCC plaintext)))
`bytes{nbsp}[{nbsp}{nbsp}0 .. 7{nbsp}{nbsp}{nbsp}{nbsp}]{nbsp}{nbsp}` Metadata, partially encrypted. +
`bytes{nbsp}[{nbsp}{nbsp}8 .. 23{nbsp}{nbsp}{nbsp}]{nbsp}{nbsp}` SIV produced by the encryption method (128 bits). +
`bytes{nbsp}[{nbsp}24 .. u+23{nbsp}]{nbsp}{nbsp}` Encrypted serialized content of the CR, with a byte length of `u`.

Both metadata and the serialization of the content are authenticated, but only part of the metadata and the content are encrypted.
The AEAD method used for this purpose is described in <<ACE-SCC-AEAD>>).

The metadata section of an SCC follows the same fixed architectural format as the metadata section of the II.
The content format—and consequently its length—is algorithm-specific (<<ACE-algorithms>>) and is determined solely by the Algorithm, Key_Type, and Direction_Policy fields in the metadata.

NOTE: The size of the SCC can differ significantly from the internal resource usage to store the CC's data in a CR—it can be larger but also smaller.
The most common case is when the SCC is larger, for instance for simple primitives, because of the SIV overhead.
On the other hand, in case of threshold implementations, where keys are exported in reconstructed form, and in modes where some derived keys that are easily reconstructed are not exported, the SCC may be smaller than the internal resource usage.

[[ACE-CSR]]
==== CSRs

ACE extends `*status` and `misa`, and adds up to 29 new CSRs, which are listed in <<ACE-CSRs-table>>.

[[ACE-CSRs-table]]
.New ACE CSRs
[cols="<16%,^11%,<24%,<49%"]
[float="center",align="center",options="header"]
|===
| Address        | Privilege | Name                     | Description
| 0xXXX          | URW       | `aceerror`               | Error code of the last ACE instruction
| 0xXXX          | URO       | `acecrstatus`            | Array of two-bit fields (similar to ACES field, but per CR)
| 0xXXX          | URW       | `acestart`               | ACE start byte index (see warning below)
| 0xXXX          | URW       | `aceiobuflen`            | ACE I/O buffer length
| 0xXXX          | URW       | `aceiobuftop`            | ACE I/O buffer limit for current transfers
| 0xXXX          | URO       | `acesequence`            | Sequence number of the last ACE instruction
| 0xXXX          | URW       | `aceactivecr`            | Active CR for `ace.input`/`ace.output`
| 0xXXX          | SRW       | `sacefilter`             | Filter that applies to U-mode
//| 0xXXX          | HRW       | `vacecrstatus`           | Array of two-bit fields (similar to ACES state, but per CR)
| 0xXXX          | MRW       | `macefilter`             | Filter that applies to (V)S/H-mode
| 0xXXX--0xXXX   | MRW (RZ)  | `macercsk{0..7}`         | ACE Root Context Sealing Key
| 0xXXX--0xXXX   | MRW (RZ)  | `maceOSSecret{0..3}`     | ACE OS Secret
| 0xXXX--0xXXX   | MRW (RZ)  | `maceBootSecret0{0..3}`  | ACE Boot Secret
| 0xXXX--0xXXX   | PRW (RZ)  | `saceSecret{0..3}`       | ACE Supervisor Secret
|===

[WARNING]
`acestart` may be overloaded with `vstart`, regardless of whether the V extension is available.
If a vector instruction is interrupted, the CSR would follow the `vstart` semantics (i.e., it would count the number of processed elements), whereas if an ACE instruction is interrupted, the CSR would follow the `acestart` semantics (i.e., it would count the number of bytes processed).

==== Extension to existing CSRs

[[ACE-ACE-field-in-misa]]
===== ACE field in `misa`

{empty}
(((CSR, ACE field in `misa`)))
Bit `L` (11) in `misa` indicates that ACE is present.

[[ACE-ACES-field-in-status]]
===== ACES field in `*status`

{empty}
(((CSR,ACES field in *status)))
The ACES field (bits [26:25]) is added to `mstatus` and shadowed in `sstatus` and `vsstatus` (if the hypervisor extension is present).
Similarly to the FS and VS fields, it is used to optimize context switching.
If ACE is implemented, ACES shall not be read-only zero.
Its possible values are given in <<ACE-aces-encoding>>.

[[ACE-aces-encoding]]
.Encoding of ACES status field
[float="center",align="center",width="100%",cols="^8%,<8%,<84%",options="header"]
|===
|Status |Name |Meaning
|   0   | Off                | ACE disabled. CRs are inaccessible. The hart will trap if the user requests to enable the feature.
|   1   | Initial            | ACE enabled. No CR is configured.
|   2   | Clean              | ACE enabled. The state matches the last context swap (Clean).
|   3   | Dirty              | ACE enabled. Some CRs may have been modified since last Clean.
|===

Writes to ACES do not affect CR contents.
Clearing state is not performed by setting ACES to Off, Initial, or Clean, and it must be explicitly done by privileged code before changing ACES.

The transitions between these states are the same as in Table “FS, VS, and XS state transitions” of cite:[RISCV-ISA-Priv]

[comment]
--
[[fsxsstates-copy]]
.ACES state transitions
[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
|Current State |Off |Initial |Clean |Dirty
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|At context save in privileged code

|Save state? +
Next state
|No +
Off
|No +
Initial
|No +
Clean
|Yes +
Clean
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|At context restore in privileged code

|Restore state? +
Next state
|No +
Off
|Yes, to initial +
Initial
|Yes, from memory +
Clean
|N/A +
N/A
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^| Execute instruction to read state

|Action? +
Next state
|Exception +
Off
|Execute +
Initial
|Execute +
Clean
|Execute +
Dirty
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|Execute instruction that possibly modifies state

|Action? +
Next state
|Exception +
Off
|Execute +
Dirty
|Execute +
Dirty
|Execute +
Dirty
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|Execute instruction to unconfigure unit

|Action? +
Next state
|Exception +
Off
|Execute +
Initial
|Execute +
Initial
|Execute +
Initial
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|Execute instruction to disable unit

|Action? +
Next state
|Execute +
Off
|Execute +
Off
|Execute +
Off
|Execute +
Off
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|Execute instruction to enable unit

|Action? +
Next state
|Execute +
Initial
|Execute +
Initial
|Execute +
Initial
|Execute +
Initial
|===
--

//

[[ACE-CSR-new-unprivileged]]
==== New Unprivileged CSRs

[[ACE-CSR-ace-error]]
===== `aceerror`

The 8-bit `aceerror` CSR records the error code from the most recent ACE instruction.
Reading it may stall the hart until the operation completes.
It is writable for context switching.

Error codes 0–127 are reserved for RVI, and codes 128–255 are reserved for custom algorithms.
The standard error codes are:

[[ACE-error-codes]]
.Error codes and their meanings
[float="center",align="center",width="100%",cols="^7%,<23%,<70%",options="header"]
|===
|Value | Mnemonic                | Examples (((ACE, error codes)))
|  0   | ace_err_ok              | No error.
|  1   | ace_err_authentication  | Authentication failure with `ace.import`.
//(`ace.import` or `ace.exec`).
|  2   | ace_err_privilege       | Violation of usage control policies.
//(`ace.exec`, `ace.state`, etc.).
|  3   | ace_err_invalid         | Invalid input/operation such as: Invalid metadata section in `ace.init` or `ace.import`;
Use of non-allowed instruction in the current algorithm state; or Attempt to use a partially configured CR.
|  4   | ace_err_unimplemented   | Algorithm or algorithm variant not implemented.
|  5   | ace_err_memory          | Insufficient CRF memory for configuration instruction.
|  6   | ace_err_unconfigured    | Software attempted to use an unconfigured CR. +
A lazy reload may be triggered instead.
//in `ace.exec`, `ace.state`, `ace.input`, `ace.output`, `ace.clone`, `ace.derive`, or `ace.restrict`.
|===

Examples of Invalid input/operation:{empty}:::
Invalid metadata passed to `ace.init` is invalid;
encryption, resp., decryption is requested from a CC not allowing it;
a Form of `ace.exec` that is not permitted in the current algorithm state is used;
the State_number in `ace.state` is not allowed;
invalid change in usage policies in `ace.restrict`;
software tried to use an incomplete CC in a CR as a source in an `ace.exec`, `ace.export`, `ace.state`, `ace.input`, `ace.output`, `ace.clone`, `ace.derive`, or `ace.restrict` operation.

[[norm:ace_exc_priority]]
.ACE error priority in decreasing priority order.
[float="center",align="center",width="100%",cols="^9%,>7%,<84%",options="header"]
|===
.>|Priority   .>|Error +
Code        .>|Description
.>|_Highest_  |6               |Unconfigured CR
|           .>|3             .>| Invalid metadata section in `ace.init` or `ace.import`
|           .>|4             .>| Algorithm or algorithm variant not implemented.
|           .>|5             .>| Insufficient CRF memory
|           .>|3             .>| Use of non-allowed instruction in the current algorithm state.
// Invalid input/output operation with `ace.exec`, `ace.state`, `ace.input`, `ace.output`, `ace.clone`, `ace.derive`, or `ace.restrict` (used incomplete CC as source)
|           .>|2, 1          .>|Access Control Failure or authentication failure with `ace.import`
|           .>|1             .>|Authentication failure in an algorithm.
|           .>|3             .>|Invalid input/output operation with `ace.exec`
                                (form not allowed in current algorithm),
                                `ace.state` (state change not allowed),
                                or `ace.restrict` (change of usage policy is not allowed)
.>|_Lowest_ .>|0             .>|No error
|===

If executing an `ace.init`, `ace.import`, `ace.export`, `ace.input`, or `ace.output` triggers a
trap, as specified in the privileged architecture, `aceerror` remains unchanged.

//

===== `acecrstatus`

The CSR `acecrstatus` tracks the configuration and dirtiness of CRs on a per-CR basis, so that privileged context switching code needs to save only the dirty CRs, and, upon restore, restore only the configured ones and explicitly clear the unconfigured ones, unless the latter are lazy-loaded:

. For RV64, `acecrstatus` has a size of 64 bits,
``acecrstatus[``2__i__+1,2__i__``]`` can take the values Off, Init, Clean, Dirty as defined for `*status.ACES` for CR #__i__.
. For RV32, there are two 32-bit registers `acecrstatush` and `acecrstatusl` (collectively referred to as `acecrstatus` in the following)
where
``acecrstatus[``2__i__+1,2__i__``]`` can take the values Off, Init, Clean, Dirty as defined for `*status.ACES` for CR #__i__
and
``acecrstatus[``2__i__+1,2__i__``]`` for CR #__i__+16.

This section defines the semantics of the `acecrstatus` bit-fields.
Here, “Configuration” refers to the management operations that can configure a CR, namely `ace.init`, `ace.import` and being the destination of an `ace.derive` operation.

* *INITIAL* (value: 1).
+
--
*Definition*: Unconfigured.

 ** *ace.clear*: status remains *INITIAL*.
 ** *Configuration*: Does not trap. Transitions to *DIRTY*.
 ** *ace.export*: Raises _ace_err_unconfigured_. No trap is generated.
 ** *Usage*: Raises _ace_err_unconfigured_. No trap is generated.
--
+

* *CLEAN* (value: 2).
+
--
*Definition*: The CR is configured. Its state has not changed since the last switch.

 ** *ace.clear*: sets status to *INITIAL*.
 ** *Configuration*: Works as expected; sets status to *DIRTY*.
 ** *ace.export*: Works as expected.
 ** *Usage*: Unrestricted; State modification sets status to *DIRTY*.
--
+

* *DIRTY* (value: 3).
+
--
*Definition*: The CR configured. Its state has potentially changed since the last switch.

 ** *ace.clear*: sets status to *INITIAL*.
 ** *Configuration*: Works as expected; status remains *DIRTY*.
 ** *ace.export*: Unrestricted.
 ** *Usage*: Unrestricted.
--
+

* *LAZY* (value: 0).
+
--
*Definition*: Unconfigured. A value is saved for lazy loading.

 ** *ace.clear*: sets status to *INITIAL*.
 ** *Configuration*: Works as expected; sets status to *DIRTY*.
 ** *ace.export*: Trigger a trap to the immediately higher mode for lazy loading. If that mode does not have a saved value, it will trap to its parent to request the value, and will also keep it.  This may have to be repeated a third time if H is implemented. +
 The CR is configured with the recovered value and execution resumes from state *CLEAN*.
 ** *Usage*: Trigger a trap to the operating system for lazy loading. +
 Execution resumes from state *CLEAN*.
--
+

//

NOTE: The *LAZY* status reuses the FS/VS/ACES encoding for “OFF”, this does not indicate that the ISE is inactive, nor that the ISE cannot use that CR.
Whether the ISE is active is encoded exclusively in ```*status```. The use of the **OFF** encoding in the per-CR fields of `acecrstatus` is a natural choice to denote an unavailable state that requires lazy loading to be made available.
If all CRs were either unconfigured or to be lazy-loaded, the ACES field would be set to **CLEAN** and not to **OFF**.

//

[[ACE-CSR-acestart]]
===== `acestart`

`acestart` is an XLEN-bit RW CSR, to track progress of long-running interruptible instructions such as `ace.init`, `ace.import`, `ace.export`, `ace.input`, and `ace.output`, as well as `ace.exec` on long inputs.
(((CSR, acestart)))

Unlike the vector extension’s `vstart`, which tracks element indices, ACE has no _intrinsic_ notion equivalent to that of vector elements.
Only the algorithms may have basic processing units which could correspond to vector elements.
However, in an attached architecture depending on these may slow down the implementation.
`acestart` therefore records a “raw” byte offset.

This register is typically written by hardware.
Software may safely write 0 to fully restart an operation, and the register can be saved and restored during context switches.
However, software must not write arbitrary nonzero values to it, as this may result in an illegal-instruction exception, as the hardware or a trapped implementation are not required to support all possible values.
Only the instructions explicitly mentioned above support non-zero `acestart` values; other ACE instructions ignore this register, and will be restarted.

Initialization, import, and export operations may be interrupted and resumed if no context switch occurs,
as indicated by the value in the `acestart` CSR.  If a context switch occurs, they must be restarted.

[NOTE]
====
_A single `acestart` value suffices due to the way the init/import/export instructions operate:_

* `_ace.init_` _and_ `_ace.import_` _use a single pass: all blocks are processed sequentially._
* `_ace.export_` _uses two passes. However, the first pass to compute the SIV is purely internal, and never accesses memory, so page faults cannot occur.
This first pass is uninterruptible.
The second pass writes metadata, the SIV, and then the content to memory.
Only the second pass can cause page faults and may require resumption._

This design obviates the need to separate data transfer from cryptographic processing during import and export operations. A separate transfer phase would require buffering the entire input within the ACE unit before processing, increasing internal resource requirements, whereas the current architecture can process data inline and is loaded with minimal overhead.
====

A different situation arises when an `ace.exec` instruction operates on long vectors containing multiple elements, in which case `VL*SEW` is a multiple of the basic processing unit usually denoted by `b` (such as a block size) in the algorithms. In this situation, `ace.exec` can work iteratively on each block of the input, and execution of `ace.exec` may be interrupted and resumed.
Regardless of whether the operations are on vectors or on the input/output buffer, `acestart` reflects the number of bytes processed so far.

The semantics and use of `acestart` are described in <<ACE-init-export-import>>.

The two CSRs described next may be used to optimize saving and restoring the input/output buffer.

[[ACE-CSR-aceiobuflen]]
===== `aceiobuflen`

`aceiobuflen` is an XLEN-bit RW CSR.

`aceiobuflen` is used to program the size of the input/output buffer for `ace.input` and `ace.output`.

Reconfiguring `aceiobuflen` will invalidate the buffer contents.

If the size is zero, `ace.input` and `ace.output` will raise an invalid instruction exception.

[[ACE-CSR-aceiobuftop]]
===== `aceiobuftop`

`aceiobuftop` is an XLEN-bit RW CSR.

`aceiobuftop` is used to program the top end of a transfer operation to and from the input/output buffer for the `ace.input` and `ace.output` instructions.
`aceiobuftop` must be {le} `aceiobuflen`. Setting a larger value will raise an invalid instruction exception.
In conjunction with `acestart`, `aceiobuftop` defines the range of buffer used in the subsequent operations.

Reconfiguring `aceiobuftop` will not invalidate the buffer contents.

Writing to `aceiobuflen` will set `aceiobuftop` to the same value.

// If `aceiobuftop` is zero, `ace.input` and `ace.output` will raise an invalid instruction exception.
If `aceiobuflen-acestart` is zero or an invalid size for the operation that uses the buffer, `aceerror` is set to error code ace_err_invalid.


[[ACE-CSR-acesequence]]
===== `acesequence`

This is an XLEN-bit URO CSR (2 bits defined).

It takes the value zero if we are using vector registers for the current `ace.exec` or `ace.derive`.
It may take non-zero values only if using `ace.input`/`ace.output` in place of vector registers.

Its usage in conjunction with the `ace.input` and `ace.output` operations is detailed in <<ACE-usage-input-output>>.

[[ACE-CSR-aceactivecr]]
===== `aceactivecr`

This is an XLEN-bit URW CSR (5 bits defined).

It serves to tie `ace.input`, `ace.output`, `ace.exec`, `ace.state` and `ace.derive` instructions to the state of a specific CR.
It can take values 0 to 31, or 32 to disable the tie.

It can only be changed if `acesequence` is zero, else an invalid instruction exception is raised.

If the value is not 32, the CR in `ace.exec` and the source CR in `ace.derive` can only have this value, otherwise an invalid instruction exception is raised.
This serves to make sure that the instructions are issued in the correct order.

==== New Privileged CSRs

The new privileged CSRs introduced by ACE are defined here.

[comment]
--
===== `vacecrstatus`

The CSR `vacecrstatus` exists only if H-mode is implemented, and it is HRW.

It is similar to `acecrstatus`, however it works to track the status of the CRs at the VS-mode.

For RV64, `vacecrstatus` has a size of 64 bits,
`vacecrstatus[``2__i__+1,2__i__``]`` can take the values Off, Init, Clean, Dirty as defined for `*status.ACES` for CR #__i__.

For RV32, there are two 32-bit registers `vacecrstatush` and `vacecrstatusl` (collectively referred to as `vacecrstatus` in the following)
where
``vacecrstatus[``2__i__+1,2__i__``]`` can take the values Off, Init, Clean, Dirty as defined for `*status.ACES` for CR #__i__
and
``vacecrstatus[``2__i__+1,2__i__``]`` for CR #__i__+16.

The semantics of the bit-fields of `vacecrstatus` are the same as those of `acecrstatus`.
--

[comment]
--
Any change to `acecrstatus` is reflected in `vacecrstatus` as follows:

* If an operation in U-mode changes a field of `acecrstatus` to *DIRTY*, the corresponding field in `vacecrstatus` is set to *DIRTY*.
* If an operation in U-mode changes a field of `acecrstatus` to *CLEAN* from a different state, the corresponding field in `vacecrstatus` is set to *DIRTY*.
* If an operation in U-mode changes a field of `acecrstatus` to *INIT*, the corresponding field in `vacecrstatus` is set to *INIT*.
* If an operation in U-mode changes a field of `acecrstatus` to *LAZY*, the corresponding field in `vacecrstatus` is set to ?.
* An operation in VS-mode changes `vacecrstatus` in the same way as the corresponding operation in U-mode would change `acecrstatus`.
* If S-mode changes a field of `acecrstatus` to *CLEAN*, the corresponding field in `vacecrstatus` is set to *CLEAN*.
* If S-mode changes a field of `acecrstatus` to *DIRTY*, the corresponding field in `vacecrstatus` is set to *DIRTY*.
* If S-mode changes a field of `acecrstatus` to *INIT*, the corresponding field in `vacecrstatus` is set to *INIT*.
* If S-mode changes a field of `acecrstatus` to *LAZY*, the corresponding field in `vacecrstatus` is set to *CLEAN*.
--

//

[[ACE-CSR-macercsk]]
===== `macercsk` group

This is an optional group of M-Mode WARZ XLEN-bit CSRs used to configure `macercsk`.
(((CSR, `macercsk`)))

* In RV32 there are eight CSRs:  `macercsk0`, `macercsk1`, ... `macercsk7`.
* In RV64 there are four CSRs: `macercsk0`, `macercsk1`, `macercsk2`, `macercsk3`

A write to `macercsk{i}` set Bits [(_i_+1) XLEN - 1 : _i_ XLEN] of the RCSK.

Any access to the `macercsk` block outside of M-mode will cause an illegal instruction exception.

The values written to the `macercsk` block must follow the value update rules defined in <<ACE-CSR-group-update-policy>>.

NOTE: We assume that  M-mode firmware is aware of whether the RCSK is configurable, ephemeral, or fixed.
If not configurable, only a fixed RCSK is guaranteed to persist across power cycles.
For reconfigurable RCSKs, system-specific mechanisms for persistence and cross-device transfer (e.g., to support VM migration) are the responsibility of M-mode firmware.
RCSK migration to any other RCSK-receiving endpoint,
whether it is the M-mode firmware of another device, a TPM for local hibernation storage, or an HSM for intermediate storage in a cloud,
must employ an authenticated public-key key-wrapping mechanism.

NOTE: Alternative approaches to re-configuring the RCSK are possible.
For instance, M-mode could have access, through an implementation-defined mechanism, to a secure IP block like Caliptra cite:[caliptra], which can be used to configure the RCSK, and also to provide the mechanism for RCSK export.
An advantage of this method is that it also shields the values of the RCSKs from M-mode, which only would ask for reconfiguration using a token or a handle.
The disadvantage would, potentially, be reduced performance, depending on the actual implementation.

[[ACE-CSR-group-update-policy]]
===== Value update policy for CSR groups

The implementation must keep track of which CSRs in the group have been written to and which CSRs have not,
and only change the key when the entire group has been written to.

// NOTE: This can be done using a bitmap with one bit per CSR in the group.
// The bitmap is cleared upon entering M-mode.
// When the __i__-th CSR in the group is written to, the __i__-th bit of the bitmap is set.
// When the bitmap is all ones, the key is set and the bitmap is cleared.

//

[[ACE-CSR-maceOSSecret]]
===== `maceOSSecret` group

This is a group of M-Mode WARZ XLEN-bit CSRs. It is used to configure `maceOSSecret`.

* In RV32 there are four CSRs: `maceOSSecret0`, `maceOSSecret1`, `maceOSSecret2`, `maceOSSecret3`.
* In RV64 there are two CSRs: `maceOSSecret0`, `maceOSSecret1`.

A write to `maceOSSecret{i}` sets Bits [(_i_+1) XLEN - 1 : _i_ XLEN] of `OSSecret`.

Any access to the `macercsk` block outside of M-mode will cause an illegal instruction exception.

The values written to the `maceOSSecret` group must follow the update rules defined in <<ACE-CSR-group-update-policy>>.

//

[[ACE-CSR-maceBootSecret]]
===== `maceBootSecret` group

This is a group of M-Mode WARZ XLEN-bit CSRs. It is used to configure `maceBootSecret`.
(((CSR, `maceBootSecret*`)))

* In RV32 there are four CSRs: `maceBootSecret0`, `maceBootSecret1`, `maceBootSecret2`, `maceBootSecret3`.
* In RV64 there are two CSRs: `maceBootSecret0`, `maceBootSecret1`.

A write to `maceBootSecret{i}` sets Bits [(_i_+1) XLEN - 1 : _i_ XLEN] of `maceBootSecret`.

Any access to the `macercsk` block outside of M-mode will cause an illegal instruction exception.

The values written to the `maceBootSecret` group must follow the update rules defined in <<ACE-CSR-group-update-policy>>.

[NOTE]
====
`maceBootSecret*` must be reconfigurable in order to support VM reboots which are independent of the boot cycles if the physical host.
====

//

[[ACE-CSR-saceSecret]]
===== `saceSecret` group

This is a group of M-Mode WARZ XLEN-bit CSRs. It is used to configure `saceSecret`.
(((CSR, `saceSecret*`)))

* In RV32 there are four CSRs: `saceSecret0`, `saceSecret1`, `saceSecret2`, `saceSecret3`.
* In RV64 there are two CSRs: `saceSecret0`, `saceSecret1`.

A write to `saceSecret{i}` sets Bits [(_i_+1) XLEN - 1 : _i_ XLEN] of `saceSecret`.

Any access to the `saceSecret` block outside of S-mode or higher will cause an illegal instruction exception.

The values written to the `saceSecret` group must follow the update rules defined in <<ACE-CSR-group-update-policy>>.

//

[[ACE-CSR-filters]]
===== `sacefilter`, `macefilter`

`sacefilter` is an XLEN-bit SRW CSRs (actual length to be defined).

`macefilter` is an XLEN-bit MRW CSRs (actual length to be defined).

Their values are compared against the Filter field of the metadata, to determine whether an `ace.exec`, `ace.state`, or `ace.derive` instruction is allowed to execute:
`sacefilter` is used to filter CC usage in U-mode
and
`macefilter` is used to filter CC usage in (V)S/H-mode.

[WARNING]
These two registers are placeholders for a later decision on how to handle the CR filtering in different modes.
One option could be to use `scontext`/`hcontext`/`mcontext` from the Sdtrig extension.
We note that under Linux `scontext` is often filled with the PID of the used process, which is at most 22 bits.
Therefore, this would fit in the metadata's `Filter` field's current length of 25 bits, which is too small for the full 32 bits of `scontext`.
`hcontext`/`mcontext` is just 14-bits long.
`Filter` can also be expanded using the currently reserved fields.
We believe that the final decision should be taken in accordance with the ARC.

[comment]
--
[[ACE-CSR-reuse-ASID-VMID]]
==== Reuse of `(v)satp`.ASID and `hgatp`.VMID without S/H?

ACE reuses `(v)satp`.ASID and `hgatp`.VMID to optionally restrict the usage of CCs to a specific process or virtual machine.
In the metadata section, `ASID` and `VMID` are always zero padded to the maximal lengths of 16 and 14 bits, respectively.

[WARNING]
Currently, `satp` is only defined when the Supervisor is enabled.
similarly, `hgatp` is only defined if the Hypervisor extension is enabled.
We propose to define the `ASID` and `VMID` fields of these registers also when ACE is provided in order to allow M-mode to be able to separate a main OS from a TEE, for instance, on devices that implement TEEs using mechanisms based on Sv, PMP/Smepmp cite:[RISCV-ISA-Priv]. If only U- and M-mode are available, this would allow M-mode to separate the CCs of the various U-mode processes.

NOTE: Regarding Supervisor Domains (SDs) cite:[RISC-V-SD] and Worlds cite:[RISC-V-Worlds] we observe that there is no room in the current metadata format for adding filtering by `SDID` (`mmtp.SDID`) and WID.
This is not an issue since we recommend to use separation by RCSK in combination with SDs or Worlds, which does not prevent a program running in a SD or World to provide a CC to a program running in a different SD or World. This is done by by configuring a CR and then relinquishing control to M-mode to export the CR with the RCSK used by the target software.
The same holds for any intended separation by hart ID (`mhartid`), which is facilitated by the fact that the RCSK CSR group is per-hart.

NOTE: The software in each World/Supervisor Domain is normally responsible to generate or obtain their own keys, and if a process (applet) in one World/Supervisor Domain is responsible to provide keys to other Worlds/Supervisor Domains, it is the responsibility of the M-mode firmware to perform an appropriate `ace.import`/RCSK switch/`ace.export` sequence.
--

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-instructions-detailed]]
=== Instructions

[WARNING]
The encodings presented here are just examples, for the moment RV64-only, and may not be final.
We currently use
`custom-0` for load-type instructions,
`custom-1` for store-type instructions, and
`custom-2` for operational instructions
(with bits [1:0] always equal to 3-all instructions are 32 bits long),
to align with store/load/operational instructions in the base and floating-point instruction sets.
They serve as a starting point for discussion and refinement as well as a proof that, at the time of this writing, the ACE instruction set can be encoded.


ACE provides a number of unprivileged instructions, some implemented as CSR read/write operations.
This section specifies the semantics and encodings of these instructions.

The notation `K[Xd]`, for a GPR `Xd`, refers to the CR whose number is contained in `Xd`,
and `Kn|K[Xn]` means that there are two different encodings for when the CR number is passed as a 5-bit immediate (`Kn`) or via the value of `Xn`.
When a GPR is used to index a CR, use of the zero register `X0` is reserved and results in an illegal instruction exception.

For each instruction, we specify whether:

* It _possibly modifies state_;
* It is _usage-controlled_, i.e., if the instruction is subject to usage control, which determines which software entities can use it (by _UC_Policy_ and non-time-based _Filter_);
* It is _trappable_, i.e., can be implemented by privileged code as trap-and-emulate; and whether
* The execution of the instruction itself can be _interrupted_, for instance by context switches or page faults, to be resumed or restarted later.

NOTE: Trappability refers only on the CPU-side of the implementation and it is a distinct concept from _custom implementations of primitives within the ACE unit_.
Implementers may, for instance, incorporate a secure CPU with updatable firmware to support new primitives.
While the architecture does not prohibit this, such an approach substantially expands the attack surface of the ACE unit.

[[ACE-instruction-init]]
==== ace.init

`ace.init Kd|K[Xd], %offset(Xs)`
(((ACE, instruction, ace.init)))

Encoding::
`ace.init` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'context', attr: ['Kd','K[Xd]'] },
    { bits:  3, name: 'ace.init', attr: [0x4,0x5] },
    { bits:  5, name: 'Xs' },
    { bits: 12, name: 'immed12', attr: ['offset'] },
]}
....

Description::
`ace.init` initializes a CR with metadata and content to create a CC.
`Kd` or `K[Xd]` denotes the CR to be initialized.
`Xs` points to the region of memory containing the metadata and the key material.
The II must be stored at a 8-byte aligned address, and its length must be a multiple of 8 bytes.
+
Similarly to entire-vector-register store instructions, `ace.init` appears to other harts as a sequence of individual reads.

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *NO*. +
Trappable: *YES*. +
Interruptible: *YES*.

NOTE: `ace.init`, as well as `ace.import`, `ace.export`, `ace.input`, and `ace.output` as described later, perform direct memory accesses.
This does not violate the RISC-V load/store architecture principles,
since `ace.init`, `ace.import` and `ace.input` can be seen as special kinds of load instructions and
`ace.export` and `ace.output` as special store instructions.
// as ACE is architected to behave like an _attached_ unit, which may have its own interfaces.

NOTE: The operation follows the two-phases processing model defined in <<ACE-init-export-import>>.
In the first phase, the metadata block is read, which determines the length of the remaining information.
Then, in the second phase, the configuration material is read and processed.

//

[[ACE-instruction-clear]]
==== ace.clear/ace.reset

`ace.clear Kd|K[Xd]` +
(((ACE, instruction, ace.clear)))
`ace.reset`
(((ACE, instruction, ace.reset)))

Encoding::
`ace.clear/ace.reset` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'context', attr: ['Ks','K[Xd]'] },
    { bits:  3, name: 'ace.clear', attr: [0x4,0x5] },
    { bits:  5, name: 0x0 },
    { bits:  5, name: 0x0 },
    { bits:  7, name: 0x0 },
]}
....

Description::
For `ace.clear`, `Kd` or `K[Xd]` denotes the CR to be cleared. +
`ace.reset` uses the encoding for `ace.clear` and `Xd` = `X0` (the `context` field is `0`) or `Xd` != `X0` containing a value larger than 31.

Properties::
`ace.clear` possibly modifies state. +
`ace.reset` unconfigures the unit. +
Usage-controlled: *NO*. +
Trappable: +
{nbsp}{nbsp}``ace.clear``: *NO*; +
{nbsp}{nbsp}``ace.reset``: *YES* (it can be implemented as a series of `ace.clear` instructions). +
Interruptible: *NO*.

//

[[ACE-instruction-export]]
==== ace.export

`ace.export %offset(Xd), Ks|K[Xs]`
(((ACE, instruction, ace.export)))

Encoding::
`ace.export` is an S-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'immed[4:0]' },
    { bits:  3, name: 'ace.export', attr: [0x0,0x1] },
    { bits:  5, name: 'Xd' },
    { bits:  5, name: 'context', attr: ['Ks','K[Xs]'] },
    { bits:  7, name: 'immed[11:5]' },
]}
....

Description::
Exports the CR `Ks` or `K[Xs]` to memory at address `Xd`, using the procedure described in <<ACE-format-SCC>>.
The SCC must be stored at a 8-byte aligned address, and its length must be a multiple of 8 bytes.
If the context is unconfigured, or `Xs` is out of range, the operation will report error ace_err_invalid.
+
The instruction must follow the interruptibility rules defined in <<ACE-CSR-acestart>> and <<ACE-init-export-import>>.
Similarly to entire-vector-register store instructions, `ace.export` appears to other harts as a sequence of individual stores.

Properties::
Possibly modifies state: *NO*. +
Usage-controlled: *NO*. +
Trappable: *YES*. +
Interruptible: *YES*.

//

[[ACE-instruction-import]]
==== ace.import

`ace.import{nbsp}{nbsp}{nbsp}Kd|K[Xd], %offset(Xn)` +
`ace.import.S{nbsp}Kd|K[Xd], %offset(Xn)`
(((ACE, instruction, ace.import)))
(((ACE, instruction, ace.import.S)))

Encoding::
`ace.import` is an I- (or R)-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'context', attr: ['Kd','K[Xd]'] },
    { bits:  3, name: 'ace.import', attr: ['0    0    S','0    1    S'] },
    { bits:  5, name: 'Xn' },
    { bits: 12, name: 'immed12' },
]}
....

Description::
`Kd` or `K[Xd]` denotes the CR into which the SCC is to be imported. +
`Xn` is the GPR containing the base address of the buffer with the source SCC.
The SCC base address must be 8-byte aligned. +
The bit S takes the values 0 (false) or 1 (true).
It is set to true if the key is in a system defined format
(`ace.import.S`)
and not the format defined by the present architecture
(`ace.import`).
+
`ace.import` must follow the interruptibility rules defined in <<ACE-CSR-acestart>> and <<ACE-init-export-import>>.
Similarly to entire-vector-register load instructions, `ace.import` appears to other harts as sequences of individual loads.
The behavior of `ace.import.S` is implementation defined.

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *NO* +
Trappable: *YES*. +
Interruptible: *YES*.

NOTE: The operation can be conceptually split into two phases.
In the first phase, the metadata block is read, which determines the length of the remaining information.
Then, in the second phase, the rest of the SCC is read and processed.

NOTE: The instruction encoding includes a single bit to indicate a system-defined format. If multiple such formats are supported, the data format itself must incorporate a unique identifier to differentiate them. The system is therefore responsible for embedding these identifiers within all system-defined formats.

NOTE: The `ace.export` instruction does not have an `ace.export.S` analogue of `ace.import.S`.
This means that system-specific dynamically generated keys can be imported but not exported in the same form: they must be exported in the format architected here for ACE CCs.

//

[[ACE-instruction-exec]]
==== ace.exec

The `ace.exec` instruction admits four Forms, namely
(((ACE, instruction, ace.exec)))

[upperalpha]
. `ace.exec  Vd, Kn|K[Xn], Vs` {nbsp}{nbsp} takes an input vector and writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}{nbsp}Kn|K[Xn], Vs` {nbsp}{nbsp} takes an input vector but does not write to an output vector.
. `ace.exec  Vd, Kn|K[Xn]{nbsp}{nbsp}{nbsp}{nbsp}` {nbsp}{nbsp} does not take an input but writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}{nbsp}Kn|K[Xn]{nbsp}{nbsp}{nbsp}{nbsp}` {nbsp}{nbsp} does not take an input vector and does not write to an output vector.

// Without this comment, the next part is not properly formatted...

Encoding::
`ace.exec` is an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'rd', attr: ['Vd','—','Vd','—'] },
    { bits:  3, name: 0x0, attr: ['ace.exec'] },
    { bits:  5, name: 'rs1', attr: ['Kn|K[Xn]'] },
    { bits:  5, name: 'rs2', attr: ['Vs','Vs','—','—'] },
    { bits:  1, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  1, name: 0x0 },
    { bits:  2, name: 'Form', attr: ['0    0','0    1','1    0','1    1'] },
    { bits:  2, name: 0x0 },
]}
....
+
Bit 25 is 0 for `ace.exec` operations. If bit 25 is 1, then other operations are encoded under the same `func3` code. +
Bit r (i.e., bit 26) takes the value 0 if the context is encoded as an immediate, and it takes the value 1 if a
GPR (scalar integer value) is used to reference it. For the four Forms A-D above, the encodings are:
For the four Forms A-D above, the encodings are:
+
[upperalpha]
. `Form` = `0b00`.
. `Form` = `0b01` and `rd` = `0b00000`.
. `Form` = `0b10` and `rs2` = `0b00000`.
. `Form` = `0b11` and `rs2` = `rd` = `0b00000`.

// To make indent in next line correct

Description::
Performs a cryptographic operation such as an encryption or decryption, absorbing a value in a hash,
an elliptic curve point addition or scalar multiplication, etc., and possibly returning a value.
+
If the V extension register file is not implemented, only Form D of `ace.exec` is supported
(the derived Forms used to define other instructions are still supported) and `ace.input`, `ace.output` must be used to
provide inputs and extract outputs from `ace.exec`.
<<ACE-usage-input-output>> described how this is done.

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *NO*. +
Interruptible: See interruptibility rules in <<ACE-generic-rules>>.

//

[[ACE-instruction-state]]
==== ace.state

The `ace.state` instruction admits three Forms, namely
(((ACE, instruction, ace.state)))

[upperalpha]
. `ace.state Kd|K[Xd], #immed7{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}` with no auxiliary input.
. `ace.state Kd|K[Xd], #immed7, Xs{nbsp}{nbsp}` with an auxiliary input in a GPR.
. `ace.state Kd|K[Xd], #immed7, Vs{nbsp}{nbsp}` with an auxiliary input in a vector register.

//

Encoding::
`ace.state` is an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Kd|K[Xd]' },
    { bits:  3, name: 'ace.state', attr: ['0    0    1','0    1    0','0    1    1'] },
    { bits:  5, name: 0x0 },
    { bits:  5, name: 'rs1', attr: ['—','Xs','Vs'] },
    { bits:  7, name: 'immed7' },
]}
....
+
The encodings for the three Forms are:
[upperalpha]
. `ace.state` = `0b001`.
. `ace.state` = `0b010`.
. `ace.state` = `0b011`.

//

Description::
The instruction is used to control the state machine of the cryptographic algorithm in CR `Kd` or `K[Xd]`.
The `#immed` operand is a constant from a set of admissible values defined for each algorithm.
The new state number, if allowed, is written into the State_Number field of the metadata, unless the algorithm requires more than 16 states, in which case an ad-hoc field must be defined in the context (for both internal representation and SCCs).
Optionally, `Xs` or `Vs` contains an auxiliary input.

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *NO*. +
Interruptible: *NO*.

The state numbers used in this specification are defined in <<ACE-state-constants>>.

It is allowed to repeat `ace.state` instructions to the current state.
When the algorithm needs to prevent this, it will automatically transition to a different state after completing `ace.state`.

//

[[ACE-instruction-error]]
==== ace.error

`ace.error Xd`
(((ACE, instruction, ace.error)))

Description::
The ACE Unit may be in an error state due to the previous operation.
The error code is written into GPR `Xd`.
`ace.error` is implemented as a read from CSR `aceerror`, which may cause the hart to wait if the error code is not yet available (<<ACE-CSR-ace-error>>).
The architected error codes are given in <<ACE-error-codes>>.

Properties::
Possibly modifies state: *NO*. +
Usage-controlled: *NO*. +
Trappable: *NO*. +
Interruptible: *NO*.

//

[[ACE-instruction-size]]
==== ace.size

There are three types of `ace.size` instructions:
(((ACE, instruction, ace.size)))

[upperalpha]
. `ace.size Xd, Ks|K[Xs]` - Context type.
. `ace.size Xd, Xs` - Metadata type.
. `ace.size.internal Xd, Xs` - Internal capacity type.

// Without this comment, the next part is not properly formatted...

Encoding::
The encoding shares `func3` with `ace.exec`, however with bit 25 (the lsb of `func7`) equal to 1 and the two msb's of `func7` equal to `00`.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x0, attr: ['ace.exec'] },
    { bits:  5, name: 'Ks/K[Xs]/Xs' },
    { bits:  5, name: 0x0 },
    { bits:  1, name: 0x1 },
    { bits:  1, name: 'r' },
    { bits:  1, name: 0x0 },
    { bits:  2, name: 'Form' },
    { bits:  2, name: 0x0, attr: ['func2'] },
]}
....
+
The Form and 'r' fields assume these values:

* Form = `00`, `r` = 0: Context type with the context given as `Ks`.
* Form = `00`, `r` = 1: Context type with the context given indirectly as `K[Xs]`.
* Form = `01`, `r` = 0: Metadata type.
* Form = `11`, `r` = 0: Internal capacity type.

Description:: {empty}

* Context type `ace.size` returns the total size (in bytes) of the memory buffer that would be necessary to store the exported SCC.
Knowing this size is necessary for any feature that relies on `ace.export`, including context switching. +

* Metadata type `ace.size` returns the total size (in bytes) of a SCC having the metadata section given in `Xn` into GPR `Xd`, and zero if the algorithm is not supported.
+
On RV32, `Xs` contains bits [31:0] of the metadata.  This suffices since they contain all fields required to determine the size of the SCC.

* Internal Capacity `ace.size` returns the amount of internal CF capacity used by a CR with metadata section matching `Xn` on the
the Algorithm, SP_Protection, and Key_Type metadata fields. In this case, all other bits must be zero.
If the combination of Algorithm, SP_Protection, and Key_Type fields is not supported, `ace.size` returns 0.
If, instead, only the State_Number is non zero and its value is 15, resp., 14, `ace.size` returns the total, resp., the remaining internal capacity of the CRF. +
All the values returned by the instruction are expressed in terms of implementation-dependent units, and in principle cannot be compared across different implementations.
+
On RV32, `Xs` contains bits [31:0] of the metadata (as for the metadata type instruction).

Properties::
Possibly modifies state: *NO*. +
Usage-controlled: *NO*. +
Trappable: *NO*. +
Interruptible: *NO*.

//

[[ACE-instruction-available]]
==== ace.available

`ace.available Xd, Xs`
(((ACE, instruction, ace.available)))

Alias to the Metadata Variant of `ace.size`, as it returns zero if the algorithm is not supported.

Properties::
Same as `ace.size`.

//

[[ACE-instruction-restrict]]
==== ace.restrict

`ace.restrict{nbsp}{nbsp}Kd|K[Xd], Xs`
(((ACE, instruction, ace.restrict)))

// Without this comment, the next part is not properly formatted...
Encoding::
The encoding shares `func3` with `ace.exec`, however with bit 25 equal to 1 and `func2` equal to 1.
It is thus an R-type instruction.
The source register field encodes a GPR and not a vector register.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 0x0 },
    { bits:  3, name: 0x0, attr: ['ace.exec'] },
    { bits:  5, name: 'Kd|K[Xd]' },
    { bits:  5, name: 'Xs' },
    { bits:  1, name: 0x1 },
    { bits:  1, name: 'r' },
    { bits:  3, name: 0x0 },
    { bits:  2, name: 0x1, attr: ['func2'] },
]}
....
+
If bit `r` (i.e., bit 26) is 0, the 5-bit destination field [11:7] contains the destination context number,
else it determines the GPR that contains the context number.

// comment

Description::
+
--
This instruction can be used to:

* Restrict the usage of a CC (as stored in a CR) to specific modes or to a specified Filter;
* Restrict the use of encryption or decryption in a CC that allows both; and
* Activate the side-channel protection of the CC or increase it.

Let `m` be the metadata field of the CC in the destination CR. +
On RV64, the semantics of the instruction are:

* `Xs`[11:0] and `Xs`[27:16] must be zero.
* `Xs`[15:12] and `Xs`[63:32] have the same format as the corresponding bits of the metadata.
* `Xs`[13:12] is used to turn on side-channel protection or increase its level, if implemented.
The level is encoded according to <<ACE-SC-protection-levels>>.
Downgrading protection level is not permitted. Attempting to do so will cause error _ace_err_invalid_ (<<ACE-error-codes>>).
* `Xs`[15:14] is used to deactivate either encryption or decryption in a CC that allows both. +
If `m`[15:14] = `0b11`, then at least one bit of `Xs`[15:14] must be set to 1 to select which operation is kept. +
If `m`[15:14] != `0b11`, then it must be `Xs`[15:14] = `m`[15:14] or `Xs`[15:14] = 0, in which case no change is made, else this will result in error _ace_err_invalid_.
* A zero in any of the four bits `Xs`[31:28] means that the corresponding policy is _not_ changed.
* A one in any of the four bits `Xs`[31:28] means that usage by the corresponding mode is forbidden, and the corresponding bit in the metadata of the destination CC is set to 1.
* `Xs`[34:32] can be non-zero only if `m`[33:32] is zero, in which case  `m`[59:35] <- `Xs`[59:35], else `aceerror` is set to _ace_err_invalid_.
* This instruction cannot set a Locality.

On RV32, `s` must be even, the register pair `X[s]` and `X[s+1]` is read,
and `(X[s+1] @ X[s])` replaces `Xs` in the RV64 description.
--
+

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *NO*. +
Interruptible: *NO*.

//

[NOTE]
====
This instruction enables several practical use cases:

*   Enabling side-channel protection when supported by the microarchitecture, even if the original CC was not configured with it.
*   Allowing privileged code to give a CC to several processes by cloning it and customizing the Filter for each clone to an authorized process.
*   Similarly, enabling privileged code to split a CC capable of both encryption and decryption into two CCs, one only capable of encryption and the other only capable of decryption, thereby creating a one-way channel between processes.

The ability to perform such customizations saves both time and computational resources by avoiding additional round-trips to trusted environments.
====

//

[[ACE-instruction-clone]]
==== ace.clone

`ace.clone Kd|K[Xd], Ks|K[Xs]`
(((ACE, instruction, ace.clone)))

Encoding::
The encoding shares `func3` with `ace.exec`, however with bit 25 equal to 1 and `func2` equal to 2.
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Kd|K[Xd]' },
    { bits:  3, name: 0x0, attr: ['ace.exec'] },
    { bits:  5, name: 'Ks|K[Xs]' },
    { bits:  5, name: 0x0 },
    { bits:  1, name: 0x1 },
    { bits:  2, name: 'R' },
    { bits:  2, name: 0x0 },
    { bits:  2, name: 0x2, attr: ['func2'] },
]}
....
+
Bits [27:26], i.e., field `R`, take the following values depending on how the CRs are given:
+
[upperalpha]
. `00`{nbsp}{nbsp} if the source and the output CRs are both encoded as immediate values.
. `01`{nbsp}{nbsp} if the source CR is encoded as immediate and the output CR is selected using a GPR.
. `10`{nbsp}{nbsp} if the source CR is selected using a GPR and the output CR is encoded as an immediate value.
. `11`{nbsp}{nbsp} if the source and the output CRs are both selected using the values of GPRs.

(The first digit is bit 27 and the second digit is bit 26.)

// Comment to ensure proper indentation in the next Description

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *NO*. +
Trappable: *YES*, it can be implemented as an export followed by an import in a handler. +
Interruptible: *NO*.

Description::
Clones source CR `Ks` (or the CR indexed by `Xs`) into destination CR `Kd` (or into the CR indexed by `Xd`).

// NOTE: The `ace.clone` instruction is an optimization for the sequence `ace.export` followed by `ace.import`. While reusing cryptographic state (e.g., encrypting with the same counter) can enable certain attacks, this risk cannot be eliminated by omitting `ace.clone`, as a state can be exported and re-imported multiple times.

[[ACE-instruction-derive]]
==== ace.derive

The `ace.derive` instruction admits three Forms, namely
(((ACE, instruction, ace.derive)))
[upperalpha]
. `ace.derive Kd|K[Xd], Ks1|K[Xs1]{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}` with no auxiliary input.
. `ace.derive Kd|K[Xd], Ks1|K[Xs1], Xs2{nbsp}{nbsp}` with an auxiliary input in a GPR.
. `ace.derive Kd|K[Xd], Ks1|K[Xs1], Vs2{nbsp}{nbsp}` with an auxiliary input in a vector register.

//

Encoding::
The encoding shares `func3` with `ace.exec`, however with bit 25 equal to 1 and `func2` equal to 3.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x6b, attr: ['custom-2'] },
    { bits:  5, name: 'Kd|K[Xd]' },
    { bits:  3, name: 0x0, attr: ['ace.exec'] },
    { bits:  5, name: 'Ks1|K[Xs1]' },
    { bits:  5, name: 'rs2'},
    { bits:  1, name: 0x1 },
    { bits:  2, name: 'R' },
    { bits:  1, name: 'v' },
    { bits:  1, name: 'g' },
    { bits:  2, name: 0x3, attr: ['func2'] },
]}
....
+
This encoding differs from Form A `ace.exec` by having bit 25 set to 1.
Bits [27:26], i.e., field `R`, is encoded exactly as for `ace.clone` (<<ACE-instruction-clone>>).
Bit 28 determines whether a vector register (or register group) is used to pass an auxiliary parameter to the key derivation mechanism or not.
Bit `v` (i.e., bit 28) is 0 for Forms A and B and 1 for Form C. +
Bit `g` (i.e., bit 29) is used to distinguish Form A, with `g` = 0, from Form B, with `g` = 1. +
The value (`g`,`v`) = (1,1) is currently an invalid instruction and reserved for future use.

Description::
Derive a new context from an existing one, with its own opaque key material, for instance using a key derivation mechanism.
The behavior of the instruction is not expected to be deterministic.
It can be used multiple times, to generate multiple derived contexts.

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *NO*. +
Interruptible: *NO*.

//

[[ACE-instruction-input]]
==== ace.input

`ace.input %offset(Xs), Xl`
(((ACE, instruction, ace.input)))

Encoding::
`ace.input` is an S-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'immed[4:0]' },
    { bits:  3, name: 0x4, attr: ['ace.input'] },
    { bits:  5, name: 'Xl' },
    { bits:  5, name: 'Xs' },
    { bits:  7, name: 'immed[11:5]' },
]}
....

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *YES* +
Trappable: *YES*. +
Interruptible: *YES*.

Description::
In all cases where the vector registers are not sufficiently long, or not implemented, inputs can be read directly from memory and written directly to memory.
For this reason, the architecture defines `ace.input` and `ace.output` (cf. next section).
`ace.input` reads `Xl` bytes from memory starting at address `%offset(Xs)` and copies them to the input buffer, starting at offset `acestart`.
+
If `Xl` == `0`, the operation is a NOP. +
`Xl` may be not greater than `aceiobuftop` - `acestart`. +
If `Xl` is greater than `aceiobuftop` - `acestart`, and invalid instruction error is raised.
+
The intended usage of `ace.input` and `ace.output` is explained in detail in <<ACE-usage-input-output>>. +

//

[[ACE-instruction-output]]
==== ace.output

`ace.output %offset(Xd), Xl`
(((ACE, instruction, ace.output)))

Encoding::
`ace.output` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-0'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x4, attr: ['ace.output'] },
    { bits:  5, name: 'Xl' },
    { bits: 12, name: 'immed' },
]}
....

Description::
This is the output operation corresponding to `ace.input`.
`ace.output` writes the contents of the input buffer, starting at offset `acestart`, to memory starting at address `%offset(Xs)`.
+
If `Xl` == `0`, the operation is a nop. +
`Xl` may be not greater than `aceiobuftop` - `acestart`. +
If `Xl` is greater than `aceiobuftop` - `acestart`, and invalid instruction error is raised.

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *YES*. +
Interruptible: *YES*.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-init-export-import]]
=== Initialization, Export and Import of Cryptographic Contexts

From the point of view of the system outside the ACE unit, `ace.init` and `ace.import` appear a series of sequential memory reads, and `ace.export`, appear a series of sequential memory writes.

The only admissible points of interruption of these instructions are the memory read or write operations.
The instructions may be interrupted because of a memory exception, and any other type of interrupt must either wait until the next memory read or write.
They may resume from the point of interruption only if the control flow is returned to them immediately after the interrupt handler has completed.
The privileged interrupt handler must ensure that the instruction is restarted only in this situation, and in any other circumstance, including context switching, the instruction must be restarted, in which case if the instruction is `ace.init` or `ace.import` it must also clear the CR.
The implementation will also restart any operation if the internal state of the CR is not in a valid interrupted state.

[NOTE]
The initial cryptographic phase of `ace.export` is currently architected to be uninterruptible.
Even if this phase is executed concurrently with other operations, an interrupt handler may need to wait for it to complete before proceeding with any access to the CR.

[WARNING]
--
The requirement that the initial cryptographic phase of `ace.export` be uninterruptible could become a performance bottleneck for very long SCCs, or cause timing issues. To address this, we could allow the SIV computation to be interrupted by using odd values in `acestart`. With reference to <<ACE-SCC-export>>, the SIV computation processes 16-byte blocks via POLYVAL. An `acestart` value of 17 would indicate interruption after the metadata has been multiplied by the hashing key; values of 33, 49, and so on would indicate interruption after subsequent content blocks have been added to the partial hash and multiplied by the hashing key. The instruction remains uninterruptible between the final hash multiplication and the subsequent encryption. Consequently, a value of `SCC_content_size() + 17` would signify that the memory write of the metadata was interrupted immediately, replacing a zero `acestart` value.
--

The Serialized Content section under Data Structures in an algorithm specification (<<ACE-algorithms>>) defines the structure of the `content[]` array.
Architecturally, `content[]` is the serialization of the content of a CR for export as a SCC.

[NOTE]
--
While `content[]` provides a view of (certain fields of) the content of a CR that matches the serialized SCC format, it needs not be converted to and from the internal representation and explicitly stored in the ACE unit's memory before export and after import.

`content[]` is a virtual representation: its byte ordering does not imply physical contiguity within the CR, nor is there a direct byte-for-byte correspondence. Changes to `content[]` are reflected in the underlying CR representation (except for excluded fields), and vice versa.

For example, let us consider a threshold implementation. A single key byte in `content[]` may correspond to multiple bytes across the key shares within the CR. Reading that byte may return the XOR of the corresponding bytes in the shares; writing to it may distribute the value across the corresponding bytes in the shares such that their XOR equals the input. These operations may be deferred until the end of an initialization or import instruction: writing to `context[]` may initially write only to the first share of a key, and at the end of the initialization or import instruction, the various shares are generated.
--

[[ACE-size-functions]]
==== Size Functions

Suppose `x` is a variable representing the first 32 bits of the metadata section of a CC.
We assume that the implementation provides the following functions (or an equivalent mechanism):

. `MD_size(x)` returns the byte length of the entire metadata section. Currently, always 8.
. `II_content_size(x)` returns the size in bytes of the content section of an II. It only depends on the 12 bits `Key_Type @ Algorithm`.
. `SCC_content_size(x)` returns the size in bytes of the content section of an SCC. It only depends on the 14 bits `Direction_Policy @ Key_Type @ Algorithm`.

The total size of an II is therefore `MD_size(x)` + `II_content_size(x)`, and the total size of an SCC is `MD_size(x)` + `SCC_content_size(x)`.

[[ACE-init]]
==== Initialization

We start with the algorithm performed by `ace.init`, which reads an II and uses it to initialize a CR.

[[ACE-init-listing]]
.Initializing a CR with metadata and content
[]
----
M : array of bytes // in memory

metadata : bits(64) = M[0 .. 7] // PREEMPTIBLE WITH `ACESTART` IN [0 .. 7]
z ← II_content_size(metadata[31:0]);

if (z == 0) // Not enough CRF capacity left for the algorithm encoded in the metadata
   error ace_err_memory

- Complete metadata parsing.
// NEXT OPERATION PREEMPTIBLE WITH `ACESTART` IN [8 .. Z+7]
- Sequentially read and parse the z bytes at M+8.
----

[[ACE-SCC-AEAD]]
==== Export and Import

The AEAD algorithm used to export CRs is an adaptation of AES-GCM-SIV cite:[DBLP-journals-iacr-GueronLL17,RFC8452].
We define the Key Derivation (<<ACE-SCC-RFC8452-derivation>>) and the DCSK Derivation (<<ACE-SCC-DCSK-derivation>>) functions first,
the generation of a SCC from a CR (<<ACE-SCC-export>>) and the import of a SCC into a CR (<<ACE-SCC-import>>) next.

[[ACE-SCC-RFC8452-derivation]]
.RFC8452 Key Derivation
[]
----
function RFC8452_KeyDeriv(key) = {
  struct {
    AESE256(key, (zeros(125) @ 0b101))[63:0] @ AESE256(key, (zeros(125) @ 0b100))[63:0] @
    AESE256(key, (zeros(125) @ 0b011))[63:0] @ AESE256(key, (zeros(125) @ 0b010))[63:0],
    AESE256(key, (zeros(125) @ 0b001))[63:0] @ AESE256(key, (zeros(125) @ 0b000))[63:0]
  }
}
----

[[ACE-SCC-DCSK-derivation]]
.DCSK Derivation
[]
----
function DCSK_KeyDeriv(key,L) = {
    AESE256(key, L ^ (zeros(127) @ 1)) @ AESE256(key, L ^ zeros(128))
}
----

NOTE: Due to the computational cost of the derivation functions, implementations may
cache recently used derived keys for both the Root RCSK and Locality-derived keys.

[[ACE-SCC-export]]
.Generation of the SCC from a CR
[]
----
metadata : bits(64);              // from the CR
SIV : bits(128);
tmp : bits(128);
enc_key : bits(256);
auth_key : bits(128);
// content as serialized "view", size in bytes derived from metadata
content : array[z] of bytes,        // from the CR's metadata
where z : int ← SCC_content_size(metadata[31:0]);
ASSERT(8 divides z);
M : array[32 + z] of bytes;          // information
let last_block_fractional : boolean ← z % 16 != 0;
let num_blocks : int ← ceil(z / 16);

if (metadata.Locality == 15) then
   CSK ← RCSK;
else
   CSK ← DCSK_KeyDeriv(RCSK, LST[metadata.Locality]);

{enc_key, auth_key} = RFC8452_KeyDeriv(CSK);

metadata.State_Number <- ace_state_initial
tmp ← POLYVAL(auth_key, zeros(64) @ metadata @ content[]);
SIV ← AESE(enc_key, 0 @ tmp[126:0]));

metadata.State_Number <- ace_state_invalid

// FOLLOWING MEMORY WRITE PREEMPTIBLE, `ACESTART` FROM 0 TO 7
M[0 .. 7] ← (metadata[63:32] xor AESE(enc_key, 1 @ SIV[126:0])[31:0])
            @  metadata[31:0];

// FOLLOWING MEMORY WRITE PREEMPTIBLE, `ACESTART` FROM 8 TO 23
M[8 .. 23] ← SIV;

foreach(i from 0 to num_blocks - 1) {
   if ((i == num_blocks - 1) and last_block_fractional)
      // FOLLOWING MEMORY WRITE PREEMPTIBLE, `ACESTART` FROM 24+i*16 TO 31+i*16
      M[24+i*16 .. 31+i*16] ← content[i*16 .. 7+i*16]
         xor AESE(enc_key, 1 @ SIV[126:32] @ (SIV[31:0] + bin(i+1, 32) % 2**32)[63:0];
   else
      // FOLLOWING MEMORY WRITE PREEMPTIBLE, `ACESTART` FROM 24+i*16 TO 39+i*16
      M[24+i*16 .. 39+i*16] ← content[i*16 .. 15+i*16]
         xor AESE(enc_key, 1 @ SIV[126:32] @ (SIV[31:0] + bin(i+1, 32) % 2**32);
}

metadata.State_Number <- ace_state_initial
----

The import Algorithm needs some special care:

* If an import operation is preempted, the hardware must save `metadata.State_Number` and set +
`metadata.State_Number <- ace_state_invalid` before relinquishing control.
* When control is returned, the previous value of `metadata.State_Number` is restored.
* How to implement this is implementation dependent, but the corresponding information is stored in the CR, i.e., there must be a bit signaling whether a value of `metadata.State_Number` has been saved and a 4-bit field with this.
* If, upon returning to the interrupted process, the bit signaling that a value for `metadata.State_Number` has been saved is unset, the operation must be restarted.
* The first read is the read of the metadata block itself. If fewer than 4 bytes are read, the instruction is interrupted with `acestart` = 0 so it will be restarted.
If at least 4 bytes have been read, the value of `metadata.State_Number` are known.

[[ACE-SCC-import]]
.Importing a SCC into a CR
[]
----
M : array of bytes // from memory
enc_key : bits(256);
auth_key : bits(128);
SIV : bits(128);
tag : bits(128);
tmp : bits(128);

// FOLLOWING MEMORY READ PREEMPTIBLE, `ACESTART` FROM 0 TO 7
metadata : bits(64) ← M[0 .. 7]
if (there is not enough memory for the algorithm encoded in the metadata)
    error ace_err_memory

saved_SN : bits(4) <- metadata.State_Number
metadata.State_Number <- saved_SN

z ← SCC_content_size(metadata[31:0]);
num_blocks ← ceil(z / 16);
last_block_fractional : boolean ← (z % 16 != 0);

if (metadata.Locality == 15) then
    CSK ← RCSK;
else
    CSK ← DCSK_KeyDeriv(RCSK, LST[metadata.Locality]);

{enc_key, auth_key} = RFC8452_KeyDeriv(CSK);

// FOLLOWING MEMORY READ PREEMPTIBLE, `ACESTART` FROM 8 TO 23
SIV ← M[8 .. 23];
metadata[63:32] ← metadata[63:32] xor AESE(enc_key, 1 @ SIV[126:0])[31:0])
tmp ← zeros(64) @ metadata;
tmp ← Montmul(tmp, auth_key);

foreach(i from 0 to num_blocks - 1) {
   if ((i == num_blocks - 1) and last_block_fractional) {
      // FOLLOWING MEMORY READ PREEMPTIBLE, `ACESTART` FROM 24+i*16 TO 31+i*16
      content[i*16 .. 7+i*16] ← M[24+i*16 .. 31+i*16]
         xor AESE(enc_key, 1 @ SIV[126:32] @ (SIV[31:0] + bin(i+1, 32) % 2**32)[63:0];
      tmp[63:0] ← tmp[63:0] xor content[i*16 .. 7+i*16];
   } else {
      // FOLLOWING MEMORY READ PREEMPTIBLE, `ACESTART` FROM 24+i*16 TO 39+i*16
      content[i*16 .. 15+i*16] ← M[24+i*16 .. 39+i*16]
         xor AESE(enc_key, 1 @ SIV[126:32] @ (SIV[31:0] + bin(i+1, 32) % 2**32);
      tmp ← tmp xor content[i*16 .. 15+i*16];
   }
   tmp ← Montmul(tmp, auth_key);
}

tag ← AESE(enc_key, 0 @ tmp[126:0]);
if (tag != SIV) then { error ace_err_authentication; }
- Now the content can be deserialized.
- This includes computing any derived values not saved as part of the SCC,
- as well as creating shares for threshold implementations.

// FINALLY:
metadata.State_Number <- ace_state_initial
----

//

[[ACE-invalidation]]
=== Invalid Inputs and Operations, CR Invalidation

{empty}
(((ACE, algorithm, invalid state)))
(((Cryptographic Register, invalidation)))
If an invalid input is provided to any ACE instruction, or an instruction that is not explicitly allowed in a given state is executed, while processing the algorithm in CR, say, `Kn`, the `Kn` is *invalidated*, namely, the following happens:

* `Kn` is put into state _invalid_;
* For instructions that refer to `Kn`:
 ** `ace.init`, `ace.clear` (thus also `ace.reset`), `ace.import`, `ace.export`, `ace.size` and `ace.available` work normally.
 ** `ace.exec`, `ace.clone`, `ace.derive`, and `ace.restrict` raise an invalid instruction error;
 ** `ace.input` and `ace.output` raise an invalid instruction error when `aceactivecr` is `Kn`;
 ** `ace.state` raises an invalid instruction error unless it is used to return to state _initial_;
 ** `ace.error` always returns error _ace_err_invalid_ after any operation involving the CR except for
    `ace.import` and `ace.export`, `ace.clean`, `ace.init`, and `ace.size`, which all work normally, and using `ace.state` to return to state _initial_.
* The current instruction is terminated.

In State _completed_, only `ace.init`, `ace.export`, `ace.import`, `ace.clear`, and `ace.error` are permitted.

//

[[ACE-trappable-insns-support]]
=== Trappable (Emulated) Operations

_This section is currently non-normative._

Instructions `ace.init`, `ace.export`, `ace.import`, `ace.input`, and `ace.output` support long inputs and outputs.
To reduce hardware complexity, these operations can be trapped and emulated in software.
(((ACE, trappable instruction)))
Upon a trap, the handler identifies the trapped instruction and uses `ace.size` on the metadata to determine the size of the data to be transferred.
Then, the emulation uses custom instructions to move data between the ACE unit and the CPU.
Three types of supporting operations are required:

 * An “`ace.mv`” instruction that loads a specified number of bytes from a GPR or vector register into the state of a CR or in the input buffer within the ACE unit.
   Initially, `ace.size` returns the total payload length to transfer.
   After each move, this value is updated to reflect the remaining bytes.
   The instruction also updates the `acestart` CSR to follow the internal progress.
 * A corresponding “`ace.mv`” instruction that exports a specified number of bytes from a CR or from the input buffer to a GPR or vector register.
   The behavior of `ace.size` will be similar to that of the `ace.mv` instruction, but it will count the number of bytes to be exported.
 * An “`ace.close`” instruction to suspend or finalize the procedure.
   If executed before all bytes are transferred, the CR state matches that of an interrupted monolithic instruction, including the Incomplete metadata field and the `acestart` value. If executed after all bytes are transferred, it also performs any final cryptographic operations, such as authenticating the CR, if needed.

All three instructions can be implemented as CSR RW instructions, for instance:

 * `acedest`, XLEN bits wide, determines what architectural state we are transferring to or from: 0..31 for the CRs and, say, 32 for the input/output buffer.
 * `acestart`, XLEN bits wide, holds the offset within the CR's virtually serialized `content[]` or the input/output buffer.
 * `acecontent`, XLEN bits wide, to which we write the content of the CR or the input/output buffer or from which we read the current content.
  A write to `acecontent` increases `acestart` by XLEN/8.

// Interrupting the firmware implementation of `ace.init`, `ace.export`, `ace.import`, `ace.input`, or `ace.output` must leave the architectural state indistinguishable from the state expected from interrupting a monolithic implementation of the instructions.
// In particular, they need to respect the value of `acestart` and update it in accordance with the expected architected behavior of the emulated instructions.
// The supporting instructions themselves must be uninterruptible.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-algorithms]]
=== Algorithms

_This section is normative._

In this section we specify the behavior of ACE instructions for the supported cryptographic algorithms.
Some specifications are generic: they define algorithm families that can be instantiated with any primitive meeting the required properties, typically parameterized only by block size `b` and key size `k`.
For example, GCM-SIV is well defined not only with AES but also with alternative block ciphers, such as SM4-GCM-SIV, when used with the same hash function.
By contrast, the specifications for other algorithm suites are specific to certain primitives, for instance, Ascon.

Each algorithm is fully defined by the following information:

Parameters:::
+
--
These include:

* The _block size_ `b`, which is the size of the basic unit of information processed by the algorithm, usually the block size of the main underlying primitive;
* The _key size_ `k`, for keyed algorithms; and
* Any other parameter (for instance, counter size) that is necessary to instantiate the algorithm with compatible primitives.
--
+

Important: In this section, all field lengths are specified in bits except where otherwise noted.

Data Structures:::
+
--
These include:

. *Initialization Input*:
The data following the metadata block in the II to `ace.init`, such as keys and other required secrets.
Fields are listed in the order they appear in the II, each with its length.

. *Internal State*:
Information that must be maintained in the internal state of a CC.
The fields are unordered and their lengths may differ from those listed, for example in threshold or fault-tolerant implementations where redundancy is added.

. *Serialized Content*:
The data that follows the metadata block in the plaintext portion of the SCC.
The fields are listed in the order they appear in the SCC, each with its length.
--
+

Algorithm-Specific Functions:::
Any other function that is specific to the algorithm.

State Machine:::
+
--
This includes:

. A list of *states* in which the internal state machine of the logic is executed, together with their representation, either as a number in the range [0..15] or by more complex structures. The values for the architected algorithms conform to <<ACE-state-constants>>.
. A complete list of the *allowed state transitions*, including the conditions under which each transition is allowed.
. The enumeration of the *allowed instructions* at each state and their *behavior*.
--
+

//

The instructions permitted in each algorithm state are typically `ace.exec` and `ace.state`, though this is a general rule.
For `ace.exec`, only one of its forms (see <<ACE-instruction-exec>>) is allowed per state, along with the corresponding replacement sequence defined in <<ACE-replacement-instructions>>.

Pseudocode is provided to illustrate the software implementation of ACE-supported algorithms using the ACE ISA.
For clarity, the pseudocode generally uses fixed parameters and omits the `ace.exec` Forms A-C replacement sequences.
The examples are non-normative.

The following table defines the state names and numbers used by the algorithms in this specification.

[[ACE-state-constants]]
.Constants defining CC states
[float="center",align="center",width="100%",cols="^6%,<26%,<16%,<52%",options="header"]
|===
| Value | Mnemonic for the Constant       | State Name          | Description
|   0   | _ace_state_initial_             | _initial_           | The context is initialized and ready for operation.
.2+| 1  | _ace_state_hash_absorb_         | _hash_absorb_       | Start and initialize a hash/tag function of an algorithm and start absorbing blocks of data.
<| _ace_state_operate_                    | _operate_           | Generic operational state.
|   2   | _ace_state_hash_last_block_     | _hash_last_block_   | In this state additional data may be absorbed, such as partial blocks and lengths, if the hash/tag algorithm processes the last block of its input or of the associated data part of its input in a different way from the other blocks.
|   3   | _ace_state_hash_finalize_       | _hash_finalize_     | Finalize the internal state of a hash/tag function.
|   4   | _ace_state_hash_verify_         | _hash_verify_       | Compare the internal hash/tag value to the provided one.
|   5   | _ace_state_hash_output_         | _hash_output_       | Enter the hash output phase of a hash/tag function.
|   6   | _ace_state_enc_last_block_      | _enc_last_block_    | For the encryption path of authenticated encryption modes of operation to process the last block separately.
|   7   | _ace_state_dec_last_block_      | _dec_last_block_    | For the decryption path of authenticated encryption modes of operation to process the last block separately.
|   8   | _ace_state_enc_tag_finalize_    | _enc_tag_finalize_  | Finalize the tag computation for AE mode encryption.
|   9   | _ace_state_dec_tag_finalize_    | _dec_tag_finalize_  | Finalize internal tag computation for AE mode decryption, verify the value.
|  10   | _ace_state_encrypt_             | _encrypt_           | In this state encryption is performed, and an update to the tag computation if part of the algorithm.
|  11   | _ace_state_decrypt_             | _decrypt_           | In this state decryption is performed, and an update to the tag computation if part of the algorithm.
|  12   | _ace_state_set_aux_value_       | _set_aux_value_     | Set a public/auxiliary value in an algorithm.
|  14   | _ace_state_invalid_             | _invalid_           | The algorithm has abnormally terminated or initialization/import have not completed.
|  15   | _ace_state_completed_           | _completed_         | The algorithm has completed, not necessarily without error.
|===

NOTE: The `ace.state` instruction used to transition to states _hash_absorb_, _encrypt_, or _decrypt_ often also sets the first (or only) public value.
For algorithms requiring multiple public values or additional parameters (e.g., tag length), these can be set by transitioning to state _set_aux_value_ using a Form of `ace.state` with an auxiliary argument, i.e., Form B or C.

Algorithms that differ substantially from those described in <<ACE-algorithms>> and thus cannot be handled by the same software, may reuse the state values in [1..12] with new mnemonics and names for their states.

The state number is stored in the metadata or content section of the CC/SCC, as described in <<ACE-metadata>>, with the constraint that the State_Number field must always contain one of the values 0, 14, 15, or 1.

Unless explicitly stated otherwise in an algorithm's specification, it is always possible to transition From any valid state to state _initial_.

NOTE: In many algorithms, an `ace.exec` or `ace.state` operation could logically imply a state change. For example, after setting an IV or nonce in an AEAD mode, the instruction might naturally transition to a subsequent state. To ensure consistent behavior, the ACE architecture favors explicit state transitions via separate instructions, even if this adds instruction count. It is always permissible to issue an `ace.state` instruction that transitions to the current state. Deviations from these behaviors may be necessary to avoid security issues.
One such example is automatic transitions from hash finalization to verification, or from hash verification to the _completed_ state (<<ACE-state-constants>> and <<ACE-algorithms>>) to prevent that the user may test several values against an unknown tag and thus potentially gain information about a hashing key.

//

[[ACE-generic-rules]]
==== Generic Rules

[[ACE-usage-input-output]]
===== Usage of `ace.input` and `ace.output` to Replace Vector Inputs and Outputs

The `ace.input` and `ace.output` instructions may be used to replace the inputs and outputs to Forms A-C of `ace.exec`, the auxiliary inputs of Form C `ace.state` or of Form C of `ace.derive` in any algorithm, to the point that an implementation of ACE without the V extension or a subset thereof is possible.
Forms A, B, and C of `ace.exec`, as well as Forms C of `ace.derive` and `ace.state`, can be replaced as follows:

[[ACE-replacement-instructions]]
.Replacement sequences for `ace.exec` and `ace.derive` using `ace.input` and `ace.output`
[float="center",align="center",width="100%",cols="<15%,<41%,<44%",options="header"]
|===
| Instr./Form | Original Instruction          | Replacement Sequence
| `ace.exec` / A | `ace.exec{nbsp}{nbsp}{nbsp}Vd, Kn\|K[Xn], Vs` | `ace.input{nbsp}{nbsp}Xl, Vs` +
`ace.exec{nbsp}{nbsp}{nbsp}Kn\|K[Xn]` +
`ace.output{nbsp}Vd,  Xl`  // Form D
| `ace.exec` / B | `ace.exec{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}Kn\|K[Xn], Vs`     | `ace.input{nbsp}{nbsp}Xl, Vs` +
`ace.exec{nbsp}{nbsp}{nbsp}Kn\|K[Xn]`  // Form D
| `ace.exec` / C | `ace.exec{nbsp}{nbsp}{nbsp}Vd, Kn\|K[Xn]`     | `ace.exec{nbsp}{nbsp}{nbsp}Kn\|K[Xn]` +
`ace.output{nbsp}Vd,  Xl`  // Form D
| `ace.state` / C | `ace.state{nbsp}{nbsp}Kd\|K[Xd], #immed, Vs` | `ace.input{nbsp}{nbsp}Xl, Vs` +
`ace.state{nbsp}{nbsp}Kd\|K[Xd], #immed` // Form A
| `ace.derive` / C | `ace.derive Kd\|K[Xd], Ks1\|K[Xs1], Vs2` | `ace.input{nbsp}{nbsp}Xl, Vs2` +
`ace.derive{nbsp}Kd\|K[Xd], Ks1\|K[Xs1]` // Form A
|===

`ace.input` and `ace.output` may be used if enabled and `aceiobuflen` is non zero, otherwise an invalid instruction error is raised.
If `aceiobuflen` is non zero, and the range size `aceiobuftop-acestart` is zero or an invalid size for the algorithm, the `ace.exec` operation is not performed and `aceerror` is set to error code ace_err_invalid.

In all cases, the `ace.input` and `ace.output` instructions must be temporarily tied to a specific context in order to properly determine the allowed sequences.
This is done by setting the `aceactivecr` CSR (<<ACE-CSR-aceactivecr>>) first. The user must not forget to set it back to 32 after the sequence is completed.

We use the `acesequence` CSR to indicate whether we are using the input/output buffer or the vector registers to provide the inputs and outputs to ACE instructions, and to track the instruction sequence.

* The initial value of `acesequence` is zero.
* As soon as one of the following events happen:
+
--
 ** an `ace.input` is completed in place of a
  *** Form A or B `ace.exec`,
  *** Form C `ace.derive`, or
  *** Form C `ace.state`
 ** or a Form D `ace.exec` is completed in place of a Form C `ace.exec`,
--
+
the CSR `acesequence` is set to 1.

* In this case, `acesequence` remains 1 until the end of the second instruction of the replacement sequence, and
* If there is a third instruction in the sequence, then `acesequence` is set to 2 until the end of the third instruction of the sequence.
* At the end of the replacement sequence, `acesequence` is reset to 0.

The ordering of the instructions in a replacement sequence is enforced by the architecture according to the value of `acesequence` and the state number of the CR configured in `aceactivecr`.

Not properly following the instruction ordering raises an invalid instruction exception.

`acesequence` can be saved and restored by privileged code together with `acestart`.

The internal input/output buffer is not part of any CR. It is architectural, i.e., per-hart. In fact, `ace.output` can be used to save the contents of the buffer, and `ace.input` can be used to restore it freely as long as `aceactivecr` takes the value 32. Also, these operations start at the offset specified in `acestart`, so the state of the buffer can easily be saved and restored with the same approach used for vectors.

//

In all algorithms, whenever one of the instructions in <<ACE-replacement-instructions>> occurs, it may be replaced by a replacement sequence. We do not write this explicitly in the algorithm descriptions for brevity.

NOTE: This mechanism is one of the reasons, besides keeping the state machines simple, that in a given state of an algorithm, only one Form of `ace.exec` or `ace.state` is allowed.  Some exceptions may be possible.  For instance, both a Form D and a Form B could be allowed, with different semantics, and when using replacement sequences, these would be distinguished according to whether `aceiobuftop` - `acestart` is zero or not.

//

[[ACE-interruptibility]]
===== Interruptibility

Operations performed by `ace.state` are uninterruptible, except when reading vector inputs, where the vector read operation may be interrupted and resumed.

The operation of `ace.exec` on a basic processing unit, in any state of any algorithm, is uninterruptible, even when described as a sequence of instructions.
If the operation accepts an input that is an integer multiple of the basic processing unit, each block is processed uninterruptibly, but the instruction may be interrupted between blocks; the hardware sets `acestart` to the resumption point.

An implementation must wait before accessing a CR that is still being written to asynchronously.

//

[[ACE-notation]]
===== Notation in the Algorithm Descriptions

* `INPUT`: The input data to be processed by the following instructions: `ace.exec`, `ace.state`, `ace.derive`.
   This can be the input vector register, or the input/output buffer, according to the semantics presented in <<ACE-usage-input-output>>.

* `OUTPUT`: The output data produced by `ace.exec`.
   This can be the output vector register, or the input/output buffer, according to the semantics presented in <<ACE-usage-input-output>>.

* `IOLEN`: Either `VL*SEW` or the length `aceiobuftop` of the input/output buffer in bytes, depending on whether vector registers are used or the input/output buffer is used.

//

[[ACE-rules-threshold-implementations]]
===== Single-Share Key Export Rule for Threshold implementations

Any CC with its algorithms implemented as threshold implementation will always initialize, import and export _all_ its keys and secrets as _single_, _reconstructed_ _shares_.
The Configuration and SCC Formats will be the same as for the non-threshold implementation variants of the same algorithm, with the only difference being the value of the Side Channel Protection bits in the metadata.
For the purpose of architecture specification, all values are also always represented as a single share in this document.
Threshold implementations are simply implementation variants of the exact same algorithm.
(((ACE, algorithm, threshold variants)))

NOTE: This rule assumes that reconstructing or re-randomizing a key is a fast operation, such as an ``xor`` with random values.
This requires the ACE execution unit to have access to a randomness source, or at least a PRNG seeded at hardware boot. +
Besides ensuring the compactness of a SCC, this rule also guarantees key portability across architectures
that implement side-channel protection in different ways.

//

[[ACE-rules-system-keys]]
===== Representation of System Keys in the Data Structures

System keys will change all the algorithms described here in the following way:

. In the II and in the SCC, the key field will contain the index of the key in place of the value.
. This field is reduced from the original key size to a 64-bit value. This saves space in the SCC and allows for faster export and import operations.
. For algorithms that require more than one key, such as XEX/XTS, a single index is still used to an entry in the SKT that contains multiple keys-and thus a single 64-bit value in the II and SCC.

//

[[ACE-ECB-mode]]
==== Electronic Codebook Modes (Direct Encryption/Decryption)

ECB mode cite:[nist-SP-800-38A-1] is the simplest way to use a block cipher.
(((ACE, algorithm, ECB)))

===== Specification

Parameters:::

* `b` = block size (8|`b`). `IOLEN` must be a multiple of `b` (including `b`).
* `k` = key size (8|`k`).

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.

* *Internal State*:
 ** `key`: `k` bits.

* *Serialized Content*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.

Algorithm-Specific Functions:::

* `enc_blk(K,p) -> c` encrypts plaintext block `p` using the key `K`, and returns the ciphertext result `c`.
* `dec_blk(K,c) -> p` decrypts ciphertext block `c` using the key `K`, and returns the plaintext result `p`.

State Machine:::

* *States:*
 ** _initial_: The CC is ready.
 ** _encrypt_: Encrypting blocks of input.
 ** _decrypt_: Decrypting blocks of input.

* *Allowed State Transitions:*
 ** From any valid state to _encrypt_, if encryption is allowed, else the CR is *invalidated* (<<ACE-invalidation>>).
 ** From any valid state to _decrypt_, if decryption is allowed, else the CR is *invalidated*.

* *Behavior:*
 ** In State _initial_, no `ace.exec` instruction is allowed.
 ** In States _encrypt_ or _decrypt_, we can only issue Form A `ace.exec` instructions, i.e., +
     “`ace.exec OUTPUT, Kn|K[Xn], INPUT`.”
  *** If the state is _encrypt_, then `OUTPUT <- enc_blk(key, INPUT)`.
  *** If the state is _decrypt_, then `OUTPUT <- dec_blk(key, INPUT)`.
  *** If `IOLEN` > `b`, then “`ace.exec OUTPUT, Kn|K[Xn], INPUT`” encrypts/decrypts block-by-block.
      Here, and in the rest of this document, this means from the blocks in the least significant positions to the most significant positions:
      . `foreach(i from 0 to IOLEN-b by b)` {
      ..   `OUTPUT[i+b-1:i] <- enc_blk(key, INPUT[i+b-1:i])`
      . }

//

[NOTE]
====
Supporting vector lengths smaller than a cipher's block size would not only complicate both the architecture and its implementation, but it would also burden the software using the feature. Therefore, in this case either the user suitably reconfigures the vector lengths, or uses the `ace.input` and `ace.output` instructions.
====

===== Usage

The following pseudocode illustrates how to use an ECB CC to encrypt a block of data using a block cipher with a width of 128 bits (`IOLEN` is also 128).

[[ACE-pseudocode-ECB-encryption]]
.Simple Example: Encryption with no Authentication
----
- Call OS API to get the necessary SCC. Assume X5 points to the SCC.
- Allocate memory for ciphertext buffer.

vsetvli zero, 4, e32, m1, ta, ma           // Use 128-bit vectors
ace.import K0, (X5)                        // Import the SCC into CR K0
ace.error X1                               // Read error from a CSR
if (X1 != 0) then { handle error }         // ACE may fail to validate SCC, algorithm may
                                           // be not supported, or CRF memory may be full
ace.state K0, #ace_state_encrypt           // Configure CR for encryption
ace.error X1                               // Read error from a CSR
if (X1 != 0) then { handle error }         // Error if encryption not allowed

foreach(i from 0 to len_in_bytes(plaintext)/16-1) { // assume plaintext in whole blocks
   V0 ← plaintext[16*i .. 16*i+15]
   ace.exec V0, K0, V0                     // Encrypt one block of the plaintext
   ciphertext[16*i .. 16*i+15] ← V0
}
----

//

[[ACE-chaining]]
==== Chaining/Feedback Modes

There is no need to explicitly architect the behavior of chaining modes, such as Cipher Block Chaining (CBC), Cipher Feedback (CFB) and Output Feedback (OFB) (all defined in cite:[nist-SP-800-38A-1]) as they are easily in software implemented on top of the ECB, with no intermediate value requiring confidentiality.

//

[[ACE-keystream-modes]]
==== CTR/LFSR/XCTR/XLFSR Keystream Generation

In the “non-X” modes, i.e., CTR mode and its analogue with an LFSR replacing the arithmetic counter, the sum of the lengths of IV and counter/LFSR equals the block size of the underlying keyed PRP or PRF. IV and counter/LFSR are concatenated to form the input to the latter.
(((ACE, algorithm, keystream generation)))

In the “X” modes, both IV and counter/LFSR have the same size as the block size of the underlying keyed PRP or PRF.
IV and counter/LFSR are ``xor``ed together to form the input to the keyed PRP or PRF.

===== Specification

Parameters:::
* `b` = block size (8|`b`). For this algorithm `IOLEN` must be a multiple of `b`.
* `k` = key size (8|`k`).
* `j` = counter size (8|`j`).
* `n` = IV size (8|`n`).
* If the mode is CTR or LFSR, it is `b = n + j`, else it is `b = n = j`.

Data Structures:::
* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.

* *Internal State*:
 ** `key`: `k` bits.
 ** `IV`: `n` bits.
 ** `ctr`: `j` bits.

* *Serialized Content*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.
 . `IV`: `n` bits.
 . `ctr`: `j` bits.

Algorithm-Specific Functions:::
* `keystream_block(p) -> c` -- usually an encryption function.
* `tick_ctr()` -- updates the `ctr` (either by a modular increment or a LFSR).

State Machine:::
* *States:*
  ** _initial_: The CC is ready.
  ** _operate_: In this state the CC will produce a keystream.

* *Allowed State Transitions:* any.

* *Behavior:*
 ** In State _initial_, the `ctr` and `IV` fields are set to 0 (`ctr` is set to 1 if the algorithm is LFSR-based).

 ** To transition to state _operate_, a Form C ``ace.state`` instruction must be issued.
  *** This sets the value of `IV` to `INPUT`.
  *** If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.

  ** In State _operate_, only Form C ``ace.exec`` instructions are allowed. +
     “```ace.exec OUTPUT, Kn|K[Xn]```” performs:
+
--
  . If in a CTR or LFSR mode then `tmp ← keystream_block(IV @ ctr)`, +
    else (i.e., if in a XCTR or XLFSR mode) `tmp ← keystream_block(IV xor ctr)`,
  . `tick_ctr()`, and
  . `OUTPUT ← tmp`.
--
+
If `IOLEN` is a multiple of `b`, the above three commands are applied to each of the `IOLEN/b` `b`-bit blocks of `INPUT`, producing each time the corresponding `b`-bit block of `OUTPUT`.
// If the number `x` of blocks to be processed in an entire run of the algorithm is not a multiple of `IOLEN`/`b`, `VL` can be set to the remainder of the division of `x` by `IOLEN`/`b` for the last instruction.

Note that if `ace.state` is issued to return to state _initial_, the CC can be reused with a new IV.

===== Usage

Example pseudocode is given in <<ACE-pseudocode-keystream-modes>> (for the case `b` = `IOLEN` = 128).

[[ACE-pseudocode-keystream-modes]]
.Encrypt with Keystream Generation
----
// Acquire payload, initialize
- Info: plaintext = *PT
- Process gets a Keystream Generation CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)

// The next operations set the nonce
V1 ← nonce
ace.state K0, #ace_state_operate, V1

// Compute keystream, use it to encrypt plaintext
foreach(i from 0 to len_in_bytes(PT)/16-1) {
   V0 ← PT[16*i .. 16*i+15]
   ace.exec V1, K0
   V1 ← V1 xor V0
   CT[16*i .. 16*i+15] ← V1
}
----

[[ACE-XEX-XTS-modes]]
==== XEX/XTS modes (one or two keys)

The XTS mode was designed for storage confidentiality cite:[DBLP-journals-ieeesp-Martin10]
and made into a Recommendation by NIST in 2010 cite:[nist-SP-800-38E].
XTS is based on the XEX construction, formalized by Phillip Rogaway cite:[DBLP-conf-asiacrypt-Rogaway04], to design _Tweakable Block Ciphers_ cite:[DBLP-conf-crypto-LiskovRW02].
A Tweakable Block Cipher (TBC) is a block cipher which, besides the key and the plaintext or ciphertext, also takes a tweak as input.
The tweak is used together with the key to select the permutation computed by the block cipher.

The XEX construction builds a TBC `Ẽ` from a block cipher `E`, with key `K`, tweak `T`, and plaintext `P`,  as follows: +
 +
`{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}`
`Ẽ(K, T, P) = E(K, P xor M) xor M` `{nbsp}{nbsp}` where `{nbsp}{nbsp}` `M = E(K, T)` `{nbsp}{nbsp}` is called a _mask_. +
 +
In XEX mode, once a mask is computed, it is then updated by using a Galois Multiplication for any successive block instead of updating the tweak and encrypting it again.

The NIST standard uses two different keys, one on the data encryption path and one for the encryption of the tweak.
The use of a single key or two independently sampled keys is determined by the algorithm, and it is not a configuration parameter for the algorithm.
We first define XEX mode functionality.
(((ACE, algorithm, XEX)))

===== Specification

Parameters:::

* `b` = block size (8|`b`). For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = key size (8|`k`).

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key1`: `k` bits, or 64 bits if a System Key index.
 . `key2`: `k` bits -- omitted if only one key is used or if both keys come from an entry in the SKT.

* *Internal State*:
 ** `key1`: `k` bits.
 ** `key2`: `k` bits -- omitted if only one key is used or if both keys come from an entry in the SKT.
 ** `mask`: `b` bits.

* *Serialized Content*:
[lowerroman]
 . `key1`: `k` bits, or 64 bits if a System Key index.
 . `key2`: `k` bits, omitted if only one key is used or if both keys come from an entry in the SKT.
 . `mask`: `b` bits.

Algorithm-Specific Functions:::

* `enc_blk(K, p) -> c` encrypts block `p` using the key `K`, and returns the result `c`.
* `dec_blk(K, c) -> p` decrypts block `c` using the key `K`, and returns the result `p`.
* `update_mask(mask) -> mask` updates the mask by a Galois Field multiplication in GF(2^b^).

State Machine:::

* *States:* _initial_, _encrypt_, and _decrypt_ (defined as before, cf. <<ACE-ECB-mode>>).

* *Allowed State Transitions:*
 ** _initial_ -> _encrypt_, if encryption is allowed, else the CR is *invalidated*.
 ** _initial_ -> _decrypt_, if decryption is allowed, else the CR is *invalidated*.
 ** _encrypt_, _decrypt_ -> _initial_.

* *Behavior:*
 ** In State _initial_:
  *** The `mask` field is set to zero.
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
 ** The ``ace.state`` instruction to transition to either _encrypt_ or _decrypt_ must be of Form C. +
    It sets the tweak, and the `mask` field is used to store it: `mask <- INPUT`.
  *** If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.
  *** Then, the following operations are performed:
  . if two independent keys are used then
  .. `mask <- enc_blk(key2, mask)`
  . else
  ..  `mask <- enc_blk(key1, mask)`
  ..  `mask <- update_mask(mask)`.

  ** In States _encrypt_ and _decrypt_, only ``ace.exec`` instructions of Form A are allowed. +
    “```ace.exec OUTPUT, Kn|K[Xn], INPUT```” performs the following operations:
+
--
  . In State _encrypt_, it computes `OUTPUT = mask xor enc_blk(key1, INPUT xor mask)`. +
    In State _decrypt_, it computes `OUTPUT = mask xor dec_blk(key1, INPUT xor mask)`.
  . `mask <- update_mask(mask)`.
--
+
If `IOLEN` is a multiple of `b`, the above commands are executed `IOLEN/b` times, processing each `b`-bit block of `INPUT` into a `b`-bit block of `OUTPUT`.
// If the number `x` of blocks to process is not a multiple of `IOLEN`/`b`, `VL` can be set to the remainder of the division of `x` by `IOLEN`/`b` for the last instruction.

//

Note that if `ace.state` is issued to return to state _initial_, the CC can be reused with a new tweak.

===== Usage

We provide only encryption pseudocode, decryption is similar
(also this example assumes `b` = `IOLEN` = 128).

[[ACE-pseudocode-basic-IV-mode]]
.Pseudocode for encryption in any IV-based non-authenticated mode without associated data
----
// Acquire payload and SCC, initialize
- Info: plaintext = *PT
- Call an API to get the corresponding SCC. Assume X5 is the pointer to it.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma          // Use 128-bit vectors
ace.import K0, (X5)

V0 ← IV
ace.state K0, #ace_state_encrypt, V1      // Configure CR for encryption
foreach(i from 0 to ceil(len_in_bytes(PT)/16)-1) {
   V0 ← PT[16*i .. 16*i+15]
   ace.exec V0, K0, V0                    // Encrypt one block of the plaintext
   CT[16*i .. 16*i+15] ← V0
}
----

To implement the XTS mode, the ciphertext stealing part is easy to realize using the XEX algorithm together with vector masking and shifting operations.
(((ACE, algorithm, XTS)))

[[ACE-tweakable]]
==== Generic Tweakable Blocks Ciphers

The specification of a generic tweakable block cipher is similar to that of a non-tweakable block cipher in ECB mode.
However, since `ace.exec` does not admit variants with two inputs, and we have a single input buffer, we need to set the tweak with a separate instruction.
If block and tweak sizes are different, a reconfiguration of the vector length may be required between operations.

Some commonly used TBCs are `Deoxys` cite:[Deoxys-141], `Skinny` cite:[DBLP-conf-crypto-BeierleJKL0PSSS16], `QARMA` cite:[DBLP-journals-tosc-Avanzi17], and ```QARMA```{empty}```v2``` cite:[DBLP-journals-tosc-AvanziBDEGNR23].

===== Specification

Parameters:::

* `b` = block size (8|`b`). For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = key size (8|`k`).
* `t` = tweak size (8|`k`).

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.

* *Internal State*:
 ** `key`: `k` bits.
 ** `tweak`: `t` bits.

* *Serialized Content*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.
 . `tweak`: `t` bits.

State Machine:::

* *States:*
 ** _initial_, _encrypt_, and _decrypt_ defined as before.
 ** _set_aux_value_, for setting the tweak value in the next encryption or decryption operation.

* *Allowed State Transitions:*.
 ** _initial_ -> _set_aux_value_
 ** _set_aux_value_ -> _encrypt_ -- if encryption is allowed, else the CR is *invalidated*.
 ** _set_aux_value_ -> _decrypt_ -- if decryption is allowed, else the CR is *invalidated*.

 * *Behavior:*
  ** In State _initial_:
   *** Upon entering the state, the `tweak` field is cleared.
  ** In each state, we can issue Form C `ace.state` instructions, i.e., ```ace.state Kn|K[Xn], #ace_state_set_aux_value, INPUT```, which perform:
   . `tweak` <- `INPUT`, and
   . _Instead of transitioning to state set_aux_value, the state remains unchanged (can be initial, encrypt, or decrypt)._
  ** In State _encrypt_, resp., _decrypt_, besides Form C `ace.state` instructions, only ``ace.exec`` instructions of Form A are allowed.
     “```ace.exec OUTPUT, Kn|K[Xn], INPUT```” encrypts, resp., decrypts `INPUT` into `OUTPUT`.

This algorithm does not automatically update the tweak value.

[[ACE-GCM-mode]]
==== GCM Mode

The GCM mode was designed by David McGrew and John Viega cite:[DBLP-conf-indocrypt-McGrewV04]
and was made into a NIST Recommendation in 2007 cite:[nist-SP-800-38D].
(((ACE, algorithm, GCM)))

===== Specification

Parameters:::

* `b` = block size (8|`b`). For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = key size (8|`k`).

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.

* *Internal State*:
 ** `key`: `k` bits.
 ** `ctr`:  `b` bits.
 ** `auth_key`, `tag`: `b` bits.

* *Serialized Content*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.
 . `ctr`: `b` bits.
 . `tag`: `b` bits.

NOTE: There are no fields for the lengths of the AD and of the plaintext, as they are maintained by the calling software.
Also, `hash_key` is not serialized, and thus it is recomputed upon `ace.import`.

Algorithm-Specific Functions:::

* `enc_blk(key, p) -> c` encrypts block `p` using the key, and returns the result `c`.

* `absorb(data)` absorbs data into the hash function by performing:
  . `tag <- tag xor INPUT`.
  . `tag <- Galoismul(tag, hash_key)`.

State Machine:::

* *States:*
 ** _initial_: The CC is ready.
 ** _hash_absorb_: Process Associated Data (AD) into the tag.
 ** _encrypt_: Encrypt the plaintext and absorb the ciphertext into the tag.
 ** _enc_tag_finalize_: Finalize the encryption tag, prepare to return its value.
 ** _decrypt_: Absorb the ciphertext into the tag and decrypt it.
 ** _dec_tag_finalize_: Finalize the encryption tag and keep it internally.
 ** _hash_verify_: Compare the tag against a user supplied value.
 ** _completed_: The algorithm has completed its operation correctly.

* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_.
 ** _hash_absorb_ -> _encrypt_ -- if encryption is allowed, else the CR is *invalidated*.
 ** _hash_absorb_ -> _decrypt_ -- if decryption is allowed, else the CR is *invalidated*.
 ** _encrypt_ -> _enc_tag_finalize_ -> _completed_.
 ** _decrypt_ -> _dec_tag_finalize_ -> _hash_verify_ -> _completed_.

* *Behavior:*
 ** In State _initial_ :
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
  *** The following initialization operations are performed:
   . `hash_key <- enc_blk(key, zeros(b))`,
   . `tag <- zeros(b)`, and
   . `ctr <- zeros(b)`.

 ** To transition to state _hash_absorb_:
 the ``ace.state`` instruction must be a Form C to set the IV, i.e., the fixed part of the counter.
 Other forms of  ``ace.state`` will raise an invalid instruction exception and the CR is *invalidated*. Then:
   . `ctr <- INPUT @ (b/4-1)b'0 @ 1`, i.e., the `b/4` most significant bits of `INPUT` are ignored, and the `b/4` least significant bits of `ctr` represent the integer 1.
  *** If the ``ace.state`` instruction is repeated, it will just update the counter again.
  *** If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.

 ** If the AD is empty, the user can immediately issue an ``ace.state`` instruction to start encrypting or decrypting, but the transition to state _hash_absorb_ is necessary anyway to initialize the counter.

 ** In State _hash_absorb_, only  ``ace.exec`` instructions of Form B are allowed.
 “```ace.exec Kn|K[Xn], INPUT```” absorbs a data block in `tag`, i.e.:
+
--
 . `absorb(INPUT)`.
--
+
If `IOLEN` > `b`, the above operation is executed `IOLEN/b` times.

** In State _encrypt_, only ``ace.exec`` instructions of Form A are allowed.
   “```ace.exec OUTPUT, Kn|K[Xn], INPUT```” encrypts `INPUT` into `OUTPUT`, and absorbs the ciphertext `OUTPUT` into the `tag`, namely:
+
--
  . If `ctr[b/4-1:0] = 0`, then
  ..  the CR is *invalidated*.
  . else
  .. `tmp <- INPUT xor enc_blk(key, ctr)`.
  .. `absorb(tmp)`.
  .. `ctr[b/4-1:0] <- ctr[b/4-1:0] + 1 % 2^b/4^`.
  .. `OUTPUT <- tmp`.
--
+
If `IOLEN` is a multiple of `b`, the above operations are executed `IOLEN/b` times, encrypting each `b`-bit block of `INPUT` into the corresponding `b`-bit block of `OUTPUT`.

** To transition to state _enc_tag_finalize_, a Form C `ace.state` instruction must be used to provide
the following value, which must be set by the software: +
 +
`{nbsp}{nbsp}{nbsp}INPUT <- bin(bit_length(AD), b/2) @ bin(bit_length(plaintext), b/2){nbsp}` . +
 +
The authentication tag is computed as follows:
+
--
  . `absorb(INPUT)`.
  . `tag <- tag xor enc_blk(key, ctr[b-1,b/4] @ zeros(b/4))`.
--
+
Finally, `tag` is returned in `OUTPUT`, and the state is changed to _completed_. +
If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.

** In State _enc_tag_finalize_, only ``ace.exec`` instructions of Form C are allowed. +
  “```ace.exec OUTPUT, Kn|K[Xn]```” writes the `tag` to `OUTPUT`, and the state transitions to _completed_.

** In State _decrypt_, only  ``ace.exec`` instructions of Form A are allowed. +
 ```ace.exec OUTPUT, Kn|K[Xn], INPUT``` absorbs the ciphertext `INPUT` into the `tag`, then decrypts `INPUT` into `OUTPUT`, namely:
+
--
  . If `ctr[b/4-1:0] == 0`, then
  .. the CR is *invalidated*.
  . else
  .. `absorb(INPUT)`.
  .. `OUTPUT  <- INPUT xor enc_blk(key, ctr)`.
  .. `ctr[b/4-1:0] <- ctr[b/4-1:0] + 1`.
--
+
If `IOLEN` is a multiple of `b`, the same behavior applies as in state _encrypt_, namely
the above operations are executed `IOLEN/b` times, decrypting each `b`-bit block of `INPUT` into the corresponding `b`-bit block of `OUTPUT`.

** To transition to state _dec_tag_finalize_, a Form C ``ace.state`` instruction must be used to provide
the following value, which must be set by the software: +
 +
 `{nbsp}{nbsp}{nbsp}INPUT <- bin(bit_length(AD), b/2) @ bin(bit_length(plaintext), b/2)` +
 +
The authentication tag is computed as follows:
+
--
  . `absorb(INPUT)`.
  . `tag <- tag xor enc_blk(key, ctr[b-1,b/4] @ zeros(b/4))`.
--
+
If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.

** To transition to state _hash_verify_, a Form C ``ace.state`` instruction must be used to provide
the value against which the internally computed tag must be compared:
   If the values match, then `aceerror` is set to _ace_err_ok_,
   else and `aceerror` is set to _ace_err_authentication_.
   The state transitions to _completed_.

** Upon completion of `ace.import`, the ACE unit recomputes `hash_key`, i.e.:
  . `hash_key <- enc_blk(key, zeros(b))`.

//

===== Usage

In <<ACE-pseudocode-GCM-encryption>> we show pseudocode for GCM encryption (again with `b` = `IOLEN` = 128).
The code assumes that both AD and plaintext (or the ciphertext for the decryption) are zero-padded to a multiple of `b` bits, in this case 128 bits.

[[ACE-pseudocode-GCM-encryption]]
.GCM Encryption
----
// Acquire payload, initialize
- Info: authenticated data = *AD, plaintext = *PT
- Process gets a GCM encryption CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)     //  Import, and compute the derived Authentication Key.

// The next operations set the nonce
ace.state K0, #ace_state_set_aux_value
V0 ← nonce
ace.exec K0, V0

// Compute AD contribution to Auth Data
ace.state K0, #ace_state_hash_absorb
foreach(i from 0 to len_in_bytes(AD)/16-1) {
   V0 ← AD[16*i .. 16*i+15]
   ace.exec K0, V0                              // Absorb it into hash
}

// Encrypt plaintext and continue computation of tag
ace.state K0, #ace_state_encrypt
foreach(i from 0 to len_in_bytes(PT)/16-1) {
   V0 ← PT[16*i .. 16*i+15]
   ace.exec V1, K0, V0
   CT[16*i .. 16*i+15] ← V1
}

// Finally, we absorb the lengths into tag, finalize it, and output it
V1 ← bin(len_in_bits(AD), 64) @ bin(len_in_bits(PT), 64)
ace.state K0, #ace_state_enc_tag_finalize, V1
ace.exec V2, K0                                 // V2 contains the finalized hash
----

GCM decryption differs from encryption as follows:
the roles of `PT` and `CT` are reversed,
states _encrypt_ and _enc_tag_finalize_ are replaced by states _decrypt_ and _dec_tag_finalize_,
and the last lines are as follows:

[[ACE-pseudocode-GCM-decryption-difference]]
.GCM Decryption
----
// Finally, we absorb the lengths into tag, finalize it, and verify it
ace.state K0, #ace_state_dec_tag_finalize
V1 ← bin(len_in_bits(AD), 64) @ bin(len_in_bits(CT), 64)
ace.exec V2, K0, V1                             // V2 contains the finalized hash

V1 ← tag_from_payload
ace.state K0, #ace_state_hash_verify, V1
ace.error X1
if (X1 != 0) then { handle error }       // do not use the plaintext if error occurred
----

//

===== Alternative Examples

GCM security is not compromised if `H` is revealed.
Consequently, an implementation based on a simpler ECB mode CC is possible, as shown below (for encryption only -- decryption is similar).
However, this significantly increases code size and requires implementing `Galoismul(V4, V3)`.
Adding a dedicated mode to the ACE unit is a minor effort, and it allows internal logic to optimize execution beyond the capabilities of, for instance, a compiler on an in-order CPU. It also means that the CPU does not have to implement the carry-less multiplication (<<ACE-V-dependency>>), and only a shared ACE unit has to,
which saves hardware costs when several small cores share a single ACE unit.

[[ACE-pseudocode-GCM-encryption-alternate]]
.Implementing GCM encryption using an ECB CC
----
// Acquire payload, initialize
- Info: authenticated data = *AD, plaintext = *PT
- Process gets an ECB encryption CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)                              // Imports SCC into CR K0
V5[127:32] ← IV
V5[31:0] ← zeros(31) @ 1

V3 ← zeros(b)                                    // “Auth Data 1”
ace.exec V4, K0, V3                              // compute H
foreach(i from 0 to ceil(len_in_bytes(AD)/16)-1) {
   V1 ← AD[16*i .. 16*i+15]
   V3 ← V3 xor V1                                // Horner scheme addition
   V3 ← Galoismul(V4, V3)                        // Horner scheme multiplication
}

counter ← 1                                      // a 32-bit integer value
foreach(i from 0 to ceil(len_in_bytes(PT)/16)-1) {
   V5[32:0] ← counter
   V1 ← PT[16*i .. 16*i+15]
   ace.exec V2, K0, V5                           // create mask by encrypting the counter
   V1 ← V1 xor V2                                // CTR encrypt
   V3 ← V3 xor V1                                // Horner scheme addition
   V3 ← Galoismul(V4, V3)                        // Horner scheme multiplication
   CT[16*i .. 16*i+15] ← V1
   counter ← counter + 1
}

V3 ← V3 xor (len_in_bits(AD) @ len_in_bits(PT))  // Horner scheme addition
V3 ← Galoismul(V4, V3)                           // Horner scheme multiplication
V5[31:0] ← zeros(31) @ 1                         // Prepare IV @ 1 for tag encryption
ace.exec V2, K0, V5
tag ← V3 xor V2                                  // Last Horner scheme add
----

[[ACE-GCM-with-IV-mode]]
==== GCM-with-set-IV

The mode of operation “GCM with a set IV” is a variant of the GCM mode where the initialization vector (IV) is predefined and not generated randomly.
This variant _cannot_ be emulated with an ECB CC because it would reveal the internal data.

The differences between GCM and GCM-with-set-IV start with the format of the Initialization Input:

* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.
 . `IV`: `3b/4` bits.
 . Padding: `b/4` bits, unless 256 divides `b`, in which case the II's length is already a multiple of 64 bits without this field.

* *State Machine Behavior:*

 ** To transition to state _hash_absorb_:
 the ``ace.state`` instruction must be used _without any additional inputs_, since the IV is already included in the II.

 ** Once in state _completed_, the CC with this algorithm *cannot* be brought back to state _initial_.
Other forms of  ``ace.state`` will raise an invalid instruction exception and the CR is *invalidated*.

These rules do not prevent cloning the CR at the beginning and reusing it, but, for decryption, it can only be used with the intended ciphertext.

NOTE: For all the following IV- or nonce-based modes, versions with a set IV or nonce (such as for GCM-SIV) can also be similarly defined.
For instance, for GCM-SIV (<<ACE-GCM-SIV-mode>>), `nonce` would be included in the II exactly as `IV` is included in the II for GCM, and the transition to _hash_absorb_ would also use a Form A ``ace.state``.
All other semantics would be unchanged.

[[ACE-GCM-SIV-mode]]
==== GCM-SIV mode

// [.red]#*TODO*: Add version with full# ```[.red]#b#```[.red]#-bits nonce?#

The GCM-SIV mode is described in cite:[DBLP-journals-iacr-GueronLL17] and cite:[RFC8452].

The GCM-SIV mode's main differences with GCM are that:

. Both encryption and authentication keys are derived from the main key, whereas in GCM the main key is used also for encryption;
. It is a MAC-then-Encrypt mode, whereas GCM is an Encrypt-then-MAC mode, therefore GCM-SIV is more amenable to Release of Unencrypted Plaintext (RUP) attacks;
. Encryption requires two passes over the plaintext, since the tag computed on the AD and plaintext is used also as the initialization vector for the CTR encryption.
(((ACE, algorithm, GCM-SIV)))

The third difference affects the state machine. While GCM-SIV's decryption state machine is similar to the GCM's, the encryption state machine is different:

* During encryption, the _hash_absorb_ state absorbs the entire associated data and plaintext. The _enc_tag_finalize_ state then absorbs the lengths and produces the SIV/tag. Finally, the _encrypt_ state performs a second pass to encrypt the plaintext using the SIV/tag as the initialization vector.
* During decryption, the _hash_absorb_ state absorbs only the associated data. The _decrypt_ state decrypts the ciphertext and simultaneously absorbs the plaintext into the hash. Finally, the _dec_tag_finalize_ state absorbs the lengths, produces the SIV/tag, and internally compares it to the provided SIV/tag.

===== Specification

Parameters:::

* `b` = block size, (8|`b`). For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = key size (8|`k`).
* It must be `k = b` or `k = 2b`.
* It must be established by the algorithm whether the authentication tag is `b` or `3b/4` bits long.
  In other words, there can be two variants.

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.

* *Internal State*:
 ** `key`, `enc_key`: `k` bits.
 ** `auth_key`: `b` bits.
 ** `nonce`: `3b/4` bits.
 ** `ctr`: `b/4` bits.
 ** `tag`: `b` bits.
 ** `SIV`: `b` or `3b/4` bits.
+
A `b`-bit `SIV` is computed by clearing the most significant bit of `tag` and encrypting it. +
For a `3b/4`-bit `SIV`, a full `b`-bit `tag` value is kept while absorbing data.
The public `SIV` value is computed by clearing the most significant bit of `tag`, encrypting it, and then removing the `b/4` least significant bits.

* *Serialized Content*:
[lowerroman]
 . `key`: `k` bits.
 . `nonce`, `3b/4` bits.
 . `ctr`, `b/4` bits.
 . `tag`, `b` bits.
 . `SIV`, `b` bits.

NOTE: The internal state fields `hash_key` and `auth_key` are not serialized, and must be recomputed upon each `ace.import`.

//

Algorithm-Specific Functions:::

* `enc_blk(key, p) -> c` encrypts block `p` using the key, and returns the result `c`.
* `absorb(data)` absorbs data into the hash function by performing a step of (a variant of) GHASH or POLYVAL as specified by the algorithm
   (for instance, AES-GCM-SIV uses POLYVAL):
  . `tag <- tag xor INPUT`.
  . `tag <- Montmul(tag, hash_key)` or `Galoismul(tag, hash_key)`, depending on the algorithm.

State Machine:::
* *States:*
 ** _initial_: The CC is ready.
 ** _set_aux_value:_ Set the value of `nonce`.
 ** _hash_absorb_: Set the SIV and process AD and, if encrypting, also the plaintext into the tag.
 ** _encrypt_: Encrypt the plaintext.
 ** _enc_tag_finalize_: Finalize the tag with the AD and PT lengths, prepare to return its value.
 ** _decrypt_: Absorb the ciphertext into the tag and decrypt it.
 ** _dec_tag_finalize_: Finalize the tag with the AD and CT lengths, then compare it against the `SIV`.
 ** _completed_: The algorithm has completed its operation.

* *Allowed State Transitions:*
 ** _initial_ -> _set_aux_value_ -> _hash_absorb_.
 ** For encryption: _hash_absorb_ -> _enc_tag_finalize_ -> _encrypt_.
 ** For decryption: _hash_absorb_ -> _decrypt_ -> _dec_tag_finalize_ -> _completed_.
 ** Transition to _encrypt_ possible only if encryption is allowed, else the CR is *invalidated*.
 ** Transition to _decrypt_ possible only if decryption is allowed, else the CR is *invalidated*.

* *Behavior:*
 ** In State _initial_ :
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
  *** The following initialization operations are performed:
   . (`enc_key`, `auth_key`) `<-` `RFC8452_KeyDeriv(key)`,
   . `nonce`, `ctr`, `tag`, `SIV <- 0`.

** Upon issuing a Form C ```ace.state Kn|K[Xn], #ace_state_set_aux_value, INPUT``` :
  *** The value of `nonce` is set to `INPUT`.
  *** (If the instruction is repeated, there is no harm, since it just overwrites the `nonce` before any other operation is performed.)

** Upon issuing a Form A or B ```ace.state Kn|K[Xn], #ace_state_set_aux_value```:
  *** An invalid instruction error is raised and the CR is *invalidated*.

** Upon issuing a Form C ```ace.state Kn|K[Xn], #ace_state_hash_absorb, INPUT```:
  *** The values of `SIV` is set to `INPUT`.
  *** NB: This version of the instruction is meant to be used during decryption.
      It is harmless to invoke it during encryption, however, as the `SIV` field will be overwritten later with the correct synthetic value.

** Upon issuing a Form A ```ace.state Kn|K[Xn], #ace_state_hash_absorb```:
  *** The `SIV` is not modified (it is assumed to be already zero).
  *** NB: This version of the instruction is meant to be used during encryption.
      If used during decryption, by leaving the `SIV` to zero it will most likely lead to an authentication error.

 ** Upon issuing a Form B ```ace.state Kn|K[Xn], #ace_state_hash_absorb, Xm```:
  *** An invalid instruction error is raised and the CR is *invalidated*.

 ** In State _hash_absorb_, only ``ace.exec`` instructions of Form B are allowed.
   This instruction absorbs its `INPUT` in the `tag`, i.e., it performs `absorb(INPUT)`. +
   If `IOLEN` is a multiple of `b`, `absorb()` is executed on each of the `IOLEN/b` blocks in `INPUT`.

** In State _enc_tag_finalize_, only an {nbsp}``ace.exec``{nbsp} instruction of Form A, are allowed.
The value
+
--
  *** `INPUT <- bin(bit_length(AD), b/2) @ bin(bit_length(plaintext), b/2)`,
--
+
is set by the user.
Then, “```ace.exec```” finalizes the SIV/tag computation by performing:
+
--
    . `absorb(INPUT)`.
    . `tmp <- enc_blk(enc_key, 0 @ (tag xor N)[b-2:0])`
    . If tag length is `b` bits, then
     .. `SIV <- tmp` and `OUTPUT <- tmp`,
    . else (tag length is `3b/4` bits)
     .. `SIV <- tmp[b-1:b/4]` and `OUTPUT <- (tmp >> b/4)`.
--
+

If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.

 ** In State _encrypt_, only  ``ace.exec`` instructions of the Form A are allowed, namely “```ace.exec OUTPUT, Kn|K[Xn], INPUT```,” to encrypt `INPUT` into `OUTPUT` as follows:
+
--
. If `ctr == 0`, then the CR is *invalidated*.
   . If the `SIV` is `b`-bits long, then
     .. ``OUTPUT <- INPUT `` +
        ``{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}xor enc_blk(enc_key, 1 @ SIV[b-2:b/4] @ (SIV[b/4-1:0] + ctr % 2^b/4^)),``
   . else (the `SIV` is `3b/4`-bits long)
      .. ``OUTPUT <- INPUT xor enc_blk(enc_key, 1 @ SIV[3b/4-2:0] @ ctr``.
   . `ctr <- ctr + 1`.
--
+
If `IOLEN` > `b`, the above operations are applied to each of the `IOLEN/b` blocks in `INPUT`.

 ** In State _decrypt_,  only Form A ``ace.exec`` instructions are allowed. “```ace.exec OUTPUT, Kn|K[Xn], INPUT```” decrypts `INPUT` into `OUTPUT` and then absorbs the plaintext `OUTPUT` into the `tag`:
+
--
     . If `ctr == 0`, then the CR is *invalidated*.
     . If the `SIV` is `b`-bits long, then +
       .. ``OUTPUT <- INPUT `` +
          ``{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}xor enc_blk(enc_key, 1 @ SIV[b-2:b/4] @ (SIV[b/4-1:0] + ctr % 2^b/4^))``,
     . else (it is `3b/4`-bits long) +
       .. ``OUTPUT <- INPUT xor enc_blk(enc_key, 1 @ SIV[3b/4-2:0] @ ctr``.
     . `absorb(OUTPUT)`.
     . `ctr <- ctr + 1`.
--
+
If `IOLEN` > `b`, the above operations are applied to each of the `IOLEN/b` blocks in `INPUT`.

 ** In State _dec_tag_finalize_,
   only an ``ace.exec`` instruction of Form B, are allowed,
   namely “```ace.exec Kn|K[Xn], INPUT```,” where it is the responsibility of the user to set
+
--
  ***  `INPUT <- bin(bit_length(AD), b/2) @ bin(bit_length(plaintext), b/2)`.
--
+
``ace.exec`` then performs the following operations:
+
--
  . `absorb(INPUT)` (which modifies `tag`).
  . `tmp <- enc_blk(enc_key, 0 @ (tag xor N)[b-2:0])`.
  . If tag length is `b` bits, then
     .. `tag <- tmp`,
  . else (tag length is `3b/4` bits)
     .. `tag <- tmp[3b/4-1:0] @ zeros(b/4)`.
    If `tag` and `SIV` match, `aceerror` is set to _ace_err_ok_, else `aceerror` is set to _ace_err_authentication_.
  . The state transitions to _completed_.
--
+
If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.

 ** Upon completion of `ace.import`, the ACE unit recomputes `enc_key` and `auth_key`, i.e.:
  . (`enc_key`, `auth_key`) <- `RFC8452_KeyDeriv(key)`.

//

===== Usage

We show in <<ACE-pseudocode-GCM-SIV-encryption>> how to perform AEAD encryption with a GCM-SIV CC (with `b` = `IOLEN` = 128).
<<ACE-pseudocode-GCM-SIV-decryption>> is the corresponding pseudocode for decryption.

[[ACE-pseudocode-GCM-SIV-encryption]]
.GCM-SIV Encryption
----
// Acquire payload, initialize
- Info: authenticated data = *AD
- Info: plaintext = *PT
- Call an API to get the corresponding key from a key management applet or HW block.
- The API returns the SCC. Assume X5 is the pointer to it.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)

// Set the nonce (and the derived Authentication Key).
ace.state K0, #ace_state_set_aux_value
V0 ← nonce
ace.exec K0, V0

foreach(i from 0 to len_in_bytes(AD)/16-1) {
   V0 ← AD[16*i .. 16*i+15]                      // Load a block of associated data
   ace.exec K0, V0                               // Absorb it into hash
}

foreach(i from 0 to len_in_bytes(PT)/16-1) {
   V0 ← PT[16*i .. 16*i+15]                      // Load a block of plaintext
   ace.exec K0, V0                               // Absorb it into hash
}

V0 ← bin(len_in_bits(AD), 64) @ bin(len_in_bits(PT), 64)
ace.exec K0, V0                                  // Absorb lengths into hash

// Finalize the SIV computation, set and return it
ace.state K0, #ace_state_enc_tag_finalize
ace.exec V2,K0
tag ← V2

// Encrypt the plaintext
ace.state K0, #ace_state_encrypt
foreach(i from 0 to len_in_bytes(PT)/16-1) {
   V0 ← PT[16*i .. 16*i+15]                      // Load a block of plaintext
   ace.exec V1, K0, V0                           // Encrypt the block
   CT[16*i .. 16*i+15] ← V1                      // Store a block of ciphertext
}
----

[[ACE-pseudocode-GCM-SIV-decryption]]
.GCM-SIV Decryption
----
// Acquire payload, initialize
- Info: authenticated data = *AD
- Info: ciphertext = *CT
- Call an API to get the corresponding key from a key management applet or HW block.
- The API returns the SCC. Assume X5 is the pointer to it.
- Allocate memory for plaintext buffer PT (if not same as CT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)

// The next operations set the nonce and SIV.
V0 ← nonce
ace.state K0, #ace_state_set_aux_value, V0

// Compute AD contribution to Auth Data
V0 ← SIV
ace.state K0, #ace_state_hash_absorb, V0
foreach(i from 0 to len_in_bytes(AD)/16-1) {
   V0 ← AD[16*i .. 16*i+15]
   ace.exec K0, V0                               // Absorb it into hash
}

// Decrypt ciphertext and continue computation of tag
foreach(i from 0 to len_in_bytes(CT)/16-1) {
   V0 ← CT[16*i .. 16*i+15]
   ace.exec V1, K0, V0
   PT[16*i .. 16*i+15] ← V1
}

// Finally, we absorb the lengths of AD and plaintext into tag AND verify
ace.state K0, #ace_state_enc_tag_finalize
V0 ← bin(len_in_bits(AD), 64) @ bin(len_in_bits(PT), 64)
ace.exec K0, V0
ace.error X1
if (X1 != 0) then { handle error }     // do not use the plaintext if error occurred
----

[[ACE-OCB-mode]]
==== OCB Mode

We only architect the OCB3 variant of OCB as specified in RFC{nbsp}7253 cite:[RFC7253] and cite:[DBLP-journals-joc-KrovetzR21].
While this algorithm is asymptotically more efficient than GCM and GCM-SIV, it has a much heavier setup and
its exported state, requires significantly more memory than the other modes.
On the other hand, since it uses only a single key and no derived keys, with ciphers with an expensive key expansion
like the AES it may use fewer internal resources.

The state machine of this algorithm closely follows RFC{nbsp}7253 (except for the ordering and numbering of the bit fields).
The algorithm and is of course identical to the RFC's for 128-bit-wide block ciphers, with the generalization to other widths being straightforward and according the security proof of the original algorithm and a lower bound on nonce length following cite:[cryptoeprint-2023-326].

===== Specification

Parameters:::
+
--
* `b` = block size. `b` is a power of two, at least 64. For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = key size, `b`|`k`.
--
+
Also, define `g` = `log_2(b)`.

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.

* *Internal State*:
 ** `key`: `k` bits.
 ** `N`: `u+1` bits (at most `u` bits are all used).
 ** `L`, `offset`, `hash_A`, `hash_P` : `b` bits.
 ** `N_len`, `tag_len`, `last_blk_len`: `g` bits.

* *Serialized Content*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.
 . `N`: `b` bits, but only `u+1` bits defined.
 . `L`: `b` bits.
 . `offset`: `b` bits.
 . `hash_A`: `b` bits.
 . `hash_P`: `b` bits.
 . `tag_len`: 16 bits
 . `last_blk_len`: 16 bits
 . `N_len` : 16 bits
 . padding : 16 bits

Algorithm-Specific Functions:::

* `enc_blk(K,p) -> c` encrypts block `p` using the key `K` and returns the result `c`.
* `dec_blk(K,c) -> p` decrypts block `c` using the key `K` and returns the result `p`.
* `double(S)`:
Let `C` be  `0x1B` for `b` = 64, `0x87` for `b` = 128, and `0x425` for `b` = 256, then: +
If S[`b`-1] == 0, then { `double(S)` <- `S << 1` } else { `double(S)` <- `(S << 1) xor C` } .

State Machine:::
* *States:*
 ** _initial_: The CC is ready.
 ** _set_aux_value:_ Set the length and the value of the nonce.
 ** _hash_absorb_: Set the tag length, and process the AD.
 ** _hash_finalize_: Set the length of the final block of the AD and process it.
 ** _encrypt_: Process the plaintext by absorbing it into the tag and encrypting it.
 ** _enc_last_block_: Provide the length of the last block of the plaintext, then absorb it into the tag and encrypt it.
 ** _enc_tag_finalize_: Return the tag.
 ** _decrypt_: Process the ciphertext by decrypting it and absorbing the plaintext into the tag.
 ** _dec_last_block_: Provide the length of the last block of the ciphertext, then decrypt it and absorb the plaintext into the tag.
 ** _hash_verify_: Compare a user-provided value with the internally computed tag.
 ** _completed_: The algorithm has completed its operation.

* *Allowed State Transitions:*
 ** _initial_ -> _set_aux_value_ -> _hash_absorb_ -> _hash_finalize_
 ** _hash_finalize_ -> _encrypt_ -- if encryption is allowed, else the CR is *invalidated*.
 ** _hash_finalize_ -> _decrypt_ -- if decryption is allowed, else the CR is *invalidated*.
 ** _encrypt_ -> _enc_last_block_ -> _enc_tag_finalize_ -> _completed_.
 ** _decrypt_ -> _dec_last_block_ -> _hash_verify_ -> _completed_.

* *Behavior:*
** In State _initial_ :
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
  *** The following initialization operations are performed:
   . `N <- 1 @ zeros(u)`.
   . `hash_A <- zeros(b)`
   . `hash_P <- zeros(b)`

** To move to _set_aux_value_, a Form A `ace.state` must be used, where the auxiliary argument `Xs` sets the nonce length `N_len`.
 `N_len` must be at least `g-1`. If not, or a different form of `ace.state` is used, then an invalid instruction error is raised, and the CR is *invalidated*.

** In State _set_aux_value_, only  ``ace.exec`` instructions of Form B, “```ace.exec Kn|K[Xn], INPUT```”, are allowed, whereby `N` is set to `INPUT`, namely
     `N <- zeros(u-N_len) @ INPUT[N_len-1:0]`
  *** If “```ace.exec Kn|K[Xn], INPUT```,” is repeated, it will rewrite `N`.
  *** If no such `ace.exec` is issued, `N` is not changed, which means that its most significant bit is 1.
      This condition results in an error when transitioning to _hash_absorb_.

** To move to _hash_absorb_, a Form A `ace.state` must be used, where the auxiliary argument `Xs` sets the tag length `tag_len`.
  *** If this argument (interpreted as an unsigned value) is larger than `b` or `0` (the latter occurs also if `X0` is passed as the auxiliary argument), an invalid instruction error is raised, and the CR is *invalidated*.
  *** If different Form of `ace.state` is used, then an invalid instruction error is raised, and the CR is *invalidated*.
  *** If `N[u] == 1`, this means that `N` was not set in state _set_aux_value_. We do not allow code that skips nonce setting, as this mode is not secure under nonce reuse, therefore in this case an invalid instruction error is raised, and the CR is *invalidated*.
  *** Following operations are performed:
  . `tag_len` <- `Xs`.
  . `offset <- zeros(b)`
  . `L <- enc_blk(key, zeros(b))`
  . `L <- double(double(L))`

** In State _hash_absorb_, only  ``ace.exec`` instructions of Form B are allowed:
  “```ace.exec Kn|K[Xn], INPUT```” absorbs a data block in `tag`, i.e.:
+
--
    . `L <- double(L)`
    . `offset <- offset xor L`
    . `hash_A <- hash_A xor enc_blk(key, INPUT xor offset)`
--
+
If `IOLEN` > `b`, the above operation is executed `IOLEN/b` times.

  *** If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.

** To move to _hash_finalize_, a Form B `ace.state` operation sets the length of the final block of the AD in `last_blk_len`.

** In State _hash_finalize_, only one `ace.exec` instructions of Form B is allowed if `last_blk_len` != `0`.
 “```ace.exec Kn|K[Xn], INPUT```” which absorbs the last data block in `tag`, i.e.:
+
--
  * `tmp : bits(b)`

[]
  . `offset <- offset xor enc_blk(key, zeros(b))`
  . `tmp <- (zeros(b-last_blk_len-1) @ 1 @ INPUT[last_blk_len-1:0]) xor offset`
  . `hash_A <- hash_A xor enc_blk(K, tmp)`
--
+
If `last_blk_len` == 0, however, no `ace.exec` can be executed, and only an `ace.state` instruction is allowed to enter state _encrypt_ or _decrypt_.

** Upon entering states `_encrypt_` or `_decrypt_`, the _setup_ and _init_ stages is performed:
+
--
 * `N_ext : bits(b)` (`N_ext` means “N, extended”)
 * `Stretch : bits(3b/2)`
 * `bot : bits(g-1)`
 * `Ktop : bits(b)`

[]
 . `offset <- zeros(b)`
 . `L <- enc_blk(key, zeros(b))`
 . `L <- double(double(L))`
 . `N_ext <- N[N_len-1:0] @ 1 @ zeros(b-g-1-N_len) @ bin(tag_len,g)`
 . `bottom <- int(N_ext[b-1:b-g+1])`   // Rogaway's paper number bits in opposite order
 . `Ktop <- enc_blk(key, zeros(g-1) @ N_ext[b-g:0])`
 . `Stretch <- (Ktop[b/2-1:0] xor Ktop[b/2+7:8]) @ Ktop`
 . `offset <- Stretch[b+bottom:bottom]`
--
+
** In State _encrypt_, only ``ace.exec`` instructions of Form A are allowed:
   “```ace.exec OUTPUT, Kn|K[Xn], INPUT```” absorbs the plaintext `INPUT` into the `tag` and encrypts `INPUT` into `OUTPUT`, namely:
+
--
 . `L <- double(L)`
 . `offset <- offset xor L`
 . `hash_P <- hash_P xor INPUT`
 . `OUTPUT <- offset xor enc_blk(key, INPUT xor offset)`
--
+
If `IOLEN > b`, the above operation sequence is executed `IOLEN/b` times, encrypting each `b`-bit block of `INPUT` into the corresponding `b`-bit block of `OUTPUT`.

** To move to _enc_last_block_, a Form B `ace.state` instruction must be used to set the bit length of the final block of the plaintext in `last_blk_len`.

** In State _enc_last_block_, only an ``ace.exec`` instruction of Form A “```ace.exec OUTPUT, Kn|K[Xn], INPUT```,”
are allowed if `last_blk_len` is nonzero.
In this case, following operations are performed:
+
--
 * `tmp : bits(last_blk_len)`
 * `tmp2 : bits(b)`
 * `aux : bits(b)`

[]
 . `aux <- enc_blk(key, zeros(b))`
 . `offset <- offset xor aux`
 . `tmp <- enc_blk(key, offset)[last_blk_len-1:0]`
 . `tmp <- INPUT[last_blk_len-1:0] xor tmp`
 . `OUTPUT <- zeros(b-last_blk_len) @ tmp`
 . `tmp2 <- (zeros(b-last_blk_len-1) @ 1 @ tmp) xor offset`
 . `aux <- double(aux)`
 . `hash_P <- enc_blk(key, hash_P xor tmp2 xor offset xor aux) xor hash_A`
--
+
On the other hand, if `last_blk_len` is zero, only an ``ace.exec`` instruction of Form D, “```ace.exec Kn|K[Xn]```,” is allowed, which performs:
+
--
* `aux : bits(b)`

[]
  . `aux <- enc_blk(key, zeros(b))`
  . `aux <- double(aux)`
  . `hash_P <- enc_blk(key, hash_P xor offset xor aux) xor hash_A`
--
+
In both cases the state then transitions to _enc_tag_finalize_.

** In State _enc_tag_finalize_, only an ``ace.exec`` instruction of Form C, “```ace.exec OUTPUT,Kn|K[Xn]```,” is allowed, which
performs `OUTPUT <- zeros(b-tag_len) @ hash_P[tag_len-1:0]`.

** In State _decrypt_, only ``ace.exec`` instructions of Form A are allowed.
    Such an ``ace.exec`` decrypts `INPUT` into `OUTPUT`, and absorbs the plaintext `OUTPUT` into the `tag`, namely:
+
--
  * `tmp : bits(b)`

[]
  . `L <- double(L)`
  . `offset <- offset xor L`
  . `tmp <- offset xor enc_blk(key, INPUT xor offset)`
  . `hash_P <- hash_P xor tmp`
  . `OUTPUT <- tmp`
--
+
If `IOLEN` > `b`, the same behavior applies as in state _encrypt_.

** To move to _dec_last_block_, a Form B `ace.state` operation must be used to set the bit length of the final block of the ciphertext in `last_blk_len`.

** In State _dec_last_block_, only an ``ace.exec`` instruction of Form A “```ace.exec OUTPUT, Kn|K[Xn], INPUT```,” is allowed if `last_blk_len` is nonzero.
In this case, the same operations as in state _enc_last_block_ are performed except for Line 6, which is instead
+
--
[start=6]
. `tmp2 <- (zeros(b-last_blk_len-1) @ 1 @ INPUT[last_blk_len-1:0]) xor offset`
--
+
and the state is changed to _hash_verify_.
+
If `last_blk_len` is zero, only an ``ace.exec`` instruction of Form D, “```ace.exec Kn|K[Xn]```,” is allowed, which performs the same operations as in state _enc_last_block_, except for the final state transition, which also in this case is to _hash_verify_.

** To complete the algorithm in the decryption branch, a Form C ``ace.state`` operation must be used to (confirm the)
transition to state _hash_verify_ and compare the `tag_len` least significant bits of `INPUT` with the `tag_len` least significant bits of `hash_P`:
+
--
  . If the values match, then `aceerror` is set to _ace_err_ok_,
  . else `aceerror` is set to _ace_err_authentication_.
  . The state transitions to _completed_.
--
+

//

===== Usage

Pseudocode for OCB encryption is given in <<ACE-pseudocode-OCB-encryption>> (again with `b` = `IOLEN` = 128).

[[ACE-pseudocode-OCB-encryption]]
.OCB Encryption
----
// Acquire payload, initialize
- Info:
 - authenticated data = *AD with bit length AD_len
 - plaintext = *PT with bit length PT_len
 - nonce N with bit length N_len
 - tag length tag_len

 - Process gets an OCB encryption CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero,4,e32,m1,ta,ma                        // Use 128-bit vectors
ace.import K0, (X5)

// The next operations set the nonce
X1 ← N_len
ace.state K0, #ace_state_set_aux_value, X1
V0 ← N
ace.exec K0, V0

// The next state change also sets the tag length
X1 ← tag_len
ace.state K0, #ace_state_hash_absorb, X1

AD_fullblocks ← floor(AD_len/128)
PT_fullblocks ← floor(PT_len/128)

// Compute AD contribution to tag
foreach(i from 0 to AD_fullblocks-1) {
   V0 ← AD[16*i .. 16*i+15]
   ace.exec K0, V0                                 // Absorb it into hash
}
X1 ← AD_len mod 128                                // Can be zero
ace.state K0, #ace_state_hash_finalize, X1
if (X1 mod 128 != 0) then {
   V0 ← zeros(128)
   V0 ← AD[AD_fullblocks*16 .. AD_fullblocks*16+ceil(X1/8)]
   ace.exec K0, V0                                 // Absorb it into hash and encrypt
}

// Encrypt plaintext and continue computation of tag
ace.state K0, #ace_state_encrypt
foreach(i from 0 to PT_fullblocks-1) {
   V0 ← PT[16*i .. 16*i+15]
   ace.exec V1, K0, V0
   CT[16*i .. 16*i+15] ← V1
}
X1 ← PT_len mod 128                                // Can be zero
ace.state K0, #ace_state_last_block, X1
if (X1 mod 128 != 0) then {
   V0 ← zeros(128)
   V0 ← PT[PT_fullblocks*16 .. PT_fullblocks*16+ceil(X1/8)]
   ace.exec V1, K0, V0                             // Absorb it into hash and encrypt
   CT[PT_fullblocks*16 .. PT_fullblocks*16+ceil(X1/8)] ← V1
} else
   ace.exec K0

ace.exec V1, K0                                    // output tag
----

OCB decryption differs from encryption as follows:
the roles of `PT` and `CT` are reversed,
states _encrypt_ and _enc_tag_finalize_ are replaced by states _decrypt_ and _dec_tag_finalize_,
and the last lines are as follows:

[[ACE-pseudocode-OCB-decryption-difference]]
.OCB Decryption
----

V1 ← tag
ace.state K0, #ace_hash_verify, V1
ace.error X1
if (X1 != 0) then { handle error }       // do not use the plaintext if error occurred
----

[[ACE-CMAC-mode]]
==== CMAC Functions

{empty}
(((ACE, algorithm, CMAC)))
CMAC is an algorithm for message authentication codes constructed from a block cipher.
It was designed by Tetsu Iwata and Kaoru Kurosawa and became a NIST recommendation in May 2005 cite:[nist-SP-800-38B].

===== Specification

Parameters:::

* `b` = block size (8|`b`).  For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = key size (8|`k`).

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits.

* *Internal State*:
 ** `key`: `k` bits.
 ** `hash`: `b` bits.
 ** `last_block_len`: 64 bits.

* *Serialized Content*:
[lowerroman]
 . `key`: `k` bits.
 . `hash`: `b` bits.
 . `last_block_len`: 64 bits.

Algorithm-Specific Functions:::

* `enc_blk(key, p) -> c` encrypts block `p` using the key `key`, and returns the result `c`.
* `gen_subkeys(K) -> (K1,K2)` generates subkeys `K1` and `K2` from the master key `K` as follows: +
Let `C` be `0x1B` for `b` = 64, `0x87` for `b` = 128, and `0x425` for `b` = 256, then

 . `L <- enc_blk(K, zeros(b))`
 . if (`msb(L){nbsp}{nbsp}== 0`) then
   { `K1 <- L{nbsp}{nbsp}<< 1` }
   else
   { `K1 <- (L{nbsp}{nbsp}<< 1) xor C` }.
 . if (`msb(K1){nbsp}== 0`) then
   { `K2 <- K1{nbsp}<< 1` }
   else
   { `K2 <- (K1{nbsp}<< 1) xor C` }.
 . return ```(K1, K2)```.

State Machine:::

* *States:*
 ** _initial_: The CC is ready.
 ** _hash_absorb_: Absorb data into the CMAC function.
 ** _hash_last_block_: Set the length of the last block to absorb, then absorb it.
 ** _hash_output_: Output the CMAC.
 ** _completed_: The CC has completed the CMAC operation.

* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_ -> _hash_last_block_ -> _hash_output_ -> _completed_.
 ** From any valid state to state _initial_.
* *Behavior:*
 ** In State _initial_:
  *** `last_block_len <- zeros(64)`
  *** `hash <- zeros(b)`
  *** No {nbsp}```ace.exec```{nbsp} operation is allowed.

 ** In State _hash_absorb_, we can only issue ``ace.exec`` instructions of Form B. +
 “```ace.exec Kn|K[Xn], INPUT```,” absorbs the data block `INPUT` into the hash as follows:
+
--
   . `hash <- enc_blk(key, hash xor INPUT)`.
--
+
If `IOLEN` > `b`, then the above operations are applied to each `b`-bit block of `INPUT`.

 ** Upon issuing a Form B “```ace.state Kn|K[Xn], #ace_state_last_block, Xs```” where `Xs` contains the bit length of the last block, the following happens:
   . if `last_block_len` != 0, then the CR is *invalidated*. (The previous block is not complete.)
   . if `Xs > b` then the CR is *invalidated*.
   . `last_block_len <- Xs`.

 ** In State _hash_last_block_,  we can only issue a single ``ace.exec`` instruction of Form B, i.e., “```ace.exec Kn|K[Xn], INPUT```”, to absorb the data block `INPUT`. If `IOLEN` > `b`, only the least significant `b` bits of `INPUT` are considered.
+
--
  . `(K1, K2) <- gen_subkeys(key)`.
  . if `last_block_len` == `b`, then
    .. `tmp <- hash xor INPUT xor K1`
  . else
    .. `tmp <- INPUT`
    .. Remove the `b` - `last_block_len` most significant bits of `tmp` and pad the resulting value with a `1` and sufficiently many `0` bits to make it `b` bits long.
    .. `tmp <- hash xor tmp xor K2`
  . `hash <- enc_blk(key, tmp)`
  . The state is changed to _hash_output_.
--
+

** In State _hash_output_, we can issue one ``ace.exec`` instruction of Form C, i.e., “```ace.exec OUTPUT, Kn|K[Xn]```”, to output the hash into `OUTPUT`.
   If `IOLEN` > `b`, only the bits of `OUTPUT` beyond the `b`-th are cleared.
   Upon issuing that instruction, the CC transitions to state _completed_ with no error.

//

===== Usage

[[ACE-pseudocode-CMAC]]
.CMAC Computation
----
- Info: CMAC input = *M with bit length M_len
- Process gets a CMAC CC from an API. Assume X5 is the pointer to the CC.

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)

ace.state K0, #ace_hash_absorb
blocks = floor(M_len/128)
remainder = M_len % 128
if remainder == 0 then
   blocks ← blocks - 1
   remainder ← 128

foreach(i from 0 to blocks-1) {
   V0 ← M[16*i .. 16*i+15]
   ace.exec K0, V0
}

X1 ← remainder
ace.state K0, #ace_hash_last_block, X1
V0 ← M[16*blocks .. 16*blocks+15]
ace.exec K0, V0

ace.state K0, #ace_hash_hash_finalize
ace.exec V0, K0  // this is the value of the CMAC
----

[[ACE-hash-functions]]
==== Hash and MAC Functions, and XOFs

{empty}
(((ACE, algorithm, general hashing)))
(((ACE, algorithm, MAC functions)))
(((ACE, algorithm, XOF)))
This section defines an interface for hash and MAC functions.
Because of the vast variety of such functions, we cannot define a completely general interface.
However, the interface defined here is sufficiently general to allow to describe most commonly used and standardized functions, such as
the SHA2 cite:[nist-fips-180-4], SHA3 and SHAKE cite:[nist-fips-202], as well HMAC cite:[nist-fips-198-1] keyed constructions, and many others.

===== Specification

Parameters:::

* `b` = block size (8|`b`). This is the size of an absorbed block and may be different from the size of the internal state that is kept by the function. For a sponge function, this value is the _rate_.
* `t` = tag len (8|`t`). This is the size of the digest, or of the block that is output each time in a XOF. The present description assumes `t` {le} `b`.
* `n` = size of the internal state that is kept by the function (8|`n`).  For a sponge function, `n-b` is the _capacity_ of the function.
Either the block size is an integer multiple of the vector length or the vector length is an integer multiple of the block size.
* `k` = key size (8|`k`). Present only if keyed, i.e., a MAC.

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits. Present only if keyed, i.e., a MAC.

* *Internal State*:
 ** `key`: `k` bits. Present only if keyed, i.e., a MAC.
 ** `state`: `n` bits.
 ** `last_block_len`: int. Present only if this Hash/MAC has special internal treatment for a fractional last block that goes beyond padding and appending the length, which are handled by user software  (field size at most 16 bits).
 ** `input_base`: int. Offset within input/output to read from/write to (field size at most 16 bits).
 ** `block_base`: int. Length of absorbed data so far for the current block (field size at most 16 bits). Only if used by the algorithm.
 ** `cumul_len`: int. Cumulative length of data absorbed so far (if the algorithm must process and incorporate it in the hash on its own).
 ** `block`: `b` bits.  We include it only if there is a partial block, i.e., for instance if the absorbed unit is larger than a normally available vector size or not a submultiple thereof, and is not directly absorbed into `state`.

* *Serialized Content*:
[lowerroman]
 . `key`: `k` bits. Present only if keyed, i.e., a MAC.
 . `state`: `n` bits.
 . `last_block_len`: 16-bit unsigned int. Only if this Hash/MAC has special internal treatment for a fractional last block that goes beyond padding and appending the length, which are handled by user software. Otherwise, this is zero.
 . `block_base`: 16-bit unsigned int. Amount of data stored so far into `block`.  Only if used by the algorithm, else zero padding.
 . `cumul_len`: 32-bit unsigned int. Cumulative length of all data absorbed so far. Only if the algorithm must process and incorporate it in the hash on its own, else zero padding.
 . `block`: `b` bits.
    We include it in a SCC only if there is a partial block, and exclude it when not.
    We reuse the most significant bit of the `state` field to store this information.
    (In theory, we could include only the part filled so far, but this would complicate the parsing of a SCC.)

NOTE: Regarding the `last_block_len`/`block_base`/`cumul_len` group: if any of these fields is not used, it is replaced by a corresponding padding block.
If all three are not used by the hashing algorithm, then the 64-bit block is omitted.

Algorithm-Specific Functions:::

* `absorb()`: process `block` into the hash or MAC. This may include, for instance, state update operations.
* `absorb_last_block()`: process `block` into the hash or MAC, using the function for the last block.
* `finalize()`: process the `state` into the digest value. We assume this either re-uses `block` (the entire digest, or a unit of XOF output should not be be bigger than that) or the digest will be part of `state`
* `update()`: updates the `state` during the digest output stage.

State Machine:::

* *States:* _initial_, _hash_absorb_, _hash_last_block_, _hash_output_ and _completed_.

 ** _initial_: The CC is ready.
 ** _hash_absorb_: Absorb data into the hash function.
 ** _hash_last_block_: Set the length of the last block to absorb, then absorb it.
 ** _hash_output_: Output the hash.
 ** _completed_: The CC has completed the operation (XOF's do not have this state).

* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_ -> _hash_last_block_ -> _hash_output_ -> _completed_.
 ** From any valid state to state _initial_.

* *Behavior:*
 ** In State _initial_:
  *** `last_block_len`, `block_base` and `block` are set to zero.
  *** `state`: the initial value is set as specified by the algorithm.
  *** Any `ace.exec` will result in the CR being *invalidated*.

 ** In State _hash_absorb_, we can only issue ``ace.exec`` instructions of Form B, i.e., +
 “```ace.exec Kn|K[Xn], INPUT```”, to absorb the data block `INPUT` into the hash as follows.
+
--
  . `input_base <- 0` // or `acestart` upon resumption
  . while `(input_base < IOLEN)` do { // as long as we have input to process
  .. `amount <- min(IOLEN-input_base, b-block_base)`
  .. ``block[block_base + amount - 1 : block_base] <-`` +
      ``{nbsp}{nbsp}{nbsp}{nbsp} <- INPUT[input_base + amount - 1 : input_base]`` +
        ``{nbsp}{nbsp}``(If there is no `block` field, could also be something like +
        ``{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}state[block_base + amount - 1 : block_base] <- `` +
        ``{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}<- state[block_base + amount - 1 : block_base] + `` +
        ``{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}+ INPUT[input_base + amount - 1 : input_base]`` , +
        ``{nbsp}{nbsp}{nbsp}``it could directly replace part of `state`, or some other function.)
  .. `input_base <- input_base + amount`
  .. `block_base <- block_base + amount`
  .. if (`block_base` == `b`) then { // it's time to absorb the block
  ... `absorb()`
  ... `block_base <- 0`
  ... *Here* the instruction may be interrupted, with `acestart <- input_base`.
  .. }
  . }
--
+

//
 ** Upon issuing a Form B “`ace.state Kn|K[Xn], #ace_state_hash_last_block, Xs`” where `Xs` contains the length of the last block, the following happens:
+
--
 . if `block_base` != 0, then the CR is *invalidated*. (The previous block is not complete.)
 . if `Xs > b`, then the CR is *invalidated*.
 . if `Xs == 0`, then the CR is *invalidated*.
 . `last_block_len <- Xs`.
--
+
Then, state transitions to _hash_last_block_ as expected.

 ** State _hash_last_block_ is very similar to _hash_absorb_, the differences being:
  *** `last_block_len` is used in place of `b` throughout.
  *** `absorb_last_block()` is called instead of `absorb()` in Step 3.d.i.
  *** The instruction is terminated after `absorb_last_block()`–only one block is absorbed–and the state transitions to _hash_output_.

 ** In State _hash_output_ we have two possible situations: we are in a hash function or in a XOF.
  *** Upon entering the state, the following operations are first performed:
  . `block[t - 1 : 0] <- finalize()`
  . `block_base <- 0`
 *** For each Form C `ace.exec` instruction “`ace.exec OUTPUT, Kn|K[Xn]`”, the following operations are performed:
+
--
    * `amount : int`, `{nbsp}` amount of data to copy from `block` to `OUTPUT`
    * `#define output_base input_base`

[]
   . `output_base <- 0` // or `acestart` upon resumption
    . while (`output_base` < `IOLEN`) do { // as long as there is room in the OUTPUT
     .. `amount` <- `min(IOLEN - output_base, t - block_base)`
     .. ``OUTPUT[output_base + amount - 1 : output_base] <- `` +
           ``{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}<- block[block_base + amount - 1 : block_base + amount]``
     .. `output_base <- output_base + amount`
     .. `block_base <- block_base + amount`
     .. if (`block_base` == `t`) then {
      ... if we are in a Hash function, transition to _completed_, and return.
      ... `update()`
      ... `block_base <- 0`
      ... *Here* the instruction can be interrupted, with `acestart <- output_base`.
    .. }
    . }
--
+

//

[[ACE-SHA-3]]
==== SHA-3 Family Specific Rules

{empty}
(((ACE, algorithm, SHA-3)))
We describe here the algorithms for the primitives in the SHA-3 family, which currently includes SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128 and SHAKE256.
These primitives are designed around a special parameter choice of KECCAK cite:[DBLP-conf-eurocrypt-BertoniDPA13] standardized by NIST cite:[nist-fips-202].
These are instantiations of the algorithm specified in <<ACE-hash-functions>>, and we need to
describe only the differences with respect to the behavior described there.

Parameters:::

* `b` = rate (8|`b`). It can be 1600 - `c` with `c` = 448, 512, 768, or 1024 being the capacity.
* `n` = 1600
* `t` = `c/2`

Data Structures:::

* *Initialization Input*: the content is empty, i.e., there is only the metadata section.

* *Internal State*:
 ** `state`: `n` bits.
 ** `last_block_len`: int.
 ** `input_base`: int.
 ** `block_base`: int.

* *Serialized Content*:
[lowerroman]
 . `state`: `n` bits.
 . `last_block_len`: 16-bit unsigned int.
 . `block_base`: 16-bit unsigned int. Amount of data placed so far into `block`.
 . padding: 32 bits.

Algorithm-Specific Functions:::
 * `P()`, computes `KECCAK-p[1600, 24]` on `state`.
 * `absorb()`: in this case there is no explicit operation to copy data into `state`, as the inputs will be directly XORed into it, however `absorb` applies `P()` to the state.
 * `absorb_last_block()`: this is a NOP.
 * `finalize()`: this is a NOP.
 * `update()`: updates the `state` during the digest output stage.  It applies `P()` to the state.

State Machine:::
* *States:* _initial_, _hash_absorb_, _hash_last_block_, _hash_finalize_, _hash_output_ and _completed_.

* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_ -> _hash_last_block_ -> _hash_finalize_ -> _hash_output_ -> _completed_.
 ** From any valid state to state _initial_.

* *Behavior:*
 ** In State _initial_, `state` is zeroed.
 ** In State _hash_absorb_, the input data is directly XORed to `state`.
 ** In State _hash_last_block_, the input data is directly XORed to `state`.
 ** Upon transitioning to state _hash_output_:
  . The suffix and padding string `S` is generated.
  . If the bit length of `S` is `b-block_base`:
   .. `S` is directly XORed to rate part of the state, and
   .. `P()` is applied.
  . If the bit length of `S` is `2b-block_base`:
   .. The first `b-block_base` bits are XORed to the rate part of the state,
   .. `P()` is applied,
   .. the remaining `b` bits are XORed to the rate part of the state, and
   .. `P()` is applied again.

The rest of the algorithm follows <<ACE-hash-functions>>.

//

[[ACE-Ascon]]
==== Ascon Specific Rules

{empty}
(((ACE, algorithm, Ascon)))
We now describe the state machines of the various Ascon-based cite:[DBLP-journals-joc-DobraunigEMS21] algorithms standardized by the NIST cite:[nist-SP-800-232].

[WARNING]
====
In all ASCON algorithms, the ordering of the bits must be verified!
====

[[ACE-Ascon-AEAD128]]
===== Ascon-AEAD128

In this mode it is the responsibility of the user to apply proper padding to the AD and plaintext.
The inputs are therefore assumed to be properly padded.
Similarly, it is the responsibility of the user to remove the padding from the decryption of the ciphertext to recover the original plaintext.

Parameters:::

* `b` = 128. For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = 128.

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: 128 bits, or 64 bits if a System Key index.

* *Internal State*:
 ** `key`: 128 bits, or 64 bits if a System Key index.
 ** `state[0 .. 4]`: five 64-bit words, i.e., 320 bits.
 ** `tag_len`: 8 bits as int.
 ** `last_block_len`: 9 bits as int.
 ** `AD_empty`: boolean;

* *Serialized Content*:
[lowerroman]
 . `key`: 128 bits, or 64 bits if a System Key index.
 . `state[0 .. 4]`: five 64-bit words, i.e., 320 bits.
 . padding: 32 bits.
 . `last_block_len`: 16 bits.
 . `tag_len`: 16 bits

Algorithm-Specific Functions:::

* `ASCON(p)` applies `p` rounds of ASCON to the `state`.

State Machine:::

* *States:*
 ** _initial_: The CC is ready.
 ** _hash_absorb_: Set the nonce, and process the AD.

 ** _encrypt_: Encrypt the plaintext.
 ** _enc_last_block_: Encrypt the last block of the plaintext.
 ** _hash_output_: Return the tag.

 ** _decrypt_: Decrypt the ciphertext.
 ** _dec_last_block_: Decrypt the last block of the ciphertext.
 ** _hash_verify_: Compare a user-provided value with the internally computed tag.

 ** _completed_: The algorithm has completed its operation.

* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_.
 **  _hash_absorb_ -> _encrypt_ -- if encryption is allowed, else the CR is *invalidated*.
 **  _hash_absorb_ -> _decrypt_ -- if decryption is allowed, else the CR is *invalidated*.
 ** _encrypt_ -> _enc_last_block_ -> _hash_output_ -> _completed_.
 ** _decrypt_ -> _dec_last_block_ -> _hash_verify_ -> _completed_.

* *Behavior:*
** In State _initial_ :
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
  *** The following initialization operations are performed:
   . `state[0] <- 0x00001000808c0001`
   . `state[1] <- key[63:0]`
   . `state[2] <- key[127:64]`
   . `state[3] <- zeros(64)`
   . `state[4] <- zeros(64)`
   . `tag_len <- 128`
   . `AD_empty` <- `true`

** To transition to state _hash_absorb_, a Form C ``ace.state`` must be used, whose `INPUT` sets the nonce of the algorithm as follows:
+
--
  . `state[3] <- INPUT[63:0]`
    . `state[4] <- INPUT[127:64]`
    . `ASCON(12)`
    . `state[3] <- state[3] xor key[63:0]`
    . `state[4] <- state[4] xor key[127:64]`
--
+
If `IOLEN` > 128, only the 128 least significant bits of `INPUT` are considered.

** In State _hash_absorb_, only  ``ace.exec`` instructions of Form B are allowed.
 “```ace.exec Kn|K[Xn], INPUT```” absorbs a data block into the state, i.e.:
+
--
 . `AD_empty` <- `false`
 . `ASCON(8)`
 . `state[0] <- state[0] xor INPUT[63:0]`
 . `state[1] <- state[1] xor INPUT[127:64]`
--
+
If `IOLEN` > 128, these operations are executed `IOLEN/128` times, once for each 128-bit block of `INPUT`.
** Upon entering state _encrypt_ or _decrypt_, the following domain separation operation is performed:
 . `lsb(state[4]) <- lsb(state[4]) xor 1`

** In State _encrypt_, only ``ace.exec`` instructions of Form A are allowed.
   “```ace.exec OUTPUT, Kn|K[Xn], INPUT```” encrypts `INPUT` into `OUTPUT`, namely:
+
--
 . `state[0] <- state[0] xor INPUT[63:0]`
 . `state[1] <- state[1] xor INPUT[127:64]`
 . `OUTPUT <- state[0] @ state[1]`
 . `ASCON(8)`
--
+
If `IOLEN` is a multiple of 128, these operations are executed `IOLEN/128` times, encrypting each 128-bit block of `INPUT` into the corresponding 128-bit block of `OUTPUT`.

** In State _enc_last_block_, only one ``ace.exec`` instruction of Form A, to encrypt the last block is allowed.
“```ace.exec OUTPUT, Kn|K[Xn], INPUT```”  performs
+
--
 . `state[0] <- state[0] xor INPUT[63:0]`
 . `state[1] <- state[1] xor INPUT[127:64]`
 . `OUTPUT <- state[0] @ state[1]` // only the 128 lsb's of `OUTPUT` are written to.
 .  The state machine then transitions to state _hash_output_.
--
+
In this state only one 128-bit block is processed. +
The differences between the operation of `ace.exec` in this state and in state _encrypt_ are the absence of the final `ASCON(8)` and the automatic transition to state _hash_output_.

** In State _hash_output_, only one ``ace.exec`` instruction of Form C, to compute the tag, is allowed.
“```ace.exec OUTPUT, Kn|K[Xn]```”  performs
+
--
 . `state[2] <- state[2] xor key[63:0]`
 . `state[3] <- state[3] xor key[127:64]`
 . `ASCON(12)`
 . `state[3] <- state[3] xor key[63:0]`
 . `state[4] <- state[4] xor key[127:64]`
 . `OUTPUT <- state[3] @ state[4]` // only the 128 lsb's of `OUTPUT` are written to.
 . The state machine then transitions to state _completed_.
--
+
In this state only one 128-bit block is processed.

** In State _decrypt_, only  ``ace.exec`` instructions of Form A are allowed., i.e.,
 `ace.exec OUTPUT,Kn|K[Xn],INPUT`. This operation performs:
+
--
* `tmp : bits(128)`

[]
. `tmp <- (state[0] xor INPUT[63:0]) @ (state[1] xor INPUT[127:64])`
. `state[0] <- INPUT[63:0]`
. `state[1] <- INPUT[127:64]`
. `ASCON(8)`
. `OUTPUT <- tmp`
--
+
If `IOLEN` is a multiple of 128, these operations are executed `IOLEN/128` times, decrypting each 128-bit block of `INPUT` into the corresponding 128-bit block of `OUTPUT`.

** In State _dec_last_block_, only a Form A ``ace.exec`` instruction is allowed, .
“```ace.exec OUTPUT, Kn|K[Xn], INPUT```” performs:
+
--
* `tmp : bits(128)`

[]
. `tmp <- (state[0] xor INPUT[63:0]) @ (state[1] xor INPUT[127:64])`
. `state[0] <- INPUT[63:0]`
. `state[1] <- INPUT[127:64]`
. The state machine transitions to state _hash_verify_.
. `OUTPUT <- tmp`
--
+

** In State _dec_tag_finalize_, a form B `ace.state Kn|K[Xn], #ace_const_dec_tag_finalize, Xs` instruction may be executed, setting
the tag len `tag_len` to the value of `Xs`, provided it is not smaller than 32 and not larger that 128.
If the value is out of bounds, the instruction raises an invalid instruction error and the CR is *invalidated*.

** In State _hash_verify_, only one ``ace.exec`` instruction of Form D, to verify the tag, is allowed, .
“```ace.exec Kn|K[Xn], INPUT```” performs
+
--
. `state[2] <- state[2] xor key[63:0]`
. `state[3] <- state[3] xor key[127:64]`
. `ASCON(12)`
. `state[3] <- state[3] xor key[63:0]`
. `state[4] <- state[4] xor key[127:64]`
. `INPUT[tag_len-1:0]` is compared to `(state[3] @ state[4])[tag_len-1:0]` and the
. If the values match, then `aceerror` is set to _ace_err_ok_,
  else `aceerror` is set to _ace_err_authentication_. The state is changed to _completed_.
--
+

//

[[ACE-Ascon-AEAD128-wsn]]
===== Ascon-AEAD128-with-set-nonce

Similarly to GCM-with-set-IV, also Ascon-AEAD128 can be made in a version with a set nonce.
In this case the state _set_aux_value_ is skipped, and the II has the following form.

* *Initialization Input*:
[lowerroman]
 . `key`: 128 bits, or 64 bits if a System Key index.
 . `nonce`: 128 bits.

In State _initial_, words 3 and 4 of `state` are initialized thus:

. `state[3] <- nonce[63:0]`
. `state[4] <- nonce[127:64]`

Once in state _completed_, the CC cannot be brought back to state _initial_.

//

[[ACE-Ascon-AEAD128-N-masking]]
===== Ascon-AEAD128 with Nonce Masking

The NIST specification also described a version of Ascon-AEAD128 with _Nonce Masking_.
This variant is described as follows:

* *Initialization Input*:
[lowerroman]
 . `K1`: 128 bits, or 64 bits if a System Key index.
 . `K2`: 128 bits, omitted if a System Key is used.

* *Internal State*:
 . `K1`: 128 bits, or 64 bits if a System Key index.
 . `K2`: 128 bits, omitted if a System Key is used.
 ** `state[0 .. 4]`: five 64-bit words, i.e., 320 bits.
 ** `tag_len`: 8 bits.

* *Serialized Content*:
[lowerroman]
 . `K1`: 128 bits, or 64 bits if a System Key index.
 . `K2`: 128 bits, omitted if a System Key is used.
 . `state[0 .. 4]`: five 64-bit words, i.e., 320 bits.
 . `tag_len`: lower 8 bits in a 64 bit field.

The algorithm has the same states as Ascon-AEAD128 as described in <<ACE-Ascon-AEAD128>>, with the key `key` equal to `K1` and the nonce `N` replaced throughout by `N xor K2`.

For encryption and decryption with both nonce masking and a set nonce, the algorithm described in <<ACE-Ascon-AEAD128-wsn>> is used, giving `K1` as the key `key` and providing `N xor K2` as the nonce value.

[[ACE-Ascon-Hash256]]
===== Ascon-Hash256

In this mode it is the responsibility of the user to apply proper padding to the inputs.

Parameters:::

* `b` = 64. For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = 128.

Data Structures:::

* *Initialization Input*:
(no content)

* *Internal State*:
 ** `state[0 .. 4]`: five 64-bit words, i.e., 320 bits.
 ** `countdown` : integer going from 3 down to 0.

* *Serialized Content*:
[lowerroman]
 . `state[0 .. 4]`: five 64-bit words, i.e., 320 bits.
 . `countdown` : integer going from 3 down to 0. Stored in a 64-bit field.

Algorithm-Specific Functions:::

* `ASCON(p)` applies `p` rounds of ASCON to the `state`.

State Machine:::

* *States:* _initial_, _hash_absorb_, _hash_finalize_, and _completed_.

* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_ -> _hash_finalize_ -> _completed_.

* *Behavior:*
 ** In State _initial_ :
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
  *** The following initialization operations are performed:
   . `state[0] <- 0x0000080100cc0002`
   . `state[1] <- zeros(64)`
   . `state[2] <- zeros(64)`
   . `state[3] <- zeros(64)`
   . `state[4] <- zeros(64)`
   . `ASCON(12)`

  ** In State _hash_absorb_, only  ``ace.exec`` instructions of Form B are allowed.
 “```ace.exec Kn|K[Xn], INPUT```” absorbs a data block into the state, i.e.:
+
--
 . `state[0] <- state[0] xor INPUT`
 . `ASCON(12)`
--
+
If `IOLEN` > `64`, these operations are executed `IOLEN/64` times, once for each `64`-bit block of `INPUT`.

** Upon entering _hash_finalize_, `countdown` is set to 3.

** In State _hash_finalize_, at most four ``ace.exec`` instructions of Form C are allowed.
To compute the tag, “```ace.exec OUTPUT, Kn|K[Xn]```”  performs
+
--
. `ASCON(12)`
. `OUTPUT <- state[0]`
. if `countdown == 0` then transition to state _completed_.
. `countdown <- countdown - 1`
--
+
If `IOLEN` {ge} `128`, these operations are executed `IOLEN/64` times, writing to `OUTPUT[63:0]` the first time,
then `OUTPUT[127:64], `OUTPUT[191:128]` and `OUTPUT[255:192]`.
If more than one ``ace.exec`` instructions are required, writing restarts from `OUTPUT[63:0]`.
If `countdown` reaches zero before the entire output registers is written to, the state of the unwritten bits is undefined: for instance
this may occur if `IOLEN` = `192` or `IOLEN` > `256`.
This is usually not a problem, since the output vectors will be usually configured for 64-bit, 128-bit, or 256-bit blocks, in which case
four, two, or one ``ace.exec`` instructions are required, respectively.

//

NOTE: There is no need to provide “keyed” versions of this algorithm.
If a providing, trusted entity wants to provide a CC in which some secret content has already been provisioned, there is nothing to prevent it.

===== Ascon-XOF128

The algorithm is the same as Ascon-Hash256 (<<ACE-Ascon-Hash256>>) with the following differences:

. The IV written to `state[0]` in state _initial_ is `0x0000080100cc0002`.
. There is no `countdown` field.
. As much output as desired can be produced in state _hash_finalize_ and the algorithm never transitions to state _completed_.

===== Ascon-CXOF128

Ascon-CXOF128 differs from Ascon-XOF128 in that the message is prepended with the customization string.
Except for the initialization of the state, Ascon-CXOF128 is identical to Ascon-XOF128 with customization string and message concatenated.
The IV for Ascon-CXOF128 is `0x0000080000cc0004` (in place of `0x0000080000cc0003`).
The states and their semantics are identical to Ascon-XOF128, and the management of the customization string is left to the user.

// //////////////////////////////////////////////////////////////////////////////////////////

[comment]
--
[[ACE-examples]]
=== Examples

==== Context Switching

[WARNING]
TBD

==== VM Migration

Users may migrate their virtual machines (VMs) between client devices with CPUs from different silicon providers—a practice already common when moving interrupted VMs between Intel and AMD systems.
In such a scenario, the ACE implementation on the destination device might have a Crypto Register File (CRF) with a smaller capacity (not necessarily a smaller internal memory, as the internal representation may be more redundant).
System software could then be unable to restore all Cryptographic Contexts.

To address this, the `acecrstatus` CSR can be used to enable lazy context reloading by causing the hart to trap to the parent mode if a CR being accessed is marked as “lazy”.  When this requires freeing one or more CRs first, system software decides which contexts to evict.

==== Key Management and Provisioning Applications

Software environments that implement key management operations for other domains require their own RCSK. A system may contain multiple such software environments.

A Key Management Applet (KMA) will

[arabic]
. Generate or retrieve a key matching a request.
. Configure a CR with this key and its associated metadata.
. Export this CR to a SCC in memory.
. Relinquish control to the MM.

The MM, which controls the CSK, can then

[arabic, start=5]
. Set the RCSK to the KMA’s RCSK.
. Re-import the SCC into a CR
. Change the RCSK to match the Requester domain's RCSK.
. Export the key for the Requester's use.
. Relinquish control to the Requester.

This is the most generic approach and allows each piece of software to use a CR of choice to generate CCs and import SCCs.
Furthermore, it protects the key from other SW environments that may be crossed while transferring control between the Requester process, the MM, and the Key Management application.

// Various optimizations are possible, which can be interesting for embedded environments: Steps 3., 5., and 6. can be omitted if the CR used for these operations is fixed and no intermediate SW environments modify that CR.
--

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-V-dependency]]
=== Dependency on the V Extension

If ACE is implemented including the operations on vector registers-and thus not exclusively relying on `ace.input` and `ace.output`-it does not require the full V extension; it depends on a minimal subset, which we call RVV-mini.
RVV-mini must maintain full opcode compatibility with RVV.
The required features are:
(((RVV-mini)))

* Support for vector registers sufficiently wide to host the block-wise operations required by the algorithms supported by ACE;
* The `vsetvli` instruction with restricted parameters (e.g., “```vsetvli zero,4,e32,m1,ta,ma```” for 128-bit-side operations); unsupported configurations must generate defined errors;
* Unit-strided vector loads and stores exclusively; and
* Vector bitwise logical operations such as `vxor`, `vand`, and `vor`.

Moreover, floating-point, fixed-point, and most arithmetic vector operations are not required, and
more complex operations for some corner-case cryptographic algorithms may be performed in GPRs, with results then inserted in vector registers via `vins`/`vext`.

// to guarantee that ACE code runs unmodified on full RVV implementations.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-RCSK-vs-ID]]
=== Programmable RCSKs vs. ID-based Usage Control

_This section is informative and non-normative._

ACE provides two architected layers of usage control:

. At the User and Supervisor levels, CC usage can be optionally constrained by ASID and VMID.
This is a lightweight mechanism.
Because filtering by ASID is inactive when the hart is in S mode or higher, context switching can be performed without modifying the RCSK.
. At higher privilege levels, not only the usage, but even the import of CCs can be restricted by a programmable RCSK.
This offers stronger security by also preventing unauthorized `ace.import` operations, but incurs higher overhead as it typically requires an `ecall`.

The envisioned usage model employs ASID/VMID filtering at the User level, and also at the Supervisor level in high-performance systems where migration is not required (e.g., automotive applications). Cryptographic domain separation via the RCSK is intended for Virtual Machines, Supervisor Domains, Worlds, and TEEs within those contexts, as these demand stronger security guarantees.

Although the architecture does not prevent assigning unique RCSKs to U-mode processes, doing so would impose a substantial burden on system software due to per-context-switch `ecall` overhead.
Hardware support—such as automatic RCSK switching based on ASID/VMID, could alleviate this burden.
However, such a mechanism is not currently under consideration due to its architectural complexity, inflexibility, and hardware cost.
For example, it would necessitate secure management of large RCSK tables, including saving, restoring, and potentially migrating entire RCSK blocks.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-threat-model]]
=== Threat Model

_This section is informative and non-normative._

The ACE threat model is straightforward.

**Assets** consist of _keys_ and any other information that could aid an adversary in recovering plaintext or forging ciphertext. This includes items such as masks in tweakable XEX modes and derived keys in AES-GCM-SIV. The critical properties of these assets are their _confidentiality_ and _integrity_.
Protecting the _Availability_ of the keys is not a goal of the architecture.

**Adversaries** are assumed capable of compromising processes by exploiting software vulnerabilities.
They are also able to gain access to memory contents, for instance, by abusing hardware interfaces or by SoC/memory interposition.
The model does not include adversaries capable of sophisticated hardware attacks, such as using
a Focused Ion Beam/Scanning Electron Microscope (FIB/SEM) to tamper with the hardware's functionality.

Side channel attacks are addressed optionally. ACE offers interfaces to both SCA-unprotected and SCA-protected implementations of cryptographic algorithms, if these options are provided by the designer.

Threats can be addressed in four ways:

[horizontal]
**C:**:: _Control_ the threat by implementing full or partial mitigations.
**A:**:: _Accept_ the threat and its associated risks.
**T:**:: _Transfer_ the threat to another party better suited to address it.
**S:**:: _Suppress_ the features that give rise to the threat.

ACE is designed to avoid the “***A***” and “***S***” options (as much as possible). It _controls_ threats through its own mechanisms and _transfers_ residual risk—specifically, the risk of key extraction from the privileged or trusted software and hardware environments that manage keys—to those same environments. For example, trusted software environments may employ control-flow integrity, memory encryption with integrity protection, and anti-replay mechanisms, while hardware key-management blocks can be hardened to protect entrusted keys.

Direct plaintext leakage, memory corruption attacks against the ACE-using process, and Release of Unverified Plaintext (RUP) attacks on the cryptographic algorithms are considered out of scope. These threats cannot be mitigated by ACE because the processed information resides within the user execution context. Consequently, these threats are _accepted_.

// ///////////////////////////////////////////////////////////////////////////////////////////
[comment]
--

[[ACE-incomplete-contexts]]
=== Appendix: Export of Partial Cryptographic Contexts

[WARNING]
This section describes a hypothetical mechanism for exporting partially initialized or imported cryptographic contexts.
This is _Gedankenexperiment_ only and _not_ a current part of the ACE specification.

Suppose we want to save and restore a _partial_ context, i.e. a context whose initialization or import operation has been interrupted for a context switch, preventing immediate return to the original control flow.  A “Partial” bit in the metadata indicates this state.
This field applies only to `ace.init` and `ace.import` operations, because they access external memory, and not to `ace.clone` and `ace.derive` as they only operate internally.
Any cryptographic operation attempted on a CR containing an partial CC results in an error or is trapped.
(((Cryptographic Register,incomplete)))

An `ace.init` operation can be interrupted at any 8-byte boundary and resumed from that point. An `ace.import` operation can also be interrupted at an 8-byte boundary, but it will only be resumed from the 48th byte or later; otherwise, it is restarted with no state saved.

NOTE: Resuming an operation may be more costly than restarting it without saved state. A third alternative—waiting to complete the operation—could introduce unacceptable delays.

When exporting a partial CR, a Partial CR Metadata (PCREM) header is used as the first 8 bytes of the SCC, preceding the nonce, SIV, and content sections as defined in <<ACE-format-SCC>>.

[[ACE-metadata-partial]]
.Format of the partial CR Metadata (PCREM)
[width="100%",cols="^9%,^7%,17%,67%",options="header"]
|===
.>|   Field .>| Width +
(bits) .>| Name                  .>| Description
|   [0:0] |   1  | Format                 | Value is 0 for the current metadata format. +
The value 1 is reserved for future formats with a length of 128 bits.
|   [1:1] |   1  | Incomplete             | Value is 1.
|   [2:2] |   1  | Variant                | The value is 0 if the configuration was interrupted at initialization, and
                                            the value is 1 if the configuration was interrupted while importing.
|   [7:3] |   5  | Reserved               | Reserved for future use.
|  [31:8] |  24  | Payload_Length         | Length of the payload in bytes (excluding the first 32 bytes)
| [63:32] |  16  | Reserved               | Zero for now.
|===

NOTE: Fields such as Algorithm, SC_Protection, State Number, Direction_Policy, UC_Policy_{empty}__i__ (i = 0..3), and Locality are omitted. Since partial CRs are architecturally forbidden for normal use, the space normally used by these fields is available for other purposes. Locality violations are handled when a complete CR is used; therefore, the RCSK is always used for partial CRs. This approach can reduce the need to compute or cache DCSKs at higher privilege levels, improving performance.

The exported content format for an incomplete initialization or import matches that of a complete CR, except that it is truncated to the actual imported length (rounded up to an 8-byte multiple). This length is recorded in the Payload_Length field.

For an incompletely imported CR, the partial hash (`tmp` from <<ACE-SCC-import>>) is prepended to the content, extending it by 16 bytes.
These 16 bytes are included in the Payload_Length and are considered as part of the content, hence they are encrypted.

After a partial CR is decrypted and authenticated in privileged mode, it is marked for resumption.
Upon returning from the context-switch handler:

. The original metadata, nonce, and SIV are recovered from less-privileged memory;

(These reads may be interrupted by page faults and resumed once the target page is mapped.)

The following steps are then executed as an atomic block:

[start=2]
. Compute `z` and `num_blocks` from the original content length, using the starting value of `i` from `acestart`.
. If the interrupted operation was an import:
.. Derive the `enc_key` and `auth_key` keys.
.. Recompute the partial hash from the current CR content.

The initialization or import operation can then resume from the point of interruption.

//

[WARNING]
The TG consensus is that `init`/`import` may resume after a page fault, but on a full context switch, partial CRs are not exported. Instead, the CRs are cleared and the instruction is restarted.

Our security analysis examined various scenarios, including one where a context switch interrupts an import, forcing export and later resumption of a partially imported context. We concluded that while privileged code can replace an SCC in a saved process's context or memory, it cannot abuse the resumption mechanism to breach SCC confidentiality or integrity.

--

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-architecture]]
== Architecture

ACE is a complex architecture and relies on certain fundamental concepts, which we first introduce together in a short section.
While this leads to some repetitions, we believe that it also brings better clarity to the presentation of the architecture.

// the clarity gained from this approach outweighs the potential drawbacks.

[[ACE-concepts]]
=== Fundamental Concepts

Cryptographic Context:::
The _Cryptographic Context_ (CC) is the fundamental concept in ACE.
(((Cryptographic Context)))
All cryptographic operations performed by ACE execute within the constraints defined by a CC.
A CC is an indivisible data structure comprising a *metadata* section and a *content* section.
The metadata has a fixed format, and it specifies the cryptographic algorithm associated to the CC and optional usage ontrol policies.
(((Cryptographic Context, metadata)))
The content has an algorithm-specific format, and it holds sensitive material such as keys, secrets and internal algorithm state.
(((Cryptographic Context, content)))
Metadata requires integrity but not confidentiality; content requires both confidentiality and integrity.
These properties are architecturally guaranteed by ACE.

Cryptographic Register:::
(((Cryptographic Register)))
Cryptographic Contexts are realized architecturally using _Cryptographic Registers_ (CRs).
CRs are architectural, i.e., per-hart, containers that safeguard CCs.
A CR is _initialized_ by writing metadata and content into it, which are thusly bound to form a CC.
A CC can be used for cryptographic operations only while resident in a CR.
Only the ACE unit may access or modify CC contents, in accordance with the architecture and the programmed algorithm.
CC content cannot be extracted in a manner that compromises its confidentiality.

Sealed Cryptographic Context:::
(((Cryptographic Context, sealed)))
To support context switching while protecting CCs outside architectural state, a CC may be exported from a CR as a _Sealed Cryptographic Context_ (SCC).
An SCC is an encrypted and authenticated representation of a CC that can later be reimported into a CR.
SCC import and export use _Context Sealing Keys_ (CSKs), which may be programmable by M-mode and may depend on _Localities_ (see below).
A CC sealed with a given CSK cannot be reimported using a different CSK, enabling cryptographic domain separation across spatial and temporal
domains.

Object-Orientation:::
CCs act as _objects_ exposing a uniform interface across algorithms.
A CC encapsulates algorithm-specific behavior, enabling interchangeable use of different primitives (e.g., AES-128, AES-256, Калина-128, Калина-256, and SM4, and so on) in identical modes (e.g., ECB, GCM-SIV, XEX/XTS) without requiring changes to compiled code.
Side-channel-resistant variants are supported transparently.

// NOTE: This flexibility allows, for example, a content distribution network to use different ciphers (AES in US/EU, SM4 in China, etc.) for GCM payloads using the same binary interface. The CC encapsulates the cipher, and the binary supports all GCM variants (cf.{nbsp}<<ACE-GCM-mode>>).

Usage Control Policy:::
(((Cryptographic Context, Usage Control)))
ACE distinguishes between CR management (e.g., import/export) and CC usage (cryptographic operations).
To prevent denial of service scenarios, CR management operations must always be permitted.
Accordingly, the optional _Usage Control_ policies restrict only cryptographic operations and state modifications, not CR or SCC management.
For this reason, the term Usage Control is used instead of Access Control.

Locality:::
(((Cryptographic Context, Locality)))
Finally, ACE can bind CCs to a _Locality_, i.e., restric usage to specific devices, device classes, software or hardware configurations, or boot cycles.
This binding uses metadata when a CC is in a CR, and a _Derived Context Sealing Key_ (DCSK) derived from the _Root Context Sealing Key_ (RCSK) and a Locality-specific secret as the CTK for import and export.
// The system maintains a _Locality Secrets Table_ (LST) with fixed, hardware-configured, and MM-programmable values.
// Metadata stores the Locality as an index into this table (cf.{nbsp}<<ACE-Localities>>).

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-extensions-overview]]
=== Extensions Overview

[WARNING]
This list is an early draft.

Unprivileged::

* `Zlio` => Support for `ace.input`/`ace.output` operations
* `Zleaes128p` => Support for AES-128 encryption and decryption (all applicable modes)-the `p` at the end denotes a primitive
* `Zleaes192p` => Support for AES-192 encryption and decryption (all applicable modes)
* `Zleaes256p` => Support for AES-256 encryption and decryption (all applicable modes)
* `Zlsm4p` => Support for SM-4 encryption and decryption (all applicable modes)
* `Zlctrm` => Support for counter mode-the `m` at the end denotes a mode
* `Zlxctrm` => Support for XCTR mode
* `Zlgcmm` => Support for GCM mode
* `Zlgcmsivm` => Support for GCM-SIV mode
* `Zlxexm` => Support for XEX and XTS modes
* `Zlocbm` => Support for OCB mode
* `Zlcmacm` => Support for CMAC
* `Zlesha2h` => Support for SHA-2 (all applicable modes)-the `h` at the end denotes a hash function
* `Zlesha3h` => Support for SHA-3 (all applicable modes)
* `Zlsm3h` => Support for SM-3 hash function (all applicable modes)
* `Zlhmacm` => Support for HMAC
* `Zlascon` => Support for the ASCON suite
* `Zlkned` => NIST Suite: AES Block Cipher. Depends on `Zleaes128` and `Zleaes256`.
* `Zlkn` => NIST Algorithm Suite. Depends on `Zlkned` and `Zlesha2`.
* `Zlace` => Must support for the following CSRs: `aceerror` and `acestart` (this is a dependency for Zicsr); must support the following instructions: `ace.init`, `ace.exec`, `ace.clear`, `ace.export`, `ace.import`, and `ace.size`; `ace.exec` must support `Zleaes128`.

Privileged::

* If `Zlace` is implemented: `misa` must implement the `L` bit, and `*status` must implement `ACES`.
* `Smacectk` => Defines the Root Context Sealing Key CSRs (`macercsk{0..7}`), which are all MRO.
* `Smacectkw` => ACE Root Context Sealing Key CSRs are MRW. Depends on `Smacectk`
* `Smaceosscrt` => Defines the ACE OS Secret CSRs (`maceOSSecret{0..3}`)
* `Smacebootscrt` => Defines the ACE Boot Secret CSRs (`maceBootSecret0{0..3}`)
* `Smacestatus` => Defines the ACES per CC CSRs (`macecrstatus`)

// ///////////////////////////////////////////////////////////////////////////////////////////

=== Programmer-Visible Architectural State

The recommended way to implement ACE is to implement the V extension, or at least a certain subset of it, as defined in <<ACE-V-dependency>>, which we call RVV-mini.

It is allowed to implement ACE without V or RVV-mini, by exclusively using the instructions `ace.input` and `ace.output` to provide input data and a buffer for output to and from the instructions that may use vectors.
These are, currently, `ace.exec` (cf.{nbsp}<<ACE-instruction-exec>>) and `ace.derive` (cf.{nbsp}<<ACE-instruction-derive>>).

[comment]
--
[[ACE-instructions-overview]]
==== Instructions Overview

ACE provides a number of unprivileged instructions, some implemented as CSR read/write operations.
The notation `K[Xd]`, for a GPR `Xd`, refers to the CR whose number is contained in `Xd`,
and `Kn|K[Xn]` means that there are two different encodings for when the CR number is passed as an immediate (`Kn`) or in `Xn`.

.The ACE instructions
[width="100%",cols="17%,27%,56%",options="header",subs="+macros"]
|===
| Instruction         | Operands                          |  Description
| `ace.init`          | `Kd\|K[Xd], %offset(Xs)`          |  Sets a CR's metadata and content.
| `ace.clear`         | `Kd\|K[Xd]`                       |  Clears a CR and marks it as no longer in use and clean.
| `ace.reset`         |                                   |  Resets ACE.
| `ace.export`        | `%offset(Xn) ,Ks\|K[Xs]`          |  Securely exports the content of a CR to memory.
| `ace.import{.S}`    | `Kd\|K[Xd], %offset(Xn)`          |  Authenticates and imports an SCC from memory. +
 `ace.import.S` provides optional support for system-defined formats.
| `ace.exec`
| A. {nbsp}{nbsp} `Vd, Kn\|K[Xn], Vs` +
  B. {nbsp}{nbsp} `{nbsp}{nbsp}{nbsp}{nbsp}Kn\|K[Xn], Vs` +
  C. {nbsp}{nbsp} `Vd, Kn\|K[Xn]` +
  D. {nbsp}{nbsp} `{nbsp}{nbsp}{nbsp}{nbsp}Kn\|K[Xn]`
| Performs a cryptographic operation. These instructions may modify CC state. This instruction admits four _Forms_, depending on whether it accepts an input or not, and whether it produces an output or not.
| `ace.size`
| `Xd, Ks\|K[Xs]` +
`Xd, Xs` .2+|  Returns the SCC size in bytes for CR `Ks`/`K[Xs]` or for an algorithm with metadata `Xs`.
Returns zero if the algorithm is unsupported.
`ace.available` is an alias for `ace.size`.
| `ace.available`     | `Xd, Xs`
| `ace.size{nbsp}{nbsp}\` +
`{nbsp}{nbsp}{nbsp}{nbsp}.internal`
| `Xd, Xs` |  Returns the internal capacity occupation for an algorithm with metadata `Xs`.
Returns zero if the algorithm is unsupported.
| `ace.clone`         | `Kd\|K[Xd], Ks\|K[Xs]`            |  Clones a source CR to a destination CR.
| `ace.derive`        | `Kd\|K[Xd], Ks\|K[Xs]` +
`Kd\|K[Xd], Ks\|K[Xs], Vs2` +
|  Optional. Configures destination CR using source CR (e.g., the source CR could hold a KEM, and derive symmetric keys).
| `ace.state` +
`(ace.dir)`
| `Kd\|K[Xd], #immed` +
`Kd\|K[Xd], #immed, Xs` |  Modifies algorithm state (e.g., phase transitions). `ace.dir` is an alias for `ace.state`.
| `ace.restrict` +
  `(ace.harden)`      | `Kd\|K[Xd], Xs`                   |  Narrows Usage Policies and enables/increases side-channel protection.
   Weakening Usage Policies and SCA protection is not permitted. `ace.harden` is an alias for `ace.restrict`.
| `ace.input`         | `Kd\|K[Xd], %offset(Xs)`          |  Optional. Provides input to the algorithm (for long inputs).
| `ace.output`        | `%offset(Xd), Ks\|K[Xs]`          |  Optional. Writes output from the algorithm (for long outputs).
| `ace.error`         | `Xd`                              |  Writes the ACE unit error code to GPR `Xd`.
|===
--
// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-cryptographic-registers]]
==== Cryptographic Registers

ACE defines 32 Cryptographic Registers (CRs), identified by numbers from 0 to 31, and called `K0`, ... , `K31`.
(((Cryptographic Context)))

CRs reside in a dedicated _CR file_ (CRF), accessible only by the ACE implementation.
(((Cryptographic Register File)))

CRs differ from conventional register in several ways:

* In place of load and store instructions, CRs can be *initialized* with clear data, but only *exported* using an AEAD algorithm, for later re-**import**.
  These actions correspond to the three instructions
  `ace.init` (cf.{nbsp}<<ACE-instruction-init>>),
  `ace.export` (cf.{nbsp}<<ACE-instruction-export>>), and
  `ace.import` (cf.{nbsp}<<ACE-instruction-import>>). In brief:
** `ace.init` is a load-type instruction that reads clear text into a CR, but there is no corresponding “store” instruction, i.e.,
    we can write clear data into a CR but not retrieve it as such;
** `ace.export` uses a nonce, so repeated export of the same content may result in different ciphertexts; and
** `ace.import` may fail if the authentication tag cannot be verified.
* Unlike conventional registers, which always contain a value, CRs can be _unconfigured_, meaning they may hold no information.
  This is achieved by using the `ace.clear` instruction (cf.{nbsp}<<ACE-instruction-clear>>).
* The amount of the capacity of the CRF used by a CR depends on the configured algorithm.
  Two CRs can use different amounts of capacity.
* ACE instructions can refer to CRs directly, i.e., with a 5-bit immediate in the instruction encoding, but also indirectly, i.e., through a value in the range [0 .. 31] in a GPR.
* There are very few instructions that can use and possibly change the contents of the CRs.
  The most important ones are:
  ** `ace.exec`, used to perform cryptographic operations on data blocks according to the algorithm configured in a CR; and
  ** `ace.state`, used to determine whether a CR is used for encryption or decryption and move between the different stages of modes of operations and hash functions.

Insufficient residual CRF capacity may prevent the execution of an instruction that configures a CR, such as `ace.init` or `ace.import`,
but also `ace.clone` (cf.{nbsp}<<ACE-instruction-clone>>) or `ace.derive` (cf.{nbsp}<<ACE-instruction-derive>>).
In this case, ACE returns _ace_err_memory_, and software must free capacity by exporting the contents of another CR (if needed) and then clearing it.

Indirectly accessing a CR that is outside the defined [0 .. 31] range, results
in a _ace_err_unconfigured_ error.

[NOTE]
====
CRF capacity is implementation-defined, but implementations must provide sufficient capacity to allow execution of all operations defined by the architecture.
The CRF must hold at least an instance of the largest possible CR or the largest CR pair for CR cloning or derivation.
An optional, possibly approximated, and implementation dependent mechanism to estimate the required capacity is defined in <<ACE-instruction-size-internal>>.
====

[NOTE]
====
The fact that CRs can be addressed indirectly two major implications:

. Adding renaming to CRs would add significant complexity to the microarchitecture.
  However, CRs are much less often redefined than integer or floating-point registers, except for internal implied changes, hence CRs can be renamed without performance issues.
. An additional bit in the instruction encoding determines whether a CR number is given by a 5-bit immediate or by the value in a GPR.
====

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-metadata]]
==== Metadata Format

For software portability and interoperability, ACE defines two external formats for CCs:
an _Initialization Input_ format, which is loaded into a CR to create a CC,
and an encrypted, authenticated format used when exporting a CR to memory for later re-import:
the Sealed Cryptographic Context (SCC) (cf.{nbsp}<<ACE-format-SCC>>).
Both formats rely on the same metadata section format, which is described here.
The formats of the Initialization Input and of the SCC are described in <<ACE-format-configuration>> and <<ACE-format-SCC>>, respectively.

The metadata section is 64 bits long and its format is described in <<ACE-metadata-standard>>.
The metadata section is used as the header of the data formats used in CR initialization, and CC export and import functions.
// The internal representation of the metadata in a CC  is implementation specific.
(((Cryptographic Context,metadata,format)))

[[ACE-metadata-standard]]
.Format of the Metadata Section
[width="100%",cols="^9%,^7%,17%,67%",options="header"]
|===
.>|   Field .>| Width +
(bits) .>| Name                  .>| Description
|   [0:0] |   1  | Format                 | Value is 0 for the current metadata format. +
Future format will have a 1 in this position and may be longer than 64 bits.
|   [4:1] |   4  | Locality               | A field which is either all ones (15) or an index into the Locality Secrets Table.
|   [5:5] |   1  | Reserved               | Zero.
|  [14:6] |   9  | Algorithm              | Algorithm (such as primitive or mode). 0 means the CC is invalid.
| [15:15] |   1  | Reserved               | Zero.
| [17:16] |   2  | SC_Protection          | Level of Side Channel Protection, encoded as per <<ACE-SC-protection-levels>>.
| [19:18] |   2  | Direction_Policy       | Determines whether the CC may be used for encryption (bit 12 set), decryption (bit 13 set), or both (bits 12 and 13 set). Valid only for encryption/decryption primitives or modes, and ignored, for instance, for hash functions.
| [21:20] |   2  | Key_Type               | Key given by explicit value / System Key (index) / Internally generated.
| [25:22] |   4  | State_Number (also Direction) | Encoding the current state of the state machine of the algorithm as a number.
| [29:26] |   4  | UC_Policy_1            | “UC Policy” means “Usage Control Policy”. If bit 26, 27, 28, resp. 29 is set, it disallows the _usage_ of this CC in User, (Virtual) Supervisor, Hypervisor, resp. M-mode .
| [31:30] |   2  | UC_Policy_2            | If bit 30, respectively, 31, is set, then restrict the usage by `ASID`, respectively, `VMID`. Restrictions by `ASID` are ignored if in S-mode or higher. Restrictions by `VMID` are ignored if in H- or M-mode.
| [47:32] |  16  | UC_Policy_3            | Zero if bit 30 unset, else `ASID` to enforce.
| [61:48] |  14  | UC_Policy_4            | Zero if bit 31 unset, else `VMID` to enforce.
| [63:62] |   2  | Reserved               | Zero.
|===

Algorithm field:::
Algorithms are encoded in a 9-bit field.
Algorithm numbers 0-447 are architecture-defined and the list of such encodings is maintained by RVI.
cf.{nbsp}<<ACE-algorithms>> for the currently encoded algorithms.

SC_Protection field::: {empty}
+
--
Certain minimal Side-Channel protection levels are defined by the architecture.
[[ACE-SC-protection-levels]]
.Encoding of Side-Channel Protection levels
[float="center",align="center",width="76%",cols="^8%,<68%",options="header"]
|===
| Value | Description
|   0   | No protection.
|   1   | Data-independent timing, first-order threshold implementation.
|   2   | Data-independent timing, first-order threshold, fault-tolerant implementation.
|   3   | Custom, algorithm dependent.
|===

Custom algorithms may offer stronger side channel protection guarantees than those specified in the encoding values 0 to 2.
In such a case, the value of the SC_Protection field must be set to 3.
--
+

Key_Type field::: {empty}
+
--
ACE supports keys provided by software, as well as system keys and keys computed with a system “recipe”.
These key types are encoded as follows:
[[ACE-key-type]]
.Encoding of Key_Type
[float="center",align="center",width="76%",cols="^8%,<68%",options="header"]
|===
| Value | Description
|   0   | Explicit value.
|   1   | The key comes from an internal, system specific System Keys Table (SKT). For each algorithm as specified in <<ACE-algorithms>>, the part of the content that normally contains the key(s) is replaced by a 64-bit value which is an index into the (SKT)-for both Initialization Input and the SCCs. The actual value of the key is never included in exported content. For threshold implementations, ACE may copy the key material from the SKT into the CR and expand it into multiple shares.
|   2   | Internally generated key.  System specific.  In the Initialization Input, the part of the content that normally contains the key(s) is replaced by a “recipe” in a system-specific format. The format is not specified by the ISA and may not be portable to other systems. Once the key material has been internally generated, the value is included in the SCC as part of the content—not the “recipe”—as for any other key(s) for the same specified algorithm.  The Key_Type field of the metadata in all representations of the CC, will keep the value 2.
|   3   | Invalid.
|===
--
+

//
State_Number field::: {empty}
+
--
The value of the State_Number Field must be zero in the initialization data.
Three values are defined for all algorithms: 0, 14, and 15, for the states _initial_, _invalidated_, and _completed_.
These states denote CCs that are ready to perform operations, that have been put into an invalid state, or that have completed their operations.

If the algorithm encoded in the CC has at most 16 states (including _initial_, _completed_, and _invalidated_), then this number is stored in this field, otherwise an algorithm-specific representation is used in the content, and this field only admits the values 0, 14, 15, and 1, the latter being a placeholder for any other operational state. The values used in the algorithms defined in this specification are listed in <<ACE-state-constants>>.
--
+

Usage Control Policies fields::: {empty}
+
--
If the H extension is not enabled, bit 28 must be set to 1, and bits 31 and [63:48] must be set to 0.
The “UC_Policy_4” field is 14 bits long, but the next two bits are reserved for compatibility with architectures employing 16-bit `VMID` fields (for instance, in heterogeneous systems).  Furthermore, the “UC_Policy_4” field may be used to filter domains also when H is not implemented.

Restricting usage by Supervisor Domain or World ID is not supported, and not only because of a lack of space in a 64-bit metadata section:
Reconfiguring the RCSK is a better approach for such isolation requirements, whereas isolation by `ASID` and `VMID` is a weaker security feature.
--
+

//

[[ACE-Localities]]
==== Localities

Internally, ACE keeps a table of 128-bit Locality Secrets (LS), the Locality Secrets Table (LST).
Some entries of the LST are fixed or configurable only using an implementation—specific authenticated hardware procedure, and these are
global and shared across all ACE units in the same system or in the same SoC.
A few entries may be programmed by M-mode and are architectural, i.e., per hart.

If the Locality Field of a CC is all ones (15), then the RCSK is used.
Otherwise, this value is used as an index _i_ in the LST, and the actual CSK is derived from the RCSK and LST[_i_].

<<ACE-locality-indexes>> lists the architected Localities and whether M-mode can configure them.
The domain of each Locality Secret is specified, i.e., whether the value is chip-wide
(i.e., the same across all chiplets in the same SoC),
device-wide, or OS-wide.

[[ACE-locality-indexes]]
.Architected Locality Values
[width="100%",cols="23%,45%,^9%,^14%,^9%",options="header"]
|===
.>| Name .>| Description .>| Domain | M-mode +
Configurable .>| Value +
(Index)
| (No Locality binding)     | No CSK derivation. CC bound to Root CSK only. | -- | -- | 15
| ChipManufacturerSecret    | Identifies the manufacturer of the SoC. Permanent. | SoC | N | 0
| ChipModelSecret           | Identifies specific chip model/family. Permanent. | SoC | N | 1
| ChipUniqueSecret          | Unique for each SoC. Permanent. | SoC | N | 2
| OEMSecret                 | Provisioned by OEM to differentiate their products from the competition.
                              Can be permanent, or optionally reconfigurable by impdef HW authenticated mechanisms. | Device | N | 3
| ProductSecret             | Identifies device/system type/model (product). Not necessarily permanent. Reconfigurable like OEMSecret. | Device | N | 4
| DeviceSecret              | Unique device (entire system) secret (_not_ the device ID such as a serial number). Shared across all harts in a SoC and shareable across multiple SoKs in a single device. Sharing mechanism impdef, i.e., not architected. Reconfigurable like OEMSecret. | Device | N | 5
| OSSecret                  | Identifies Operating System (or System Stack).
                              Not permanent, must be configured at (virtual) boot. | OS | Allowed | 6
| BootSecret                | Regenerated at each (virtual) boot. | OS | Allowed | 7
| Reserved                  | Reserved for future use (RZ if not defined). | Impdef | Impdef | 8-14
|===

The constant Localities_MAX is the maximum number of Localities supported by the system.

NOTE: M-mode is responsible for virtualizing the OSSecret and BootSecret Locality Secrets.

*Example*: _If a key's metadata specifies a Locality field value of 2, the import/export key is derived from the RCSK and the OEM Secret. An SCC created on one device will fail authentication when imported on another device if their OEM Secrets differ._

NOTE: A CC may reference a key via an index into the System Key Table (SKT).
A device-specific SKT entry may correspond to a different key on another device.
Using the latter may lead to unspecified behavior.
Implementations of the SKT *must* provide a suitable Locality to the ACE unit during CR configuration, and set usage policies that are at least as strict as the key's own.

[[ACE-format-definition]]
==== Initialization Inputs

The Initialization Input configures a Cryptographic Register (CR) to create a Cryptographic Context (CC).
Its total length must be a multiple of 8 bytes.
The first 8 bytes constitute the metadata section, as defined in <<ACE-metadata>>.
The subsequent bytes form the *content*—the key material and any algorithm-specific data—whose format and length are specified in <<ACE-algorithms>> for all architected algorithms. The content's structure and size are entirely determined by the Algorithm and Key_Type fields within the metadata.

[[ACE-format-SCC]]
==== Sealed Cryptographic Contexts

The format of the SCCs is used when exporting a CC from a CR and is used also to reimport the CC into a CR.
It is dependent on the algorithm being used.
Its size must be a multiple of 8 bytes.

Format of SCC:::
(((Cryptographic Context, SCC plaintext)))
`bytes 0 .. 7  {nbsp}{nbsp}{nbsp}{nbsp}{nbsp}` metadata section, +
`bytes 8 .. 19  {nbsp}{nbsp}{nbsp}{nbsp}` nonce used in the encryption (96 bits), +
`bytes 20 .. 31  {nbsp}{nbsp}{nbsp}` tag produced by the encryption method (96 bits), and +
`bytes 32 .. u+31  {nbsp}` encryption of the serialization of the content of the CR, with a byte length of `u`.

Both metadata and the serialization of the content are authenticated, but only the latter is encrypted (the method is described in <<ACE-SCC-AEAD>>).

The metadata section of an SCC follows the same fixed architectural format as for the corresponding section of the Initialization Input.
The content format—and consequently its length—is algorithm-specific (cf.{nbsp}<<ACE-algorithms>>) and is determined solely by the Algorithm and Key_Type fields in the metadata as well, but in general differs from the content section of the Initialization Input.

[[ACE-CSR]]
==== CSRs

ACE extends `*status` and `misa`, and adds 23 new CSRs (of which 20 are optional, 16 M-mode exclusive) to manage its execution environment.
They are listed in <<ACE-SCRs-table>>.

[[ACE-SCRs-table]]
.New ACE CSRs
[cols="<16%,^11%,<24%,<49%"]
[float="center",align="center",options="header"]
|===
| Address        | Privilege | Name                     | Description
| 0xXXX          | URW       | `aceerror`               | Error code of the last ACE instruction
| 0xXXX          | URO       | `acecrstatus`            | Array of two-bit fields (similar to ACES state, but per CR)
| 0xXXX          | URW       | `acestart`               | ACE start byte index
| 0xXXX          | URW       | `aceiobuflen`            | ACE I/O buffer length
| 0xXXX          | URW       | `aceiobuftop`            | ACE I/O buffer limit for current transfers
| 0xXXX          | URO       | `acesequence`            | Sequence number of the last ACE instruction
| 0xXXX          | URW       | `aceactivecr`            | Active CR for `ace.input`/`ace.output`
| 0xXXX--0xXXX   | MRW (RZ)  | `macercsk{0..7}`         | ACE Root Context Sealing Key
| 0xXXX--0xXXX   | MRW (RZ)  | `maceOSSecret{0..3}`     | ACE OS Secret
| 0xXXX--0xXXX   | MRW (RZ)  | `maceBootSecret0{0..3}`  | ACE Boot Secret
|===

==== Extension to existing CSRs

[[ACE-ACE-field-in-misa]]
===== ACE field in `misa`

Bit `L` (11) in `misa` indicates that ACE is present.
(((CSR, ACE field in `misa`)))

[[ACE-ACES-field-in-status]]
===== ACES field in `*status`

The ACES field (bits 26:25) is added to `mstatus` and shadowed in `sstatus` and `vsstatus` (if the hypervisor extension is present).
(((CSR,ACES field in *status)))
Similarly to the FS and VS fields, it is used to optimize context switching.
If ACE is implemented, ACES shall not be read-only zero.
Its possible values are given in <<ACE-aces-encoding>>.

[[ACE-aces-encoding]]
.Encoding of ACES status field
[float="center",align="center",width="100%",cols="^8%,<8%,<84%",options="header"]
|===
|Status |Name |Meaning
|   0   | Off                | ACE disabled. CRs are inaccessible. The hart will trap if the user requests to enable the feature.
|   1   | Initial            | ACE enabled. No CR is configured.
|   2   | Clean              | ACE enabled. The state matches the last context swap (Clean).
|   3   | Dirty              | ACE enabled. Some CRs may have been modified since last Clean.
|===

Writes to ACES do not affect CR contents.
Clearing state is not performed by setting ACES to Off, Initial, or Clean, and it must be explicitly done by privileged code before changing ACES.

In <<fsxsstates-copy>> we describe the transitions between states.

[WARNING]
<<fsxsstates-copy>> is a copy of <<fsxsstates>> of cite:[RISCV-ISA-Priv]
and it will be removed from this document once the extension is ratified.

//

[[fsxsstates-copy]]
.ACES state transitions
[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
|Current State |Off |Initial |Clean |Dirty
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|At context save in privileged code

|Save state? +
Next state
|No +
Off
|No +
Initial
|No +
Clean
|Yes +
Clean
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|At context restore in privileged code

|Restore state? +
Next state
|No +
Off
|Yes, to initial +
Initial
|Yes, from memory +
Clean
|N/A +
N/A
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^| Execute instruction to read state

|Action? +
Next state
|Exception +
Off
|Execute +
Initial
|Execute +
Clean
|Execute +
Dirty
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|Execute instruction that possibly modifies state

|Action? +
Next state
|Exception +
Off
|Execute +
Dirty
|Execute +
Dirty
|Execute +
Dirty
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|Execute instruction to unconfigure unit

|Action? +
Next state
|Exception +
Off
|Execute +
Initial
|Execute +
Initial
|Execute +
Initial
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|Execute instruction to disable unit

|Action? +
Next state
|Execute +
Off
|Execute +
Off
|Execute +
Off
|Execute +
Off
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|Execute instruction to enable unit

|Action? +
Next state
|Execute +
Initial
|Execute +
Initial
|Execute +
Initial
|Execute +
Initial
|===

==== New Unprivileged CSRs

The new unprivileged CSRs introduced by ACE are defined here.

[[ACE-CSR-ace-error]]
===== `aceerror`

The 8-bit `aceerror` CSR records the error code from the most recent ACE instruction.
Reading it may stall the hart until the operation completes.
It is writable for context switching.

Error codes 0–127 are reserved for RVI, and codes 128–255 are reserved for custom algorithms.
The standard error codes are:

[[ACE-error-codes]]
.Error codes and their meanings
[float="center",align="center",width="100%",cols="^6%,<24%,<70%",options="header"]
|===
|Value | Mnemonic                | Examples (((ACE, error codes)))
|  0   | ace_err_ok              | No error.
|  1   | ace_err_authentication  | Authentication failure (`ace.import` or `ace.exec`).
|  2   | ace_err_privilege       | Access control failure (`ace.exec`, `ace.state`, etc.).
|  3   | ace_err_invalid         | Invalid input/operation. +
Examples:
invalid metadata passed to `ace.init` is invalid;
encryption, resp., decryption is requested from a CC only configured for decryption, resp., encryption;
a Form of `ace.exec` that is not permitted in the current algorithm state is used;
the requested change of state in `ace.state` is not permitted;
the change in usage policies in `ace.restrict` is not permitted;
software tried to use an incomplete CC in a CR as a source in an `ace.exec`, `ace.state`, `ace.input`, `ace.output`, `ace.clone`, `ace.derive`, `ace.harden`, or `ace.restrict` operation.
|  4   | ace_err_unimplemented   | Algorithm or algorithm variant not implemented.
|  5   | ace_err_memory          | Insufficient CRF memory to perform `ace.init`, `ace.exec`, `ace.clone`, or `ace.derive`.
|  6   | ace_err_unconfigured    | Usage of unconfigured CR in `ace.exec`, `ace.state`, `ace.input`, `ace.output`, `ace.clone`, `ace.derive`, or `ace.harden`/`ace.restrict`. Can trigger lazy reload.
|===

[[norm:ace_exc_priority]]
.ACE error priority in decreasing priority order.
[%autowidth,float="center",align="center",cols="<,>,<",options="header",]
|===
.>|Priority   .>|Exception +
Code        .>|Description
.>|_Highest_  |6               |Unconfigured CR
|           .>|3             .>|Invalid input/output operation with `ace.init` (invalid metadata)
|           .>|4             .>|Algorithm or algorithm variant not implemented.
|           .>|5             .>|Insufficient CRF memory
|           .>|3             .>|Invalid input/output operation with `ace.exec`, `ace.state`, +
                                `ace.input`, `ace.output`, `ace.clone`, `ace.derive`, +
                                `ace.harden`, or `ace.restrict` (used incomplete CC as source)
|           .>|2, 1          .>|Access Control Failure or authentication failure with `ace.import`
|           .>|1             .>|Authentication failure with `ace.exec`
|           .>|3             .>|Invalid input/output operation with `ace.exec` +
                                (form not allowed in current algorithm), +
                                `ace.state` (state change not allowed), +
                                or `ace.restrict` (change of usage policy is not allowed)
.>|_Lowest_ .>|0             .>|No error
|===

If executing an `ace.init`, `ace.import`, `ace.export`, `ace.input`, or `ace.output` triggers a
trap, as specified in the privileged architecture, `aceerror` remains unchanged.

//

===== `acecrstatus`

The CSR `acecrstatus` tracks the configuration and dirtiness of CRs on a per-CR basis, so that privileged context switching code needs to save only the dirty CRs, and restore only the configured ones, unless the latter are lazy-loaded:

. For RV64, `acecrstatus` has a size of 64 bits,
``acecrstatus[``2__i__+1,2__i__``]`` can take the values Off, Init, Clean, Dirty as defined for `*status.ACES` for CR #__i__.
. For RV32, there are two 32-bit registers `acecrstatush` and `acecrstatusl` (collectively referred to as `acecrstatus` in the following)
where
``acecrstatus[``2__i__+1,2__i__``]`` can take the values Off, Init, Clean, Dirty as defined for `*status.ACES` for CR #__i__
and
``acecrstatus[``2__i__+1,2__i__``]`` for CR #__i__+16.

This section defines the semantics of the `acecrstatus` bitfields:

* *INITIAL* (value: 1).
+
--
** *State*: Unconfigured.
** *Permitted operations*: None.
** *Usage*: Raises _ace_err_unconfigured_. No trap is generated.
** *Configuration*: Does not trap. Transitions to *DIRTY*.
--
+

* *LAZY* (value: 0).
+
--
** *State*: Unconfigured. A value is saved for lazy loading.
** *Permitted operations*: Export and usage trigger a trap to the operating system for lazy loading. Execution resumes from state *CLEAN*.
** *Configuration*: Works as expected; sets status to *DIRTY*.
--
+

* *CLEAN* (value: 2).
+
--
** *State*: The CR configured and loaded. Its state has not changed since the last switch.
** *Permitted operations*: Unrestricted; modification sets status to *DIRTY*.
** *Configuration*: Works as expected; sets status to *DIRTY*.
--
+

* *DIRTY* (value: 3).
+
--
** *State*: The CR configured and loaded. Its state has potentially changed since the last switch.
** *Permitted operations*: Unrestricted.
** *Configuration*: Works as expected; status unchanged.
--
+

//

NOTE: The *LAZY* status reuses the FS/VS/ACES encoding for “OFF”, this does not indicate that the ISE is inactive, nor that the ISE cannot use that CR.
Whether the ISE is active is encoded exclusively in ```*status```. The use of the **OFF** encoding in the per-CR fields of `acecrstatus` is a natural choice to denote an unavailable state that requires lazy loading to be made available.
If all CRs were either unconfigured or to be lazy-loaded, the ACES field would be set to **CLEAN** and not to **OFF**.

//

[[ACE-CSR-acestart]]
===== `acestart`

`acestart` is an XLEN-bit RW CSR, similar to `vstart`, tracking progress of long-running interruptible instructions such as `ace.init`, `ace.import`, `ace.export`, `ace.input`, and `ace.output`.
(((CSR, acestart)))

Unlike the vector extension’s `vstart`, which tracks element indices, ACE has no notion equivalent to that of vector elements:
`acestart` therefore records a byte offset.
For a load-type instruction (e.g., `ace.init`, `ace.import`, `ace.input`), this offset indicates how many bytes of input have already been read and processed.
For a store-type instruction (e.g., `ace.export`, `ace.output`), it indicates how many bytes of output have already been computed and written.
The value includes all payload bytes (metadata, content, nonce, tag) and accommodates piecewise execution via traps (cf.{nbsp}<<ACE-trappable-insns-support>>).

This register is typically written by hardware.
Software may safely write 0 to fully restart an operation, and the register can be saved and restored during context switches.
However, software must not write arbitrary nonzero values to it, as this may result in an illegal-instruction exception, as the hardware or a trapped implementation are not required to support all possible values.
Only the instructions explicitly mentioned above support non-zero `acestart` values; other ACE instructions ignore this register, and will be restarted.

Initialization, import, and export operations may be interrupted and resumed if no context switch occurs,
as indicated by the value in the `acestart` CSR.  If a context switch occurs, these operations must be restarted.

[NOTE]
====
_A single `acestart` value suffices due to the way the init/import/export instructions operate:_

* `_ace.init_` _and_ `_ace.import_` _use a single pass: all blocks are processed sequentially._
* `_ace.export_` _uses two passes. However, the first pass to compute the SIV is purely internal, and never accesses memory, so page faults cannot occur. This first stage is uninterruptible. The second pass writes metadata, nonce, SIV, then encrypted content to memory. Only the second pass can cause page faults and requires resumption._

This design obviates the need to separate data transfer from cryptographic processing during import and export operations. A separate transfer phase would require buffering the entire input within the ACE unit before processing, increasing internal resource requirements, whereas the current architecture can process data inline and is loaded with minimal overhead.
====

A different situation arises when an `ace.exec` instruction operates on long vectors containing multiple elements.
In the algorithm description we explicitly mention that a block of operations is repeated for each block in the vector:
the execution of these iterative `ace.exec` instructions may be interrupted and resumed, and `acestart` reflects the number of bytes processed so far.

The semantics and use of `acestart` are described in <<ACE-format-configuration>>.

To optimize the save and restore of the input/output buffer, we also use the two CSRs described in the next two sections.

[[ACE-CSR-aceiobuflen]]
===== `aceiobuflen`

`aceiobuflen` is an XLEN-bit RW CSR.

`aceiobuflen` is used to program the size of the input/output buffer for the `ace.input` and `ace.output` instructions.

Reconfiguring `aceiobuflen` will invalidate the buffer contents.

If the size is zero, the buffer is disabled and `ace.input` and `ace.output` will raise an invalid instruction exception.

[[ACE-CSR-aceiobuftop]]
===== `aceiobuftop`

`aceiobuftop` is an XLEN-bit RW CSR.

`aceiobuftop` is used to program the top end of a transfer operation to and from the input/output buffer for the `ace.input` and `ace.output` instructions.
It works in conjunction with `acestart` to define the range of buffer.

Reconfiguring `aceiobuftop` will not invalidate the buffer contents.

Reconfiguring `aceiobuflen` will initially set `aceiobuftop` to the same value.

If `aceiobuftop` is zero, `ace.input` and `ace.output` will raise an invalid instruction exception.

[[ACE-CSR-acesequence]]
===== `acesequence`

This is an XLEN-bit URO CSR (2 bits defined).

It takes the value zero if we are using vector registers for the current `ace.exec` or `ace.derive`.
It may take non-zero values only if using `ace.input`/`ace.output` in place of vector registers.

Details in <<ACE-usage-input-output>>.

[[ACE-CSR-aceactivecr]]
===== `aceactivecr`

This is an XLEN-bit URW CSR (5 bits defined).

It serves to tie `ace.input`,  `ace.output`, `ace.exec`, and `ace.derive` instructions to the state of a specific CR.
It can take values 0 to 31, or 32 to disable the tie.

It can only be changed if `acesequence` is zero.

If the value is not 32, the CR in `ace.exec` and the source CR in `ace.derive` can only have this value, otherwise an invalid instruction exception is raised.
This serves to make sure that the instructions are issued in the correct order.

==== New Privileged CSRs

The new privileged CSRs introduced by ACE are defined here.

[[ACE-CSR-macercsk]]
===== `macercsk` group

This is a group of M-Mode WARZ XLEN-bit CSRs.

Eight CSRs may be defined in RV32 and four in RV64 to configure `macercsk`:
(((CSR, `macercsk`)))

* In RV32 these are `macercsk0`, `macercsk!`, ... `macercsk7`.
* In RV64 these are `macercsk0`, `macercsk1`, `macercsk2`, and `macercsk3`

A write to `macercsk{i}` set Bits [(_i_+1) XLEN - 1 : _i_ XLEN] of the RCSK.

Any access to the `macercsk` block outside of M-mode will cause an illegal instruction exception.

NOTE: We assume that M-mode firmware knows if RCSK is configurable, ephemeral, or fixed.
RCSK cannot be assumed to be preserved across power cycles, unless it is fixed.
If the RCSK is reconfigurable, mechanisms for RCSK persistence and cross-device transfer to assist VM migration are system-specific and belong to M-mode firmware.
Cross-device RCSK migration must use a public-key key wrapping mechanism.
Since M-mode FW cannot just trust any external entity claiming to be a trusted device:
all receiving end points, whether they are the M-mode FW of another trusted device, a TPM for temporary storage of a VM's CSK during device hibernation, or an HSM for intermediate CSK storage, must authenticate themselves.

The values written to the `macercsk` block must follow the value update rules defined in <<ACE-CSR-group-update-policy>>.

[[ACE-CSR-group-update-policy]]
===== Value update policy for CSR groups

The implementation must keep track of which CSRs in the group have been written to and which CSRs have not,
and only change the key when the entire group has been written to.

This can be done by maintaining a bitmap with one bit per CSR in the group.
The bitmap is initially all zeros.
When the __i__-th CSR in the group is written to, the __i__-th bit of the bitmap is set to one.
When the bitmap is all ones, the key is then set with the values written to all CSRs in the group and the bitmap is reset to zero.

===== `maceOSSecret` group

This is a group of M-Mode WARZ XLEN-bit CSRs.

Four CSRs may be defined in RV32 and two in RV64 to configure `maceOSSecret`:
(((CSR, `maceOSSecret*`)))

* In RV32 these are `maceOSSecret0`, `maceOSSecret1`, `maceOSSecret2`, and `maceOSSecret3`.
* In RV64 these are `maceOSSecret0` and `maceOSSecret1`.

A write to `maceOSSecret{i}` sets Bits [(_i_+1) XLEN - 1 : _i_ XLEN] of `OSSecret`.

Any access to the `macercsk` block outside of M-mode will cause an illegal instruction exception.

The values written to the `maceOSSecret` group must follow the update rules defined in <<ACE-CSR-group-update-policy>>.

===== `maceBootSecret` group

This is a group of M-Mode WARZ XLEN-bit CSRs.

Four CSRs may be defined in RV32 and two in RV64 to configure `maceeBootSecret`:
(((CSR, `maceeBootSecret*`)))

* In RV32 these are `maceeBootSecret0`, `maceeBootSecret1`, `maceeBootSecret2`, and `maceeBootSecret3`.
* In RV64 these are `maceeBootSecret0` and `maceeBootSecret1`.

A write to `maceeBootSecret{i}` sets Bits [(_i_+1) XLEN - 1 : _i_ XLEN] of `maceBootSecret`.

Any access to the `macercsk` block outside of M-mode will cause an illegal instruction exception.

The values written to the `maceeBootSecret` group must follow the update rules defined in <<ACE-CSR-group-update-policy>>.

[NOTE]
====
`maceBootSecret*` must be reconfigurable in order to support VM reboots which are independent of the boot cycles if the physical host.
====

==== Reuse of `(v)satp`.ASID and `hgatp`.VMID

ACE reuses `(v)satp`.ASID and `hgatp`.VMID to optionally restrict the usage of CCs to a specific process or virtual machine.
In the metadata section, `ASID` and `VMID` are always zero padded to the maximal lengths of 16 and 14 bits, respectively.

[WARNING]
If the Hypervisor extension is not present, `hgatp` is also not present.
We propose to define the `VMID` field of this register also when ACE is provided in order to allow M-mode to be able to separate a main OS from a TEE, for instance, on devices that implement TEEs using mechanisms based on Sv, PMP/Smepmp cite:[RISCV-ISA-Priv].
Regarding Supervisor Domains (SDs) cite:[RISC-V-SD] and Worlds cite:[RISC-V-Worlds] we observe that there is no room in the current metadata format for adding filtering by `SDID` (`mmtp.SDID`) and WID.
This is not an issue since we recommend to use separation by RCTK in combination with SDs or Worlds, which does not prevent a program running in a SD or World to provide a CC to a program running in a different SD or World. This is done by by configuring a CR and then relinquishing control to M-mode to export the CR with the RCTK used by the target software.
The same holds for any intended separation by hart ID (`mhartid`), which is facilitated by the fact that the RCTK CSR group is per-hart.

NOTE: The software in each World/Supervisor Domain is normally responsible to generate or obtain their own keys, and if a process (applet) in one World/Supervisor Domain is responsible to provide keys to other Worlds/Supervisor Domains, it is the responsibility of the M-mode formware to perform an appropriate `ace.import`/RCSK switch/`ace.export` sequence.

[[ACE-format-configuration]]
=== Semantics of Initialization, Export and Import of Cryptographic Contexts

In the pseudocode listings of this section, `UNINTERRUPTIBLE_BLOCK_START` marks the start of an uninterruptible code block, and `UNINTERRUPTIBLE_BLOCK_END` its end.
When an interrupted init, export or import or operation is resumed, it will resume at the point of interruption.

Anything before the first `UNINTERRUPTIBLE_BLOCK_START` consists only of type declarations and possibly information that is trivial to reconstruct.

The Data Structures of the algorithms (such as those defined in <<ACE-algorithms>>) also define the `content[]` array in the pseudocode.
`content[]` offers a _view_ of (certain fields of the) the content of a CR as if it were serialized as in the plaintext format of the content in an SCC, such that any change in one, except for the non-serialized fields, is reflected in the other.
As such, it is a virtual representation; its consecutive bytes do not imply physical contiguity within the CR, nor there is a 1-1 correspondence between its bytes and those in the CR.  For instance, keys may be split across shares in a threshold implementation, so that one key byte in `content[]` corresponds to two or three non-contiguous bytes in the CR.
However, any read or write to `content[]` must bijectively map to the underlying representation, in the sense that a write followed by a read must return the original data, and a read followed by a write must restore an equivalent microarchitectural state.

[[ACE-init]]
==== Initialization

We start with the algorithm that reads an initialization input and uses it to initialize a CR. The algorithm is as follows:

[[ACE-init-listing]]
.Initializing a CR with metadata and content
[]
----
M : array of bytes // from memory

// next instruction preemptible, with `acestart` from 0 to 7
UNINTERRUPTIBLE_BLOCK_START
|   metadata : bits(64) = M[0 .. 7]
|   if (there is not enough memory for the algorithm encoded in the metadata)
|       error ace_err_insufficient_memory
|   z = size(content according to metadata);
|   content = internal buffer for z bytes;
|   num_blocks = ceil(z / 16);
|   last_block_fractional : boolean = (z % 16 != 0);
UNINTERRUPTIBLE_BLOCK_END

foreach(i from 0 to num_blocks - 1) {
    // next instruction preemptible, with `acestart` from 32+i*16 to 39+i*16 or 47+i*16
    UNINTERRUPTIBLE_BLOCK_START
    |   if ((i == num_blocks - 1) and last_block_fractional)
    |       content[i*16 .. 7+i*16] = M[8+i*16 .. 15+i*16];
    |   else
    |       content[i*16 .. 15+i*16] = M[8+i*16 .. 23+i*16];
    UNINTERRUPTIBLE_BLOCK_END
}

// if preempted here, `acestart` will be z
UNINTERRUPTIBLE_BLOCK_START
|   - Now the content can be deserialized, for instance keys may be converted into shares.
|   - Any derived values not given in the initialization input will be computed here
UNINTERRUPTIBLE_BLOCK_END
----

[[ACE-SCC-AEAD]]
==== AEAD Algorithm for SCC Export and Import

The AEAD algorithm chosen to export CRs into SCCs is AES-GCM-SIV.
We follow the definition of the algorithm from cite:[DBLP-journals-iacr-GueronLL17] and cite:[RFC8452].
We first define the Key Derivation and the DCSK Derivation functions.

.RFC8452 Key Derivation
[]
----
function RFC8452_KeyDeriv(key) = {
  struct {
    AESE256(key, (125`b0 @ 0b101))[63:0] @ AESE256(key, (125`b0 @ 0b100))[63:0] @
    AESE256(key, (125`b0 @ 0b011))[63:0] @ AESE256(key, (125`b0 @ 0b010))[63:0],
    AESE256(key, (125`b0 @ 0b001))[63:0] @ AESE256(key, (125`b0 @ 0b000))[63:0]
  }
}
----

.Derived Key Derivation
[]
----
function DCSK_KeyDeriv(key,L) = {
    AESE256(key, L ^ (127'b0 @ 1'b1)) @ AESE256(key, L ^ (127'b0 @ 1'b0))
}
----

NOTE: Due to the computational cost of the derivation functions, implementations may
cache recently used derived keys for both the Root RCSK and Locality-derived keys.

The generation of the SCC from the CC in a CR (cf.{nbsp}<<ACE-SCC-export>>) and the import of a SCC into a CR (cf.{nbsp}<<ACE-SCC-import>>) are defined next.

[[ACE-SCC-export]]
.Generation of the SCC from a CR Using AES-GCM-SIV (RFC8452)
[]
----
metadata : bits(64); // from the CR
N, SIV : bits(96);
tmp : bits(128);
Kenc : bits(256);
Kauth : bits(128);
content : array[z] of bytes,      // from the CR's metadata
where z : int = size(content);    // content is serialized, size derived from metadata
ASSERT(8 divides z);
M : array[32 + z] of bytes;       // information
let last_block_fractional : boolean = z % 16 != 0;
let num_blocks : int = ceil(z / 16);

UNINTERRUPTIBLE_BLOCK_START
|   N = random(96 bits);
|
|   if (metadata.Locality == 15) then
|       CSK = RCSK;
|   else
|       CSK = DCSK_KeyDeriv(RCSK, LST[metadata.Locality]);
|
|   {Kenc, Kauth} = RFC8452_KeyDeriv(CSK);
|
|   - If some internal operations are needed to make the content available,
|   - such as reconstructing threshold keys/values into a single share, these
|   - must be computed at this point. Starting with the following POLYVAL operation
|   - content will refer to the resulting data as architected for non-threshold
|   - implementations.
|
|   tmp = POLYVAL(Kauth, 64'b0 @ metadata @ content);
|   SIV = AESE(Kenc, 1'b0 @ (tmp[126:0] xor (31'b0 @ N)))) >> 32;
UNINTERRUPTIBLE_BLOCK_END

// preemptible here, with `acestart` from 0 to 15
UNINTERRUPTIBLE_BLOCK_START
|   M[0 .. 15] = N[63:0] @ metadata[63:0];
UNINTERRUPTIBLE_BLOCK_END

// preemptible here, with `acestart` from 16 to 31
UNINTERRUPTIBLE_BLOCK_START
|   M[16 .. 31] = SIV[95:0] @ N[95:64];
UNINTERRUPTIBLE_BLOCK_END

foreach(i from 0 to num_blocks - 1) {
    // next instruction preemptible, with `acestart` from 32+i*16 to 39+i*16 or 47+i*16
    UNINTERRUPTIBLE_BLOCK_START
    |   if ((i == num_blocks - 1) and last_block_fractional)
    |       M[32+i*16 .. 39+i*16] = content[i*16 .. 7+i*16] xor
    |                       AESE(Kenc, 1'b1 @ SIV[94:0] @ (binary(i)[31:0]))[63:0];
    |   else
    |       M[32+i*16 .. 47+i*16] = content[i*16 .. 15+i*16] xor
    |                       AESE(Kenc, 1'b1 @ SIV[94:0] @ (binary(i)[31:0]));
    UNINTERRUPTIBLE_BLOCK_END
}
----

[[ACE-SCC-import]]
.Importing a SCC into a CR Using AES-GCM-SIV (RFC8452)
[]
----
M : array of bytes // from memory
Kenc : bits(256);
Kauth : bits(128);
N, SIV : bits(96);
tmp : bits(128);
tag : bits(96);

// next instruction preemptible, with `acestart` from 0 to 7
UNINTERRUPTIBLE_BLOCK_START
|   metadata : bits(64) = M[0 .. 7]
|   if (there is not enough memory for the algorithm encoded in the metadata)
|       error ace_err_insufficient_memory
UNINTERRUPTIBLE_BLOCK_END

UNINTERRUPTIBLE_BLOCK_START
|   z = size(content according to metadata);
|   content = internal buffer for z bytes;
|   num_blocks = ceil(z / 16);
|   last_block_fractional : boolean = (z % 16 != 0);
|
|   if (metadata.Locality == 15) then
|       CSK = RCSK;
|   else
|       CSK = DCSK_KeyDeriv(RCSK, LST[metadata.Locality]);
|
|   {Kenc, Kauth} = RFC8452_KeyDeriv(CSK);
|
|   // next instruction preemptible, with `acestart` from 8 to 19
|   N = M[8 .. 19]
UNINTERRUPTIBLE_BLOCK_END

// next instruction preemptible, with `acestart` from 20 to 31
UNINTERRUPTIBLE_BLOCK_START
|   SIV = M[20 .. 31]
|   tmp = 64'b0 @ metadata;
|   tmp = tmp * Kauth;  // * = Montgomery multiplication
UNINTERRUPTIBLE_BLOCK_END

foreach(i from 0 to num_blocks - 1) {
    // next instruction preemptible, with `acestart` from 32+i*16 to 39+i*16 or 47+i*16
    UNINTERRUPTIBLE_BLOCK_START
    |   if ((i == num_blocks - 1) and last_block_fractional) {
    |       content[i*16 .. 7+i*16] = M[32+i*16 .. 39+i*16] xor
    |                     AESE(Kenc, 1'b1 @ SIV[94:0] @ (binary(i)[31:0]))[63:0];
    |       tmp[63:0] = tmp[63:0] xor content[i*16 .. 7+i*16];
    |   } else {
    |       content[i*16 .. 15+i*16] = M[32+i*16 .. 47+i*16] xor
    |                     AESE(Kenc, 1'b1 @ SIV[94:0] @ (binary(i)[31:0]));
    |       tmp = tmp xor content[i*16 .. 15+i*16];
    |   }
    |   tmp = tmp * Kauth;  // * = Montgomery multiplication
    UNINTERRUPTIBLE_BLOCK_END
}

// if preempted here, `acestart` will be z + 32

UNINTERRUPTIBLE_BLOCK_START
|   tag = AESE(Kenc, 1'b0 @ (tmp[126:0] xor (31'b0 @ N)))) >> 32;
|   if (tag != SIV) then { error ace_err_authentication; }
|   - Now the content can be deserialized.
|   - This includes computing any derived values not saved as part of the SCC,
|   - as well as creating shares for threshold implementations.
UNINTERRUPTIBLE_BLOCK_END
----

//

// ///////////////////////////////////////////////////////////////////////////////////////////

=== Supported Algorithms

[WARNING]
This list is not yet finalized. Also, at the end we must add algorithm numbers!

ACE architects support for several algorithms. The following is the minimal required subset:

* AES-128 and AES-256 encryption and decryption.
* AES-CTR, AES-GCM, AES-GCM-SIV, AES-XTS using AES-128/256.
* AES-CMAC using AES-128/256.
* SHA-2, SHA-2-HMAC.

The list of other architected algorithms is subject to change, but it includes at least:

* AES-192, alone and with the above modes.
* SM4 Block Cipher.
* The Ascon suite (Ascon-128/128a-AEAD, Ascon-Hash, Ascon-XOF, Ascon-80pq).
* SHA-3, SHA-3-HMAC.
* SM3 Secure Hash.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-instructions-detailed]]
=== Instructions

ACE provides a number of unprivileged instructions, some implemented as CSR read/write operations.
This section specifies the semantics and encodings of these instructions.

The notation `K[Xd]`, for a GPR `Xd`, refers to the CR whose number is contained in `Xd`,
and `Kn|K[Xn]` means that there are two different encodings for when the CR number is passed as a 5-bit immediate (`Kn`) or via the value of `Xn`.
When a GPR is used to index a CR, use of the zero register `X0` is reserved and results in an illegal instruction exception.

For each instruction, we specify whether

* it _possibly modifies state_,
* it is _usage-controlled_,
* it is _trappable_, i.e., can be implemented by privileged code as trap-and-emulate, and whether
* the execution of the instruction itself can be _interrupted_, for instance by context switches or page faults, to be resumed or restarted later.

NOTE: Trappability refers only on the CPU-side of the implementation and it is a distinct concept from _custom implementations of primitives within the ACE unit_.
Implementers may, for instance, incorporate a secure CPU with updatable firmware to support new primitives.
While the architecture does not prohibit this, such an approach substantially expands the attack surface of the ACE unit.

[WARNING]
The encodings presented here are just examples, and for the moment RV64-only, and may not be final.
They serve as a starting point for discussion and refinement as
well as a proof that, at the time of this writing, the ACE instruction set
can be encoded.


[[ACE-instruction-init]]
==== ace.init

`ace.init Kd|K[Xd], %offset(Xs)`
(((ACE, instruction, ace.init)))

Encoding::
`ace.init` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Ks','K[Xd]'] },
    { bits:  3, name: 'ace.init', attr: [0x4,0x5] },
    { bits:  5, name: 'Xs' },
    { bits: 12, name: 'imm', attr: ['offset'] },
]}
....

Description::
`ace.init` initializes a CR with metadata and content to create a CC.
`Kd` or `K[Xd]` denotes the CR to be initialized.
`Xs` points to the region of memory containing the metadata and the key material.

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *NO*. +
Trappable: *YES*. +
Interruptible: *YES*.

NOTE: `ace.init`, as well as `ace.import`, `ace.export`, `ace.input`, and `ace.output` as described later, perform direct memory accesses.
This does not violate the RISC-V load/store architecture principles,
since `ace.init`, `ace.import` and `ace.input` can be seen as special kinds of load instructions and
`ace.export` and `ace.output` as special store instructions.
// as ACE is architected to behave like an _attached_ unit, which may have its own interfaces.

NOTE: The operation follows the two-phases processing model defined in <<ACE-format-configuration>>.
In the first phase, the metadata block is read, which determines the length of the remaining information.
Then, in the second phase, the configuration material is read and processed.

[[ACE-instruction-clear]]
==== ace.clear/ace.reset

`ace.clear Kd|K[Xd]` +
(((ACE, instruction, ace.clear)))
`ace.reset`
(((ACE, instruction, ace.reset)))

Encoding::
`ace.clear/ace.reset` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Ks','K[Xd]'] },
    { bits:  3, name: 'ace.clear', attr: [0x6,0x7] },
    { bits:  5, name: 0x0 },
    { bits: 12, name: 0x0 },
]}
....

Description::
For `ace.clear`, `Kd` or `K[Xd]` denotes the CR to be cleared. +
`ace.reset` uses the encoding for `ace.clear` with indirect CR addressing (the `ace.clear` field is `3'b111`) and `Xd` = `X0` (the `context` field is `0`).

Properties::
`ace.clear` possibly modifies state. +
`ace.reset` unconfigures the unit. +
Usage-controlled: *NO*. +
Trappable: +
{nbsp}{nbsp}``ace.clear``: *NO*; +
{nbsp}{nbsp}``ace.reset``: *YES* (it can be implemented as a series of `ace.clear` instructions). +
Interruptible: *NO*.

[[ACE-instruction-export]]
==== ace.export

`ace.export %offset(Xd), Ks|K[Xs]`
(((ACE, instruction, ace.export)))

Encoding::
`ace.export` is an S-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'imm[4:0]' },
    { bits:  3, name: 'ace.export', attr: [0x0,0x1] },
    { bits:  5, name: 'Xd' },
    { bits:  5, name: 'context', attr: ['Ks','K[Xs]'] },
    { bits:  7, name: 'imm[11:5]' },
]}
....

Description::
Exports the CR `Ks` or `K[Xs]` to memory at address `Xd`, using the procedure described in <<ACE-format-SCC>>.
If the context is unconfigured, or `Xs` is out of range, the operation will report error ace_err_invalid.

The instruction must follow the interruptibility rules defined in <<ACE-CSR-acestart>>.
Similarly to entire-vector-register store instructions, `ace.export` appears to other harts as sequences of individual stores.

The initial cryptographic phase of `ace.export`, as well as the authentication phase of `ace.import`, must be uninterruptible.
Even if these parts are executed concurrently with other operations, an interrupt handler may need to wait for these steps to complete before proceeding with any memory accesses.

Properties::
Possibly modifies state: *NO*. +
Usage-controlled: *NO*. +
Trappable: *YES*. +
Interruptible: *YES*.


[[ACE-instruction-import]]
==== ace.import

`ace.import{nbsp}{nbsp}{nbsp}Kd|K[Xd], %offset(Xn)` +
`ace.import.S{nbsp}Kd|K[Xd], %offset(Xn)`
(((ACE, instruction, ace.import)))
(((ACE, instruction, ace.import.S)))

Encoding::
`ace.import` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Kd','K[Xd]'] },
    { bits:  3, name: 'ace.import', attr: ['0    0    S','0    1    S'] },
    { bits:  5, name: 'Xn' },
    { bits: 12, name: 'imm' },
]}
....

Description::
`Kd` or `K[Xd]` denotes the CR into which the SCC is to be imported. +
`Xn` is the GPR containing the base address of the buffer with the source SCC. +
The bit S takes the values 0 (false) or 1 (true).
It is set to true if the key is in a system defined format
(`ace.import.S`)
and not the format defined by the present architecture
(`ace.import`).

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *NO* +
Trappable: *YES*. +
Interruptible: *YES*.


The instruction must follow the interruptibility rules defined in <<ACE-CSR-acestart>>.
Similarly to entire-vector-register load instructions, `ace.import` appears to other harts as sequences of individual loads.

NOTE: The operation can be conceptually split into two phases.
In the first phase, the metadata
block is read, which determines the length of the remaining information.
Then, in the second phase, the rest of the SCC is read and processed.

NOTE: The instruction encoding includes a single bit to indicate a system-defined format. If multiple such formats are supported, the data format itself must incorporate a unique identifier to differentiate them. The system is therefore responsible for embedding these identifiers within all system-defined formats.

NOTE: The `ace.export` instruction does not have an `ace.export.S` analogue of `ace.import.S`.
This means that system-specific dynamically generated keys can be imported but not exported in the same form: they must be exported in the format architected here for ACE CCs.

[[ACE-instruction-exec]]
==== ace.exec

The `ace.exec` instruction admits four Forms, namely
(((ACE, instruction, ace.exec)))

[upperalpha]
. `ace.exec  Vd, Kn|K[Xn], Vs` {nbsp}{nbsp} takes an input vector and writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}{nbsp}Kn|K[Xn], Vs` {nbsp}{nbsp} takes an input vector but does not write to an output vector.
. `ace.exec  Vd, Kn|K[Xn]{nbsp}{nbsp}{nbsp}{nbsp}` {nbsp}{nbsp} does not take an input but writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}{nbsp}Kn|K[Xn]{nbsp}{nbsp}{nbsp}{nbsp}` {nbsp}{nbsp} does not take an input vector and does not write to an output vector.

// Without this comment, the next part is not properly formatted...

Encoding::
`ace.exec` is an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Vd' },
    { bits:  3, name: 'ace.exec' },
    { bits:  5, name: 'Kn|K[Xn]' },
    { bits:  5, name: 'Vs' },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....
+
Bit `r` (i.e., bit 27) takes the value 0 if the context is encoded as an immediate,
and it takes the value 1 if a GPR (scalar integer value) is used to reference it.
For the four Forms A-D above, the encodings are:
+
[upperalpha]
. `ACE.exec` = `0b000`.
. `ACE.exec` = `0b001` and `rs2` = `0b00000`.
. `ACE.exec` = `0b010` and `rd` = `0b00000`.
. `ACE.exec` = `0b011` and `rs2` = `rd` = `0b00000`.

NOTE: We admit variants of Forms B and D, which we call Form B', resp., Form D',
with non-zero values in `rd`, resp., `rs2`, to encode additional instructions.

// To make indent in next line correct

Description::
Performs a cryptographic operation such as an encryption or decryption, absorbing a value in a hash,
an elliptic curve point addition or scalar multiplication, etc., and possibly returning a value.
+
If the V extension register file is not implemented, only Form D of `ace.exec` is supported
(the derived Forms used to define other instructions are still supported) and `ace.input`, `ace.output` must be used to
provide inputs and extract outputs from `ace.exec`.
<<ACE-usage-input-output>> described how this is done.

NOTE: In many algorithms, performing an operation could imply a state change. For instance, setting an IV or nonce in an AEAD mode of operation might also transition to the state for absorbing associated data.  To maintain consistency, ACE mandates explicit state transitions, even when this requires additional instructions.  ACE also requires that only one form of the `ace.exec` instruction is allowed per distinct algorithm state.  Exceptions are permitted only when necessary to maintain security, such as automatic transitions from hash finalization to verification, or to the _completed_ or _invalidated_ states (cf.{nbsp}<<ACE-state-constants>> and <<ACE-algorithms>>).

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *NO*. +
Interruptible: See interruptibility rules in <<ACE-generic-rules>>.

[[ACE-instruction-size]]
==== ace.size

`ace.size` returns the size of the memory buffer that would be necessary to store the exported SCC.
(((ACE, instruction, ace.size)))
Knowing this size is necessary for any feature that relies on `ace.export`, including context switching.

Properties::
Possibly modifies state: *NO*. +
Usage-controlled: *NO*. +
Trappable: *NO*. +
Interruptible: *NO*.

//

[[ACE-instruction-size-CR]]
===== Context Variant

`ace.size Xd, Ks|K[Xs]`

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x3, attr: ['ace.exec', '(Form D\')'] },
    { bits:  5, name: 'Ks|K[Xs]' },
    { bits:  5, name: 0x1, attr: ['ace.size'] },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....
+
Bit `r` (i.e., bit 27) is 0 if the CR is encoded as an immediate, and 1 if the CR's number is given in a GPR.

Description::
Returns the size of the SCC corresponding to the source CR `Ks` or `K[Xs]`.

NOTE: The returned value can significantly differ from the internal resource usage to store the CC's data in a CR—it can be larger (for simple primitives, because of the nonce/SIV overhead) but
also smaller (for keys split into shares for threshold implementations, but saved
externally in reconstructed form).

[[ACE-instruction-size-metadata]]
===== Metadata Variant

`ace.size Xd, Xs`

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x3, attr: ['ace.exec', '(Form D\')'] },
    { bits:  5, name: 'Xs' },
    { bits:  5, name: 0x2, attr: ['ace.size'] },
    { bits:  7, name: 0x0 },
]}
....

Description::
This instruction writes the size of a SCC having the metadata section given in `Xn` into GPR `Xd`, and zero if the algorithm is not supported.
Only the Algorithm and Key_Type fields of the metadata section of a CC need to be considered to determine the size of the SCC (as per <<ACE-algorithms>>).
+
On RV32 the GPR `Xs` needs to contain only the lower 32 bits of the metadata section, since they contain the fields which are required to determine the size of the SCC.

[[ACE-instruction-size-internal]]
===== Internal Capacity Variant

`ace.size.internal Xd, Xs`

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x3, attr: ['ace.exec', '(Form D\')'] },
    { bits:  5, name: 'Xs' },
    { bits:  5, name: 0x3, attr: ['ace.size'] },
    { bits:  7, name: 0x0 },
]}
....

Description::
This instruction writes into GPR `Xd` the amount of internal capacity a CC having the metadata section given in `Xn` would occupy in terms of implementation-dependent units. Passing the value `ones(64)` into `Xs` results in the total amount of internal capacity.
Only the bits corresponding to the Algorithm, SP_Protection, Direction_Policy and Key_Type fields are considered and all other bits must be zero, except when passing `ones(64)`.
If the combination of Algorithm, SP_Protection, Direction_Policy and Key_Type fields is not supported, the instruction writes zero into `Xd`.
+
On RV32 the GPR `Xs` needs to contain only the lower 32 bits of the metadata section, since they contain the fields which are required to determine the size of the SCC.
In this case, the value of `Xs` to obtain the fill CRF capacity is `ones(32)`.


[[ACE-instruction-available]]
==== ace.available

`ace.available Xd, Xs`
(((ACE, instruction, ace.available)))

Alias to the Metadata Variant of `ace.size`, as it returns zero if the algorithm is not supported.

Properties::
Same as `ace.size`.

//

[[ACE-instruction-clone]]
==== ace.clone

`ace.clone Kd|K[Xd], Ks|K[Xs]`
(((ACE, instruction, ace.clone)))

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Kd|K[Xd]' },
    { bits:  3, name: 0x3, attr: ['ace.exec','(Form D\')'] },
    { bits:  5, name: 'Ks|K[Xs]' },
    { bits:  5, name: 0x3, attr: ['ace.clone'] },
    { bits:  1, name: 0x0 },
    { bits:  2, name: 'R' },
    { bits:  4, name: 0x0 },
]}
....
+
Bits [27:26], i.e., field `R`, take the following values depending on how the CRs are given:
+
[upperalpha]
. `00`{nbsp}{nbsp} if the source and the output CRs are both encoded as immediates.
. `01`{nbsp}{nbsp} if the source CR is selected using a GPR and the output CR is encoded as an immediate.
. `10`{nbsp}{nbsp} if the source CR is encoded as immediate and the output CR is selected using a GPR.
. `11`{nbsp}{nbsp} if the source and the output CRs are both selected using the values of GPRs.

(The first digit is bit 27 and the second digit is bit 26.)

// Comment to ensure proper indentation in the next Description

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *NO*. +
Trappable: *YES*, it can be implemented as an export followed by an import in a handler. +
Interruptible: *NO*.

Description::
Clones source CR `Ks` (or the CR indexed by `Xs`) into destination CR `Kd` (or into the CR indexed by `Xd`).

NOTE: The `ace.clone` instruction is an optimization for the sequence `ace.export` followed by `ace.import`. While reusing cryptographic state (e.g., encrypting with the same counter) can enable certain attacks, this risk cannot be eliminated by omitting `ace.clone`, as a state can be exported and re-imported multiple times.

[[ACE-instruction-derive]]
==== ace.derive (optional)

`ace.derive Kd|K[Xd], Ks1|K[Xs1]` +
`ace.derive Kd|K[Xd], Ks1|K[Xs1], Vs2`
(((ACE, instruction, ace.derive)))

Encoding::
The encoding is a variant of Form A `ace.exec` encoding, and is thus an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Kd|K[Xd]' },
    { bits:  3, name: 0x0, attr: ['ace.exec (Form A)'] },
    { bits:  5, name: 'Ks1|K[Xs1]' },
    { bits:  5, name: 'Vs2', attr: ['use for additional input','no additional input (zero field)'] },
    { bits:  1, name: 0x1 },
    { bits:  2, name: 'R' },
    { bits:  1, name: 'z', attr: [0x1,0x0] },
    { bits:  3, name: 0x0 },
]}
....
+
This encoding differs from Form A `ace.exec` by having bit 25 set to 1.
Bits [27:26], i.e., field `R`, is encoded exactly as for `ace.clone` (cf.{nbsp}<<ACE-instruction-clone>>).
Bit 28 determines whether an additional vector register (or register group) is used to pass a parameter to the key derivation mechanism or not.

Description::
The instruction is used to derive a new context from an existing one, with its own opaque key material.
It is similar to `ace.clone`, but the derived context is not a copy of the source context,
rather, it is a new context that is derived from it, for instance, through a key derivation mechanism.
This instruction can be used multiple times, to generate multiple derived contexts.
+
The first variant of `ace.derive` has the same semantics of the second variant if the input/output buffer is not empty
(cf.{nbsp}<<ACE-usage-input-output>>).


Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *NO*. +
Interruptible: *NO*.

[[ACE-instruction-state]]
==== ace.state/ace.dir

`ace.state`/`ace.dir Kd|K[Xd], #immed7` +
`ace.state`/`ace.dir Kd|K[Xd], #immed7, Xs`
(((ACE, instruction, ace.state)))
(((ACE, instruction, ace.dir)))

Encoding::
`ace.state`/`ace.dir` is an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Kd|K[Xd]' },
    { bits:  3, name: 0x4, attr: ['ace.state'] },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
    { bits:  5, name: 'Xs' },
    { bits:  7, name: 'immed7' },
]}
....
+
Bit `r` (i.e., bit 15) is 0 if the context is encoded as an immediate, and 1 if a GPR is used to reference it.

Description::
`ace.state` and `ace.dir` are the same instruction. +
`Ks` or `K[Xs]` is the CR whose state is to be set. +
The `#immed` operand is a constant from the set of admissible values defined for each algorithm, used to manage the algorithm's internal state machine when additional states are required. +
`Xs` is a GPR that is either `X0` or contains an optional additional parameter for the state machine.
The new state number, if allowed, is written into the State_Number field of the metadata, unless the algorithm requires more than 16 states, in which case an ad-hoc field must be defined in the context (for both internal representation and SCCs).

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *NO*. +
Interruptible: *NO*.

The state numbers used in this specification are defined in <<ACE-state-constants>>.

It is always allowed to repeat `ace.state` instructions to the current state, provided that the correct form of the instruction is used.

[[ACE-instruction-restrict]]
==== ace.restrict/ace.harden

`ace.restrict/ace.harden{nbsp}{nbsp}Kd|K[Xd], Xs`
(((ACE, instruction, ace.restrict)))
(((ACE, instruction, ace.harden)))

// Without this comment, the next part is not properly formatted...
Encoding::
The encoding uses `ace.exec` Form B', with bit 7 (which is in the `rd` field) set.
It is thus a variant of an R-type instruction.
The source register field encodes a GPR and not a vector register.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 0x1 },
    { bits:  3, name: 0x1, attr: ['ace.exec', '(Form B\')'] },
    { bits:  5, name: 'Kd|K[Xd]' },
    { bits:  5, name: 'Xs' },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....
+
If bit `r` (i.e., bit 27) is 0, the 5-bit destination field [11:7] contains the destination context number,
else it determines the GPR that contains the context number.

// comment

Description::
+
--
This instruction can be used to:

* Restrict the usage of a CC (as stored in a CR) to specific modes or to a specified `ASID` or `VMID`;
* Restrict the use of encryption or decryption in a CC that allows both; and
* Activate the side-channel protection of the CC or increase it.

Let `m` be the metadata field of the CC in the destination CR. +
On RV64, the instruction works as follows:

* `Xs`[15:0] and `Xs`[25:20] must be zero
* `Xs`[19:16] and `Xs`[63:32] must have the same format as the corresponding bits of the metadata.
* `Xs`[17:16] can be used to turn on or increase the level of the side-channel protection of the algorithm in the CC, if the microarchitecture supports the corresponding implementation. The levels are defined in <<ACE-SC-protection-levels>>. Downgrading side-channel protection is not permitted, and attempting to do so will result in error _ace_err_invalid_ (cf.{nbsp}<<ACE-error-codes>>).
* `Xs`[19:18] can be used to deactivate encryption or decryption in a CC that allows both, otherwise it is ignored. Writing to them cannot be used to deactivate both encryption and decryption simultaneously, nor to activate encryption, resp., decryption in a CC that did not allow it.  In particular, if `m`[19:18] = `2'b11`, then this case at least one bit of `Xs`[19:18] must be set to 1. In all other cases, either `Xs`[19:18] = `m`[19:18] or zero, in which case it is ignored.
* A zero in any of the six bits `Xs`[31:26] means that the corresponding policy is _not_ changed.
* A one in any of the four bits `Xs`[29:26] means that usage by the corresponding mode is forbidden, and the corresponding bit in the metadata of the destination CC is set to 1.
* If `Xs`[30] is set and `m`[30] is NOT set, then UC_Policy_3, i.e., `m`[47:32], is set to `Xs`[47:32].
* If `Xs`[31] is set and `m`[31] is NOT set, then UC_Policy_4, i.e., `m`[63:48], is set to `Xs`[63:48].
* If `Xs`[30] and `m`[30] are both set and `Xs`[47:32] != `m`[47:32], then `aceerror` is set to ace_error_invalid.
* If `Xs`[31] and `m`[31] are both set and `Xs`[63:48] != `m`[63:48], then `aceerror` is set to ace_error_invalid.

On RV32, `s` must be even and register pair `X[s]` and `X[s+1]` is read, where
`X[s]` corresponds to bits [31:0] and `X[s+1]` to bits [63:32] of the metadata.
In other words, `Xs` is replaced by `(X[s+1] @ X[s])` in the above description.
--
+

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *NO*. +
Interruptible: *NO*.

//

[NOTE]
====
This instruction enables several practical use cases:

*   Enabling side-channel protection when supported by the microarchitecture, even if the original CC was not configured with it.
*   Allowing privileged code to give a CC to several processes by first cloning it and setting UC_Policy_3 in each copy to the target process's `ASID`, thereby restricting usage of this CC only to authorized processes.
*   Similarly, enabling privileged code to split a CC capable of both encryption and decryption into two CCs, one only capable of encryption and the other only capable of decryption, thereby creating a one-way channel between processes.

The ability to perform such customizations saves both time and computational resources by avoiding additional round-trips to trusted environments.
====

//

[[ACE-instruction-error]]
==== ace.error

`ace.error Xd`
(((ACE, instruction, ace.error)))

Description::
The ACE Unit may be in an error state due to the previous operation.
The corresponding error code is written into GPR `Xd`.
This is implemented as a read from CSR `aceerror`, which may cause the hart to wait if the error code is not yet available (cf.{nbsp}<<ACE-CSR-ace-error>>).
The error code list is architected and given in <<ACE-error-codes>>.

Properties::
Possibly modifies state: *NO*. +
Usage-controlled: *NO*. +
Trappable: *NO*. +
Interruptible: *NO*.

//

[[ACE-instruction-input]]
==== ace.input (optional)

`ace.input %offset(Xs), Xl`
(((ACE, instruction, ace.input)))

Encoding::
`ace.input` is an S-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'imm[4:0]' },
    { bits:  3, name: 'ace.input', attr: [0x4] },
    { bits:  5, name: 'Xl' },
    { bits:  5, name: 'Xs' },
    { bits:  7, name: 'imm[11:5]' },
]}
....

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *YES* +
Trappable: *YES*. +
Interruptible: *YES*.

Description::
In all cases where the vector registers are not sufficiently long, or even absent, inputs can be read directly from memory and written directly to memory.
For this reason, the architecture defines `ace.input` and `ace.output` (cf. next section).
Their usage is explained in <<ACE-usage-input-output>>.

//

[[ACE-instruction-output]]
==== ace.output (optional)

`ace.output %offset(Xd), Xl`
(((ACE, instruction, ace.output)))

Encoding::
`ace.output` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 'ace.output', attr: [0x4] },
    { bits:  5, name: 'Xl' },
    { bits: 12, name: 'imm' },
]}
....

Properties::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *YES*. +
Interruptible: *YES*.

//

[[ACE-usage-input-output]]
==== Usage of the ace.input and ace.output Instructions

The `ace.input` and `ace.output` instructions can replace the inputs and outputs to Forms A-C of `ace.exec` and the input of `ace.derive`.
They can be used only if the size in CSR `aceiobuflen` is non-zero and is a valid size (for instance the block size `b` or a multiple thereof),
otherwise an invalid instruction error is raised.

If `aceiobuflen` is non-zero, then Forms A, B, and C of `ace.exec` and `ace.derive` can be replaced in the code as follows:

[[ACE-replacement-instructions]]
.Replacement for `ace.exec` instructions with input/output
[float="center",align="center",width="80%",cols="<42%,<38%",options="header"]
|===
| Original Instruction          | Replacement Sequence
| `ace.exec{nbsp}{nbsp}{nbsp}Vd, Kn\|K[Xn], Vs` | `ace.input{nbsp}{nbsp}Xl, Vs` +
`ace.exec{nbsp}{nbsp}{nbsp}Kn\|K[Xn]` +
`ace.output{nbsp}Vd,  Xl`
| `ace.exec{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}Kn\|K[Xn], Vs`     | `ace.input{nbsp}{nbsp}Xl, Vs` +
`ace.exec{nbsp}{nbsp}{nbsp}Kn\|K[Xn]`
| `ace.exec{nbsp}{nbsp}{nbsp}Vd, Kn\|K[Xn]`     | `ace.exec{nbsp}{nbsp}{nbsp}Kn\|K[Xn]` +
`ace.output{nbsp}Vd,  Xl`
| `ace.derive Kd\|K[Xd], Ks1\|K[Xs1], Vs2` | `ace.input{nbsp}{nbsp}Xl, Vs2` +
`ace.derive{nbsp}Kd\|K[Xd], Ks1\|K[Xs1]` +
|===

In all cases, the `ace.input` and `ace.output` instructions must be temporarily tied to a specific context in order to properly determine the allowed sequences.
This is done by setting the `aceactivecr` CSR (cf.{nbsp}<<ACE-CSR-aceactivecr>>) first. The user must not forget to set it back to 32 after the sequence is completed.

We use the `acesequence` CSR to indicate whether we are using the input/output buffer or the vector registers to provide the inputs and outputs to ACE instructions, and to track the instruction sequence.
The initial value of `acesequence` is zero.
As soon as an `ace.input` is completed in place of a Form A or B `ace.exec` or `ace.derive`, or a Form D `ace.exec` is completed in place of a Form C `ace.exec`, `acesequence` is set to 1.
In this case, `acesequence` remains 1 until the end of the second instruction of the replacement sequence, and-if there is a third instruction in the sequence-then set to 2 until the end of the third instruction of the sequence.
At the end of the sequence, `acesequence` is reset to 0.
The ordering of the instructions in a replacement sequence is enforced by the architecture according to the value of `acesequence` and the state number of the CR configured in `meta`.
Not properly following the instruction ordering raises an invalid instruction exception.
`acesequence` can be saved and restored by privileged code together with `acestart`.

The internal input/output buffer, if enabled, is not part of a CR but is a separate structure. It is also architectural, i.e., per-hart.
In fact, `ace.output` can be used to save the contents of the buffer, and `ace.input` can be used to restore it freely as long as `aceactivecr` takes the value 32.
Also, these operations start at the offset specified in `acestart`, so the state of the buffer can easily be saved and restored with the same approach used for vectors.

NOTE: This mechanism is one of the reasons, besides keeping the state machines simple, that in a given state of an algorithm, in each state only one Form of `ace.exec` instruction is allowed.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-trappable-insns-support]]
==== Support for Trappable (Emulated) Operations

[WARNING]
This section is currently non-normative. There are ongoing discussions on whether to formalize it completely and make it normative.

Instructions `ace.init`, `ace.export`, `ace.import`, `ace.input`, and `ace.output` support long inputs and outputs.
To reduce hardware complexity, these operations can be trapped and emulated in software.
(((ACE, trappable instruction)))
Upon a trap, the handler identifies the trapped instruction and uses `ace.size` on the metadata to determine the size of the data to be transferred.
Then, the emulation uses custom instructions to move data between the ACE unit and the CPU.
Three types of supporting operations are required:

 * An “`ace.mv`” instruction that loads a specified number of bytes from a GPR or vector register into the state of a CR or in the input buffer within the ACE unit.
   Initially, `ace.size` returns the total payload length to transfer.
   After each move, this value is updated to reflect the remaining bytes.
   The instruction also updates the `acestart` CSR to follow the internal progress.
 * A corresponding “`ace.mv`” instruction that exports a specified number of bytes from a CR or from the input buffer to a GPR or vector register.
   The behavior of `ace.size` will be similar to that of the `ace.mv` instruction, but it will count the number of bytes to be exported.
 * An “`ace.close`” instruction to suspend or finalize the procedure.
   If executed before all bytes are transferred, the CR state matches that of an interrupted monolithic instruction, including the Incomplete metadata field and the `acestart` value. If executed after all bytes are transferred, it also performs any final cryptographic operations, such as authenticating the CR, if needed.

All three instructions can be implemented as CSR RW instructions, for instance:

 * `acedest`, XLEN bits wide, determines what architectural state we are transferring to or from: 0..31 for the CRs and, say, 32 for the input/output buffer.
 * `aceoffset`, XLEN bits wide, holds the offset within the CR's virtual `content` or the input/output buffer (maybe the same as `acestart` ?).
 * `acecontent`, XLEN bits wide, to which we write the content of the CR or the input/output buffer or from which we read the current content.
  A write to `acecontent` would also increase `aceoffset` (or `acestart`) by XLEN/8.

Interrupting the firmware implementation of `ace.init`, `ace.export`, `ace.import`, `ace.input`, or `ace.output` must leave the architectural state indistinguishable from the state expected from interrupting a monolithic implementation of the instructions.
In particular, they need to respect the value of `acestart` and update it in accordance with the expected architected behavior of the emulated instructions.

The supporting instructions themselves must be uninterruptible.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-algorithms]]
=== Algorithm-Specific Data Formats and Instruction Semantics

In this chapter we specify the behavior of Cryptographic Contexts for various cryptographic algorithms.
Some specifications are generic in the sense that they apply to all algorithms of a certain type and can be instantiated with different primitives with varying parameters such as block and key sizes.
Further specifications pertain to cryptographic algorithms that require specific primitives.

NOTE: This chapter is normative, defining the behavior of instructions and the data formats they use for certain classes of cryptographic algorithms including some mandatory ones.
For example, AES-GCM-SIV is fully specified in <<ACE-GCM-SIV-mode>>, where the block size `b` = 128 and the key size `k` is 128 or 256 bits and the hashing function is POLYVAL as defined in <<ACE-GCM-SIV-mode>>. +
This specification ensures that an instantiation of the same mode of operation with a different primitive, such as SM4-GCM-SIV using the same hash, is also well defined.

Each algorithm is fully defined by the following information:

Parameters:::
These include:
* The block size, which is the size of the basic unit of information processed by the algorithm, usually the block size of the main underlying primitive;
* The key size, for keyed algorithms; and
* Any other parameter (for instance, counter size) that is necessary to instantiate the algorithm with compatible primitives.

Important: In this section, all field lengths are specified in bits except where otherwise noted.

Data Structures:::
These include:

. *Initialization Input*:
The data following the metadata block in the initialization input to `ace.init`, such as keys and other required secrets.
Fields are listed in the order they appear in the initialization input, each with its length.

. *Internal State*:
Information that must be maintained in the internal state of a CC.
The fields are unordered, and their lengths may differ from those listed—for example, in threshold or fault-tolerant implementations where redundancy is added. Notably, the full single-share key size is listed even when a System Key is used, as this reflects the size of the key material the algorithm operates on.

. *Serialized Content*:
The data that follows the metadata block in the plaintext portion of the SCC.
The fields are listed in the order they appear in the SCC, each with its length.

// Generic Functions:::
// If necessary, redefine generic functions that apply to all contexts.

Algorithm-Specific Functions:::
Any other function that is specific to the algorithm.

State Machine:::
This includes:

. A list of *states* in which the internal state machine of the logic is executed, together with their representation, either as a number in the range [0..15] or by more complex structures. The values for the architected algorithms conform to <<ACE-state-constants>>.
. A complete list of the *allowed state transitions*, including the conditions under which each transition is allowed.
. The enumeration of the *allowed instructions* at each state and their *behavior*.

[WARNING]
When defining an algorithm, the structure and size of the content of the Initialization Input and of the serialized content *must* be determinable solely from the Algorithm and Key_Type fields in the metadata.

The instructions allowed at each state of an algorithm are usually only `ace.exec` and `ace.state`, but this is not mandated.
Regarding `ace.exec`, only a single form of `ace.exec` may be allowed (cf.{nbsp}<<ACE-instruction-exec>>), together with a suitable replacement sequence as described in <<ACE-replacement-instructions>>.

We provide pseudocode to clarify how the algorithms supported by an ACE unit are implemented in software using the ACE ISA.
For simplicity's sake, pseudocode is usually restricted to set parameters and does not use the `ace.exec` Forms A-C replacement instruction sequences.
Pseudocode examples are naturally non-normative.

The following table defines the state numbers used by the algorithms defined in this specification.

[[ACE-state-constants]]
.Constants defining CC states
[float="center",align="center",width="100%",cols="^6%,<29%,<65%",options="header"]
|===
| Value | Mnemonic                      | Examples
|   0   | ace_state_initial             | The context is initialized and ready for operation.
|   1   | ace_state_hash_absorb         | Start (and initialize) a hash function or the sub-function of an algorithm, preparing it to absorb blocks of data.
|   2   | ace_state_hash_finalize       | Finalize the internal state of a hash function and possibly prepare it for outputting the result. In this state and in the following two states, additional data may be absorbed, such as partial blocks and lengths.
|   3   | ace_state_enc_hash_finalize   | Finalize the internal state of a hash function for the encryption algorithm of an authenticated encryption mode of operation and possibly prepare it for outputting the result.
|   4   | ace_state_dec_hash_finalize   | Finalize the internal state of a hash function for the decryption algorithm of an authenticated decryption mode of operation.
|   5   | ace_state_hash_verify         | Compare the internal state of a hash function to the provided value.
|   6   | ace_state_enc_last_block      | For the encryption path of authenticated encryption modes of operation if the length of the last block must be given.
|   7   | ace_state_dec_last_block      | For the decryption path of authenticated encryption modes of operation if the length of the last block must be given.
|   8   | ace_state_encrypt +
ace_state_operate
|  Encryption is requested. +
Algorithm is ready to process.
|   9   | ace_state_decrypt             | Decryption is requested.
|  10   | ace_state_set_public_value    | Set a public value (like a nonce or an IV) in an algorithm. Some algorithms require more than one public value (for instance, they may admit a re-useable hash of some associated data and a unique nonce), in which case the second public value can be set using the next message.
|  11   | ace_state_set_public_value_2  | Set the second public value in an algorithm.
|  12   | ace_state_input_for_derive    | Tells the CC to expect additional information for feeding the `ace.derive` instruction.
|  14   | ace_state_invalidated         | The algorithm has abnormally terminated. `ace.error` will always return error code _ace_err_invalid_.
|  15   | ace_state_completed           | The algorithm has correctly completed.
|===

Algorithms that significantly differ from those we describe in <<ACE-algorithms>> and therefore cannot share the same software for their usage,
may reuse the same values in [1..12] with new constant mnemonics to define their own states.

In what follows, “state _name_” refers to the state with number _ace_state_name_ in <<ACE-state-constants>>.

[[ACE-generic-rules]]
==== Generic Rules

Modes of operation:::
Most modes of operations have a generic specification, i.e., the specification depends only on certain parameters of the underlying primitives, such as the block width `b` of a block cipher or key length `k` of a symmetric cipher.
Other modes, whose description depends on other parameters or special properties of the underlying primitives, are specified separately.

States:::
If the number of states of the algorithm is at most 16 (including _initial_, _completed_, and _invalidated_), the `state` of the metadata is used to store this value.
Otherwise, the specification of the algorithm must include a suitable field in the content section of the CC/SCC.

Invalid Inputs and Operations, CR Invalidation:::
+
--
If an invalid input is provided to any ACE instruction, or an instruction that is not explicitly allowed in a given state is executed, while processing the algorithm in CR, say, `Kn`, the `Kn` is *invalidated*, namely, the following happens:
(((ACE, algorithm, invalid state)))
(((Cryptographic Register, invalidated)))

* `Kn` is put into state _invalid_;
* For instructions that refer to `Kn`:
 ** any Form of `ace.exec`, `ace.clone, `ace.derive`, `ace.restrict`, and `ace.harden` raise an invalid instruction error;
 ** `ace.input` and `ace.output` raise an invalid instruction error when `aceactivecr` is `Kn`;
 ** `ace.state` raises an invalid instruction error unless it is used to return to state _initial_;
 ** `ace.error` always returns error _ace_err_invalid_ after any operation involving the CR except for
    `ace.import` and `ace.export`, `ace.clean`, `ace.init`, and `ace.size`, which all work normally, and using `ace.state` to return to state _initial_.
* The current instruction is terminated.

In state _completed_, only `ace.init`, `ace.export`, `ace.import`, `ace.clear`, and `ace.error` are permitted.
--
+

Interruptibility:::
+
--
Operations performed by `ace.state` are uninterruptible.

The actions of the `ace.exec` operations on the basic processing units are uninterruptible.
If the operation admits inputs which are a multiple of this basic processing unit, then each block is processed uninterruptibly but the instruction may be interrupted between blocks. `acestart` is used to determine the point of resumption of the instruction.

An implementation must wait before accessing a CR that is still being written to asynchronously.
--
+

//

[[ACE-rules-threshold-implementations]]
==== Rules for Threshold implementations

Single-Share Key Export:::
Any CC with its algorithms implemented as threshold implementation will always initialize, import and export _all_ its keys and secrets as _single_, _reconstructed_ _shares_.
The Configuration and SCC Formats will be the same as for the non-threshold implementation variants of the same algorithm, with the only difference being the value of the Side Channel Protection bits in the metadata.
For the purpose of architecture specification, all values are also always represented as a single share in this document.
Threshold implementations are simply implementation variants of the exact same algorithm.
(((ACE, algorithm, threshold variants)))

NOTE: This rule assumes that reconstructing a key or re-randomizing it are fast operations, such as ``xor``s with random values.
This in turn implies that ACE execution unit must have access to a source of randomness, or at least a PRNG that is seeded at hardware boot.

NOTE: The rule not only  ensures the compactness of a SCC, but also that the key can be ported across architectures.
In fact, some threshold implementations may have a different number of shares even if they claim the same order of side-channel protection.

[[ACE-rules-system-keys]]
==== Rules for System Keys

Representation of System Keys in the Data Strctures:::
+
--
System keys that are referred to by an index will cause the following changes in all the algorithms described in what follows:

. In the initialization input and in the SCC, the key/main key field will contain the index of the key in the SKT in place of a key value.
. This field is always a 64-bit value, even if the key itself is larger. This saves space in the SCC and allows for faster export and import operations.
. For algorithms that require more than one key, such as XEX/XTS, ALL the keys are referred to by a single index, i.e., a single 64-bit value in the initialization input and the SCC.
. Accordingly, the SCC generation functions will support System Keys by producing and reading the shorter fields with the indexes in place of the longer fields that would be required when the key values are explicitly provided.
--
+

NOTE: Internally, the ACE unit may use the value from the SKT, or copy it to the internal state of the CR.
The architecture does not restrict the choice of the implementation.
On the other hand, keys generated from a system block, using a custom “recipe”, are always represented by their values and once generated have the exact same behavior as any other key that does not come from the SKT.

//

[[ACE-ECB-mode]]
==== Electronic Codebook Modes (Direct Encryption/Decryption)

While listing the rules for the ECB mode
cite:[nist-SP-800-38A-1]
is in principle easy, it does display all the rules that are required to describe an arbitrarily complex mode.
(((ACE, algorithm, ECB)))

===== Specification

Parameters:::

* `b` = block size (8|`b`). `VL*SEW` must be a multiple of `b`.
* `k` = key size (8|`k`).

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.

* *Internal State*:
 ** `key`: `k` bits.

* *Serialized Content*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.

Algorithm-Specific Functions:::

* `enc_blk(p) -> c` encrypts plaintext block `p` using the key, and returns the ciphertext result `c`.
* `dec_blk(c) -> p` decrypts ciphertext block `c` using the key, and returns the plaintext result `p`.

State Machine:::

* *States:* _initial_, _encrypt_, and _decrypt_
* *Allowed State Transitions:*
 ** From any state to state _encrypt_, if metadata allows encryption, else the CR is *invalidated*.
 ** From any state to state _decrypt_, if metadata allows decryption, else the CR is *invalidated*.
* *Behavior:*
 ** In state _initial_, no `ace.exec` instruction is allowed.
 ** In states _encrypt_ or _decrypt_, we can only issue Form A `ace.exec` instructions, i.e., of the Form “`ace.exec Vd, Kn|K[Xn], Vs`.”
  *** If the state is _encrypt_, then `Vd = enc_blk(Vs)`.
  *** If the state is _decrypt_, then `Vd = dec_blk(Vs)`.
  *** If `VL*SEW` > `b`, then “`ace.exec Vd, Kn|K[Xn], Vs`” encrypts/decrypts block-by-block.

//

[NOTE]
====
Supporting vector lengths smaller than a cipher's block size would not only complicate both the architecture and its implementation, but it would also burden the software using the feature.
Therefore, instead of using multiple `ace.exec` instructions to process data in smaller chunks,
the architecture defines the `ace.input` and `ace.output` instructions.
====

===== Usage

The following pseudocode illustrates how to use an ECB CC to encrypt a block of data using a block cipher with a width of 128 bits (`VL*SEW` is also 128).

[[ACE-pseudocode-ECB-encryption]]
.Simple Pseudocode Example: Encryption with no Authentication
----
- Call OS API to get the necessary SCC. Assume X5 points to the SCC.
- Allocate memory for ciphertext buffer.

vsetvli zero, 4, e32, m1, ta, ma           // Use 128-bit vectors
ace.import K0, (X5)                        // Import the SCC into CR K0
ace.error X1                               // Read error from a CSR
if (X1 != 0) then { handle error }         // ACE may fail to validate SCC, algorithm may
                                           // be not supported, or CRF memory may be full
ace.state K0, #ace_state_encrypt           // Configure CR for encryption
ace.error X1                               // Read error from a CSR
if (X1 != 0) then { handle error }         // Error if encryption not allowed

foreach(i from 0 to len_in_bytes(plaintext)/16-1) { // assume plaintext in whole blocks
    - load V0 from address plaintext+16*i
    ace.exec V0, K0, V0                    // Encrypt one block of the plaintext
    - store V0 at address ciphertext+16*i
}
----

// vle32.v  V0, (plaintext)              // load V0 from address plaintext+16*i
//                                       // assume plaintext is in a register
// ace.exec V0, K0, V                    // Encrypt one block of the plaintext
// vse32.v  V0, (ciphertext)             // store V0 at address ciphertext+16*i
// add plaintext, plaintext, 16          // advance plaintext pointer
// add ciphertext, ciphertext, 16        // advance ciphertext pointer

[[ACE-chaining]]
==== Chaining/Feedback Modes

There is no need to explicitly architect the behavior of chaining modes,
such as
Cipher Block Chaining (CBC),
Cipher Feedback (CFB) and
Output Feedback (OFB) (all defined in cite:[nist-SP-800-38A-1])
as they can be easily implemented on top of the ECB functionality in software,
and no intermediate value in these algorithms requires confidentiality.

[[ACE-keystream-modes]]
==== CTR/LFSR/XCTR/XLFSR Keystream Generation

In the “non-X” modes, i.e., in the CTR mode and its analogue that replaces the arithmetic counter by a LFSR, the sum of the lengths of IV and counter/LFSR equals the block size of the underlying keyed PRP or PRF. IV and counter/LFSR are concatenated to form the input to the keyed PRP or PRF.
(((ACE, algorithm, keystream generation)))

The “X” modes have both IV and counter/LFSR of the same size as the block size of the underlying keyed PRP or PRF:
IV and counter/LFSR are ``xor``ed together to form the input to the keyed PRP or PRF—which explains the “X” in the mode names.

===== Specification

Parameters:::
* `b` = block size (8|`b`). For this algorithm `VL*SEW` must be a multiple of `b`.
* `k` = key size (8|`k`).
* `j` = counter size (8|`j`).
* `n` = IV size (8|`n`).
* If the mode is CTR or LFSR, it is `b = n + j`.
* If the mode is an “X” mode, it is `b = n = j`.

Data Structures:::
* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.

* *Internal State*:
 ** `key`: `k` bits.
 ** `IV`: `n` bits.
 ** `ctr`: `j` bits.

* *Serialized Content*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.
 . `IV`: `n` bits.
 . `ctr`: `j` bits.

Algorithm-Specific Functions:::
* `keystream_block(p) -> c` -- usually an encryption function.
* `tick_ctr()` -- updates the `ctr` (either by a modular increment or a LFSR).

State Machine:::
* *States:* _initial_, _set_public_value_, _operate_.
* *Allowed State Transitions:*
 ** _initial_ -> _set_public_value_ -> _operate_.
 ** All states to _initial_.
* *Behavior:*
 ** In state _initial_, the `ctr` and `IV` fields are set to 0 (`ctr` is set to 1 if the algorithm is LFSR-based).
 ** In state _set_public_value_, only ``ace.exec`` instructions of Form B are allowed. +
     “```ace.exec Kn|K[Xn], Vs```” sets the IV value to `Vs`.
  *** If no such instruction is issued, the value of the IV will remain zero.
  *** If `VL*SEW` > `b`, only the `b` least significant bits of `Vs` are considered.
  *** If such operations are issued more times, they will just update the IV value again. Since this can be done only before any encryption or decryption operation, this does not represent a security issue.
 ** In state _operate_, only ``ace.exec`` instructions of Form C are allowed. +
     “```ace.exec Vd, Kn|K[Xn]```” performs:
+
--
  . If in a CTR or LFSR mode then `tmp ← keystream_block(IV @ ctr)`, +
    else (i.e., if in a XCTR or XLFSR mode) `tmp ← keystream_block(IV xor ctr)`,
  . `tick_ctr()`, and
  . `Vd ← tmp`.
--
+
If `VL*SEW` is a multiple of `b`, the above three commands are applied to each of the `VL*SEW/b` `b`-bit blocks of `Vs`, producing each time the corresponding `b`-bit block of `Vd`.
If the number `x` of blocks to be processed in an entire run of the algorithm is not a multiple of `VL*SEW`/`b`, `VL` can be set to the remainder of the division of `x` by `VL*SEW`/`b` for the last instruction.

Note that if `ace.state` is issued to return to state _initial_, the CC can be reused with a new `IV`.

===== Usage

Example pseudocode is given in <<ACE-pseudocode-keystream-modes>> (for the case `b` = `VL*SEW` = 128).

[[ACE-pseudocode-keystream-modes]]
.Encrypt with Keystream Generation
----
// Acquire payload, initialize
- Info: plaintext = *PT
- Process gets a Keystream Generation CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)

// The next operations set the nonce (and the derived Authentication Key).
ace.state K0, #ace_state_set_public_value
V0 ← nonce
ace.exec K0, V0

// Compute keystream, use it to encrypt plaintext
foreach(i from 0 to len_in_bytes(PT)/16-1) {
    - load V0 from address PT+16*i
    ace.exec V1, K0
    V1 ← V1 xor V0
    - store V1 at address CT+16*i
}
----

[[ACE-XEX-XTS-modes]]
==== XEX/XTS modes (one or two keys)

The XTS mode was designed for storage confidentiality cite:[DBLP-journals-ieeesp-Martin10]
and made into a Recommendation by NIST cite:[nist-SP-800-38E].

The use of a single key or two independently sampled keys is determined by the algorithm, and it is not a configuration parameter for the algorithm.
We first define XEX mode functionality.
(((ACE, algorithm, XEX)))

===== Specification

Parameters:::

* `b` = block size (8|`b`). For this algorithm we require `VL*SEW` to be an integer multiple of `b`.
* `k` = key size (8|`k`).

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key1`: `k` bits, or 64 bits if a System Key index.
 . `key2`: `k` bits -- omitted if only one key is used or if both keys come from an entry in the SKT.

* *Internal State*:
 ** `key1`: `k` bits.
 ** `key2`: `k` bits -- omitted if only one key is used or if both keys come from an entry in the SKT.
 ** `mask`: `b` bits.

* *Serialized Content*:
[lowerroman]
 . `key1`: `k` bits, or 64 bits if a System Key index.
 . `key2`: `k` bits, omitted if only one key is used or if both keys come from an entry in the SKT.
 . `mask`: `b` bits.

Algorithm-Specific Functions:::

* `enc_blk(key, p) -> c` encrypts block `p` using the key, and returns the result `c`.
* `dec_blk(key,c) -> p` decrypts block `c` using the key, and returns the result `p`.
* `update_mask(mask) -> mask` updates the mask by a Galois Field multiplication in GF(2^b^).

State Machine:::

* *States:* _initial_, _set_public_value_, _encrypt_, and _decrypt_.

* *Allowed State Transitions:*
 ** _initial_ -> _set_public_value_.
 ** _set_public_value_ -> _initial_.
 ** _set_public_value_ -> _encrypt_, if metadata allows encryption, else the CR is *invalidated*.
 ** _set_public_value_ -> _decrypt_, if metadata allows decryption, else the CR is *invalidated*.
 ** _encrypt_, _decrypt_ -> _initial_.

* *Behavior:*
 ** In state _initial_:
  *** The `mask` field is set to zero.
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
 ** In state _set_public_value_, only ``ace.exec`` instructions of Form B are allowed. +
 “```ace.exec Kn|K[Xn], Vs```” sets the _tweak_. The `mask` field is used to store the tweak: `mask <- Vs`.
  *** If no such instruction is issued, the value of the tweak will remain zero.
  *** If `VL*SEW` > `b`, only the `b` least significant bits of `Vs` are considered.
  *** If “```ace.exec Kn|K[Xn], Vs```” is repeated, it will just re-write the mask.
 ** When transitioning from _set_public_value_ to either _encrypt_ or _decrypt_, the following operations are performed:
  . `mask <- enc_blk(key2, mask)` or `mask <- enc_blk(key1, mask)` if only one key is used.
  . If only one key is used then update mask: `mask <- update_mask(mask)`.
 ** In states _encrypt_ and _decrypt_, only ``ace.exec`` instructions of Form A are allowed. +
    “```ace.exec Vd, Kn|K[Xn], Vs```” performs the following operations:
+
--
  . in state _encrypt_, it computes `Vd = mask xor enc_blk(key1, Vs xor mask)` ... +
    in state _decrypt_, it computes `Vd = mask xor dec_blk(key1,Vs xor mask)` ...
  . ... and updates the mask: `mask <- update_mask(mask)`.
--
+
If `VL*SEW` is a multiple of `b`, the above commands are executed `VL*SEW/b` times, processing each `b`-bit block of `Vs` into a `b`-bit block of `Vd`. This operation is clearly parallelizable. If the number `x` of blocks to process is not a multiple of `VL*SEW`/`b`, `VL` can be set to the remainder of the division of `x` by `VL*SEW`/`b` for the last instruction.

//

Note that if `ace.state` is issued to return to state _initial_, the CC can be reused with a new tweak.

===== Usage

Using XEX mode is very easy. We include pseudocode for encryption only, decryption is entirely similar
(this example is also assuming `b` = `VL*SEW` = 128).

[[ACE-pseudocode-basic-IV-mode]]
.Pseudocode for encryption in any IV-based non-authenticated mode without associated data
----
// Acquire payload
- Info: plaintext = *PT
- Call an API to get the corresponding key from a key management applet or HW block.
- The API returns the SCC. Assume X5 is the pointer to it.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma             // Use 128-bit vectors
ace.import K0, (X5)

ace.state K0, #const_set_public_value        // this can be an IV or a nonce.
V0 ← IV
ace.exec K0, V0

ace.state K0, #ace_state_encrypt             // Configure CR for encryption
foreach(i from 0 to ceil(len_in_bytes(PT)/16)-1) {
    - load V0 from address PT+16*i
    ace.exec V0, K0, V0                      // Encrypt one block of the plaintext
    - store V0 at address CT+16*i
}
----

To implement the XTS mode, the ciphertext stealing part is easy to realize using the XEX algorithm together with vector masking and shifting operations.
(((ACE, algorithm, XTS)))

// N.B. another ace.state K0, #const_set_public_value would reset the internal state and allow to begin another decryption with a new IV.

[[ACE-GCM-mode]]
==== GCM Mode

The GCM mode was designed by David McGrew and John Viega cite:[DBLP-conf-indocrypt-McGrewV04]
and became a NIST Recommendation in 2007 cite:[nist-SP-800-38D].
(((ACE, algorithm, GCM)))

===== Specification

Parameters:::

* `b` = block size (8|`b`). For this algorithm we require `VL*SEW` to be an integer multiple of `b`.
* `k` = key size (8|`k`).

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.

* *Internal State*:
 ** `key`: `k` bits.
 ** `ctr`:  `b` bits as integer.
 ** `hash_key`, `auth_tag`: `b` bits.

* *Serialized Content*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.
 . `ctr`: `b` bits as integer.
 . `auth_tag`: `b` bits.

NOTE: There are no fields for the lengths of the AD and of the plaintext, as they are maintained by the calling software.
Also, `hash_key` is not serialized, and thus it is recomputed upon `ace.import`.

Algorithm-Specific Functions:::

* `enc_blk(key, p) -> c` encrypts block `p` using the key, and returns the result `c`.

* `absorb(data)` absorbs data into the hash function by performing:
  . `auth_tag <- auth_tag xor Vs`.
  . `auth_tag <- auth_tag * hash_key`.

State Machine:::

* *States:* _initial_, _set_public_value_, _hash_absorb_, _encrypt_, _enc_hash_finalize_, _decrypt_, _dec_hash_finalize_, and _hash_verify_, _completed_.

* *Allowed State Transitions:*
 ** From all states to _initial_.
 ** _initial_ -> _set_public_value_ -> _hash_absorb_.
 ** _hash_absorb_ -> _encrypt_ -- if metadata allows encryption, else the CR is *invalidated*.
 ** _hash_absorb_ -> _decrypt_ -- if metadata allows decryption, else the CR is *invalidated*.
 ** _encrypt_ -> _enc_hash_finalize_, later automatically transitioning to _completed_.
 ** _decrypt_ -> _dec_hash_finalize_.
 ** _dec_hash_finalize_ -> _hash_verify_, later automatically transitioning to _completed_.

* *Behavior:*
 ** In state _initial_ :
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
  *** The following initialization operations are performed:
   . `hash_key <- enc_blk(key, zeros(b))`,
   . `auth_tag <- zeros(b)`, and
   . `ctr <- zeros(b)`.
 ** In state _set_public_value_:
  *** Only  ``ace.exec`` instructions of Form B are allowed.
  “```ace.exec Kn|K[Xn], Vs```” sets
   . `ctr <- Vs @ (b/4-1)b'0 @ 1'b1`, i.e., the `b/4` most significant bits of `Vs` are ignored, and the `b/4` least significant bits of `ctr` represent the integer 1.
  *** If “```ace.exec Kn|K[Xn], Vs```,” is repeated, it will just re-write the IV.
  *** If no such `ace.exec` to set the IV is issued, `ctr` remains zero.
  *** If `VL*SEW` > `b`, only the `b` least significant bits of `Vs` are considered.

 ** In state _hash_absorb_, only  ``ace.exec`` instructions of Form B are allowed. +
 “```ace.exec Kn|K[Xn], Vs```” absorbs a data block in `auth_tag`, i.e.:
+
--
 . `absorb(Vs)`.
--
+
If `VL*SEW` > `b`, the above operation is executed `VL*SEW/b` times.

** In state _encrypt_, only ``ace.exec`` instructions of Form A are allowed.
   “```ace.exec Vd, Kn|K[Xn], Vs```” encrypts `Vs` into `Vd`, and absorbs the ciphertext `Vd` into the `auth_tag`, namely:
+
--
  . If `ctr[b/4-1:0] = 0`, then
  ..  the CR is *invalidated*.
  . else
  .. `tmp <- Vs xor enc_blk(key, ctr)`.
  .. `absorb(tmp)`.
  .. `ctr[b/4-1:0] <- ctr[b/4-1:0] + 1 % 2^b/4^`.
  .. `Vd <- tmp`.
--
+
If `VL*SEW` is a multiple of `b`, the above operations are executed `VL*SEW/b` times, encrypting each `b`-bit block of `Vs` into the corresponding `b`-bit block of `Vd`. There is significant potential for parallelization, including in the `absorb` function. If the number `x` of blocks to encrypt is not a multiple of `VL*SEW`/`b`, `VL` can be set to the remainder of the division of `x` by `VL*SEW`/`b` for the last instruction.

** In state _enc_hash_finalize_, only ``ace.exec`` instructions of Form A are allowed. The value
+
--
*** `Vs = IntTo{b/2}Bits(bit_length(AD)) @ IntTo{b/2}Bits(bit_length(plaintext))`
--
+

must be set by the software, then,
  “```ace.exec Vd, Kn|K[Xn], Vs```”
  computes the authentication tag and completes the algorithm as follows:
+
--
  . `absorb(Vd)`.
  . `auth_tag <- auth_tag xor enc_blk(key, ctr[b-1,b/4] @ 0[b/4-1,0])`.
  . Finally, `auth_tag` is returned in `Vd`, and the state is changed to _completed_.
--
+
If `VL*SEW` > `b`, only the `b` least significant bits of `Vs` are considered.

** In state _decrypt_, only  ``ace.exec`` instructions of Form A are allowed.
 `ace.exec Vd,Kn|K[Xn],Vs`
   absorbs the ciphertext `Vs` into the `auth_tag`, then decrypts `Vs` into `Vd`, namely
+
--
  . If `ctr[b/4-1:0] == 0`, then
  .. the CR is *invalidated*.
  . else
  .. `absorb(Vs)`.
  .. `Vd  <- Vs xor enc_blk(key, ctr)`.
  .. `ctr[b/4-1:0] <- ctr[b/4-1:0] + 1`.
--
+
If `VL*SEW` is a multiple of `b`, the same behavior applies as in state _encrypt_, namely
the above operations are executed `VL*SEW/b` times, decrypting each `b`-bit block of `Vs` into the corresponding `b`-bit block of `Vd`.

** In state _dec_hash_finalize_, only a Form A ``ace.exec`` instruction is allowed.
The value +
 `{nbsp}{nbsp}{nbsp}Vs = IntTo{b/2}Bits(bit_length(AD)) @ IntTo{b/2}Bits(bit_length(plaintext))` +
 must be set by the software, then “```ace.exec Vd, Kn|K[Xn], Vs```” computes the authentication tag as follows:
+
--
  . `absorb(Vs)`.
  . `auth_tag <- auth_tag xor enc_blk(key, ctr[b-1,b/4] @ 0[b/4-1,0])`.
--
+
If `VL*SEW` > `b`, only the `b` least significant bits of `Vs` are considered.

** In state _hash_verify_, only an ``ace.exec`` instruction of Form B, i.e., “```ace.exec Kn|K[Xn], Vs```” is allowed.
    It compares `Vs` with `auth_tag`:
+
--
  . If the values match, then the state is changed to _completed_, and `ace.error` returns no error,
  . else the state is changed to _completed_, and `ace.error` returns `ace_err_authentication`.
--
+
If `VL*SEW` > `b`, only the `b` least significant bits of `Vs` are compared to `auth_tag`.

** Upon completion of `ace.import`, the ACE unit recomputes `hash_key`:
  . `hash_key <- enc_blk(key, zeros(b))`.

//

===== Usage

In <<ACE-pseudocode-GCM-encryption>> we show pseudocode for GCM encryption (again with `b` = `VL*SEW` = 128).
The code assumes that both AD and plaintext (or the ciphertext for the decryption) are zero-padded to a multiple of `b` bits, in this case 128 bits.

[[ACE-pseudocode-GCM-encryption]]
.GCM Encryption
----
// Acquire payload, initialize
- Info: authenticated data = *AD, plaintext = *PT
- Process gets a GCM encryption CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)

// The next operations set the nonce (and the derived Authentication Key).
ace.state K0, # ace_state_set_public_value
V0 ← nonce
ace.exec K0, V0

// Compute AD contribution to Auth Data
ace.state K0, #ace_state_hash_absorb
foreach(i from 0 to len_in_bytes(AD)/16-1) {
    - load V0 from address AD+16*i
    ace.exec K0, V0                              // Absorb it into hash
}

// Encrypt plaintext and continue computation of auth_tag
ace.state K0, #ace_state_encrypt
foreach(i from 0 to len_in_bytes(PT)/16-1) {
    - load V0 from address PT+16*i
    ace.exec V1, K0, V0
    - store V1 at address CT+16*i
}

// Finally, we absorb the lengths into auth_tag, finalize it, and output it
ace.state K0, #ace_state_enc_hash_finalize
V1 ← IntTo64Bits(len(AD)) @ IntTo64Bits(len(PT))
ace.exec V2, K0, V1                              // V2 contains the finalized hash
----

GCM decryption differs from encryption as follows:
the roles of `PT` and `CT` are reversed,
states _encrypt_ and _enc_hash_finalize_ are replaced by states _decrypt_ and _dec_hash_finalize_,
and the last lines are as follows:

[[ACE-pseudocode-GCM-decryption-difference]]
.GCM Decryption
----
// Finally, we absorb the lengths into auth_tag, finalize it, and verify it
ace.state K0, #ace_state_dec_hash_finalize
V1 ← IntTo64Bits(len(AD)) @ IntTo64Bits(len(CT))
ace.exec V2, K0, V1                                // V2 contains the finalized hash

ace.state K0, #ace_state_hash_verify
V1 ← tag_from_payload
ace.exec K0, V1                                  // V1 contains the tag from the input
ace.error X1
if (X1 != 0) then { handle error }       // do not use the plaintext if error occurred
----

//

===== Alternative Examples

GCM security is not compromised if `H` is revealed.
Consequently, an implementation based on a simpler ECB mode CC is possible,
as shown below (for encryption only -- decryption is similar).
However, this significantly increases code size and requires implementing `galois_mult(V4,V3)`.
Adding a dedicated mode to the ACE unit is a minor effort, and it allows internal logic to optimize execution
beyond the capabilities of, for instance, a compiler on an in-order CPU. It also means that the CPU
does not have to implement the carryless multiplication (cf.{nbsp}<<ACE-V-dependency>>),
and only a shared ACE unit has to,
which saves hardware costs when several small cores share a single ACE unit.

[[ACE-pseudocode-GCM-encryption-alternate]]
.Implementing GCM encryption using an ECB CC
----
// Acquire payload, initialize
- Info: authenticated data = *AD, plaintext = *PT
- Process gets a GCM encryption CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)                              // Imports SCC into CR K0
V5[127:32] ← IV
V5[31:0] ← zeros(31) @ 1

V3 ← zeros(b)                                    // “Auth Data 1”
ace.exec V4, K0, V3                              // compute H
foreach(i from 0 to ceil(len_in_bytes(AD)/16)-1) {
    - load 16 bytes from AD+16*i into V1
    V3 ← V3 xor V1                               // Horner scheme add
    V3 ← galois_mult(V4,V3)                      // Horner scheme mult
}

counter ← 1                                      // a 32-bit integer value
foreach(i from 0 to ceil(len_in_bytes(PT)/16)-1) {
    V5[32:0] ← counter
    - load 16 bytes from PT+16*i into V1
    ace.exec V2, K0, V5                          // create mask by encrypting the counter
    V1 ← V1 xor V2                               // CTR encrypt
    V3 ← V3 xor V1                               // Horner scheme add
    V3 ← galois_mult(V4,V3)                      // Horner scheme mult
    - store V1 at *(CT+16*i))
    counter ← counter + 1
}

V3 ← V3 xor (len_in_bits(AD) @ len_in_bits(PT))  // Horner scheme add
V3 ← galois_mult(V4,V3)                          // Horner scheme mult
V5[32:0] ← zeros(31) @ 1                         // Prepare IV || 1 for tag encryption
ace.exec V2, K0, V5
tag ← V3 xor V2                                  // Last Horner scheme add
----

[[ACE-GCM-SIV-mode]]
==== GCM-SIV mode

The GCM-SIV mode is described in cite:[DBLP-journals-iacr-GueronLL17] and cite:[RFC8452].

The GCM-SIV mode's main differences with GCM are that:

. Both encryption and authentication keys are derived from the main key, whereas in GCM the main key is used also for encryption;
. It is a MAC-then-Encrypt mode, whereas GCM is an Encrypt-then-MAC mode, therefore GCM-SIV is more amenable to Release of Unencrypted Plaintext (RUP) attacks;
. Encryption requires two passes over the plaintext, since the tag computed on the AD and plaintext is used also as the initialization vector for the CTR encryption.
(((ACE, algorithm, GCM-SIV)))

The third difference affects the state machine. While GCM-SIV's decryption state machine is similar to the GCM's, the encryption state machine is different:

* During encryption, the _hash_absorb_ state absorbs the entire associated data and plaintext. The _enc_hash_finalize_ state then absorbs the lengths and produces the SIV/tag. Finally, the _encrypt_ state performs a second pass to encrypt the plaintext using the SIV/tag as the initialization vector.
* During decryption, the _hash_absorb_ state absorbs only the associated data. The _decrypt_ state decrypts the ciphertext and simultaneously absorbs the plaintext into the hash. Finally, the _dec_hash_finalize_ state absorbs the lengths, produces the SIV/tag, and internally compares it to the provided SIV/tag.

===== Specification

Parameters:::

* `b` = block size, (8|`b`). For this algorithm we require `VL*SEW` to be an integer multiple of `b`.
* `k` = key size (8|`k`).
* It must be `k = b` or `k = 2b`.
* It must be established by the algorithm whether the authentication tag is `b` or `3b/4` bits long.

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.

* *Internal State*:
** `key`, `enc_key`: `k` bits.
** `auth_key`: `b` bits.
** `nonce`: `3b/4` bits.
** `ctr`: `b/4` bits.
** `auth_tag`: `b` bits.
** `SIV`: `b` or `3b/4` bits.
+
A `b`-bit `SIV` is computed by clearing the most significant bit of `auth_tag` and encrypting it. +
For a `3b/4`-bit `SIV`, a full `b`-bit `auth_tag` value is kept while absorbing data.
The public `SIV` value is computed by clearing the most significant bit of `auth_tag`, encrypting it, and then removing the `b/4` least significant bits.

* *Serialized Content*:
[lowerroman]
 . `key`: `k` bits.
 . `nonce`, `3b/4` bits.
 . `ctr`, `b/4` bits.
 . `auth_tag`, `b` bits.
 . `SIV`, `b` bits.

NOTE: `hash_key` and `auth_key` are not serialized,
and must be recomputed upon each `ace.import`. +
 +
The `SIV` field is actually only needed for decryption, since it must be maintained separately from the `auth_tag` field, which changes with each processed block as it is computed, whereas for encryption it is first computed completely and then used in the encryption process. However, since the same CC could be configured to support both encryption and decryption, the `SIV` field always present in the internal state (even if not used) and in the exported state.

//

Algorithm-Specific Functions:::

* `enc_blk(key, p) -> c` encrypts block `p` using the key, and returns the result `c`.
* `absorb(data)` absorbs data into the hash function by performing a step of (a variant of) GHASH or POLYVAL as specified by the algorithm
   (for instance, AES-GCM-SIV uses POLYVAL):
  . `auth_tag <- auth_tag xor Vs`.
  . `auth_tag <- auth_tag * hash_key`, where `*` denotes either Galois field multiplication (for GHASH) or Montgomery multiplication (for POLYVAL/MHASH), as specified by the algorithm.
State Machine:::
* *States:* _initial_, _set_public_value_, _set_public_value_2_, _hash_absorb_, _enc_hash_finalize_, _dec_hash_finalize_, _encrypt_, _decrypt_, and _completed_.

* *Allowed State Transitions:*
** From all states to _initial_.
** For encryption:
   _initial_ -> _set_public_value_ -> _hash_absorb_ -> _enc_hash_finalize_ -> _encrypt_.
** For decryption: +
   _initial_ -> _set_public_value_ -> _set_public_value_2_ -> _hash_absorb_ -> _decrypt_ -> _dec_hash_finalize_.
** Transition to _encrypt_ possible only if metadata allows encryption, else the CR is *invalidated*.
** Transition to _decrypt_ possible only if metadata allows decryption, else the CR is *invalidated*.

* *Behavior:*
** In state _initial_ :
*** No {nbsp}``ace.exec``{nbsp} operation is allowed.
*** The following initialization operations are performed:
  . (`enc_key`, `auth_key`) <- `RFC8452_KeyDeriv(key)`,
  . `nonce`, `ctr`, `auth_tag`, `SIV <- 0`.

** In states _set_public_value_, resp. _set_public_value_2_:
*** We can only issue  ``ace.exec`` instructions of Form B, i.e., “```ace.exec Kn|K[Xn], Vs```”, to set the value of `nonce`, resp. `SIV`.
*** If “```ace.exec Kn|K[Xn], Vs```” is repeated, it will just re-write the value of `nonce`, resp. `SIV`.
*** If no such `ace.exec` is issued, `nonce`, resp. `SIV`, remain equal to zero.
*** If `VL*SEW` > `b`, only the `b` least significant bits of `Vs` are considered.
+
NOTE: There is no harm in moving to state _set_public_value_2_ and setting the
SIV while encrypting, since that field is not used in the encryption path until
it is set (thus overwriting any previous content) by the state machine itself.
Accepting this redundant but harmless behavior simplifies the state machine.
+
** In state _hash_absorb_:
+
--
   *** Only ``ace.exec`` instructions of the Form “```ace.exec Kn|K[Xn], Vs```” are allowed. Such an instruction accumulates a value in the `auth_tag`:
   i.e., perform `absorb(Vs)`.
--
+
If `VL*SEW` is a multiple of `b`, `absorb` is executed on each of the `VL*SEW/b` blocks in `Vs`.

** In state _enc_hash_finalize_, only an {nbsp}``ace.exec``{nbsp} of Form A is allowed, i.e.,
  “```ace.exec Vd, Kn|K[Xn], Vs```,” where it is the responsibility of the user to set
+
--
  *** `Vs <- IntTo{b/2}Bits(bit_length(AD)) @ IntTo{b/2}Bits(bit_length(plaintext))`,
--
+
finalizes the computation of the SIV/tag, by performing:
+
--
    . `absorb(Vs)`.
    . `tmp <- enc_blk(enc_key, 1'b0 @ (auth_tag xor N)[b-2:0])`
    . If tag length is `b` bits, then
     .. `SIV <- tmp` and `Vd <- tmp`,
    . else (tag length is `3b/4` bits)
     .. `SIV <- tmp[b-1:b/4]` and `Vd <- (tmp >> b/4)`.
--
+

If `VL*SEW` > `b`, only the `b` least significant bits of `Vs` are considered.

** In state _encrypt_, only  ``ace.exec`` instructions of the Form A are allowed, namely “```ace.exec Vd, Kn|K[Xn], Vs```,” to encrypt `Vs` into `Vd` as follows:
+
--
. If `ctr == 0`, then the CR is *invalidated*.
   . If the `SIV` is `b`-bits long, then
     .. ``Vd <- Vs xor enc_blk(key, 1'b1 @ SIV[b-2:b/4] @ (SIV[b/4-1:0] + ctr % 2^b/4^)),``
   . else (the `SIV` is `3b/4`-bits long)
      .. ``Vd <- Vs xor enc_blk(key, 1'b1 @ SIV[3b/4-2:0] @ ctr``.
   . `ctr <- ctr + 1`.
--
+
If `VL*SEW` > `b`, the above operations are applied to each of the `VL*SEW/b` blocks in `Vs`.

** In state _decrypt_,  only  ``ace.exec`` instructions of the Form A are allowed, namely “```ace.exec Vd, Kn|K[Xn], Vs```,” to decrypt `Vs` into `Vd` and then absorb the plaintext `Vs` into the `auth_tag`:
+
--
     . If `ctr == 0`, then the CR is *invalidated*.
     . If the `SIV` is `b`-bits long, then +
       .. ``Vd <- Vs xor enc_blk(key, 1'b1 @ SIV[b-2:b/4] @ (SIV[b/4-1:0] + ctr % 2^b/4^)),``
     . else (it is `3b/4`-bits long) +
       .. ``Vd <- Vs xor enc_blk(key, 1'b1 @ SIV[3b/4-2:0] @ ctr``.
     . `absorb(Vs)`.
     . `ctr <- ctr + 1`.
--
+
If `VL*SEW` > `b`, the above operations are applied to each of the `VL*SEW/b` blocks in `Vs`.

** In state _dec_hash_finalize_,
   only an ``ace.exec`` instruction of Form B is allowed,
   namely “```ace.exec Kn|K[Xn], Vs```,” where it is the responsibility of the user to set
+
--
  ***  `Vs = IntTo{b/2}Bits(bit_length(AD)) @ IntTo{b/2}Bits(bit_length(plaintext))`.
--
+
``ace.exec`` thus performs the following operations:
+
--
  . `absorb(Vs)` (which modifies `auth_tag`).
  . `tmp <- enc_blk(enc_key, 1'b0 @ (auth_tag xor N)[b-2:0])`.
  . If tag length is `b` bits, then
     .. `auth_tag <- tmp`,
  . else (tag length is `3b/4` bits)
     .. `auth_tag <- tmp[b-1:0] @ (b/4)b0`.
  . Finally, `auth_tag` and `SIV` are compared:
     .. If the values match, the state transitions to _completed_ and `ace.error` returns no error,
  else the state transitions to _completed_ and `ace.error` returns `ace_err_authentication`.
--
+
If `VL*SEW` > `b`, only the `b` least significant bits of `Vs` are considered.

** Upon completion of `ace.import`, the ACE unit recomputes `hash_key` and `auth_key`
  . (`enc_key`, `auth_key`) <- `RFC8452_KeyDeriv(key)`.

//

===== Usage

We show in <<ACE-pseudocode-GCM-SIV-encryption>> how to perform AEAD encryption with a GCM-SIV CC (with `b` = `VL*SEW` = 128).
<<ACE-pseudocode-GCM-SIV-decryption>> is the corresponding pseudocode for decryption.

[[ACE-pseudocode-GCM-SIV-encryption]]
.GCM-SIV Encryption
----
// Acquire payload, initialize
- Info: authenticated data = *AD
- Info: plaintext = *PT
- Call an API to get the corresponding key from a key management applet or HW block.
- The API returns the SCC. Assume X5 is the pointer to it.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)

// Set the nonce (and the derived Authentication Key).
ace.state K0, #ace_state_set_public_value
V0 ← nonce
ace.exec K0, V0

foreach(i from 0 to len_in_bytes(AD)/16-1) {
    - load V0 from address AD+16*i               // Load a block of associated data
    ace.exec K0, V0                              // Absorb it into hash
}

foreach(i from 0 to len_in_bytes(PT)/16-1) {
    - load V0 from address PT+16*i               // Load a block of plaintext
    ace.exec K0, V0                              // Absorb it into hash
}

V0 ← IntTo64Bits(len(AD)) @ IntTo64Bits(len(PT))
ace.exec K0, V0                                  // Absorb lengths into hash

// Finalize the SIV computation, set and return it
ace.state K0, #ace_state_enc_hash_finalize
ace.exec V2,K0
- store V2 into tag

// Encrypt the plaintext
ace.state K0, #ace_state_encrypt
foreach(i from 0 to len_in_bytes(PT)/16-1) {
    - load V0 from address PT+16*i               // Load a block of plaintext
    ace.exec V1, K0, V0                          // Encrypt the block
    - store V1 at address CT+16*i                // Store a block of ciphertext
}
----

[[ACE-pseudocode-GCM-SIV-decryption]]
.GCM-SIV Decryption
----
// Acquire payload, initialize
- Info: authenticated data = *AD
- Info: ciphertext = *CT
- Call an API to get the corresponding key from a key management applet or HW block.
- The API returns the SCC. Assume X5 is the pointer to it.
- Allocate memory for plaintext buffer PT (if not same as CT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)

// The next operations set the nonce and SIV.
ace.state K0, #ace_state_set_public_value
V0 ← nonce
ace.exec K0, V0
ace.state K0, #ace_state_set_public_value_2
V0 ← SIV
ace.exec K0, V0

// Compute AD contribution to Auth Data
ace.state K0, #ace_state_hash_absorb
foreach(i from 0 to len_in_bytes(AD)/16-1) {
    - load V0 from address AD+16*i
    ace.exec K0, V0                              // Absorb it into hash
}

// Decrypt ciphertext and continue computation of auth_tag
foreach(i from 0 to len_in_bytes(CT)/16-1) {
    - load V0 from address CT+16*i
    ace.exec V1, K0, V0
    - store V1 at address PT+16*i
}

// Finally, we absorb the lengths of AD and plaintext into auth_tag AND verify
ace.state K0, #ace_state_enc_hash_finalize
V0 ← IntTo64Bits(len(AD)) @ IntTo64Bits(len(PT))
ace.exec K0, V0
ace.error X1
if (X1 != 0) then { handle error }               // do not use the plaintext if error occurred
----

[[ACE-OCB-mode]]
==== OCB Mode

We only architect the OCB3 variant of OCB as specified in RFC{nbsp}7253 cite:[RFC7253] and cite:[DBLP-journals-joc-KrovetzR21].
While this algorithm is asymptotically more efficient than GCM and GCM-SIV, it has a much heavier setup and
its exported state, requires significantly more memory than the other modes.
On the other hand, since it uses only a single key and no derived keys, with ciphers with an expensive key expansion
like the AES it may use fewer internal resources.

The state machine of this algorithm closely follows RFC{nbsp}7253 (except for the ordering and numbering of the bit fields).
The algorithm and is of course identical to the RFC's for 128-bit-wide block ciphers, with the generalisation to other widths being straightforward and according the security proof of the original algorithm and a lower bound on nonce length following cite:[cryptoeprint-2023-326].

===== Specification

Parameters:::
+
--
* `b` = block size. `b` is a power of two, at least 64. For this algorithm we require `VL*SEW` to be an integer multiple of `b`.
* `k` = key size, `b`|`k`.
--
+
Also, define `g` = `log_2(b)`.

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.

* *Internal State*:
 ** `key`: `k` bits.
 ** `N`: `u+1` bits (at most `u` bits are all used).
 ** `L`, `offset`, `hash_A`, `hash_P` : `b` bits.
 ** `N_len`, `tag_len`, `last_blk_len`: `g` bits as integer.

* *Serialized Content*:
[lowerroman]
 . `key`: `k` bits, or 64 bits if a System Key index.
 . `N`: `b` bits, but only `u+1` bits defined.
 . `L`: `b` bits.
 . `offset`: `b` bits.
 . `hash_A`: `b` bits.
 . `hash_P`: `b` bits.
 . `tag_len`: 16 bits
 . `last_blk_len`: 16 bits
 . `N_len` : 16 bits
 . padding : 16 bits

 Algorithm-Specific Functions:::

* `enc_blk(K,p) -> c` encrypts block `p` using the key `K` and returns the result `c`.
* `dec_blk(K,c) -> p` decrypts block `c` using the key `K` and returns the result `p`.
* `double(S)`:
Let `C` be  `0x1B` for `b` = 64, `0x87` for `b` = 128, and `0x425` for `b` = 256, then: +
If S[`b`-1] == 0, then { `double(S)` <- `S << 1` } else { `double(S)` <- `(S << 1) xor C` } .

State Machine:::

* *States:* _initial_, _set_public_value_, _set_public_value_2_, _hash_absorb_, _encrypt_, _enc_last_block_, _enc_hash_finalize_, _decrypt_, _dec_last_block_, _dec_hash_finalize_, _hash_verify_, and _completed_.

* *Allowed State Transitions:*
 ** From all states to _initial_.
 ** _initial_ -> _set_public_value_ -> _set_public_value_2_ -> _hash_absorb_ -> _hash_finalize_
 ** _hash_finalize_ -> _encrypt_ -- if metadata allows encryption, else the CR is *invalidated*.
 ** _hash_finalize_ -> _decrypt_ -- if metadata allows decryption, else the CR is *invalidated*.
 ** _encrypt_ -> _enc_last_block_ -> _enc_hash_finalize_ -> _hash_output_, later automatically transitioning to _completed_.
 ** _decrypt_ -> _dec_last_block_ -> _hash_verify_, later automatically transitioning to _completed_.

* *Behavior:*
** In state _initial_ :
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
  *** The following initialization operations are performed:
   . `N <- 1'b1 @ zeros(u)`.
   . `hash_A <- zeros(b)`
   . `hash_P <- zeros(b)`

 ** To move to _set_public_value_, the `ace.state` operation must use the additional argument, which sets the nonce length `N_len`.
 `N_len` must be at least `g-1`. If not, an invalid instruction error is raised, and the CR is *invalidated*.

** In state _set_public_value_, only  ``ace.exec`` instructions of Form B, “```ace.exec Kn|K[Xn], Vs```”, is allowed, whereby `N` is set to `Vs`, namely
     `N <- zeros(u-N_len) @ Vs[N_len-1:0]`
  *** If “```ace.exec Kn|K[Xn], Vs```,” is repeated, it will rewrite `N`.
  *** If no such `ace.exec` is issued, `N` remains zero. This condition results in an error at a later state transition.

** To move to _set_public_value_2_, the `ace.state` operation must have the additional argument, which sets the tag length `tag_len`.
   If this argument (interpreted as an unsigned value) is larger than `b` or `0` (the latter occurs also
   if `X0` is passed as the additional argument), an invalid instruction error is raised, and the CR is *invalidated*.
  *** If `N[u] == 1'b1`, this means that `N` was not set in state _set_public_value_. We do not allow code that skips nonce setting, as this mode is not secure under nonce reuse, therefore in this case an invalid instruction error is raised, and the CR is *invalidated*.
  *** The following operation must be an `ace.state` to move to _hash_absorb_

** Upon entering state _hash_absorb_,  following operations are performed:

  . `offset <- zeros(b)`
  . `L <- enc_blk(key, zeros(b))`
  . `L <- double(double(L))`

** In state _hash_absorb_, only  ``ace.exec`` instructions of Form B are allowed:
  “```ace.exec Kn|K[Xn], Vs```” absorbs a data block in `auth_tag`, i.e.:
+
--
    . `L <- double(L)`
    . `offset <- offset xor L`
    . `hash_A <- hash_A xor enc_blk(key, Vs xor offset)`
--
+
If `VL*SEW` > `b`, the above operation is executed `VL*SEW/b` times.

  *** If `VL*SEW` > `b`, only the `b` least significant bits of `Vs` are considered.

** To move to _hash_finalize_, the `ace.state` operation must have the additional argument, which sets the length of the final block of the AD in `last_blk_len`.

** In state _hash_finalize_, only one `ace.exec` instructions of Form B is allowed if `last_blk_len` != 0.
 “```ace.exec Kn|K[Xn], Vs```” which absorbs the last data block in `auth_tag`, i.e.:
+
--
  * `tmp : bits(b)`

[]
  . `offset <- offset xor enc_blk(key, zeros(b))`
  . `tmp <- (zeros(b-last_blk_len-1) @ 1b'1 @ Vs[last_blk_len-1:0]) xor offset`
  . `hash_A <- hash_A xor enc_blk(K, tmp)`
--
+
If `last_blk_len` == 0, however, no `ace.exec` can be executed, and only an `ace.state` instruction is allowed to enter state _encrypt_ or _decrypt_.

** Upon entering states `_encrypt_` or `_decrypt_`, the _setup_ and _init_ stages is performed:
+
--
 * `N_ext : bits(b)` (`N_ext` means “N, extended”)
 * `Stretch : bits(3b/2)`
 * `bot : bits(g-1)`
 * `Ktop : bits(b)`

[]
 . `offset <- zeros(b)`
 . `L <- enc_blk(key, zeros(b))`
 . `L <- double(double(L))`
 . `N_ext <- N[N_len-1:0] @ 1'b1 @ zeros(b-g-1-N_len) @ numtobits(tag_len,g)`
 . `bottom <- int(N_ext[b-1:b-g+1])` // Rogaway's paper number bits in opposite order
 . `Ktop <- enc_blk(key, zeros(g-1) @ N_ext[b-g:0])`
 . `Stretch <- (Ktop[b/2-1:0] xor Ktop[b/2+7..8]) @ Ktop`
 . `offset <- Stretch[b+bottom:bottom]`
--
+
** In state _encrypt_, only ``ace.exec`` instructions of Form A are allowed:
   “```ace.exec Vd, Kn|K[Xn], Vs```” absorbs the plaintext `Vs` into the `auth_tag` an encrypts `Vs` into `Vd`, namely:
+
--
 . `L <- double(L)`
 . `offset <- offset xor L`
 . `hash_P <- hash_P xor Vs`
 . `Vd <- offset xor enc_blk(key, Vs xor offset)`
--
+
If `VL*SEW > b`, the above operation sequence is executed `VL*SEW/b` times, encrypting each `b`-bit block of `Vs` into the corresponding `b`-bit block of `Vd`.

** To move to _enc_last_block_, the `ace.state` operation must have the additional argument, which sets the bit length of the final block of the plaintext in `last_blk_len`.

** In state _enc_last_block_, only an ``ace.exec`` instruction of Form A “```ace.exec Vd, Kn|K[Xn], Vs```,” is allowed if `last_blk_len` is nonzero.
In this case, following operations are performed:
+
--
 * `tmp : bits(last_blk_len)`
 * `tmp2 : bits(b)`
 * `aux : bits(b)`

[]
 . `aux <- enc_blk(key, zeros(b))`
 . `offset <- offset xor aux`
 . `tmp <- enc_blk(key, offset)[last_blk_len-1:0]`
 . `tmp <- Vs[last_blk_len-1:0] xor tmp`
 . `Vd <- zeros(b-last_blk_len) @ tmp`
 . `tmp2 <- (zeros(b-last_blk_len-1) @ 1'b1 @ tmp) xor offset`
 . `aux <- double(aux)`
 . `hash_P <- enc_blk(key, hash_P xor tmp2 xor offset xor aux) xor hash_A`
--
+
On the other hand, if `last_blk_len` is zero, only an ``ace.exec`` instruction of Form D, “```ace.exec Kn|K[Xn]```,” is allowed, which performs:
+
--
* `aux : bits(b)`

[]
  . `aux <- enc_blk(key, zeros(b))`
  . `aux <- double(aux)`
  . `hash_P <- enc_blk(key, hash_P xor offset xor aux) xor hash_A`
--
+
In both cases the state then transitions to _enc_hash_finalize_.

** In state _enc_hash_finalize_, only an ``ace.exec`` instruction of Form C, “```ace.exec Vd,Kn|K[Xn]```,” is allowed, which
performs `Vd <- zeros(b-tag_len) @ hash_P[tag_len-1:0]`.
** In state _decrypt_, only ``ace.exec`` instructions of Form A are allowed.
    “```ace.exec Vd, Kn|K[Xn], Vs```” decrypts `Vs` into `Vd`, and absorbs the plaintext `Vd` into the `auth_tag`, namely:
+
--
  * `tmp : bits(b)`

[]
  . `L <- double(L)`
  . `offset <- offset xor L`
  . `tmp <- offset xor enc_blk(key, Vs xor offset)`
  . `hash_P <- hash_P xor tmp`
  . `Vd <- tmp`
--
+
If `VL*SEW` > `b`, the same behavior applies as in state _encrypt_.

** To move to _dec_last_block_, the `ace.state` operation must have the additional argument, which sets the bit length of the final block of the ciphertext in `last_blk_len`.

** In state _dec_last_block_, only an ``ace.exec`` instruction of Form A “```ace.exec Vd, Kn|K[Xn], Vs```,” is allowed if `last_blk_len` is nonzero.
In this case, the same operations as in state _enc_last_block_ are performed except for line 6., that reads instead
+
--
[start=6]
. `tmp2 <- (zeros(b-last_blk_len-1) @ 1'b1 @ Vs[last_blk_len-1:0]) xor offset`
--
+
If `last_blk_len` is zero, only an ``ace.exec`` instruction of Form D, “```ace.exec Kn|K[Xn]```,” is allowed, which performs the same operations as in state _enc_last_block_.
+
For any value of `last_blk_len`, the state is changed to _hash_verify_.

** In state _hash_verify_, only an ``ace.exec`` instruction of Form B, i.e., “```ace.exec Kn|K[Xn], Vs```” is allowed.
    It compares the `tag_len` least significant bits of `Vs` with the `tag_len` least significant bits of `hash_P`:
+
--
  . If the values match, then the state is changed to _completed_, and `ace.error` returns no error,
  . else the state is changed to _completed_, and `ace.error` returns `ace_err_authentication`.
--
+

//

===== Usage

Pseudocode for OCB encryption is given in <<ACE-pseudocode-OCB-encryption>> (again with `b` = `VL*SEW` = 128).

[[ACE-pseudocode-OCB-encryption]]
.OCB Encryption
----
// Acquire payload, initialize
- Info:
 - authenticated data = *AD with bit length AD_len
 - plaintext = *PT with bit length PT_len
 - nonce N with bit length N_len
 - tag length tag_len

- Process gets an OCB encryption CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero,4,e32,m1,ta,ma                      // Use 128-bit vectors
ace.import K0, (X5)

// The next operations set the nonce
X1 ← N_len
ace.state K0, #ace_state_set_public_value,X1
V0 ← N
ace.exec K0, V0

// The next operations set the tag lenth
X1 ← tag_len
ace.state K0, #ace_state_set_public_value_2,X1

// Compute AD contribution to tag
ace.state K0, #ace_state_hash_absorb

foreach(i from 0 to floor(AD_len/128)-1) {
    - load V0 from address AD+16*i
    ace.exec K0, V0                                // Absorb it into hash
}

X1 ← AD_len mod 128                                // Can be zero
ace.state K0, #ace_state_hash_finalize, X1
if (X1 mod 128 != 0) then
    - load V0 from address AD+floor(AD_len/128)*i  // may be a shorter load
    ace.exec K0, V0                                // Absorb it into hash and encrypt

// Encrypt plaintext and continue computation of auth_tag
ace.state K0, #ace_state_encrypt
foreach(i from 0 to floor(PT_len/128)-1) {
    - load V0 from address PT+16*i
    ace.exec V1, K0, V0
    - store V1 at address CT+16*i
}

X1 ← PT_len mod 128                                // Can be zero
ace.state K0, #ace_state_enc_hash_finalize, X1
if (X1 mod 128 != 0) then
    - load V0 from address AD+floor(AD_len/128)*i  // may be a shorter load
    ace.exec V1, K0, V0                            // Absorb it into hash and encrypt
- store V1 at address CT+floor(AD_len/128)*i       // may be a shorter store

ace.state K0, #ace_state_output
ace.exec V1, K0, V1                                // output tag
----

OCB decryption differs from encryption as follows:
the roles of `PT` and `CT` are reversed,
states _encrypt_ and _enc_hash_finalize_ are replaced by states _decrypt_ and _dec_hash_finalize_,
and the last lines are as follows:

[[ACE-pseudocode-OCB-decryption-difference]]
.OCB Decryption
----

ace.state K0, #ace_hash_verify
- load tag into V1
ace.exec K0, V1                          // V1 contains the tag from the input
ace.error X1
if (X1 != 0) then { handle error }       // do not use the plaintext if error occurred
----




[[ACE-CMAC-mode]]
==== CMAC Functions

CMAC is an algorithm for message authentication codes constructed from a block cipher.
It was designed by Tetsu Iwata and Kaoru Kurosawa and became a NIST recommendation in May 2005 cite:[nist-SP-800-38B].
(((ACE, algorithm, CMAC)))

===== Specification

Parameters:::

* `b` = block size (8|`b`).  For this algorithm we require `VL*SEW` to be an integer multiple of `b`.
* `k` = key size (8|`k`).

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits.

* *Internal State*:
 ** `key`: `k` bits.
 ** `hash`: `b` bits.
 ** `last_block_len`: 64 bits.

* *Serialized Content*:
[lowerroman]
 . `key`: `k` bits.
 . `hash`: `b` bits.
 . `last_block_len`: 64 bits.

Algorithm-Specific Functions:::

* `enc_blk(key, p) -> c` encrypts block `p` using the key, and returns the result `c`.
* `gen_subkeys(K) -> (K1,K2)` generates subkeys `K1` and `K2` from the master key `K` as follows: +
Let `C` be `0x1B` for `b` = 64, `0x87` for `b` = 128, and `0x425` for `b` = 256, then

 . `L <- enc_blk(K, zeros(b))`
 . if (`most_significant_bit(L){nbsp}{nbsp}= 0`) then
   { `K1 <- L{nbsp}{nbsp}<< 1` }
   else
   { `K1 <- (L{nbsp}{nbsp}<< 1) xor C` }.
 . if (`most_significant_bit(K1){nbsp}= 0`) then
   { `K2 <- K1{nbsp}<< 1` }
   else
   { `K2 <- (K1{nbsp}<< 1) xor C` }.
 . return ```(K1,K2)```.

State Machine:::

* *States:* _initial_ (0), _hash_absorb_, _hash_last_block_, _hash_finalize_, and _completed_.
* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_.
 ** _hash_absorb_ -> , _hash_last_block_ -> _hash_finalize_ -> _completed_.
 ** From any state to state _initial_.
* *Behavior:*
 ** In state _initial_:
  *** `last_block_len <- zeros(64)`
  *** `hash <- zeros(b)`
  *** No {nbsp}```ace.exec```{nbsp} operation is allowed.

 ** In state _hash_absorb_, we can only issue ``ace.exec`` instructions of Form B, i.e., “```ace.exec Kn|K[Xn], Vs```,” to absorb the data block `Vs` into the hash. This is performed as follows:
+
--
   . `hash <- enc_blk(key, hash xor Vs)`.
--
+
If `VL*SEW` > `b`, then the above operations are applied to each `b`-bit block of `Vs`.

 ** Upon issuing “```ace.state Kn|K[Xn], #ace_state_last_block, Xs```” where `Xs` contains the bit length of the last block, the following happens:
   . if `partial_len` != 0, then the CR is *invalidated*. (The previous block is not complete.)
   . if `Xs > b` then the CR is *invalidated*.
   . `last_block_len <- Xs`.

 ** In state _hash_last_block_,  we can only issue a single ``ace.exec`` instruction of Form B, i.e., “```ace.exec Kn|K[Xn], Vs```”, to absorb the data block `Vs`. If `VL*SEW` > `b`, only the least significant `b` bits of `Vs` are considered.
+
--
  . `(K1, K2) <- gen_subkeys(key)`.
  . if `last_block_len` == `b`, then
    .. `tmp <- hash xor Vs xor K1`
  . else
    .. `tmp <- Vs`
    .. Remove the `b` - `last_block_len` most significant bits of `tmp` and pad the resulting value with a `1` and sufficiently many `0` bits to make it `b` bits long.
    .. `tmp <- hash xor tmp xor K2`
  . `hash <- enc_blk(key, tmp)`
  . The state is changed to _hash_finalize_.
--
+

** In state _hash_finalize_, we can issue one ``ace.exec`` instruction of Form C, i.e., “```ace.exec Vd, Kn|K[Xn]```”, to output the hash into `Vd`.
   If `VL*SEW` > `b`, only the bits of `Vd` beyond the `b`-th are cleared.
   Upon issuing that instruction, the CC transitions to state _completed_ with no error.

//

===== Usage

[[ACE-pseudocode-CMAC]]
.CMAC Computation
----
- Info: CMAC input = *M with bit length M_len
- Process gets a CMAC CC from an API. Assume X5 is the pointer to the CC.

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)

ace.state K0, #ace_hash_absorb
blocks = floor(M_len/128)
remainder = M_len % 128
if remainder == 0 then
    blocks ← blocks - 1
    remainder ← 128

foreach(i from 0 to blocks-1) {
    - load V0 from address M+16*i
    ace.exec K0, V0
}

X1 ← remainder
ace.state K0, #ace_hash_last_block, X1
- load V0 from address M+16*blocks
ace.exec K0, V0

ace.state K0, #ace_hash_hash_finalize
ace.exec V0, K0  // this is the value of the CMAC
----


[[ACE-hash-functions]]
==== Hash and MAC Functions (Including XOF Variants Thereof)

This section defines an interface for hash and MAC functions.
Because of the vast variety of such functions, we cannot define a completely general interface.
However, the interface defined here is sufficiently general to allow to describe most commonly used and standardized functions, such as
the SHA2 cite:[nist-fips-180-4], SHA3 and SHAKE cite:[nist-fips-202], as well HMAC cite:[nist-fips-198-1] keyed constructions, and many others.
(((ACE, algorithm, general hashing)))
(((ACE, algorithm, MAC functions)))
(((ACE, algorithm, XOF)))

===== Specification

Parameters:::

* `b` = block size (8|`b`). This is the size of an absorbed block and may be different from the size of the internal state that is kept by the function.
* `n` = size of the internal state that is kept by the function (8|`n`).
Either the block size is an integer multiple of the vector length or the vector length is an integer multiple of the block size.
* `k` = key size (8|`k`). Present only if keyed, i.e., a MAC.

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k` bits. Present only if keyed, i.e., a MAC.

* *Internal State*:
 ** `key`: `k` bits. Present only if keyed, i.e., a MAC.
 ** `hash_state`: algorithm specific length.
 ** `last_block_len`. Present only if this Hash/MAC has special internal treatment for a fractional last block that goes beyond padding and appending the length, which are handled by user software  (field size at most 16 bits).
 ** `used_VLxSEW`.  Current used vector length.
 ** `partial_len`.  Length of absorbed data so far for the current block (field size at most 16 bits). Only if used by the algorithm.
 ** `partial_block`: `b` bits (a priori we cannot know whether `b > VL*SEW` or not, and changing the internal memory requirements of a CC depending on the `VL*SEW` can lead to memory exhaustion).

* *Serialized Content*:
[lowerroman]
 . `key`: `k` bits. Present only if keyed, i.e., a MAC.
 . `hash_state`: `n` bits.
 . `used_VLxSEW`: 16 bits. Current vector length.
 . `last_block_len`: 16 bits. Only if this Hash/MAC has special internal treatment for a fractional last block that goes beyond padding and appending the length, which are handled by user software. Otherwise, this is zero.
 . `partial_len`: 16 bits. Length of absorbed data so far for the current block. Only if used by the algorithm, else zero padding.
 . padding: 16 bits.
 . `partial_block`: `b` bits. We include it only if there is a partial block, and exclude it when not.
 We reuse the most significant bit of the `state` field to store this information.
 (In theory, we could include only the part filled so far, but this would complicate the parsing of a SCC.)

Algorithm-Specific Functions:::

* `absorb(p)`: process block `p` into the hash or MAC.

State Machine:::

* *States:* _initial_ (0), _hash_absorb_ (1 or 9), _hash_last_block_ (5 or 13), _hash_finalize_, and _completed_ (15).
The values 9 and 13 are used when there is a partial block.
* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_.
 **  If the algorithm has a special treatment for the last block, either if it is partial or always, then
  *** _hash_absorb_ ->  _hash_last_block ->  _hash_finalize_ -> _completed_.
  *** else _hash_absorb_ ->  _hash_finalize_ -> _completed_.
 ** From any state to state _initial_.

* *Behavior:*
 ** In state _initial_:
  *** `last_block_len`, `partial_len` and `partial_block` are set to zero.
  *** `hash`: the initial value is set as specified by the algorithm.
  *** `used_VLxSEW` is set to the current value of `VL*SEW`.
  *** Any `ace.exec` will result in the CR being *invalidated*.

  ** In each state except _initial_, before performing any operation except `ace.import`, `ace.export`, and `ace.clone`, `used_VLxSEW` is compared to `VL*SEW`.
  If there is a mismatch, the CR will be *invalidated* and any operation will result in an invalid instruction exception.

  ** In state _hash_absorb_, we can only issue ``ace.exec`` instructions of Form B, i.e., “```ace.exec Kn|K[Xn], Vs```”, to absorb the data block `Vs` into the hash:
  *** If `VL*SEW` is a multiple of `b` (including the case where `VL*SEW` = `b`), then `absorb` is applied to each `b`-bit segment of `Vs`.
  *** If `b` is a multiple of `VL*SEW` and `b` > `VL*SEW`, then
   . `Vs` is written to `partial_block` starting at byte offset `partial_len`.
   . `partial_len <- partial_len + VL*SEW`.
   . if `partial_len` == `b`, then
   .. `absorb` is applied to `partial_block`,
   .. `partial_len <- 0` and `partial_block` is cleared.

 ** Upon issuing “`ace.state Kn|K[Xn], #ace_last_block, Xs`” where `Xs` contains the length of the last block, the following happens:
+
--
 . if `partial_len` != 0, then the CR is *invalidated*. (The previous block is not complete.)
 . if `Xs > b`, then the CR is *invalidated*.
 . if `Xs == 0`, then the CR is *invalidated*.
 . `last_block_len <- Xs`.
--
+

 ** In state _hash_last_block_:
  *** if `last_block_len` == 0, then the CR is *invalidated*.
  *** If `VL*SEW` is a multiple of `b` (including the case where `VL*SEW` == `b`), then
      we only issue a single ``ace.exec`` instruction of Form B, i.e., “```ace.exec Kn|K[Xn], Vs```,” to absorb the least significant `b` bits of data block `Vs`.
  *** If `b` is a multiple of `VL*SEW` and `b` > `VL*SEW`, then we can issue one or more ``ace.exec`` instructions of Form B, i.e., “```ace.exec Kn|K[Xn], Vs```,” to absorb the data block `Vs` into the hash, i.e. “```ace.exec Kn|K[Xn], Vs```”:
   . if `partial_len < b`, then
   .. The instruction must be of Form B, else the CR is *invalidated*.
   .. `Vs` is written to `partial_block` starting at byte offset `partial_len`.
   .. `partial_len <- partial_len + VL*SEW`.
   . else if `partial_len+VL*SEW == b`, then the CR is *invalidated*.

  ** In state _hash_finalize_:
   *** If the function is a XOF, then
       we can issue an arbitrarily large number of ``ace.exec`` of Form C instructions, i.e., “```ace.exec Vd, Kn|K[Xn]```,” to output the hash.
       This can be done with any of the two mechanisms below, except that the state never transitions to _completed_.
   *** If `VL*SEW` is a multiple of `b` (including the case where `VL*SEW` == `b`), then
      we only issue a single ``ace.exec`` of Form C, i.e., “```ace.exec Vd, Kn|K[Xn]```”, to output the hash.
      The value is, if necessary, finalized, before being output.
      The state is then changed to _completed_ with no errors (unless the algorithm is a XOF).
   *** If `b` is a multiple of `VL*SEW` and `b` > `VL*SEW`, then we can issue one or more ``ace.exec`` instructions of Form C, i.e., “```ace.exec Vd, Kn|K[Xn]```”, to output the hash:
    . Upon entering state _hash_finalize_, `last_block_len` is reused to store the length of the output hash (in any case `b` if the algorithm is a XOF).
    . After each “```ace.exec Vd, Kn|K[Xn]```”:
     .. We write a new block of the final value of the hash function to `Vd`, with the caveat that if `0` < `last_block_len`  < `VL*SEW`, the value in `Vd` is accordingly truncated to the least significant `last_block_len` bits and zero-padded.
     .. `last_block_len <- max(last_block_len - VL*SEW, 0)`
     .. if `last_block_len` == 0 then the state is changed to _completed_ with no errors (unless the algorithm is a XOF).
//, in which case the internal state is updated again, `last_block_len <- b`, and more “```ace.exec Vd, Kn|K[Xn]```” instructions can be issued.

NOTE: The description of states _hash_absorb_ and _hash_finalize_ should make it clear that allowing `b` and `VL*SEW` to be in relations other than one being an integer multiple of the other, as well as allowing a change of `VL*SEW`, would significantly complicate the state machine.

===== Usage

The usage of this type of algorithms is very similar to that of CMAC (cf.{nbsp}<<ACE-CMAC-mode>>), with the exception that if the last block is not treated in a special way, there is no state _hash_last_block_ and after the last block is absorbed, the state is changed to _hash_finalize_.

[[ACE-Ascon]]
==== Ascon Specific Rules

We now describe the state machines of the various Ascon-based cite:[DBLP-journals-joc-DobraunigEMS21] algorithms standardized by the NIST cite:[nist-SP-800-232].
(((ACE, algorithm, Ascon)))

===== Ascon-128 and Ascon-128a authenticated ciphers

[WARNING]
TBD

===== Ascon-Hash cryptographic hash

[WARNING]
TBD

===== Ascon-Xof extendable-output function

[WARNING]
TBD

===== Ascon-80pq cipher with the increased 160-bit key

[WARNING]
TBD

// //////////////////////////////////////////////////////////////////////////////////////////

[comment]
--
[[ACE-examples]]
=== Examples

==== Context Switching

[WARNING]
TBD

==== VM Migration

Users may migrate their virtual machines (VMs) between client devices with CPUs from different silicon providers—a practice already common when moving interrupted VMs between Intel and AMD systems.
In such a scenario, the ACE implementation on the destination device might have a Crypto Register File (CRF) with a smaller capacity (not necessarily a smaller internal memory, as the internal representation may be more redundant).
System software could then be unable to restore all Cryptographic Contexts.

To address this, the `acecrstatus` CSR can be used to enable lazy context reloading by causing the hart to trap to the parent mode if a CR being accessed is marked as “lazy”.  When this requires freeing one or more CRs first, system software decides which contexts to evict.

==== Key Management and Provisioning Applications

Software environments that implement key management operations for other domains require their own RCSK. A system may contain multiple such software environments.

A Key Management Applet (KMA) will

[arabic]
. Generate or retrieve a key matching a request.
. Configure a CR with this key and its associated metadata.
. Export this CR to a SCC in memory.
. Relinquish control to the MM.

The MM, which controls the CSK, can then

[arabic, start=5]
. Set the RCSK to the KMA’s RCSK.
. Re-import the SCC into a CR
. Change the RCSK to match the Requester domain's RCSK.
. Export the key for the Requester's use.
. Relinquish control to the Requester.

This is the most generic approach and allows each piece of software to use a CR of choice to generate CCs and import SCCs.
Furthermore, it protects the key from other SW environments that may be crossed while transferring control between the Requester process, the MM, and the Key Management application.

// Various optimizations are possible, which can be interesting for embedded environments: Steps 3., 5., and 6. can be omitted if the CR used for these operations is fixed and no intermediate SW environments modify that CR.
--

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-V-dependency]]
=== Dependency on the V Extension

[WARNING]
RVV-mini is not yet fully defined.

If ACE is implemented including the operations on vector registers-and thus not exclusively relying on `ace.input` and `ace.output`-it does not require the full V extension; it depends on a minimal subset, which we call RVV-mini. The required features are:
(((RVV-mini)))

* Support for vector registers sufficiently wide to host the block-wise operations required by the algorithms supported by ACE;
* The `vsetvli` instruction with restricted parameters (e.g., “```vsetvli zero,4,e32,m1,ta,ma```” for 128-bit-side operations); unsupported configurations must generate defined errors;
* Unit-strided vector loads and stores exclusively; and
* Vector bitwise logical operations such as `vxor`, `vand`, and `vor`.

Moreover,

* floating-point, fixed-point, and most arithmetic vector operations are not required, and
* more complex operations for some corner-case cryptographic algorithms may be performed in GPRs, with results then inserted in vector registers via `vins`/`vext`.

RVV-mini must maintain full opcode compatibility with RVV to guarantee that ACE code runs unmodified on full RVV implementations.


// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-RCSK-vs-ID]]
=== Programmable RCSKs vs. ID-based Usage Control

This section is informative and non-normative.

ACE provides two architected layers of usage control:

. At the User and Supervisor levels, CC usage can be optionally constrained by ASID and VMID.
This is a lightweight mechanism.
Because filtering by ASID is inactive when the hart is in S mode or higher, context switching can be performed without modifying the RCSK.
. At higher privilege levels, not only the usage, but even the import of CCs can be restricted by a programmable RCSK.
This offers stronger security by also preventing unauthorized `ace.import` operations, but incurs higher overhead as it typically requires an `ecall`.

The envisioned usage model employs ASID/VMID filtering at the User level, and also at the Supervisor level in high-performance systems where migration is not required (e.g., automotive applications). Cryptographic domain separation via the RCSK is intended for Virtual Machines, Supervisor Domains, Worlds, and TEEs within those contexts, as these demand stronger security guarantees.

NOTE: Although the architecture does not prevent assigning unique RCSKs to U-mode processes, doing so would impose a substantial burden on system software due to per-context-switch `ecall` overhead.
Hardware support—such as automatic RCSK switching based on ASID/VMID, could alleviate this burden.
However, such a mechanism is not currently under consideration due to its architectural complexity, inflexibility, and hardware cost.
For example, it would necessitate secure management of large RCSK tables, including saving, restoring, and potentially migrating entire RCSK blocks.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-threat-model]]
=== Threat Model

This section is informative and non-normative

The ACE threat model is straightforward.

**Assets** consist of _keys_ and any other information that could aid an adversary in recovering plaintext or forging ciphertext. This includes items such as masks in tweakable XEX modes and derived keys in AES-GCM-SIV. The critical properties of these assets are their _confidentiality_ and _integrity_.

**Adversaries** are assumed capable of compromising processes by exploiting software vulnerabilities.
They are also able to gain access to memory contents, for instance, by abusing hardware interfaces or by SoC/memory interposition.
The model does not include adversaries capable of sophisticated hardware attacks, such as using
a Focused Ion Beam/Scanning Electron Microscope (FIB/SEM) to tamper with the hardware's functionality.

Side channel attacks are addressed optionally. ACE offers interfaces to both SCA-unprotected and SCA-protected implementations of cryptographic algorithms, if these options are provided by the designer.

Threats can be addressed in four ways:

[horizontal]
**C:**:: _Control_ the threat by implementing full or partial mitigations.
**A:**:: _Accept_ the threat and its associated risks.
**T:**:: _Transfer_ the threat to another party better suited to address it.
**S:**:: _Suppress_ the features that give rise to the threat.

ACE is designed to avoid the “***A***” and “***S***” options (as much as possible). It _controls_ threats through its own mechanisms and _transfers_ residual risk—specifically, the risk of key extraction from the privileged or trusted software and hardware environments that manage keys—to those same environments. For example, trusted software environments may employ control-flow integrity, memory encryption with integrity protection, and anti-replay mechanisms, while hardware key-management blocks can be hardened to protect entrusted keys.

Direct plaintext leakage, memory corruption attacks against the ACE-using process, and Release of Unverified Plaintext (RUP) attacks on the cryptographic algorithms are considered out of scope. These threats cannot be mitigated by ACE because the processed information resides within the user execution context. Consequently, these threats are _accepted_.

// ///////////////////////////////////////////////////////////////////////////////////////////
[comment]
--

[[ACE-incomplete-contexts]]
=== Appendix: Export of Partial Cryptographic Contexts

[WARNING]
This section describes a hypothetical mechanism for exporting partially initialized or imported cryptographic contexts.
This is _Gedankenexperiment_ only and _not_ a current part of the ACE specification.

Suppose we want to save and restore a _partial_ context, i.e. a context whose initialization or import operation has been interrupted for a context switch, preventing immediate return to the original control flow.  A "Partial" bit in the metadata indicates this state.
This field applies only to `ace.init` and `ace.import` operations, because they access external memory, and not to `ace.clone` and `ace.derive` as they only operate internally.
Any cryptographic operation attempted on a CR containing an partial CC results in an error or is trapped.
(((Cryptographic Register,incomplete)))

An `ace.init` operation can be interrupted at any 8-byte boundary and resumed from that point. An `ace.import` operation can also be interrupted at an 8-byte boundary, but it will only be resumed from the 48th byte or later; otherwise, it is restarted with no state saved.

NOTE: Resuming an operation may be more costly than restarting it without saved state. A third alternative—waiting to complete the operation—could introduce unacceptable delays.

When exporting a partial CR, a Partial CR Metadata (PCREM) header is used as the first 8 bytes of the SCC, preceding the nonce, SIV, and content sections as defined in <<ACE-format-SCC>>.

[[ACE-metadata-partial]]
.Format of the partial CR Metadata (PCREM)
[width="100%",cols="^9%,^7%,17%,67%",options="header"]
|===
.>|   Field .>| Width +
(bits) .>| Name                  .>| Description
|   [0:0] |   1  | Format                 | Value is 0 for the current metadata format. +
Future format will have a 1 in this position and may be longer than 64 bits.
|   [1:1] |   1  | Incomplete             | Value is 1.
|   [2:2] |   1  | Variant                | The value is 0 if the configuration was interrupted at initialization, and
                                            the value is 1 if the configuration was interrupted while importing.
|   [7:3] |   5  | Reserved               | Reserved for future use.
|  [31:8] |  24  | Payload_Length         | Length of the payload in bytes (excluding the first 32 bytes)
| [63:32] |  16  | Reserved               | Zero for now.
|===

NOTE: Fields such as Algorithm, SC_Protection, State Number, Direction_Policy, UC_Policy_{empty}__i__ (i = 0..3), and Locality are omitted. Since partial CRs are architecturally forbidden for normal use, the space normaly used by these fields is available for other purposes. Locality violations are handled when a complete CR is used; therefore, the RCSK is always used for partial CRs. This approach can reduce the need to compute or cache DCSKs at higher privilege levels, improving performance.


The exported content format for an incomplete initialization or import matches that of a complete CR, except that it is truncated to the actual imported length (rounded up to an 8-byte multiple). This length is recorded in the Payload_Length field.

For an incompletely imported CR, the partial hash (`tmp` from <<ACE-SCC-import>>) is prepended to the content, extending it by 16 bytes.
These 16 bytes are included in the Payload_Length and are considered as part of the content, hence they are encrypted.

After a partial CR is decrypted and authenticated in privileged mode, it is marked for resumption.
Upon returning from the context-switch handler:

. The original metadata, nonce, and SIV are recovered from less-privileged memory;

(These reads may be interrupted by page faults and resumed once the target page is mapped.)

The following steps are then executed as an atomic block:

[start=2]
. Compute `z` and `num_blocks` from the original content length, using the starting value of `i` from `acestart`.
. If the interrupted operation was an import:
.. Derive the `Kenc` and `Kauth` keys.
.. Recompute the partial hash from the current CR content.

The initialization or import operation can then resume from the point of interruption.

//

[WARNING]
The TG consensus is that `init`/`import` may resume after a page fault, but on a full context switch, partial CRs are not exported. Instead, the CRs are cleared and the instruction is restarted.

Our security analysis examined various scenarios, including one where a context switch interrupts an import, forcing export and later resumption of a partially imported context. We concluded that while privileged code can replace an SCC in a saved process's context or memory, it cannot abuse the resumption mechanism to breach SCC confidentiality or integrity.

--

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-architecture]]
== Architecture

[[ACE-concepts]]
=== Fundamental Concepts

Opaque Key:::
The fundamental concept of ACE is the _opaque key_, i.e., a cryptographic key whose value remains hidden to software even while being used in cryptographic operations.

Cryptographic Context:::
ACE implements the concept of opaque key through _Cryptographic Contexts_ (CCs), architectural containers that protect sensitive information.
Each CC consists of a non-opaque *metadata section* and of an opaque *content section*.
The metadata section defines the cryptographic algorithm and optional usage policies, while the content section comprises sensitive material—including keys, other secrets, and internal algorithm state.
The confidentiality and integrity of CC content section is enforced by restricting modifications and access to architectural mechanisms that enforce rules defined by the configured algorithm. The content section may contain any type of data required by the algorithm selected by the metadata, not only keys. The concept of _opaqueness_ extends to the entirety of the data in the content section.

Object-Oriented Architecture:::
CCs are _objects_ that may expose a uniform interface despite implementing different algorithms.  A CC (or SCC) encapsulates its own behavior, allowing, for instance, AES-128, AES-256, Калина-128, Калина-256, and SM4 instances in ECB mode to be used interchangeably without code changes.  Similarly, modes such as GCM-SIV or XEX/XTS, that can be instantiated with any of these algorithms would also offer the same binary interface, as long as the code supports variable SCC sizes, which can be dynamically discovered. Side-channel-resistant variants would also be supported transparently.

Sealed Cryptographic Context:::
Only the ACE implementation can access CC content.
For protection outside the architectural state, a CC can be exported as a _Sealed Cryptographic Context_ (SCC), i.e., an encrypted and authenticated package containing metadata, a nonce, and authentication tag, and encrypted content.
SCCs can be reimported into CCs when needed.
These operations use a _Context Transport Key_ (CTK).
The most commonly used CTK is the _Root Context Transport Key_ (RCTK), which is stored in an MM-only CSR.
MM manages the RCTK unless it is hardwired or hardware-generated.
Besides the content section in a CC, also the content section as encrypted in an SCC is called _opaque_.

Usage Control Policy:::
An important distinction in ACE is between the _import_ and _export_ operations on CCs, and the _use_ of CCs in cryptographic operations.
It must be always possible to import and export SCCs, and also to clear and overwrite CCs for the purpose of managing cryptographic operations, otherwise a process may be prevented from performing cryptographic operations by clobbering all the CCs.
Therefore, the _Usage Control policies_ in the metadata section may optionally restrict only the operations that perform algorithms that are configured by a CC's metadata, including modifying its state, to specified Modes, ASIDs and VMIDs.

NOTE: We introduce the concept of _Usage Control_, distinct from Access Control, to emphasize that restricted CCs and SCCs may still be exported and reimported by otherwise unauthorized environments, and only their _use_ in cryptographic operations is restricted.

Locality:::
In addition to Usage Control policies,
ACE can bind opaque keys to a _Locality_, restricting their usage to a specific device, device class, software or hardware configuration, or boot cycle.
This binding uses both metadata and a _Derived CTK_ (DCTK) derived from the RCTK and a Locality-specific secret via a key derivation function for the purpose of importing and exporting opaque keys.
The system maintains a _Locality Secrets Table_ (LST) containing both system-wide values which are fixed, values that can be configured in an externally defined way,
and fields that can be programmed by MM.
The metadata stores the Locality as an index into this table. See <<ACE-Localities>> for more details.

NOTE: The term "Locality" is borrowed from TPMs.
In TPMs, localities are 8-bit values used to restrict object usage by binding it to the source of a command (e.g., application, operating system, or driver layer).  In TPMs, if an object is bound to the "Trusted OS" locality (usually with a value of 4), it can be used by any Trusted OS running on the system. This contrasts with the ACE mechanism, which allows for more fine-grained control over key usage: The MM firmware can reprogram the corresponding Locality Secret to a unique value for each Trusted OS, for instance by reprogramming the "OS_Secret" field in <<ACE-locality-indexes>>.

// ///////////////////////////////////////////////////////////////////////////////////////////

=== ACE Programmer's Model

The Atomic Cryptography Extension requires a subset of the V extension to be implemented, including the
vector register file (see <<ACE-Dependencies>>).
[.red]#Discussions are still ongoing on what subset will be required, and
if a dependency on just the GPRs can be provided in addition.#

[[ACE-instructions-overview]]
==== Instructions Overview

ACE provides a number of unprivileged instructions.
Some are implemented as CSR reads or writes.
The non-standard notation `C[Xd]`, for a GPR Xd refers to the CC whose number is contained in `Xd`,
and `Cn|C[Xn]` means that there are two different encodings for when the operand is `Cn` or `C[Xn]`.

.The ACE instructions
[width="100%",cols="17%,27%,56%",options="header",subs="+macros"]
|===
| Instruction     | Operands                        |  Description
| `ace.enable` +
`ace.disable`     |                                 |  Enables/Disables the feature in the current mode.  CSRW pseudo-operation.  May trap to handle enablement.
| `ace.init`      | `Cd\|C[Xd], %offset(Xs)`        |  Sets the metadata and key(s) for the CC.
| `ace.clear`     | `Cd\|C[Xd]`                     |  Clears a CC and marks it as no longer in use and clean.
| `ace.export`    | `%offset(Xn), Cs\|C[Xs]`        |  Securely exports the content of a CC to memory.
| `ace.import{.S}` | `Cd\|C[Xd], %offset(Xn)`      |  Authenticates and imports a SCC from memory into a CC. +
 `ace.import.S` optionally supports system defined formats.
| `ace.exec`
| A. {nbsp}{nbsp} `Vd, Cn\|C[Xn], Vs` +
  B. {nbsp}{nbsp} `Cn\|C[Xn], Vs` +
  C. {nbsp}{nbsp} `Vd, Cn\|C[Xn]` +
  D. {nbsp}{nbsp} `Cn\|C[Xn]`
| Performs a cryptographic operation. The instruction may also modify the internal state of the CC. This instruction admits four _forms_, depending on whether it accepts an input or not, and whether it produces an output or not.
| `ace.size`
| `Xd, Cs\|C[Xs]` +
`Xd, Xs` .2+|  `ace.size` returns the size in bytes of the SCC exported from CC `Cs` or `C[Xs]`, or from a CC that had the metadata block `Xs`. +
Returns zero if the algorithm specified in `Xs` is not supported. +
`ace.available` is an alias for `ace.size`.
| `ace.available` | `Xd, Xs`
| `ace.clone`     | `Cd\|C[Xd], Cs\|C[Xs]`            |  Clones a source CC into a destination CC.
| `ace.derive`    | `Cd\|C[Xd], Cs\|C[Xs]` +
`Cd\|C[Xd], Cs\|C[Xs], Vs2` +
|  Optional. Uses the source CC to configure the destination CC. +
For instance, the source CC could be a KEM that configures the destination CC with a symmetric key.
| `ace.state` +
`(ace.dir)`
| `Cd\|C[Xd], #immed` +
`Cd\|C[Xd], #immed, Xs`  |  Triggers transitions in the algorithm's state (such as the different stages of hash functions or modes of operation) or provide additional information.
`ace.dir` is an alias for `ace.state`.
| `ace.restrict` +
  `(ace.harden)`  | `Cd\|C[Xd], Xs`                  |  Narrows the Usage Policies of a CC and turns on or increases the side-channel protection of the algorithm in it, if the microarchitecture supports it.
  Removing or reducing these protections is not permitted.
   `ace.harden` is an alias.
| `ace.input`     | `Cd\|C[Xd], %offset(Xs)`         |  Optional. Provides an input to the algorithm configured in the CC `Cd` or `CC[Xd]`, in place of providing it through the `ace.exec` instruction. Needed only when the inputs are very long, such as the inputs to certain public key schemes.
| `ace.output`    | `%offset(Xd), Cs\|C[Xs]`         |  Optional. Writes the output of an algorithm configured in the CC `Cs` or `CC[Xs]`, in place of providing it through the `ace.exec` instruction. Needed when the outputs are very long, such as the outputs of certain public key schemes.
| `ace.error`     | `Xd`                             |  Write the error value of the ACE unit into GPR `Xd`.
|===

// ///////////////////////////////////////////////////////////////////////////////////////////

==== Cryptographic Contexts

ACE does not add a traditional register file.
Rather, it defines 32 Cryptographic Contexts (CCs) for storing cryptographic keys and metadata.
Each CC is identified by a number from 0 to 31, which the ACE unit uses to access its contents.

Cryptographic Contexts (CCs) reside in a dedicated internal _context file_ (CF) that is inaccessible to any entity outside the ACE implementation, including software, other hardware blocks, and invasive debug interfaces. The CF's memory capacity is implementation-defined and may be as large as 32 times the size of the largest possible CC; however, a smaller amount of memory may be used in practice. At a minimum, the CF must be capable of holding either (i) a single instance of the largest possible CC, or the largest CC pair in which the first CC derives the second (via `ace.derive`), as well as (ii) a metadata block for each other possible context.
The size of each CC is dynamic, determined by the cryptographic algorithm with which it is configured.
This is an important difference with respect to GPRs and vector registers, which always have the same size.
ACE returns an error ace_err_memory when insufficient memory prevents `ace.init` and `ace.import` operations, requiring the software to free memory by exporting or clearing a different CC. Implementations must provide sufficient CF memory to prevent infinite `ace.export`/`ace.import` loops.
A further difference between CCs and registers is that CCs
are not only addressable via static 5-bit immediate addressing (as normal registers), but also indirectly, i.e., via a value from 0 to 31 in any general-purpose register.
This has two major implications:

. Adding renaming to CCs would add significant complexity to the microarchitecture.
  However CCs are much less often redefined than, say, integer or floating point registers, except for internal implied changes, and therefore we can assume that CCs are not renamed without performance issues.
. An additional bit in the instruction encoding determines whether a CC number is given by a 5-bit immediate or by the value in a GPR.

[[ACE-CSR]]
==== CSRs

ACE extends the `*status` CSRs and adds five new CSRs to manage its execution environment.
It also requires a subset of the V extension to be implemented, including the vector register file.

.New ACE CSRs
[cols="2,2,2,10"]
[%autowidth,float="center",align="center",options="header"]
|===
| Address | Privilege | Name          | Description

| 0xXXX   | URW       | aceerror      | Error code of the last ACE instruction
| 0xXXX   | URO       | aceccactive   | Number and ID of active Contexts
| 0xXXX   | URO       | aceccdirty    | Number and ID of dirty Contexts
| 0xXXX   | URW       | ccstart       | ACE start byte index
| 0xXXX   | MRW       | macerctk[0,7] | ACE Root Context Transport Key
|===

[[ACE-CSR-enable]]
===== `aceenable`

`aceenable` is a single-bit CSR.

Enabling ACE in any mode is done by writing a 1 to `aceenable`.
Disabling ACE is done by writing a zero to `aceenable`, which also clears the CCs, as described in <<ACE-tracking-cc-dirtiness>>.

[NOTE]
====
While the standard floating-point and vector extensions do not support User Mode disable/enable instructions, the ACE unit can in general be enabled and disabled in zUser Mode, instead of using an OS call or trapping.
However, if the ACE unit contains state from a different process, and its interface is disabled for the current one, enabling it will trap to the Supervisor (as described in <<ACE-ACES-field>>) to allow the latter to first save the state in case it was not saved before and then clear it (lazy context switch).

When a process that has ACE enabled is preempted, the parent modes inherit the state to be able to export and
re-import the CCs. Hence, `aceenable` is not cleared, and the `*status.ACES` fields (see <<ACE-ACES-field>>) of the parent domains will take the value Enabled.
Tracking the CCs which are active, resp., dirty is done on an individual basis and is described in <<ACE-tracking-cc-dirtiness>>.
====

[[ACE-ACES-field]]
===== ACES field in `*status`

An ACE context status field, ACES, is added to `mstatus`[26:25], and is shadowed in `sstatus`[26:25] and in `vsstatus`[26:25] if the hypervisor extension is present.
Similar to the FS and VS fields, it can be used to optimize context switching.
//Its status encoding differs from the FS, VS, and XS fields (which are defined in <<fsxsencoding>>).
Its possible values are described in <<ACE-fsxsencoding>>.

[[ACE-fsxsencoding]]
.Encoding of ACES status field
[float="center",align="center",width="100%",cols="^7%,<18%,<75%",options="header"]
|===
|Status |Name |Meaning
|   0   | Disabled-Clean     | ACE ISE not enabled, software assumes no context being configured for this hart. +
The ACE unit will erase all contexts if ACE is enabled by writing to the `aceenable` CSR.
|   1   | Disabled-Clobbered | ACE ISE not enabled, software assumes there are configured contexts left for this hart from other environments.
The hart will trap if ACE ISE is enabled by writing to the `aceenable` CSR. To be used only if explicitly supported in system SW stack, otherwise Disabled-Clean must be used.
|   2   | Enabled            | ACE ISE enabled.
|   3   | Invalid            | Reserved.
|===

The Disabled-Clean and Disabled-Clobbered states are set by the parent mode.
Disabled-Clobbered is used when the parent-mode software stack does not save Cryptographic Contexts before transferring control to a process that does not (yet) have enabled ACE. If that process later enables ACE by writing to `aceenable`, the hart traps to the parent mode, allowing lazy context save; the parent must then manually reset all Cryptographic Contexts. In contrast, a software stack that always saves the contexts of a switched-out process must configure only the Disabled-Clean state.
The Disabled-Clobbered state is primarily intended for small devices where thread migration between harts is infrequent, and possibly only one process may be dealing with cryptographic operations.

NOTE: It is responsibility of the exception handler to properly handle the contents of the CCs when the feature is enabled while ACES=Disabled-Clobbered, as described in <<ACE-tracking-cc-dirtiness>>.

Writes to ACES do not affect the contents of the CCs.
Setting ACES=Disabled-Clean or Disabled-Clobbered does not destroy the state, nor does setting ACES=Enabled clear the contents.

Fine-grained tracking activeness and dirtiness of individual CCs uses the `aceccactive` and `aceccdirty` CSRs, cf.{nbsp}<<ACE-tracking-cc-dirtiness>>.

[[ACE-CSR-ace-error]]
===== `aceerror`

The `aceerror` CSR is an 8-bit CSR that indicates the error condition on the last ACE instruction.
This implies that any read from the `aceerror` CSR may cause a hart to wait until the last operation in the ACE unit which has been issued by the same hart completes.

It can be freely read and written, in particular by context switching software to make sure that the error status is properly handled when a process resumes execution.

In <<ACE-error-values>> below, we define the mandatory error codes.
The range [0..127] of the error codes is reserved for RVI.
Error codes specific to custom algorithms may be freely defined in the range [128..255], and are allowed to overlap between algorithms.

[[ACE-error-values]]
.Error values and their meanings
[float="center",align="center",width="100%",cols="^6%,<24%,<70%",options="header"]
|===
|Value | Mnemonic                  | Examples
|  0   | ace_err_ok                | No error.
|  1   | ace_err_authentication    | Authentication failure in `ace.import`, but can also follow `ace.exec` with certain algorithms.
|  2   | ace_err_privilege         | `ace.exec`, `ace.state`, `ace.clone`, `ace.derive` failed because the access control policies in the metadata prevent usage in the current architectural state.
|  3   | ace_err_invalid           | Invalid input or operation. +
Examples:
the metadata section passed to `ace.init` is invalid;
encryption, resp., decryption is requested from a CC only configured for decryption, resp., encryption, and more generally
the current state of the CC does not expect the used form of `ace.exec`;
the requested change of state in `ace.state` is not permitted;
the change in usage policies in `ace.restrict` is not permitted because it would either downgrade or overwrite the current restrictions in the CC;
a request to clone a CC violates the re-initialisation policies of the source CC;
software tried to use an incomplete CC as a source in a `ace.exec`, `ace.state`, `ace.input`, `ace.output`, `ace.clone`, `ace.derive`, `ace.harden`, `ace.restrict` operations.
|  4   | ace_err_unimplemented     | The requested algorithm is not implemented. May be triggered also on algorithm variants, for instance if `ace.harden` is issued on an algorithm for which a non-side channel protected version is not implemented.
|  5   | ace_err_memory            | The free internal CF memory is not sufficient to perform the `ace.init`, `ace.exec`, `ace.clone`, or `ace.derive`.
The implementation must make sure this cannot happen with any other operation.
If algorithms that support `ace.derive` are implemented, the implementation must make sure that both the input and output CCs of this operation can be allocated.
|  6   | ace_err_unallocated_CC    | Software tried to use an unallocated CC as a source in one of the following instructions: `ace.exec`, `ace.state`, `ace.input`, `ace.output`, `ace.clone`, `ace.derive`, or `ace.harden`/`ace.restrict`.. +
This can be used in low CF memory situations to trigger a lazy re-load of that CC.
|===

[[ACE-tracking-cc-dirtiness]]
===== Fine Grained CC Management: `aceccactive` and `aceccdirty`

This is done by using two CSRs, which track the use and dirtiness of the CCs individually:

[arabic]
. `aceccactive`: XLEN bits, with a bit per CC to denote whether the register is in use or not (cleared contextually to CC erasure to dispose of the key). Read-only.
. `aceccdirty`: XLEN bits, with a bit per CC to track whether the corresponding CC has been modified since the last time the same bit has been cleared. +

If the _i_-th bit of `aceccdirty` is set, then the _i_-th bit of `aceccactive` must also be set.

Two types of actions can modify a CC and thus must update also `aceccdirty`:

* An explicit initialization/configuration/import; and
* Certain cryptographic operations, such as absorbing information in a hash function, that modify the internal state.

It is also possible to directly write to `aceccdirty` to optimize context switching.

Implementations are required to track the dirtiness of any CC precisely and individually.
This is different from the tracking of the dirtiness of the floating-point state, for instance.

Context-switching code must save CC number _i_ if the _i_-th bit of `aceccdirty` is set.
However, it can clear `aceccdirty` when returning control to the same process after restoring its ACE state.
This indicates to the context-switching code that there is no need to save the CC number _i_ again at the next context switch out of that process unless it has been modified again thus setting the _i_-th bit of `aceccdirty` anew.

Upon a write to `aceenable` that changes its value, the following happens to `aceccvalid` and `aceccdirty`:

* If ``aceenable``'s value is changed to 0, then all CCs are cleared, both `aceccvalid` and `aceccdirty` are set to 0, and ``*status.ACES`` is set to Disabled-Clean.
* If ``aceenable``'s value is changed to 1, and if the parent domain's ``*status.ACES``=Disabled-Clean, then we simply assume that the parent process has cleared the CC and set both `aceccvalid` and `aceccdirty` to 0 before transferring the control flow to the current process.
* If ``aceenable``'s value is changed to 1, and if the parent's ``*status.ACES``=Disabled-Clobbered, then the hart traps to allow the parent domain responsible for handling context-switched to finish saving the state and ensure that both `aceccvalid` and `aceccdirty` are set to 0, and finally set ``*status.ACES``=Disabled-Clean.
// [.red]#This behavior should be restricted only to User mode.#

[[ACE-ccstart-definition]]
===== `ccstart`

`ccstart` is an XLEN-bit CSR that serves a similar role in ACE as `vstart` does in the V extension.

The instructions `ace.init`, `ace.import`, `ace.export`, `ace.input`, and `ace.output` may require significant execution time and can be interrupted mid-instruction by interrupts or memory exceptions.
In such cases, implementations may set `ccstart` to a non-zero value, enabling the instruction to resume from the interruption point rather than restart from the beginning.
Since ACE does not have the concept of the length of an element,
`ccstart` represents a byte offset rather than an element index as in `vstart`.
Specifically, a load-type instruction was interrupted after reading _and_ processing `ccstart` bytes of input in the state, and a store-type instruction was interrupted after computing and writing `ccstart` bytes of output.

[NOTE]
====
The `ccstart` value is given in bytes, even though payload sizes are always multiples of 8 bytes. This design accommodates piecewise execution via traps for the `ace.init`, `ace.clear`, `ace.export`, `ace.import`, `ace.input`, and `ace.output` operations, which involve `mv` operations at long-word, quad-word, or vector-register granularity, cf.{nbsp}<<ACE-trappable-insns-support>> for more details.
This is also compatible with the fact that `ace.size` returns a size in bytes.
====

Like `vstart`, `ccstart` is a standard read/write CSR; however, software must not write arbitrary non-zero values to it.
Normally, hardware sets this register on trap.
Software may safely write 0 to restart operations completely, and the register can be saved and restored during context switches.
Writing an arbitrary non-zero value may raise an illegal-instruction exception, as hardware is not required to support all values.
If no exception is raised and an invalid value is written, authentication will fail upon import because portions the content are replaced with arbitrary values, or exports will produce unauthenticatable output.  Only `ace.init` may still create a valid context, but since the key values were already in plaintext within the same domain, this does not expand the attack surface.

Only the instructions explicitly mentioned above support non-zero `ccstart` values; other ACE instructions ignore this register, and will be restarted.

[[ACE-why-restarting,Remark {counter:remark}]]
*Remark {counter:remark}.*
_A single `ccstart` value suffices due to the authenticated encryption algorithm used. The operations behave as follows:_

* `_ace.init_` _is a single-pass operation: the metadata section is read first, determining the payload length. If sufficient memory is available, subsequent blocks are read sequentially and passed to a deserialization circuit to populate the CC._
* `_ace.import_` _operates similarly to `ace.init`: the metadata section is read first to determine the payload length. If sufficient memory is available, the remaining blocks are read, decrypted, and passed to a deserialization circuit to populate the CC._
* `_ace.export_` _involves two passes, but the first pass is entirely internal to the ACE unit. Hence, the first pass cannot cause a page fault, and is easily restarted. Specifically, it computes the SIV by applying POLYVAL to the serialized CC content. Subsequently, the serialized metadata, the nonce, and the SIV are written out, followed by the CC content serialized, encrypted and written out block by block. It is this last part that may cause page faults, and that may require resumption._

_Although these operations are inherently complex, the ACE unit is architected to function like a separate machine executing simpler instructions sequentially. State machines (one per CPU hart connected to the ACE unit, potentially in a 1-to-1 configuration) receive commands from the CPU and break them into smaller steps._

_Therefore, separating data transfer from cryptographic operations in import/export is unnecessary. Otherwise, the loaded payload would need to be stored within the ACE unit rather than processed inline with minimal overhead, and this may lead to higher internal resource requirements_

_Finally, resuming requires at least as many cryptographic operations as restarting if the trapped domain also saves and resumes partial SCCs. Memory accesses may be reduced, but since data read from memory initially (for `ace.init` or `ace.export`) may no longer reside in the caches, resuming may offer better performance on some systems. Additionally, resuming avoids potential circular page-fault issues, as opposed to restarting._

[.red]#*TBD* Specify the exact semantics of `ccstart` and define the points at which various operations can be interrupted.#

===== Reuse of ASID and VMID (to be verified).

We reuse the CSRs for `ASID`, resp., `VMID`
(i.e., the CSR fields `satp`.ASID and `hgatp`.VMID).
to give only certain User processes and Supervisor processes access to certain key spaces.
The maximal bit length of `ASID` is 9 for Sv32 addresses or 16 for Sv39, Sv48, and Sv57 addresses.
The maximal bit length of `VMID` is 7 for Sv32x4 or 14 for Sv39x4, Sv48x4, and Sv57x4 addresses.
In the metadata section, `ASID` and `VMID` are always zero padded to the maximal lengths of 16 and 14 bits, respectively.

[.red]#However, we need a mechanism to make sure that if the system is not configured to insert `ASID`, resp., `VMID` into the GVAs/GPAs, we can still usage them for the purpose of policing the usage of CCs.#

[[ACE-providing-keys,Remark {counter:remark}]]
*Remark {counter:remark}.* _The software in each World/Supervisor Domain is normally responsible to generate or obtain their own keys, and if a process (applet) in one World/Supervisor Domain is responsible to provide keys to other Worlds/Supervisor Domains, it is the responsibility of the MM to perform an appropriate sequence of import, switch the CTK, then export operations._

====== ACE field in `misa`

The `misa.ACE` field uses bit `L` (11) to indicate that the ACE extension is implemented.
//This bit is chosen because the extension goes _beyond_ the cryptographic extension, which will likely use bit `K` (10).

====== `macerctk`

If the RCTK can be programmed, it can only be programmed by M-mode.
For this purpose, we use eight 32-bit WARL CSRs in RV32 and four 64-bit WARL CSRs in RV64.
The CSRs are: `macerctk0`, `macerctk1`, `macerctk2`, and `macerctk3` in RV64, to which we add
`macerctk4`, `macerctk5`, `macerctk6`, and `macerctk7` in RV32.
Bits [(_i_+1) XLEN - 1 : _i_ XLEN] of the RCTK are written to `macerctk{i}`.

Attempting to access the `acerctk` block outside of MM will cause an illegal instruction exception.

NOTE: Discoverability of whether the RCTK can be configured or not is not critical, since this is information known by the MM firmware.
[.red]#We can use the data structure pointed by `mconfigptr` in order to track optional features of ACE including whether the `acerctk` CSR block is implemented, and if not whether whether the value is ephemeral or fixed.# +
 +
User mode, and even operating systems and hypervisors, need not be aware of the `acerctk` block. Other mechanisms could have been chosen to program the CTK, such as an MM-exclusive dedicated hardware interface or memory-mapped interface.

NOTE: Mechanisms for persisting Root Context Transport Keys (RCTKs) across reboots or transferring them between devices are outside the scope of the present ACE architecture. These are system-specific and belong to MM firmware. For cross-device migration, the use of a public-key key-encapsulation mechanism (KEM) is recommended.


====== Re-configurable Localities

Two groups of CSRs, only accessible and programmable by MM, are used for two reconfigurable Localities (cf.{nbsp}<<ACE-concepts>>).
These are:

* CSRs `mace_OS_Secret0` and `mace_OS_Secret1`, to configure the "OS_Secret" entry in RV64, to which RV32 adds `ace_OS_Secret2` and `ace_OS_Secret3`.
* CSRs `mace_Boot_Session0` and `mace_Boot_Session1`, to configure the "Boot_Session_Secret" entry in RV64, to which RV32 adds `ace_Boot_Session2` and `ace_Boot_Session3` (cf.{nbsp}<<ACE-Localities>>).

Bits [(_i_+1) XLEN - 1 : _i_ XLEN] of the "OS_Secret", resp., "Boot_Session_Secret", are configured by writing to `ace_OS_Secret{i}`, resp. `ace_Boot_Session{i}`.

[NOTE]
====
The reason `ace_Boot_Session*` must be reconfigurable is that it must change in a VM if the latter's virtual hardware is re-booted, and this can happen independently from the underlying host and other VMs. For instance, a VM may be frozen, then the host may be rebooted, and then the VM may be resumed, in which case no boot session occurred in the VM, while it happened in the host hardware.

User mode, and even operating systems and hypervisors, need not be aware of the `mace_OS_Secret{i}` and `mace_Boot_Session{i}` blocks. Other mechanisms could have been chosen to program the "OS Secret" and  "Boot Session" entries, such as an MM-exclusive dedicated hardware interface or memory-mapped interface.
====

[[ACE-data-structures]]
==== Data Structures

ACE defines two distinct representations of cryptographic information: the CC configuration format, and the encrypted, authenticated SCC format. These two  formats are architected for software portability and interoperability.
//, enabling virtual-machine migration across heterogeneous hardware—for example, between cloud or consumer devices with CPUs from different vendors.
The internal CC representation, on the other hand, is implementation-specific.

All data formats are little-endian.

[[ACE-metadata]]
===== Metadata Section Format

The metadata section is 64 bits long and its format described in <<ACE-metadata-standard>>.
This format is used for CC initialization, export and import purposes.
The internal representation is implementation specific.


[[ACE-metadata-standard]]
.Format of the Metadata Section
[width="100%",cols=">9%,^7%,17%,67%",options="header"]
|===
|   Field | Width | Name                  | Description
|   [0:0] |   1  | Format                 | 0 for the current metadata format. +
Future format will have a 1 in this position and may be longer than 64 bits.
|   [1:1] |   1  | Is_Placeholder         | 1 if this is a placeholder for a CC. +
[.red]#Semantics TBD: In this case bits [63:2] are used as an identifier/address for the parent environment to solve the issue, content is empty, and SW will trap when trying to use this CC in any operation.#
|   [9:2] |   8  | Algorithm              | Algorithm (such as primitive or mode). 0 means the CC is invalid.
| [11:10] |   2  | SC_Protection          | Level of Side Channel Protection, encoded as per <<ACE-SC-protection-levels>>.
| [13:12] |   2  | Direction_Policy       | Determines whether the CC may be used for encryption (bit 11 set), decryption (bit 12 set), or both (bits 11 and 12 set).
Valid only for encryption/decryption primitives or modes, and ignored, for instance, for hash functions.
| [15:14] |   2  | Key_Type               | By explicit value / Immutable (index) / Internally generated.
| [17:16] |   2  | Completion             | Defined in <<ACE-CC-complete>>.
Used to determine whether an operation must be restarted.
| [21:18] |   4  | Stage (also Direction) | Encoding the current state of the state machine of the algorithm as a number (also called the "stage" of the algorithm).
The value must be zero in the initialization data, but, internally, it can be changed immediately by the algorithm.
If the algorithm encoded in the CC has at most 16 states
(including _initial_, _completed_, and _invalidated_, cf. <<ACE-stage-constants>>), then this number is stored in this field, cf. <<stage-field>>,
otherwise an algorithm-specific representation is used in the content, and this field only admits the values 0 (initial), 14 (invalidated), 15 (completed) or 1 (anything other operational state). The values must conform to <<ACE-stage-constants>>.
| [25:22] |   4  | Locality               | Field which is either -1 or an index into the Locality Secrets Table.
| [29:26] |   4  | UC_Policy_1            | "UC Policy" means "Usage Control Policy". +
Disallow the _usage_ of this CC in User, (Virtual) Supervisor, Hypervisor, resp., MM if bit 26, 27, 28, resp. 29, is set. Cf. <<stage-no-H-no-VMID>>.
| [31:30] |   2  | UC_Policy_2            | If bit 30, resp., 31, is set, then restrict the usage by `ASID`, resp., `VMID`. Restriction by `ASID` ignored if in S Mode or higher. Cf. <<stage-no-H-no-VMID>>.
| [47:32] |  16  | UC_Policy_3            | Zero if bit 30 unset, else `ASID` to enforce.
| [63:48] |  16  | UC_Policy_4            | Zero if bit 31 unset, else `VMID` to enforce. Cf. <<stage-no-H-no-VMID>>.
|===

NOTE: Bit "Is_Placeholder" is used to implement lazy loading of contexts.
If any operation (except `ace.export` and then `ace.import`) is attempted on a CC with this bit set, the operation is trapped to allow
the parent software to load the context, possibly freeing other contexts in order to make room for the new context.
While this feature is not strictly necessary in normal use, it is indispensible when migrating a VM to a new device where the ACE unit has a smaller CF.
In turn, this allows system software to implement lazy loading for all context, if desired.

Algorithms are encoded in a 8 bit field.
A zero in the algorithm field means the CC is invalid.
Algorithm numbers 1-191 are architecture-defined and the list of such encodings is maintained by RVI.
See <<ACE-Algorithms>> for the currently encoded algorithms.
Algorithm numbers 192-255 are reserved for custom algorithms.


[[ACE-SC-protection-levels]]
.Encoding of Side-Channel Protection levels
[float="center",align="center",width="76%",cols="^8%,<68%",options="header"]
|===
| Value | Description
|   0   | No protection.
|   1   | Data independent timing, first-order threshold implementation.
|   2   | Data independent timing, first-order threshold, fault tolerant implementation.
|   3   | Custom, algorithm dependent.
|===

Custom algorithms may offer stronger side channel protection guarantees than those specified in the encoding values 0 to 2.
In such a case, the value of the SC_Protection field must be set to 3.

[[ACE-key-type]]
.Encoding of Key Type
[float="center",align="center",width="76%",cols="^8%,<68%",options="header"]
|===
| Value | Description
|   0   | Explicit value.
|   1   | Internal table. System specific. For each algorithm as specified in <<ACE-Algorithms>>, the part of the content that normally contains the key(s) is replaced by a 64-bit value which is an index into the internal System Keys Table (SKT) --- for both Configuration Input and the SCCs. The actual value of the key is never included in exported content. For threshold algorithms, ACE may copy the key material from the SKT into the CC and expand it into multiple shares.
|   2   | Internally generated key. System specific.  In the Configuration Input, the part of the content that normally contains the key(s) is replaced by a "recipe" in a system-specific format. The format is not specified by the ISA and may not be portable to other systems. Once the key material has been internally generated, the value is included in the SCC as part of the content - not the "recipe" - as for any other key(s) for the same specified algorithm.  Even in the SCC, however, the Key_Type field of the metadata, both in the CC and in an SCC, will keep the value 2.
|   3   | Invalid.
|===

[[ACE-CC-complete]]
.Encoding of Completion field
[float="center",align="center",width="58%",cols="^8%,<50%",options="header"]
|===
| Value | Description
|   0   | No `ace.init`, `ace.input`, `ace.output`, `ace.import` or `ace.export` operation currently incomplete.
|   1   | `ace.init`, `ace.input`, or `ace.output` was interrupted.
|   2   | `ace.import` was interrupted.
|   3   | `ace.export` was interrupted.
|===

NOTE: The information in the Completion field is in principle known to the system software/firmware stack, we duplicate it into the metadata to ensure that it remains accessible after nested interrupts, i.e., after switching partially configured/imported or exported CCs in or out. While authentication also guarantees the integrity of the SCCs and of their import, this is both a robustness measure and serves to simplify system stacks.

[[stage-field,Remark {counter:remark}]]
*Remark {counter:remark}.* _The "state" field accommodates modes of operation with a small number of states.
For algorithms with more complex state machines, machine state information can be stored in a custom data section of the CC._

[[stage-no-H-no-VMID,Remark {counter:remark}]]
*Remark {counter:remark}.* _If the H extension is not enabled, bit 28 must be set to 1, and bits 31 and [63:48] must be set to 0.
The "UC_Policy_4" field is 16 bits long for compatibility with architectures employing 16-bit `VMID` fields (for instance, in heterogeneous systems).
While interoperability cannot be guaranteed when this policy is used, this ensures that the two top bits are not used for other purposes. +
Filtering usage by Supervisor Domain or World ID is not supported, and not only because of lack of space in a 64-bit metadata section:
Reconfiguring the RCTK is a better approach for such isolation requirements, whereas isolation by `ASID` and `VMID` is a weaker security feature._

[[ACE-Localities]]
===== Localities

Internally, ACE keeps a table of 128-bit Locality Secrets (LS), the Locality Secrets Table (LST).
Some of these entries are fixed, other values may be configurable only using an implementation-specific authenticated hardware procedure, and the remaining may be programmed by MM (*Note:* _we need to define the corresponding CSRs_).
The LST is a global table shared across all ACE units with some fields which can be MM-programmed and are architectural (i.e., per hart).

If the Locality Field of a context (CC/SCC) is -1 (all ones), then the RCTK is used.
Otherwise, this value is used as an index _i_ in the HST, and a derived key computed from RCTK and LST[_i_] is used for import/export in place of the RCTK.
The encryption and authentication keys are then derived from the DCTK.

In <<ACE-locality-indexes>>, we list the mandatory entries.
Column "MM-Config." indicates whether MM may be allowed to configure the entry.
We also specify the domain of each Locality Secret, i.e., whether the value is
chip-wide (should be the same across all chiplets in the same SoC, two distinct SoCs the same decide may have different values),
device-wide, or (usually) OS-wide.

[[ACE-locality-indexes]]
.Mandatory Locality Values
[width="100%",cols="25%,48%,^9%,^9%,^9%",options="header"]
|===
.>| Name .>| Description .>| Domain | MM-Config. .>| Value +
(Index)
| No Locality binding       | No CTK derivation. CC bound to Root CTK only. | -- | -- | -1 (15)
| Chip_Manufacturer_Secret  | Identifies the manufacturer of the SoC. Permanent. | SoC | N | 0
| Chip_Model_Secret         | Identifies specific chip model/family. Permanent. | SoC | N | 1
| OEM_Secret                | Provisioned by OEM to differentiate their products from the competition.
                              Can be permanent in a device — optional reconfiguration using impdef HW authenticated mechanisms. | Device | N | 2
| Product_Secret            | Identifies device/system type/model (product). Not necessarily permanent. Reconfigurable like OEM_Secret. | Device | N | 3
| Device_Secret             | Unique device (entire system) secret (not the device ID such as a serial number, but it can be derived from it, for instance by hashing). Shared across all harts in a Soc and shareable across multiple SoCs in a single device. Sharing mechanism impdef, i.e., not architected. Reconfigurable like OEM_Secret. | Device | N | 4
| OS_Secret                 | Identifies Operating System (or System Stack).
                              Not permanent, must be configured during (virtual) boot. | OS | Allowed | 5
| Boot_Session_Secret       | Regenerated at each (virtual) boot. | OS | Allowed | 6
| Reserved                  | Reserved for future use (RZ if not defined). | Impdef | Impdef | 7-14
|===

The constant Localities_MAX is the maximum number of Localities supported by the system.

NOTE: MM is responsible for virtualizing the OS_Secret and Boot_Session_Secret Locality Secrets.

*Example*: _If a key's metadata specifies a Locality field value of "2", the key for import/export operations is derived from the RCTK and the "OEM Secret".
Consequently, while `ace.export` remains functional on the same device to support context switching, an `ace.import` of the resulting SCC on a device from a different OEM will trigger an authentication failure (provided that the OEM Secrets are, in fact, different)._

NOTE: _A CC may reference a key via an index into the system-defined System Key Table (SKT).
A device-specific SKT entry may correspond to a different key on another device, leading to unspecified behavior.
Consequently, implementations of the STK must provide appropriate Locality metadata to the ACE unit during CC configuration, verify compatibility between the key's policies and the user's request, and enforce stricter policies if necessary._

[[ACE-formats]]
===== Formats of Configuration Inputs and Sealed Configuration Contexts

The formats of the configuration payload, of the content section, and of SCCs
depends on the algorithm being used.
Each algorithm must provide following functions:

* `metadata_serialize(CC) -> byte array`: Serializes the internal metadata into a 64-bit block for export.
* `metadata_deserialize(CC,byte array) -> CC.metadata`: Takes a metadata block formatted as described in <<ACE-metadata>> and deserializes it to the internal representation of the metadata section.
* `initial_content_deserialize(CC,byte array) -> CC.content`:
Reads the information provided to `ace.init` as the byte array that follows the metadata, and deserializes it for the internal representation.
It must be the same as the format used for the SCC except for some omitted fields.
* `content_serialize(CC) -> byte array`: Serializes a CC's content to a byte array to be encrypted for export.
* `content_deserialize(CC,byte array) -> CC.content`:
Takes the decrypted byte array, that comes after the metadata, nonce and authentication tag, and deserializes it into a CC's content.
The format depends on the algorithm which is specified in metadata information.

The size of a SCC, and of all byte arrays read or written by the above five functions, must be a multiple of 8 bytes.
See <<ACE-Algorithms>> for algorithm-specific details on the inputs and outputs of these functions.

Format of Configuration Input:::
The format of the input to `ace.init` is simple.
The first 8 bytes must contain the 64-bit metadata section as specified in <<ACE-metadata>>,
followed by the content, i.e., the key(s) and possibly other information, to be passed to `initial_content_deserialize`.

Plaintext Format of SCC:::
`bytes 0..7  {nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}` contain the 64-bit metadata section, +
`bytes 8..19  {nbsp}{nbsp}{nbsp}{nbsp}{nbsp}` contain the nonce (96 bits), +
`bytes 20..31  {nbsp}{nbsp}{nbsp}{nbsp}` contain the SIV (96 bits), and +
`bytes 32..u+31  {nbsp}{nbsp}` contain `content_serialize(CC.content)`, which has a byte length of `u`.
+
Only the serialization of the content is encrypted, while both metadata and content are included in the computation of the authentication tag, as described next.

//

To describe the authenticated encryption of a SCC, we first define the RFC8452 Key Derivation and the DCTK Derivation functions.

.RFC8452 Key Derivation
[source,sail]
----
function RFC8452_KeyDeriv(K) = {
  struct {
    AESE256(K, (0[125:0] @ 0b101))[63:0] @ AESE256(K, (0[125:0] @ 0b100))[63:0] @
    AESE256(K, (0[125:0] @ 0b011))[63:0] @ AESE256(K, (0[125:0] @ 0b010))[63:0],
    AESE256(K, (0[125:0] @ 0b001))[63:0] @ AESE256(K, (0[125:0] @ 0b000))[63:0]
  }
}
----

.Derived Key Derivation
[source,sail]
----
function DCTK_KeyDeriv(K,L) = {
  AESE256(K, L ^ (0[125:0] @ 0b011))[63:0] @ AESE256(K, L ^ (0[125:0] @ 0b010))[63:0] @
  AESE256(K, L ^ (0[125:0] @ 0b001))[63:0] @ AESE256(K, L ^ (0[125:0] @ 0b000))[63:0]
}
----

<<<
We can now define the generation of the SCC from a CC.

.Generation of the SCC from a CC
[source,sail]
----
metadata : bits(64);
last_block_fractional : boolean;
content : array[num_blocks] of bits(128); // last block is zero-padded
                                          // if last_block_fractional = true
M : array[num_blocks+2] of bits(128);
let N : bits(96) = random(96 bits);
Kenc : bits(256);
Kauth : bits(128);

if (metadata.Locality == 15) then {
    CTK = RCTK;
} else {
    CTK = DCTK_KeyDeriv(RCTK, LST[metadata.Locality]);
}

{Kenc, Kauth} = RFC8452_KeyDeriv(CTK);
let T : bits(96) = POLYVAL(Kauth, metadata @ content
                                           @ IntTo64Bits(64)
                                           @ IntTo64Bits(len_in_bits(content)))[95:0];
let SIV : bits(96) = AESE(Kenc, 0 1b0 @ ((T xor N)[126:0]))[127:32];

M[0][127:0] = N[63:0] @ metadata[63:0];
M[1][127:0] = SIV[95:0] @ N[95:64];
if (last_block_fractional) then last = num_blocks - 1 else last = num_blocks - 2;
foreach(i from 0 to last) {
    M[i + 2][127:0] = content[i] xor AESE(Kenc, 1 @ SIV[94:0] @ (binary(i)[31:0]));
}
if (last_block_fractional) then {
    M[last + 1][63:0] = content[last + 1]
                        xor AESE(Kenc, 1 @ SIV[94:0] @ (binary(last + 1)[31:0]))[63:0];
}
----

NOTE: Due to the computational cost of the derivation functions, implementations may
cache recently used derived keys for both the Root RCTK and Locality-derived keys.

//NOTE: This simplification of AES-GCM-SIV does not require appending the lengths
// of metadata and content to the hash, as these lengths are already implied by the
// cleartext bits of the metadata, which are included in the authentication tag computation.

NOTE: Certain format details are fixed across algorithms. All pure ciphers use a single
key, regardless of whether they employ a normal or threshold implementation; threshold
implementations are always reduced to a single key. Some modes follow the same convention,
while others require algorithm-specific state formatting.

// The total output length must be a multiple of 64 bits. If the combined metadata and
// content do not meet this requirement, the final block is zero-padded.

// ///////////////////////////////////////////////////////////////////////////////////////////


=== Supported Algorithms

[.red]#Add algorithm numbers!#

We architect support for several algorithms, and also define a minimal subset (current suggestion):

* AES-128 and AES-256 encryption and decryption.
* AES-CTR, AES-GCM, AES-GCM-SIV, AES-XTS using AES-128/256.
* AES-CMAC using AES-128/256.
* SHA-2, SHA-2-HMAC.

The list of other architected algorithms is TBD, but it must include at least

* AES-192, alone and with the above modes.
* SM4 Block Cipher.
* The Ascon suite (Ascon-128/128a-AEAD, Ascon-Hash, Ascon-XOF, Ascon-80pq).
* SHA-3, SHA-3-HMAC.
* SM3 Secure Hash.

// ///////////////////////////////////////////////////////////////////////////////////////////


=== Instructions

We now give detailed descriptions of the instructions, including their semantics and encoding.

NOTE: Instructions `ace.init`, `ace.import`, `ace.export`, `ace.input`, and `ace.output` perform direct memory accesses.
This does not violate the RISC-V load/store architecture principles, as ACE is architected to behave like an _attached_ unit, which may have its own interfaces.

NOTE: The encodings presented here are just examples, and may not be final.
They serve as a starting point for discussion and refinement as
well as a proof that, at the time of this writing, the ACE instruction set
can be encoded.

NOTE: ACE is an ideal candidate for the Composable Custom Extensions framework,
even though our aim is to make it into a ratified extension.

[[ACE-instruction-enable-enable]]
==== ace.enable/ace.enable

`ace.enable` +
`ace.disable`

Description::
Enable/Disable the feature in the current process domain and (*TBD* determine
how many contexts we need).
`ace.enable` must be issued before using any ACE operation.
This is a pseudo-operation implemented as a write to a WARL CSR.
See <<ACE-CSR-enable>> and <<ACE-ACES-field>> for more details.

[[ACE-instruction-init]]
==== ace.init

`ace.init Cd|C[Xd], %offset(Xs)`

Encoding::
`ace.init` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Cs','C[Xd]'] },
    { bits:  3, name: 'ace.init', attr: [0x4,0x5] },
    { bits:  5, name: 'Xs' },
    { bits: 12, name: 'imm', attr: ['offset'] },
]}
....

Description::
`ace.init` configures a CC with metadata and content.
`Cd` is the source CC to be configured (encoded as a 5-bit immed).
`Xd`, alternatively, is a GPR containing a number from 0 to 31 to select the context
to be configured.
`Xs` points to the region of memory containing the metadata and the key material.


NOTE: The operation can be conceptually split into two phases.
In the first phase, the metadata
block is read, which determines the length of the remaining information.
Then, in the second phase, the configuration material is read and processed.

// [.red]#(TBdetermined whether it is secure)# This instruction is trappable and may also be resumed or restarted.

[[ACE-instruction-clear]]
==== ace.clear

`ace.clear Cd|C[Xd]`

Encoding::
`ace.clear` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Cs','C[Xd]'] },
    { bits:  3, name: 'ace.clear', attr: [0x6,0x7] },
    { bits:  5, name: 0x0 },
    { bits: 12, name: 0x0 },
]}
....

Description::
`Cd` is the source CC to be cleared (encoded as a 5-bit immed). +
`Xd` alternatively, is a GPR containing a number from 0 to 31 to select the context to be cleared. +

[[ACE-instruction-export]]
==== ace.export

`ace.export %offset(Xd), Cs|C[Xs]`

Encoding::
`ace.export` is an S-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'imm[4:0]' },
    { bits:  3, name: 'ace.export', attr: [0x0,0x1] },
    { bits:  5, name: 'Xd' },
    { bits:  5, name: 'context', attr: ['Cs','C[Xs]'] },
    { bits:  7, name: 'imm[11:5]' },
]}
....

Description::
Exports the CC `Cs` or `C[Xs]` to memory, starting at address `Xd`, using
the procedure described in <<ACE-formats>>.
If the context `Cs` is clear, or `Xs` is out of range,
the operation will report error ace_err_invalid.

The instruction must be resumable in case of interrupts.
Similarly to entire-vector-register store instructions, `ace.export` appears to other harts as
sequences of individual stores.

[[ACE-instruction-import]]
==== ace.import

`ace.import Cd|C[Xd], %offset(Xn)` +
`ace.import.S Cd|C[Xd], %offset(Xn)`

Encoding::
`ace.import` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Cd','C[Xd]'] },
    { bits:  3, name: 'ace.import', attr: ['0    0    S','0    1    S'] },
    { bits:  5, name: 'Xn' },
    { bits: 12, name: 'imm' },
]}
....

Description::
`Cd` is the destination CC to be imported, as an immed (5-bit). Alternatively,
the number of context into which import the SCC is stored in the GPR `Xd` as a
number from 0 to 31. `Xn` is the GPR containing the base address of the buffer
with the SCC. +
The bit S takes the values 0 (false) or 1 (true).
It is set to true if the key is in a system defined format
(`ace.import.S`)
and not the format defined by the present architecture
(`ace.import`).

The instruction must be resumable in case of interrupts.
Similarly to entire-vector-register load instructions, `ace.import` appears to other harts as
sequences of individual loads.

NOTE: The operation can be conceptually split into two phases.
In the first phase, the metadata
block is read, which determines the length of the remaining information.
Then, in the second phase, the rest of the SCC is read and processed.

NOTE: There is no further specification as to
what the system defined format is in the encoding of the instruction, and in
case more than one system defined format is defined, the data format itself
must distinguish between them.  In other words, it is the responsibility of
the system to augment all the system defined formats with a unique identifier
that can be used to distinguish between them. +

NOTE: The `ace.export` instruction does not have a `ace.export.S` analogue of `ace.import.S`.
This means that system HW dynamically generated keys can be imported but not
exported in the same form: they must be exported in the format architected in
this specification.

// If the value cannot be transported to other devices or to
// other Locality states of the same device, the internal logic must bind them to a
// specific DCTK). The instruction imports them like software keys and sets
// the appropriate policies.

// [.red]#(TBdetermined whether it is secure)# This instruction is trappable and may also be resumed or restarted.

[[ACE-instruction-exec]]
==== ace.exec

The instruction admits four Forms, namely

[upperalpha]
. `ace.exec  Vd, Cn|C[Xn], Vs` {nbsp}{nbsp} takes an input vector and writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}{nbsp}Cn|C[Xn], Vs` {nbsp}{nbsp} takes an input vector but does not write to an output vector.
. `ace.exec  Vd, Cn|C[Xn]{nbsp}{nbsp}{nbsp}{nbsp}` {nbsp}{nbsp} does not take an input but writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}{nbsp}Cn|C[Xn]{nbsp}{nbsp}{nbsp}{nbsp}` {nbsp}{nbsp} does not take an input vector and does not write to an output vector.

Form D instructions perform internal processing only in the CC.

// Without this comment, the next part is not properly formatted...
Encoding::
`ace.exec` is an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Vd', attr: ['rd'] },
    { bits:  3, name: 'ace.exec' },
    { bits:  5, name: 'Cn|C[Xn]', attr: ['rs1'] },
    { bits:  5, name: 'Vs', attr: ['rs2'] },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....
+
Bit `r` (i.e., bit 27) takes the value 0 if the context is encoded as an immediate,
and it takes the value 1 if a GPR (scalar integer value) is used to reference it.
For the four Forms A-D above, the encodings are:
+
[upperalpha]
. `ACE.exec` = `0b000`.
. `ACE.exec` = `0b001` and `rs2`=`0b00000`.
. `ACE.exec` = `0b010` and `rd`=`0b00000`.
. `ACE.exec` = `0b011` and `rs2`=`rd`=`0b00000`.

NOTE: We admit variants of Forms B and D, which we call Form B', resp., Form D',
with non-zero values in `rd`, resp., `rs2`, to encode additional instructions.

// To make indent in next line correct

Description::
Performs a cryptographic operation such as an encryption or decryption, absorbing a value in a hash, and possibly returning a value.

NOTE: In many algorithms, the successive stage is often implied by the operation
just performed. For instance, in AEAD algorithms, after setting an IV or a nonce,
one could argue that there is no need to explicitly move to the stage of absorbing
the associated data into the hash. However, to avoid inconsistency, we have chosen
to avoid implicit stage transitions, even if this could save a handful of instructions,
unless if strictly necessary. This can occur for security reasons, such as going to
hash finalization to hash verification states, or transitions to states such as
_completed_ or _invalidated_ (see <<ACE-stage-constants>> and <<ACE-Algorithms>>).

[[ACE-instruction-size]]
==== ace.size

===== Context Variant

`ace.size Xd, Cs|C[Xs]`

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus is an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x3, attr: ['ace.exec', '(Form D\')'] },
    { bits:  5, name: 'Cs|C[Xs]' },
    { bits:  5, name: 0x1, attr: ['ace.size'] },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....
+
Bit `r` (i.e., bit 27) is 0 if the CC is encoded as an immediate, and 1 if a GPR is used to reference it.

Description::
This instruction writes the size of the SCC corresponding to CC `Cs`, or the CC
whose number is in `Xs`) into GPR `Xd`, and zero if the algorithm is not supported.

Knowing the size of the SCC serves to properly implement any feature that
relies on `ace.export`, for instance context switching.

NOTE: The value can significantly differ from the internal resource usage ot the CC —
it can be larger (for simple primitives, because of the nonce/SIV overhead) but
also smaller (for keys split into shares for threshold implementations, but saved
externally in reconstructed form).

===== Metadata Variant

`ace.size Xd, Xs`

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus is an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x3, attr: ['ace.exec', '(Form D\')'] },
    { bits:  5, name: 'Xs' },
    { bits:  5, name: 0x2, attr: ['ace.size'] },
    { bits:  7, name: 0x0 },
]}
....

Description::
This instruction writes the size of a SCC having the metadata section given in `Xn` into GPR `Xd`, and zero if the algorithm is not supported.
Only the Algorithm and SC_Protection fields of the metadata section of a CC are considered.

[[ACE-instruction-available]]
==== ace.available

`ace.available Xd, Xs`

The instruction is an alias to the Metadata Variant of `ace.size`, as the latter returns zero if the algorithm is not supported.

[[ACE-instruction-clone]]
==== ace.clone

`ace.clone Cd|C[Xd], Cs|C[Xs]`

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus is an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Cd|C[Xd]' },
    { bits:  3, name: 0x3, attr: ['ace.exec','(Form D\')'] },
    { bits:  5, name: 'Cs|C[Xs]' },
    { bits:  5, name: 0x3, attr: ['ace.clone'] },
    { bits:  1, name: 0x0 },
    { bits:  2, name: 'R' },
    { bits:  4, name: 0x0 },
]}
....
+
Bits [27:26], i.e., field `R`, take following values depending on how the CCs are
referred:
+
[upperalpha]
. `0b00` if the source and the output CCs are both encoded as immediates.
. `0b01` if the source CC is selected using a GPR and the output CC is encoded as an immediate.
. `0b10` if the source CC is encoded as immediate and the output CC is selected using a GPR.
. `0b11` if the source and the output CCs are both selected using the values of GPRs.

// Comment to ensure the proper indentation in th next Description

Description::
Clones source CC `Cs` (or the CC indexed by `Xs`) into destination CC `Cd` (or
into the CC indexed by `Xd`).

// NOTE: The `ace.clone` instruction is an optimization for the sequence `ace.export` followed by `ace.import`. While reusing cryptographic state (e.g., encrypting with the same counter) can enable certain attacks, this risk cannot be eliminated by omitting `ace.clone`, as a state can be exported and re‑imported multiple times.

[[ACE-instruction-derive]]
==== ace.derive (optional)

`ace.derive Cd|C[Xd], Cs1|C[Xs1]` +
`ace.derive Cd|C[Xd], Cs1|C[Xs1], Vs2`

Encoding::
The encoding is a variant of Form A `ace.exec` encoding, and is thus is an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Cd|C[Xd]' },
    { bits:  3, name: 0x0, attr: ['ace.exec (Form A)'] },
    { bits:  5, name: 'Cs1|C[Xs1]' },
    { bits:  5, name: 'Vs2', attr: ['use for additional input','no additional input (zero field)'] },
    { bits:  1, name: 0x1 },
    { bits:  2, name: 'R' },
    { bits:  1, name: 'z', attr: [0x1,0x0] },
    { bits:  3, name: 0x0 },
]}
....
+
This encoding differs from Form A `ace.exec` by having bit 25 set to 1.
Bits [27:26], i.e., field `R`, is encoded exactly as for `ace.clone` (cf.{nbsp}<<ACE-instruction-clone>>).
Bit 28 determines whether an additional vector register (or register group) is used to pass a parameter to the key derivation mechanism or not.

Description::
The instruction is used to derive a new context from an existing one, with its own opaque key material.
It is similar to `ace.clone`, but the derived context is not a copy of the source context,
rather, it is a new context that is derived from it, for instance, through a key derivation mechanism.
This instruction can be used multiple times, to generate multiple derived contexts.


[[ACE-instruction-state]]
==== ace.state/ace.dir

`ace.state`/`ace.dir Cd|C[Xd], #immed7` +
`ace.state`/`ace.dir Cd|C[Xd], #immed7, Xs`

Encoding::
`ace.state`/`ace.dir` is an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Cd|C[Xd]' },
    { bits:  3, name: 0x4, attr: ['ace.state'] },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
    { bits:  5, name: 'Xs' },
    { bits:  7, name: 'immed7' },
]}
....
+
Bit `r` (i.e., bit 15) is 0 if the context is encoded as an immediate, and 1 if a GPR is used to reference it.

Description::
Two pseudo-instructions that map to the same instruction. +
`Cn` is the CC in which to set the stage (i.e., state number) of the internal state. +
`Xn` is a GPR containing a number from 0 to 31 to dynamically address the
context in which to change the stage of the internal state. +
The `#immed` is a constant from a set of admissible values that are defined for
each algorithm, to manage an internal state machine of said algorithm in case
more stages are needed. +
`Xs` is a GPR being either `X0` or containing an optional additional parameter for the state machine.

The state numbers defined in this specification are given in the table that follows.

[[ACE-stage-constants]]
.Constants defining CC states
[float="center",align="center",width="100%",cols="^6%,<29%,<65%",options="header"]
|===
| Value | Mnemonic                      | Examples
|   0   | ace_state_initial             | The context is initialized and ready for operation.
|   1   | ace_state_encrypt +
ace_const_operate
|  Encryption is requested. +
Algorithm is ready to process.
|   2   | ace_state_decrypt             | Decryption is requested.
|   3   | ace_state_hash_absorb         | Start (and initialize) a hash function or the sub-function of an algorithm, preparing it to absorb blocks of data.
|   4   | ace_state_hash_finalize +
ace_state_hash_finalize_enc             | Finalize the internal state of a hash function (including for the encryption algorithm of an for an authenticated encryption mode of operation) and prepare it for outputting the result. In this state additional data may be absorbed, such as lengths.
|   5   | ace_state_hash_finalize_dec   | Finalize the internal state of a hash function for the decryption algorithm an authenticated decryption mode of operation. In this state additional data may be absorbed, such as lengths.
|   6   | ace_state_hash_verify         | Finalize the internal state of a hash function and compare it to the provided value.
|   7   | ace_state_last_block_len   | For a hash or MAC function, the next `ace.exec` this is the length of the last block of data.
|   8   | ace_state_set_public_value    | Set a public value (like a nonce or an IV) in an algorithm. Some algorithms require more than one public value (for instance, they may admit a re-useable hash of some associated data and a unique nonce), in which case the second public value can be set using the next message.
|   9   | ace_state_set_public_value_2  | Set the second public value in an algorithm.
|  10   | ace_state_input_for_derive    | Tells the CC to expect additional information for feeding the `ace.derive` instruction.
|  14   | ace_state_invalidated         | The algorithm has abnormally terminated. `ace.error` will always return error code _ace_err_invalid_.
|  15   | ace_state_completed           | The algorithm has correctly completed.
|===

Algorithms that significantly differ from those we describe in <<ACE-algorithms>> and therefore cannot share the same software for their usage,
may reuse the same values in [1..13] with new constant mnemonics to define their own states.



[[ACE-instruction-restrict]]
==== ace.restrict/ace.harden

`ace.restrict   Cd|C[Xd], Xs` +
`ace.harden     Cd|C[Xd], Xs`

// Without this comment, the next part is not properly formatted...
Encoding::
The encoding uses `ace.exec` Form B', with bit 7 (which is in the `rd` field) set.
It is thus a variant of an R-type instruction.
The source register field encodes a GPR and not a vector register.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 0x1 },
    { bits:  3, name: 0x1, attr: ['ace.exec', '(Form B\')'] },
    { bits:  5, name: 'Cd|C[Xd]' },
    { bits:  5, name: 'Xs' },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....
+
If bit `r` (i.e., bit 27) is 0, the 5-bit destination field [11:7] contains the destination context number,
else it determines the GPR that contains the context number.

// comment

Description::
This instruction restricts the usage of a CC to specific modes or to a specified `ASID` or `VMID`. +
It can also increase the side-channel protection level of the CC. +
Let `m` be the metadata field in the destination CC. The instruction works as follows:

* Bits [10:9] and [63:25] of the input register `Xs` have the same format as the corresponding bits of the metadata.
* Bits [8:0], [24:11] and 31 of the input register `Xs` are ignored.
* Bits [10:9] can be used to turn on or increase the level of the side-channel protection of the algorithm in the CC, if the microarchitecture supports the corresponding implementation. The levels are defined in <<ACE-SC-protection-levels>>. Downgrading side-channel protection is not permitted, and attempting to do so will result in error ace_err_invalid (cf.{nbsp}<<ACE-error-values>>).
* A zero in any of the six bits `Xs`[30:25] means that the corresponding policy is not changed.
* A one in the any of the four bits `Xs`[28:25] means that usage by the corresponding mode is forbidden, and the corresponding bit in the metadata of the destination CC is set to 1.
* If `Xs`[29] is set and `m`[29] is NOT set, then Usage_Policy_3, i.e., `m`[47:32], is set to `Xs`[47:32].
* If `Xs`[30] is set and `m`[30] is NOT set, then Usage_Policy_4, i.e., `m`[63:48], is set to `Xs`[63:48].
* If `Xs`[29] and `m`[29] are both set and `Xs`[47:32] <> `m`[47:32], or if `Xs`[30] and `m`[30] are both set and `Xs`[63:48] <> `m`[63:48], then `aceerror` is set to ace_error_invalid.

[[ACE-instruction-input]]
==== ace.input (optional)

`ace.input Cd|C[Xd], %offset(Xs)`

Encoding::
`ace.input` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Cd','C[Xd]'] },
    { bits:  3, name: 'ace.input', attr: [0x4,0x5] },
    { bits:  5, name: 'Xs' },
    { bits: 12, name: 'imm' },
]}
....

// [.red]#(TBdetermined whether it is secure)# This instruction is trappable and may also be resumed or restarted.

[[ACE-instruction-output]]
==== ace.output (optional)

`ace.output  %offset(Xd), Cs|C[Xs]`

Encoding::
`ace.output` is an S-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'imm[4:0]' },
    { bits:  3, name: 'ace.output', attr: [0x4,0x5] },
    { bits:  5, name: 'Xd' },
    { bits:  5, name: 'context', attr: ['Cs','C[Xs]'] },
    { bits:  7, name: 'imm[11:5]' },
]}
....

[[ACE-instruction-error]]
==== ace.error

`ace.error Xd`

Description::
The ACE Unit may be in an error state due to the previous operation.
The corresponding error value is written into GPR `Xd`.
This is implemented as a read from CSR `aceerror`, which may cause the hart to wait if the error value is not yet available
(cf.{nbsp}<<ACE-CSR-ace-error>>).
The error value list is architected and given in <<ACE-error-values>>.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-trappable-insns-support]]
==== Support for Trappable Operations

Instructions `ace.init`, `ace.export`, `ace.import`, `ace.input`, and `ace.output` support arbitrarily long inputs and outputs.
To reduce hardware complexity, these operations can be trapped and emulated in software using custom instructions.

Upon a trap, the handler identifies the trapped instruction and uses the Algorithm field of the metadata block
`ace.size` to determine the size of the data to be transferred.

In order to support interrupts of the emulation libraries, such instructions need to respect the value of `ccstart` and update it in accordance with the expected architected behavior the trapped instructions.  We provide here non-normative definition for such a set of instructions in <<ACE-trappable-insns-support>>.
Three types of supporting operations are required:

 * A `mv` instruction that loads a specified number of bytes from a GPR or vector register into a CC within the ACE unit.
   Initially, `ace.size` returns the total payload length to transfer.
   After each move, this value is updated to reflect the remaining bytes.
   The instruction also updates the `ccstart` CSR to follow the internal progress.
 * A corresponding `mv` instruction that exports a specified number of bytes from a CC to a GPR or vector register.
   The behavior of `ace.size` will be similar to that of the move instruction, but it will count the number of bytes to be exported.
 * A “`close`” instruction to suspend or finalize the procedure.
   If executed before all bytes are transferred, the CC state matches that of an interrupted monolithic instruction, including the Completion metadata field and the `ccstart` value. If executed after all bytes are transferred, it also performs any final cryptographic operations, such as authenticating the CC, if needed.

These supporting instructions must be uninterruptible.

Furthermore, the initial cryptographic phase of `ace.export` and the authentication phase of `ace.import` must be uninterruptible as well.
Even if these parts are executed concurrently with other operations, the trap handler may need to wait for these steps to complete before proceeding with memory/move operations.

The support instructions are implementation-specific and not explicitly defined in the architecture.
However, interrupting the firmware implementation of `ace.init`, `ace.export`, `ace.import`, `ace.input` or `ace.output`
must leave the architectural state indistinguishable from the state expected from interrupting a monolithic implementation of the instructions.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-Algorithms]]
=== Data Formats and Instruction Semantics for Various Algorithms

In this chapter we specify the behavior of Cryptographic Contexts for various cryptographic algorithms.
Some of these specifications are generic in the sense that they apply to all algorithms of a certain type and can be instantiated with different primitives with varying parameters such as block and key sizes.
Others specifications, on the other hand, pertain to algorithms that are specific to certain cryptographic primitives.

NOTE: This chapter is normative because it defines the behavior of the instructions and the data formats they use.
For instance, since AES-GCM-SIV is one of the mandatory algorithms, its behavior is completely determined by the specification of <<ACE-GCM-SIV>>
where the block size is `b` = 128 and the key size `k` can be 128, or 256 bits.
The specification of GCM-SIV here also guarantees that all implementations of, say, SM4-GCM-SIV (with the binary field in Montgomery representation using the same polynomial as AES-GCM-SIV) would be able to interoperate.

Each algorithm is fully defined by the following information:

Parameters:::
These include:
* The block size, which is the size of the basic unit of information processed by the algorithm, usually the block size of the main underlying primitive;
* The key size, for keyed algorithms; and
* Any other parameter (for instance, counter size) that is necessary to instantiate the algorithm with specific primitives.

Data Structures:::
These include:

. *Configuration Input*:
The data following the metadata block in the initialization input to `ace.init`, such as keys and other required secrets.
Fields are listed in the order they appear in the configuration input, each with its length in bytes.

. *Content, Internal*:
Information that must be maintained in the internal state of a CC.
The fields are unordered, and their lengths in bytes may differ from those listed—for example, in threshold or fault-tolerant implementations where redundancy is added. Notably, the full single-share key size is listed even when a System Key is used, as this reflects the size of the key material the algorithm operates on.

. *Content, Exported*:
The data that follows the metadata block in the plaintext portion of the SCC, as serialized by the algorithm's `content_serialize` function. The fields are listed in the order they appear in the SCC, each with its length in bytes.

Generic Functions:::
If necessary, redefine generic functions that apply to all contexts.
Each algorithm must provide the functions described in <<ACE-formats>>.

Algorithmic-Specific Functions:::
Any other function that is specific to the algorithm.

State Machine:::
This includes:

. A list of *States* in which the internal state machine of the logic is executed, together with their representation, either as a number in the range [0..15] or by more complex structures. The values must conform to <<ACE-stage-constants>>.
. A complete list of the *Allowed State Transitions*, including the conditions under which each transition is allowed.
. The *Behavior* of all ACE instructions at each state.

We also add pseudocode to clarify how the algorithms supported by an ACE unit are implemented in software using the ACE ISA.

[[ACE-generic-rules]]
==== Generic Rules

For modes of operations that can be instantiated with different primitives, we specify more general rules, where the differences between instantiations in some cases are limited to the widths of the inputs and outputs of the primitive. If the primitive is a block cipher, then `b` is its block width in bits.

Recall that the architecture views a CC as a structure with two fields: the metadata (currently 64 bits), which has a unique specification, and the content (variable length), which is algorithm-specific.

In the descriptions of the algorithms below, we do not need to redefine these two functions if they are not changed, i.e., if there are no changes to the metadata format.

If the number of states of the algorithm is at most 16 (including _initial_, _completed_, and _invalidated_),= the `stage` of the metadata is used to store this value.
Otherwise, the specification of the algorithm must include a suitable field in the content section of the CC/SCC.

An important rule is the following.
If an invalid input is provided to any ACE instruction, or a non-admitted instruction is executed, while processing the algorithm in CC, say, Cn,
the `Cn` is *invalidated*, namely, the following happens:

* `Cn` is put into state _invalidated_;
* For instructions that refers to `Cn`:
 ** any form of `ace.exec` performs no operation and, if it provides an output, the latter is always zero;
 ** `ace.clone` and `ace.derive` clean the destination contexts;
 ** `ace.restrict` and `ace.harden` perform no operation;
 ** `ace.input` and `ace.output` perform no operation;
 ** `ace.state` perform no operation, unless is is used to return to state _initial_;
 ** `ace.error` always returns error _ace_err_invalid_ after any operation involving the CC except for
    `ace.import` and `ace.export`, `ace.clean`, `ace.init`, and `ace.size`, which all work normally, and using `ace.stage` to return to state _initial_.

The function that puts the CC in this state is called `invalidate()`.

In state _completed_, no operation can be performed except `ace.init`, `ace.export`, `ace.import`, `ace.clear`, or `ace.error`.
Any other operation, if it has an output, it returns zero, and will cause the CC to be *invalidated*.

All the operations performed by `ace.exec` or `ace.state` in the rules given for each algorithm are assumed to be *uninterruptible*.
This includes the case where very long vector inputs are processed but all operations are completely internal to ACE and require no external resource access, such as encryptions, decryptions, hashing, point multiplications, and other cryptographic operations.
Since such operations can operate independently of the CPU core, they may continue to execute also when the process that issued them is interrupted, so the hart implementation may cause the context switching software to wait when accessing a CC that is going to be written to.
We do not specify whether these instructions write their results to the CC atomically or piecewise.
[.red]#(Only in case we still want to make long cryptographic operations interruptible.)#

In what follows, when we write of "state _name_" we refer to the state which has number _ace_state_name_ as described in <<ACE-stage-constants>>.

The rules from <<ACE-ECB-mode>> to <<ACE-CMAC>> can be instantiated, like the modes that they describe, with a variety of block ciphers and polynomials for GHASH- or POLYVAL-like hashes, where only the block and key sizes are needed to get a full specification.

On the other hand, the specifications from <<ACE-hash-functions>> to <<ACE-Ascon>> are in general heavily primitive dependent.

[[ACE-rules-threshold-implementations]]
==== Rules for Threshold implementations

Any CC with its algorithms implemented as threshold implementation will always initialize, import and export _all_ its keys and secrets as _single_, _reconstructed_ _shares_.
The Configuration and SCC Formats will be the same as for the non-threshold implementations variants of the same algorithm, with the only difference being the value of the Side Channel Protection bits in the metadata.
For the purpose of architecture specification, all values are also always represented as a single share in this document.
Threshold implementations are simply implementation variants of the exact same algorithm.

NOTE: This assumes that reconstructing a key or re-randomizing it are fast operations, such as ``xor``s with random values.
This in turn implies that ACE execution unit must have access to a source of randomness, or at least a PRNG that is seeded at hardware boot.

This ensures not only the compactness of a SCC, but also that the key can be ported across architectures.
In fact, some threshold implementations may have a different number of shares even if they claim the same order of side-channel protection.

[[ACE-rules-system-keys]]
==== Rules for System Keys

System keys that are referred to by an index will cause following changes in all the algorithms described in what follows:

. In the configuration input and in the SCC, the key/main key field will contain the index of the key in the SKT in place of a key value.
. This field is always a 64-bit value, even if the key itself is larger. This saves space in the SCC and allows for faster export and import operations.
. For algorithms that require more than one key, such as XEX/XTS, ALL the keys are referred to by a single index, i.e., a single 64-bit value in the configuration input and the SCC.
. Accordingly, the `content_serialize` and `content_deserialize` functions will support System Keys by producing and reading the shorter fields with the indexes in place of the longer fields that would be required when the key values are explicitly provided.

NOTE: Internally, the ACE unit can either directly use the value from the SKT, or copy it to the CC. The architecture does not restrict the choice of the implementation.

// On the other hand, keys generated from a system block, using a custom "recipe", are always represented by their values and once generated have the exact same behavior as any other key that does not come from the SKT.

[[ACE-ECB-mode]]
==== Electronic Codebook Modes (Direct Encryption/Decryption)

While listing the rules for the ECB mode is in principle easy, it does display all the rules that are required to describe an arbitrarily complex mode.

// comment to reset formatting

Parameters:::

* `b` = block size in bits (8|`b`). [.red]#`VLEN` must be a multiple of `b`.#
* `k` = key size in bits (8|`k`).

Data Structures:::

* *Configuration Input*:
[lowerroman]
 . `key`: `k/8` bytes, or 8 bytes if a System Key index.

* *Content, Internal*:
 ** `key`: `k/8` bytes.

* *Content, Exported*:
[lowerroman]
 . `key`: `k/8` bytes, or 8 bytes if a System Key index.

Algorithm-Specific Functions:::

* `enc_block(p) -> c` encrypts plaintext block `p` using the key, and returns the ciphertext result `c`.
* `dec_block(c) -> p` decrypts ciphertext block `c` using the key, and returns the plaintext result `p`.

State Machine:::

* *States:* _initial_ (0), _encrypt_ (1), and _decrypt_ (2)
* *Allowed State Transitions:*
 ** From any state to state _encrypt_, if metadata allows encryption, else the CC is *invalidated*.
 ** From any state to state _decrypt_, if metadata allows decryption, else the CC is *invalidated*.
* *Behavior:*
 ** In state _initial_, any `ace.exec` will result in the CC being *invalidated*.
 ** In state _encrypt_:
  *** If{nbsp} `ace.exec Vd, Cn|C[Xn], Vs` {nbsp}is issued, then {nbsp} `Vd = enc_block(Vs)`.
  *** [.red]#If `VLEN` is a multiple of `b`, then `ace.exec Vd, Cn|C[Xn], Vs` encrypts block-by-block.#
  *** If any other form of `ace.exec` is issued, then the CC is *invalidated*.
 ** In state _decrypt_:
  *** If{nbsp} `ace.exec Vd, Cn|C[Xn], Vs` {nbsp}is issued, then {nbsp} `Vd = dec_block(Vs)`.
  *** [.red]#If `VLEN` is a multiple of `b`, then `ace.exec Vd, Cn|C[Xn], Vs` decrypts block-by-block.#
  *** If any other form of `ace.exec` is issued, then the CC is *invalidated*.

[NOTE]
====
[.red]#Supporting vector lengths smaller than a cipher's block size would complicate the architecture.
For example, even in a simple ECB mode, we would require instruction sequences like#
[C]
----
ace.exec     C0, V0          // load lower half of plaintext
ace.exec     C0, V1          // load upper half of plaintext
ace.exec V0, C0              // store lower half of ciphertext
ace.exec V1, C0              // store upper half of ciphertext
----
[.red]#in place of a single `ace.exec Vd, Cn|C[Xn], Vs`.
Supporting this behaviour would not only complicate both the architecture and its implementation, but it would also burden the software using the feature.
Therefore, the present specification assumes that vector lengths (or vector groups) can be configured to at least the block size of the cipher.#
====

[discrete]
==== Usage

The following pseudocode illustrates how to use an ECB CC to encrypt a block of data using a block cipher with a width of 128 bits (`VLEN` is also 128).

[[ACE-pseudocode-ECB-encryption]]
.Simple Pseudocode Example: Encryption with no Authentication
[C]
----
- Call OS API to get the necessary SCC. Assume X5 points to the SCC.
- Allocate memory for ciphertext buffer.

vsetvli zero, 4, e32, m1, ta, ma          // Use 128-bit vectors
ace.import C0, (X5)                       // Import the SCC into CC C0
ace.error X1                              // Read error from a CSR
if (X1 != 0) then { handle error }        // ACE may fail to validate SCC, algorithm may
                                          // be not supported, or CF memory may be full
ace.state C0, #ace_state_encrypt          // Configure CC for encryption
ace.error X1                              // Read error from a CSR
if (X1 != 0) then { handle error }        // Error if encryption not allowed

foreach (i from 0 to len_in_bytes(plaintext)/16-1) { // assume plaintext in whole blocks
    - load V0 from address plaintext+16*i
    ace.exec V0, C0, V0                   // Encrypt one block of the plaintext
    - store V0 at address ciphertext+16*i
}
----

// vle32.v  V0, (plaintext)              // load V0 from address plaintext+16*i
//                                       // assume plaintext is in a register
// ace.exec V0, C0, V                    // Encrypt one block of the plaintext
// vse32.v  V0, (ciphertext)             // store V0 at address ciphertext+16*i
// add plaintext, plaintext, 16          // advance plaintext pointer
// add ciphertext, ciphertext, 16        // advance ciphertext pointer




[[ACE-chaining]]
==== Chaining/Feedback Modes

There is no need to explicitly architect the behavior of chaining modes,
such as
Cipher Block Chaining (CBC),
Propagating Cipher Block Chaining (PCBC),
Cipher Feedback (CFB) and
Output Feedback (OFB)
as they can be easily implemented on top of the ECB functionality in software,
and no intermediate value in these algorithms needs to be kept secret.

[[ACE-keystream-modes]]
==== CTR/LFSR/XCTR/XLFSR Modes to Produce a Keystream

In the "non-X" modes, i.e., in the CTR mode and its analague that replaces the arithmetic counter by a LFSR, the sum of the lengths of IV and counter/LSFR equals the block size of the underlying keyed PRP or PRF. IV and counter/LFSR are concatenated to form the input to the keyed PRP or PRF.

The "X" modes have both IV and counter/LSFR of the same size as the block size of the underlying keyed PRP or PRF:
IV and counter/LFSR are ``xor``ed together to form the input to the keyed PRP or PRF -- which explains the "X" in the mode names.

//

Parameters:::
* `b` = block size in bits (8|`b`). [.red]#`VLEN` must be a multiple of `b`.#
* `k` = key size in bits (8|`k`).
* `j` = counter size in bits (8|`j`).
* `n` = IV size in bits (8|`n`).
* If the mode is CTR or LFSR, it is `b = n + j`.
* If the mode is an "X" mode, it is `b = n = j`.

Data Structures:::
* *Configuration Input*:
[lowerroman]
 . `key`: `k/8` bytes, or 8 bytes if a System Key index.

* *Content, Internal*:
 ** `key`: `k/8` bytes.
 ** `IV`: `n/8` bytes.
 ** `ctr`: `j/8` bytes.

* *Content, Exported*:
[lowerroman]
 . `key`: `k/8` bytes, or 8 bytes if a System Key index.
 . `IV`: `n/8` bytes.
 . `ctr`: `j/8` bytes.

Algorithm-Specific Functions:::
* `keystream_block(p) -> c` -- usually an encryption function.
* `tick_ctr()` -- updates the ctr (either by a modular increment or a LFSR).

State Machine:::
* *States:* _initial_ (0), _set_public_value_ (8), _operate_ (1).
* *Allowed State Transitions:*
 ** _initial_ -> _set_public_value_ -> _operate_.
 ** All states to _initial_.
* *Behavior:*
 ** In state _initial_, the `ctr` and `IV` fields are set to 0 (`ctr` is set to 1 if the algorithm is LFSR-based).
 ** In state _set_public_value_, we can only issue ``ace.exec`` instructions of Form B, namely, "```ace.exec Cn|C[Xn], Vs```", which set the IV value to `Vs`.
  *** If no such instruction is issued, the value of the IV will remain zero.
  *** [.red]#If `VLEN` is larger than `b`, the most significant bits of `Vs` (i.e., the "tail" of the vector) are ignored.#
  *** If such operations are issued more times, they will just update the IV value again. Since this can be done only before any encryption or decryption operation, this does not represent a security issue.
  *** Any other form of {nbsp}``ace.exec``{nbsp} will produce a null output and *invalidate* the CC.
 ** In state _operate_, we can only issue ``ace.exec`` instructions of Form C, "```ace.exec Vd, Cn|C[Xn]```", which perform:
+
--
  . If in a CTR or LFSR mode then `tmp ← keystream_block(IV @ ctr)`, +
    else (i.e., if in a XCTR or XLFSR mode) `tmp ← keystream_block(IV xor ctr)`,
  . `tick_ctr()`, and
  . `Vd ← tmp`.
--
+
[.red]#If `VLEN` is a multiple of `b`, the above three commands are applied to each of the `VLEN/b` `b`-bit blocks of `Vs`, producing each time the corresponding `b`-bit block of `Vd`.
If the number `x` of blocks to be processed in an entire run of the algorithm is not a multiple of `VLEN`/`b`, `VL` can be set to the remainder of the division of `x` by `VLEN`/`b` for the last instruction.#

 ** In state _operate_, any other form of {nbsp}``ace.exec``{nbsp} will produce a null output and *invalidate* the CC.

Note that if `ace.stage` is issued to return to state _initial_, the CC can be reused with a new `IV`.

[discrete]
==== Usage

Example pseudocode is given in <<ACE-pseudocode-keystream-modes>> (for the case `b` = `VLEN` = 128).

[[ACE-pseudocode-keystream-modes]]
.Encrypt with Keystream Generation
[C]
----
// Acquire payload, initialize
- Info: plaintext = *PT
- Process gets a Keystream Generation CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import C0, (X5)

// The next operations set the nonce (and the derived Authentication Key).
ace.stage C0, #ace_state_set_public_value
V0 ← nonce
ace.exec C0, V0

// Compute keystream, use it to encrypt plaintext
for i = 0 to len_in_bytes(PT)/16-1 do
    - load V0 from address PT+16*i
    ace.exec V1, C0
    V1 ← V1 xor V0
    - store V1 at address CT+16*i
----

[[ACE-XEX-XTS-modes]]
==== XEX/XTS modes (one or two keys)

Note that the use of a single key or two independently sampled keys is
determined by the algorithm field, and it is not determined by a configuration
parameter for the same algorithm.
We first define XEX mode functionality.

Parameters:::

* `b` = block size in bits (8|`b`).
* `k` = key size in bits (8|`k`).

Data Structures:::

* *Configuration Input*:
[lowerroman]
 . `key1`: `k/8` bytes, or 8 bytes if a System Key index.
 . `key2`: `k/8` bytes  -- omitted if only one key is used or if both keys come from an entry in the SKT.

* *Content, Internal*:
 ** `key1`: `k/8` bytes.
 ** `key2`: `k/8` bytes.
 ** `mask`: `b/8` bytes.

* *Content, Exported*:
[lowerroman]
 . `key1`: `k/8` bytes, or 8 bytes if a System Key index.
 . `key2`: `k/8` bytes -- omitted if only one key is used or if both keys come from an entry in the SKT.
 . `mask`: `b/8` bytes.

Algorithm-Specific Functions:::

* `enc_block(key,p) -> c` encrypts block `p` using the key, and returns the result `c`.
* `dec_block(key,c) -> p` decrypts block `c` using the key, and returns the result `p`.
* `update_mask(mask) -> mask` -- updates the mask by a Galois Field multiplication in GF(2^b^)

State Machine:::

* *States:* _initial_ (0), _set_public_value_ (8), _encrypt_ (1), and _decrypt_ (2).

* *Allowed State Transitions:*
 ** _initial_ -> _set_public_value_.
 ** _set_public_value_ -> _initial_.
 ** _set_public_value_ -> _encrypt_, if metadata allows encryption, else the CC is *invalidated*.
 ** _set_public_value_ -> _decrypt_, if metadata allows decryption, else the CC is *invalidated*.
 ** _encrypt_, _decrypt_ -> _initial_.

* *Behavior:*
 ** In state _initial_:
  *** The `mask` field is set to zero.
  *** Any {nbsp}``ace.exec``{nbsp} operation will produce null outputs and causes the CC to be *invalidated*.
 ** In state _set_public_value_, we can only issue ``ace.exec`` instructions of Form B, namely, "```ace.exec Cn|C[Xn], Vs```", to set the
 _tweak_. The `mask` field is used to initially store the tweak: `mask <- Vs`.
  *** If no such instruction is issued, the value of the tweak will remain zero.
  *** [.red]#If `VLEN` is larger than `b`, the most significant bits of `Vs` (i.e., the "tail" of the vector) are ignored.#
  *** If "```ace.exec Cn|C[Xn], Vs```" is repeated, it will just re-write the mask.
  *** Other forms of `ace.exe` not allowed, will produce null outputs and the CC is *invalidated*.
 ** When transitioning from _set_public_value_ to either _encrypt_ or _decrypt_, the following operations are performed:
  . `mask <- enc_block(key2,mask)` or `mask <- enc_block(key1,mask)` if only one key is used.
  . If only one key is used then update mask: `mask <- update_mask(mask)`.
 ** In _encrypt_ and _decrypt_ states, we can only issue ``ace.exec`` instructions of Form A, i.e., "```ace.exec Vd, Cn|C[Xn], Vs```", which:
+
--
  *** in state _encrypt_, computes `Vd = mask xor enc_block(key1,Vs xor mask)` ... +
      in state _decrypt_, computes `Vd = mask xor dec_block(key1,Vs xor mask)` ...
  *** ... and updates the mask: `mask <- update_mask(mask)`.
--
+
[.red]#If `VLEN` is a multiple of `b`, the above commands are executed `VLEN/b` times, processing each `b`-bit block of `Vs` into a `b`-bit block of `Vd`. This operation is clearly parallelizable. If the number `x` of blocks to process is not a multiple of `VLEN`/`b`, `VL` can be set to the remainder of the division of `x` by `VLEN`/`b` for the last instruction.#

//

Note that if `ace.stage` is issued to return to state _initial_, the CC can be reused with a new `IV`.

[discrete]
==== Usage

Using XEX mode is very easy. We include pseudocode for encryption only, decryption is entirely similar
(this example is also assuming `b` = `VLEN` = 128).

[[ACE-pseudocode-basic-IV-mode]]
.Pseudocode for encryption in any IV-based non-authenticated modes without associated data
[C]
----
// Acquire payload
- Info: plaintext = *PT
- Call an API to get the corresponding key from a key management applet or HW block.
- The API returns the SCC. Assume X5 is the pointer to it.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import C0, (X5)

ace.stage C0, #const_set_public_value            // this can be an IV or a nonce.
V0 ← IV
ace.exec C0, V0

ace.state C0, #ace_state_encrypt                 // Configure CC for encryption
for i = 0 to ceil(len_in_bytes(plaintext)/16)-1 do
    - load V0 from address plaintext+16*i
    ace.exec V0, C0, V0                          // Encrypt one block of the plaintext
    - store V0 at address ciphertext+16*i
----

To implement the XTS mode, the ciphertext stealing part is easy to realize using the XEX algorithm together with vector masking and shifting operations.

// N.B. another ace.stage C0, #const_set_public_value would reset the internal state and allow to begin another decryption with a new IV.

<<<

[[ACE-GCM-mode]]
==== GCM mode

Parameters:::

* `b` = block size in bits (8|`b`).
* `k` = key size in bits (8|`k`).

Data Structures:::

* *Configuration Input*:
[lowerroman]
 . `key`: `k/8` bytes, or 8 bytes if a System Key index.

* *Content, Internal*:
 ** `key`: `k/8` bytes.
 ** `ctr`: `b/8` bytes.
 ** `hash_key`: `b/8` bytes.
 ** `auth_tag`: `b/8` bytes.

* *Content, Exported*:
[lowerroman]
 . `key`: `k/8` bytes, or 8 bytes if a System Key index.
 . `ctr`: `b/8` bytes.
 . `auth_tag`: `b/8` bytes.

NOTE: There are no fields for the lengths of the AD and of the plaintext, as they are maintained by the calling software.
Also, `hash_key` is not serialized, and thus it is recomputed upon `ace.import`.

Algorithm-Specific Functions:::

* `enc_block(key,p) -> c` encrypts block `p` using the key, and returns the result `c`.

* `absorb_into_hash(data)` absorbs data into the hash function by performing:
  . `auth_tag <- auth_tag xor Vs`.
  . `auth_tag <- auth_tag * hash_key`.

State Machine:::

* *States:* _initial_ (0), _set_public_value_ (8), _hash_absorb_ (3), _encrypt_ (1), _hash_finalize_enc_ (4), _decrypt_ (2), _hash_finalize_dec_ (5), and _hash_verify_ (6), _completed_ (15).

* *Allowed State Transitions:*
 ** From all states to _initial_.
 ** _initial_ -> _set_public_value_ -> _hash_absorb_.
 ** _hash_absorb_ -> _encrypt_ -- if metadata allows encryption, else the CC is *invalidated*.
 ** _hash_absorb_ -> _decrypt_ -- if metadata allows decryption, else the CC is *invalidated*.
 ** _encrypt_ -> _hash_finalize_enc_, later automatically transitioning to _completed_.
 ** _decrypt_ -> _hash_finalize_dec_.
 ** _hash_finalize_dec_ -> _hash_verify_, later automatically transitioning to _completed_.

* *Behavior:*
 ** In state _initial_ :
  *** Any {nbsp}``ace.exec``{nbsp} operation will produce null outputs and causes the CC to be *invalidated*.
  *** The following initialization operations are performed:
   . `hash_key <- enc_block(key,0)`,
   . `auth_tag <- 0`, and
   . `ctr <- 0`.
 ** In state _set_public_value_:
  *** We can only issue  ``ace.exec`` instructions of Form B, i.e., "```ace.exec Cn|C[Xn], Vs```," to set
   . `ctr <- Vs << b/4`  (i.e., the `b/4` most significant bits of `Vs` are ignored, and the `b/4` least significant bits of `ctr` are set to zero.)
  *** If{nbsp} `ace.exec Cn|C[Xn], Vs`,{nbsp} is repeated, it will just re-write the IV.
  *** If no such {nbsp} `ace.exec Cn|C[Xn], Vs`{nbsp} to set is issued, `ctr` remains zero.
  *** [.red]#If `VLEN` is larger than `b`, the most significant bits of `Vs` (i.e., the "tail" of the vector) are ignored.#
  *** Any other form of {nbsp}``ace.exec``{nbsp} will produce null outputs and causes the CC to be *invalidated*.

 ** In state _hash_absorb_, we can only issue  ``ace.exec`` instructions of Form B, i.e., "```ace.exec Cn|C[Xn], Vs```" to absorb a data block in `auth_tag`, i.e.:
+
--
 . `absorb_into_hash(Vs)`.
--
+
[.red]#If `VLEN` is a multiple of `b`, the above operation is executed `VLEN/b` times, absorbing each `b`-bit block of `Vs` into the hash.
This operation is also parallelizable by having the implementation precompute the first four powers of `hash_key`, keeping it internally in the CC (and reconstructing them after `ace.import`). If the number `x` of blocks to process is not a multiple of `VLEN`/`b`, `VL` can be set to the remainder of the division of `x` by `VLEN`/`b` for the last instruction.#

** If the _encrypt_ state, we can only issue  ``ace.exec`` instructions of Form A, namely "```ace.exec Vd, Cn|C[Xn], Vs```" to
   encrypt `Vs` into `Vd`, and absorb the ciphertext `Vd` into the `auth_tag`, namely
+
--
  . If `ctr[b/4-1:0] = 0`, the CC is *invalidated*.
  . `tmp <- Vs xor enc_block(key,ctr)`.
  . `absorb_into_hash(tmp)`.
  . `ctr[b/4-1:0] <- ctr[b/4-1:0] + 1 % 2^b/4^`.
  . `Vd <- tmp`.
--
+
[.red]#If `VLEN` is a multiple of `b`, the above are executed `VLEN/b` times, encrypting each `b`-bit block of `Vs` into the corresponding `b`-bit block of `Vd`. There is significant potential for parallelization, including in the `absorb_into_hash` function. If the number `x` of blocks to encrypt is not a multiple of `VLEN`/`b`, `VL` can be set to the remainder of the division of `x` by `VLEN`/`b` for the last instruction.#

** In state _hash_finalize_enc_, we can only issue a Form A "```ace.exec Vd, Cn|C[Xn], Vs```," where +
 `{nbsp}{nbsp}{nbsp}Vs = IntTo{b/2}Bits(bit_length(AD)) @ IntTo{b/2}Bits(bit_length(plaintext))` +
 is set by the user, to compute the authentication tag and complete the algorithm as follows:
+
--
  . `absorb_into_hash(Vd)`.
  . `auth_tag <- auth_tag xor enc_block(key,ctr[b-1,b/4] @ 0[b/4-1,0])`.
  . Finally, `auth_tag` is returned in `Vd`, and the state is changed to _completed_.
--
+
[.red]#If `VLEN` is larger than `b`, the most significant bits of `Vs` (i.e., the "tail" of the vector) are ignored.#

 ** In state _decrypt_, we can only issue  ``ace.exec`` instructions of the form{nbsp} `ace.exec Vd, Cn|C[Xn], Vs`{nbsp} to
   absorb the ciphertext `Vs` into the `auth_tag`, then decrypt `Vs` into `Vd`, namely
+
--
  . If `ctr[b/4-1:0] = 0`, the CC is *invalidated*.
  . `absorb_into_hash(Vs)`.
  . `Vd  <- Vs xor enc_block(key,ctr)`.
  . `ctr[b/4-1:0] <- ctr[b/4-1:0] + 1`.
--
+
[.red]#If `VLEN` is a multiple of `b`, the same behavior applies as in state _encrypt_.#

** In state _hash_finalize_dec_, we can only issue a Form A "```ace.exec Vd, Cn|C[Xn], Vs```" where +
 `{nbsp}{nbsp}{nbsp}Vs = IntTo{b/2}Bits(bit_length(AD)) @ IntTo{b/2}Bits(bit_length(plaintext))`, +
 is formed by the user  to compute the authentication tag as follows:
+
--
  . `absorb_into_hash(Vs)`.
  . `auth_tag <- auth_tag xor enc_block(key,ctr[b-1,b/4] @ 0[b/4-1,0])`.
--
+
[.red]#If `VLEN` is larger than `b`, the most significant bits of `Vs` (i.e., the "tail" of the vector) are ignored.#

** In state _hash_verify_, we can only issue  ``ace.exec`` instructions of the form{nbsp} `ace.exec Cn|C[Xn], Vs`{nbsp}.
    `Vs` is compared to `auth_tag`:
+
--
    *** If the values match, then the state is changed to _completed_, and `ace.error` returns no error,
        else the state is changed to _completed_, and `ace.error` returns `ace_err_authentication`.
--
+
[.red]#If `VLEN` is larger than `b`, only the `b` least significant bits `Vs` are compared to `auth_tag`.#

** Upon completion of `ace.import`, the ACE unit recomputes `hash_key`:
  . `hash_key <- enc_block(key,0)`.

//

<<<
[discrete]
==== Usage

In <<ACE-pseudocode-GCM-encryption>> we show pseudocode for GCM encryption (again with `b` = `VLEN` = 128).

[[ACE-pseudocode-GCM-encryption]]
.GCM Encryption
[C]
----
// Acquire payload, initialize
- Info: authenticated data = *AD, plaintext = *PT
- Process gets a GCM encryption CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import C0, (X5)

// The next operations set the nonce (and the derived Authentication Key).
ace.stage C0, #ace_const_set_public_value
V0 ← nonce
ace.exec C0, V0

// Compute AD contribution to Auth Data
ace.stage C0, #ace_const_hash_absorb
for i = 0 to len_in_bytes(AD)/16-1  do
    - load V0 from address AD+16*i
    ace.exec C0, V0                              // Absorb it into hash

// Encrypt plaintext and continue computation of auth_tag
for i = 0 to len_in_bytes(PT)/16-1 do
    - load V0 from address PT+16*i
    ace.exec V1, C0, V0
    - store V1 at address CT+16*i

// Finally, we absorb the lengths into auth_tag, finalize it, and output it
ace.stage C0, #ace_const_hash_finalize_enc
V1 ← IntTo64Bits(len(AD)) @ IntTo64Bits(len(PT))
ace.exec V2, C0, V1                              // V2 contains the finalized hash
----

GCM decryption differs from enc as follows:
the roles of `PT` and `CT` are reversed,
states _encrypt_ and _hash_finalize_enc_ are replaced by states _decrypt_ and _hash_finalize_dec_,
and the last lines are as follows:

[[ACE-pseudocode-GCM-decryption-difference]]
.GCM Decryption
[C]
----
// Finally, we absorb the lengths into auth_tag, finalize it, and verify it it
ace.stage C0, #ace_const_hash_finalize_dec
V1 ← IntTo64Bits(len(AD)) @ IntTo64Bits(len(CT))
ace.exec V2, C0, V1                              // V2 contains the finalized hash

ace.stage C0, #ace_const_hash_verify
V1 ← tag_from_payload
ace.exec C0, V1                                  // V1 contains the tag from the input
ace.error X1
if (X1 != 0) then { handle error }       // do not use the plaintext if error occurred
----

//
<<<
[discrete]
==== Alternative Examples

GCM security is not compromised if `H` is revealed.
Consequently, an implementation based on a simpler ECB mode CC is possible,
as shown below (for encryption only -- decryption is similar).
However, this significantly increases code size and requires implementing `galois_mult(V4,V3)`.
Adding a dedicated mode to the ACE unit is a minor effort, and it allows internal logic to optimize execution
beyond the capabilities of, for instance, a compiler on an in-order CPU. It also means that the CPU
does not have to implement the carryless multiplication (cf. <<ACE-Dependencies>>),
and only a shared ACE unit has to,
which saves hardware costs when several small cores share a single ACE unit.

[[ACE-pseudocode-GCM-encryption-alternate]]
.Implementing GCM encryption using an ECB CC
[C]
----
// Acquire payload, initialize
- Info: authenticated data = *AD, plaintext = *PT
- Process gets a GCM encryption CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import C0, (X5)                              // Imports SCC into CC C0
V5[127:32] ← IV

V3 ← 0                                           // “Auth Data 1”
ace.exec V4, C0, V3                              // compute H
for i = 0 to ceil(len_in_bytes(AD)/16)-1  do
    - load 16 bytes from AD+16*i into V1
    V3 ← V3 xor V1                               // Horner scheme add
    V3 ← galois_mult(V4,V3)                      // Horner scheme mult

counter ← 1                                      // a 32-bit integer value
for i = 0 to ceil(len_in_bytes(PT)/16)-1  do
    V5[32:0] ← counter
    - load 16 bytes from PT+16*i into V1
    ace.exec V2, C0, V5                          // create mask by encrypting the counter
    V1 ← V1 xor V2                               // CTR encrypt
    V3 ← V3 xor V1                               // Horner scheme add
    V3 ← galois_mult(V4,V3)                      // Horner scheme mult
    - store V1 at *(CT+16*i))
    counter ← counter + 1

V3 ← V3 xor (len_in_bits(AD) @ len_in_bits(PT))  // Horner scheme add
V3 ← galois_mult(V4,V3)                          // Horner scheme mult
V5[32:0] ← 0                                     // Prepare IV || 0 for tag encryption
ace.exec V2, C0, V5
tag ← V3 xor V2                                  // Last Horner scheme add
----

<<<

[[ACE-GCM-SIV]]
==== GCM-SIV mode

The GCM-SIV mode's main differences with GCM are that:

. Both encryption and authentication keys are derived from the main key, whereas in GCM the main key is used also for encryption;
. It is a MAC-then-Encrypt mode, whereas GCM is a Encrypt-then-MAC mode, therefore GCM-SIV is more amenable to Release of Unencrypted Plaintext (RUP) attacks;
. Encryption requires two passes over the plaintext, since the tag computed on the AD and plaintext is used also as the initialization vector for the CTR encryption.

The third difference affects the state machine. While GCM-SIV's decryption state machine is similar to the GCM's, the encryption state machine is different:

* During encryption, the _hash_absorb_ state absorbs the entire associated data and plaintext. The _hash_finalize_enc_ state then absorbs the lengths and produces the SIV/tag. Finally, the _encrypt_ state performs a second pass to encrypt the plaintext using the SIV/tag as the initialization vector.
* During decryption, the _hash_absorb_ state absorbs only the associated data. The _decrypt_ state decrypts the ciphertext and simultaneously absorbs the plaintext into the hash. Finally, the _hash_finalize_dec_ state absorbs the lengths, produces the SIV/tag, and internally compares it to the provided SIV/tag.

// Comment to reset indentation of blocks

Parameters:::

* `b` = block size in bits, (`8|b`).
* `k` = key size in bits (8|`k`).
* It must be `k = b` or `k = 2b`.
* It must be established by the algorithm whether the authentication tag is `b` or `3b/4` bits long.

Data Structures:::

* *Configuration Input*:
[lowerroman]
 . `key`: `k/8` bytes, or 8 bytes if a System Key index.

* *Content, Internal*:
 ** `key`: `k/8` bytes.
 ** `enc_key`: `k/8` bytes.
 ** `auth_key`: `b/8` bytes.
 ** `nonce`: `3b/32` bytes (`3b/4` bits).
 ** `ctr`: `b/32` bytes (`b/4` bits).
 ** `auth_tag`: `b/8` bytes.
 ** `SIV`: `b/8` or `3b/32` bytes (`b` or `3b/4` bits).
+
A `b`-bit `SIV` is computed by clearing the most significant bit of `auth_tag` and encrypting it. +
For a `3b/4`-bit `SIV`, a full `b`-bit `auth_tag` value is kept while absorbing data.
The public `SIV` value is computed by clearing the most significant bit of `auth_tag`, encrypting it, and then removing the `b/4` least significant bits.

* *Content, Exported*:
[lowerroman]
 . `key`: `k/8` bytes.
 . `nonce`, `3b/32` bytes.
 . `ctr`, `b/32` bytes.
 . `auth_tag`, `b/8` bytes.
 . `SIV`, `b/8` bytes.

NOTE: `hash_key` and `auth_key` are not serialized,
and must be recomputed upon each `ace.import`. +
 +
The `SIV` field is actually only needed for decryption, since it must be maintained separately from the `auth_tag` field, which changes with each processed block as it is computed, whereas for encryption it is first computed completely and then used in the encryption process. However, since the same CC could be configured to support both encryption and decryption, the `SIV` field always present in the internal state (even if not used) and in the exported state.

//

Algorithm-Specific Functions:::

* `enc_block(key,p) -> c` encrypts block `p` using the key, and returns the result `c`.
* `absorb_into_hash(data)` absorbs data into the hash function by performing a step of (a variant of) GHASH or POLYVAL as specified by the algorithm
   (for instance, AES-GCM-SIV uses POLYVAL):
  . `auth_tag <- auth_tag xor Vs`.
  . `auth_tag <- auth_tag * hash_key`, where `*` denotes either Galois field multiplication (for GHASH) or Montgomery multiplication (for POLYVAL/MHASH), as specified by the algorithm.
State Machine:::
* *States:* _initial_ (0), _set_public_value_ (8), _set_public_value_2_ (9), _hash_absorb_ (3), _hash_finalize_enc_ (4), _hash_finalize_dec_ (5), _encrypt_ (1), _decrypt_ (2), and _completed_ (15).

* *Allowed State Transitions:*
 ** From all states to _initial_.
 ** For encryption:
    _initial_ -> _set_public_value_ -> _hash_absorb_ -> _hash_finalize_enc_ -> _encrypt_.
 ** For decryption: +
    _initial_ -> _set_public_value_ -> _set_public_value_2_ -> _hash_absorb_ -> _decrypt_ -> _hash_finalize_dec_.
 ** Transition to _encrypt_ possible only if metadata allows encryption, else the CC is *invalidated*.
 ** Transition to _decrypt_ possible only if metadata allows decryption, else the CC is *invalidated*.

* *Behavior:*
 ** In state _initial_ :
  *** Any {nbsp}``ace.exec``{nbsp} operation will produce a null output and the CC will be *invalidated*.
  *** The following initialization operations are performed:
    . `enc_key`, `auth_key <- RFC8452_KeyDeriv(key)`,
    . `nonce`, `ctr`, `auth_tag`, `SIV <- 0`.

  ** In states _set_public_value_, resp. _set_public_value_2_:
    *** We can only issue  ``ace.exec`` instructions of Form B, i.e. "```ace.exec Cn|C[Xn], Vs```," to set the value of `nonce`, resp. `SIV`.
    *** If "```ace.exec Cn|C[Xn], Vs```" is repeated, it will just re-write the value of `nonce`, resp. `SIV`.
    *** If no such "```ace.exec Cn|C[Xn], Vs```" is issued, `nonce`, resp. `SIV`, remain equal to zero.
    *** [.red]#If `VLEN` is larger than `b`, the most significant bits of `Vs` (i.e., the "tail" of the vector) are ignored.#
    *** Other forms of `ace.exe` will produce null outputs and *invalidate* the CC.
+
NOTE: There is no harm in moving to state _set_public_value_2_ and setting the
SIV while encrypting, since that field is not used in the encryption path until
it is set (thus overwriting any previous content) by the state machine itself.
Accepting this redundant but harmless behavior simplifies the state machine.
+
** In state _hash_absorb_:
+
--
   *** Only ``ace.exec`` instructions of the form "```ace.exec Cn|C[Xn], Vs```" can be issued. Such an instruction accumulates a value in the `auth_tag`:
   i.e., perform `absorb_into_hash(Vs)`.
--
+
[.red]#If `VLEN` is a multiple of `b`, `absorb_into_hash` is executed on each of the `VLEN/b` blocks in `Vs`.#

*** Other forms of `ace.exec` will produce null outputs and *invalidate* the CC.

** In state _hash_finalize_enc_, we can only issue an {nbsp}``ace.exec``{nbsp} of Form A, i.e., "```ace.exec Vd, Cn|C[Xn], Vs```," where it is the responsibility of the user to set +
`{nbsp}{nbsp}{nbsp}Vs = IntTo{b/2}Bits(bit_length(AD)) @ IntTo{b/2}Bits(bit_length(plaintext))`, +
to finalize the computation of the SIV/tag, by performing:
+
--
    . `absorb_into_hash(Vs)`.
    . `tmp <- enc_block(enc_key, 1b0 @ ((auth_tag xor N)[b-2:0]))`
    . If tag length is `b` bits, then
     *** `SIV <- tmp` and `Vd <- tmp`,
    . else (tag length is `3b/4` bits)
     *** `SIV <- tmp[b-1:b/4]` and `Vd <- (tmp >> b/4)`.
--
+
[.red]#If `VLEN` is larger than `b`, the most significant bits of `Vs` (i.e., the "tail" of the vector) are ignored.#

*** Other forms of `ace.exec` will produce null outputs and *invalidate* the CC.

** In state _encrypt_, we can only issue  ``ace.exec`` instructions of the Form A, namely "```ace.exec Vd, Cn|C[Xn], Vs```," to encrypt `Vs` into `Vd` as follows:
+
--
. If `ctr = 0`, then the CC is *invalidated*.
   . If the `SIV` is `b`-bits long, then +
     *** ``Vd <- Vs xor enc_block(key, 1b1 @ SIV[b-2:b/4] @ (SIV[b/4-1:0] + ctr % 2^b/4^)),``
   . else (the `SIV` is `3b/4`-bits long) +
      *** ``Vd <- Vs xor enc_block(key, 1b1 @ SIV[3b/4-2:0] @ ctr``.
   . `ctr <- ctr + 1`.
--
+
[.red]#If `VLEN` is a multiple of `b`, the above operations are applied to each of the `VLEN/b` blocks in `Vs`.#

*** Other forms of `ace.exec` will produce null outputs and *invalidate* the CC.

** In state _decrypt_,  we can only issue  ``ace.exec`` instructions of the Form A, i.e., "```ace.exec Vd, Cn|C[Xn], Vs```," to decrypt `Vs` into `Vd` and then absorb the plaintext `Vs` into the `auth_tag`, namely
+
--
     . If `ctr = 0`, then the CC is *invalidated*.
     . If the `SIV` is `b`-bits long, then +
       *** ``Vd <- Vs xor enc_block(key, 1b1 @ SIV[b-2:b/4] @ (SIV[b/4-1:0] + ctr % 2^b/4^)),``
     . else (it is `3b/4`-bits long) +
       *** ``Vd <- Vs xor enc_block(key, 1b1 @ SIV[3b/4-2:0] @ ctr``.
     . `absorb_into_hash(Vs)`.
     . `ctr <- ctr + 1`.
--
+
[.red]#If `VLEN` is a multiple of `b`, the above operations are applied to each of the `VLEN/b` blocks in `Vs`.#

*** Other forms of `ace.exec` will produce null outputs and *invalidate* the CC.

 ** In state _hash_finalize_dec_,
    we can only issue an ``ace.exec`` of Form B, namely "```ace.exec Cn|C[Xn], Vs```," where it is the responsibility of the user to set +
    `{nbsp}{nbsp}{nbsp}Vs = IntTo{b/2}Bits(bit_length(AD)) @ IntTo{b/2}Bits(bit_length(plaintext))`. +
    ``ace.exec`` thus performs the following operations:
+
--
  . `absorb_into_hash(Vs)` (which modifies `auth_tag`).
  . `tmp <- enc_block(enc_key, 1b0 @ ((auth_tag xor N)[b-2:0]))`.
  . If tag length is `b` bits, then
     *** `auth_tag <- tmp`,
  . else (tag length is `3b/4` bits)
     *** `auth_tag <- tmp[b-1:0] @ (b/4)b0`.
  . Finally, `auth_tag` and `SIV` are compared:
     *** If the values match, the state transitions to _completed_ and `ace.error` returns no error,
  else the state transitions to _completed_ and `ace.error` returns `ace_err_authentication`.
--
+
[.red]#If `VLEN` is larger than `b`, the most significant bits of `Vs` beyojnd the `b`-th (i.e., the "tail" of the vector) are ignored.#

  ** Upon completion of `ace.import`, the ACE unit recomputes `hash_key` and `auth_key`
    . `enc_key`, `auth_key <- RFC8452_KeyDeriv(key)`.

//
<<<

[discrete]
==== Usage

We show in <<ACE-pseudocode-GCM-SIV-encryption>> how to perform AEAD encryption with a GCM-SIV CC (with `b` = `VLEN` = 128).
<<ACE-pseudocode-GCM-SIV-decryption>> is the corresponding pseudocode for decryption.

[[ACE-pseudocode-GCM-SIV-encryption]]
.GCM-SIV Encryption
[C]
----
// Acquire payload, initialize
- Info: authenticated data = *AD
- Info: plaintext = *PT
- Call an API to get the corresponding key from a key management applet or HW block.
- The API returns the SCC. Assume X5 is the pointer to it.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import C0, (X5)

// Set the nonce (and the derived Authentication Key).
ace.stage C0, #ace_const_set_public_value
V0 ← nonce
ace.exec C0, V0

for i = 0 to len_in_bytes(AD)/16-1  do
    - load V0 from address AD+16*i               // Load a block of associated data
    ace.exec C0, V0 		                     // Absorb it into hash

    for i = 0 to len_in_bytes(PT)/16-1  do
    - load V0 from address PT+16*i               // Load a block of plaintext
    ace.exec C0, V0 		                     // Absorb it into hash
V0 ← IntTo64Bits(len(AD)) @ IntTo64Bits(len(PT))
ace.exec C0, V0		          	                 // Absorb lengths into hash

// Finalize the SIV computation, set and return it
ace.stage C0, #ace_const_hash_finalize_enc
ace.exec V2, C0
- store V2 into tag

// Encrypt the plaintext
ace.stage C0, #ace_const_encrypt
for i = 0 to len_in_bytes(PT)/16-1  do
    - load V0 from address PT+16*i               // Load a block of plaintext
    ace.exec V1, C0, V0                          // Encrypt the block
    - store V1 at address CT+16*i                // Store a block of ciphertext
----

<<<

[[ACE-pseudocode-GCM-SIV-decryption]]
.GCM-SIV Decryption
[C]
----
// Acquire payload, initialize
- Info: authenticated data = *AD
- Info: ciphertext = *CT
- Call an API to get the corresponding key from a key management applet or HW block.
- The API returns the SCC. Assume X5 is the pointer to it.
- Allocate memory for plaintext buffer PT (if not same as CT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import C0, (X5)

// The next operations set the nonce and SIV.
ace.stage C0, #ace_const_set_public_value
V0 ← nonce
ace.exec C0, V0
ace.stage C0, #ace_const_set_public_value_2
V0 ← SIV
ace.exec C0, V0

// Compute AD contribution to Auth Data
ace.stage C0, #ace_const_hash_absorb
for i = 0 to len_in_bytes(AD)/16-1  do
    - load V0 from address AD+16*i
    ace.exec C0, V0                              // Absorb it into hash

// Decrypt ciphertext and continue computation of auth_tag
for i = 0 to len_in_bytes(CT)/16-1 do
    - load V0 from address CT+16*i
    ace.exec V1, C0, V0
    - store V1 at address PT+16*i

// Finally, we absorb the lengths of AD and plaintext into auth_tag AND verify
ace.stage C0, #ace_const_hash_finalize_enc
V0 ← IntTo64Bits(len(AD)) @ IntTo64Bits(len(PT))
ace.exec C0, V0
ace.error X1
if (X1 != 0) then { handle error }               // do not use the plaintext if error occurred
----

<<<

[[ACE-CMAC]]
==== CMAC functions

// comment to reset formatting

Parameters:::

* `b` = block size in bits (8|`b`)
* `k` = key size in bits (8|`k`).

Data Structures:::

* *Configuration Input*:
[lowerroman]
 . `key`: `k/8` bytes.

* *Content, Internal*:
 ** `key`: `k/8` bytes.
 ** `hash`: `b/8` bytes.
 ** `last_block_len`: `8` bytes.

* *Content, Exported*:
[lowerroman]
 . `key`: `k/8` bytes.
 . `hash`: `b/8` bytes.
 . `last_block_len`: `8` bytes.

Algorithm-Specific Functions:::

* `enc_block(key,p) -> c` encrypts block `p` using the key, and returns the result `c`.
* `gen_subkeys(K) -> K1,K2` generates subkeys `K1` and `K2` from the master key `K` as follows: First, let `C` be the non-leading coefficients of the lexicographically first irreducible binary polynomial of degree `b` with the minimal number of ones: `0x1B` for `b` = 64, `0x87` for `b` = 128, and `0x425` for `b` = 256. Then
//First, `C` is a `b` bit value that, if interpreted as a polynomial in the letter `x` over GF(2), makes `x^b^ + const_Rb` irreducible.
 . `L <- AES-enc_block(K, 0)`
 . if (`most_significant_bit(L){nbsp}{nbsp}= 0`) then
   { `K1 <- L{nbsp}{nbsp}<< 1` }
   else
   { `K1 <- (L{nbsp}{nbsp}<< 1) xor C` }.
 . if (`most_significant_bit(K1){nbsp}= 0`) then
   { `K2 <- K1{nbsp}<< 1` }
   else
   { `K2 <- (K1{nbsp}<< 1) xor C` }.
 . return ```(K1,K2)```.

State Machine:::

* *States:* _initial_ (0), _hash_absorb_ (3), _hash_finalize_ (4), and _completed_ (15).
* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_.
 ** _hash_absorb_ -> _hash_finalize_ -> _completed_.
 ** From any state to state _initial_.
* *Behavior:*
 ** In state _initial_:
  *** `last_block_len` is set to the full block length `b`.
  *** `hash` is set to zero.
  *** Any `ace.exec` will result in the CC being *invalidated*.

 ** In state _hash_absorb_, we can only issue instructions ``ace.exec`` of form B, i.e., "```ace.exec Cn|C[Xn], Vs```", to absorb the data block `Vs` into the hash. This is performed as follows:
+
--
  . `tmp <- hash xor Vs`.
   . `hash <- enc_block(key,tmp)`.
--
+
[.red]#If `VLEN` is a multiple of `b`, then the above operations are applied to each `b`-bit block of `Vs`.#

 ** Upon issuing `ace.stage Cn|C[Xn], #ace_state_hash_finalize, Xs` where `Xs` contains the length of the last block in bits, following happens:
   . The CC transitions to state _hash_finalize_.
   . `last_block_len <- Xs`.

 ** In state _hash_finalize_, we can only issue a single instruction ``ace.exec`` of form A, i.e., "```ace.exec Cn|C[Xn], Vs```", to absorb the data block `Vs` and write the final hash value in `Vd`. After this, the state transitions to _completed_:
+
--
  . `K1,K2 <- gen_subkeys(key)`.
  . if `last_block_len` = `b`, then
    *** `tmp <- hash xor Vs xor K1`,
  . else
    *** `tmp <- Vs`
    *** Remove the `b` - `last_block_len` most significant bits of `tmp` and pad the resulting value with a `1` and sufficiently many `0` bits to make it `b` bits long.
    *** `tmp <- hash xor tmp xor K2`.
  . `hash <- enc_block(key,tmp)`.
  . The CC transitions to state _completed_.
--
+
[.red]#If `VLEN` is larger than `b`, the most significant bits of `Vs` beyojnd the `b`-th (i.e., the "tail" of the vector) are ignored.#


 ** In any state, issuing any form of ``ace.exec`` that is not the allowed one will produce a null output and the CC will be *invalidated*.


[.red]#Fill missing example#

<<<

[[ACE-hash-functions]]
==== Hash Functions

[.red]#TBD#


[[ACE-Ascon]]
==== Ascon Specific Rules

===== Ascon-128 and Ascon-128a authenticated ciphers

[.red]#TBD#

===== Ascon-Hash cryptographic hash

[.red]#TBD#

===== Ascon-Xof extendable-output function

[.red]#TBD#

===== Ascon-80pq cipher with the increased 160-bit key

[.red]#TBD#

// //////////////////////////////////////////////////////////////////////////////////////////

[[ACE-examples]]

=== Examples

==== Context Switching

[.red]#TBD.#

==== VM migration

Just as the same VM can be made to run in an Intel or an AMD processor, for instance many users of client devices may switch to a device with a CPU from a different SiP and carry their VMs.
However, it may occur that the ACE implementation on the new device has a CF with reduced capacity. In this case, the system software may not be able to restore all the contexts. Therefore, we added a single-block context format to <<ACE-metadata-standard>> that can be used by system software in such a situation, which can be used to store a (truncated) pointer or other information to be used, upon trapping, to identify which context to load.
This of course requires to free one or more CCs beforehand and, it will be up to the same SW to decide which context to free.

This mechanism, can also be used to implement lazy loading of contexts upon context switching.

==== Key Management and Provisioning Applications

Software environments that implement key management operations for other domains require their own RCTK. A system may contain multiple such software environments.

A Key Management Applet (KMA) will

[arabic]
. Generate or retrieve a key matching a request.
. Configure a CC with this key and its associated metadata.
. Export this CC to a SCC in memory.
. Relinquish control to the MM.

The MM, which controls the CTK, can the

[arabic, start=5]
. Set the RCTK to the KMA’s RCTK.
. Re-import the SCC into a CC
. Change the RCTK to match the requester domain's RCTK.
. Export the key for the Requester's use.
. Relinquish control to the Requester.

This is the most generic approach and allows each piece of software to use a CC of choice to generate and import SCCs.
Furthermore, it protects the key from other SW environments that may be crossed while transferring control between the Requester process, the MM, and the Key Management application.

// Various optimizations are possible, which can be interesting for embedded environments: Steps 3., 5., and 6. can be omitted if the CC used for these operations is fixed and no intermediate SW environments modify that CC.

// ==== Decryption and Authentication, encrypt–then–MAC
//
// This example assumes a keyed hash function (MAC) where the CC/SCC includes the key.
// With the hash function programmed in CC C1, `ace.state C1, #ace_const_hash_start` initializes or resets the function to compute a new hash with the same key.
// `ace.state C1, #ace_const_hash_finalize` finalizes the operation, allowing the hash value to be extracted via one or more `ace.exec V0, C1` instructions.
// `#ace_const_hash_start` is always valid and resets the state, whereas `#ace_const_hash_finalize` is valid only after initialization, and it can be called also with an empty payload.
//
// Following `#ace_const_hash_start`, only Form B `ace.exec` instructions are permitted.
// Following `#ace_const_hash_finalize`, only Form C `ace.exec` instructions are permitted. Attempting to extract data beyond the full hash length results in zero output and raises an error.
//
// .Decryption and Authentication, encrypt–then–MAC
//
// [C]
// ----
// - Process obtains an AES-encrypted, hashed, payload (the ciphertext) from a service.
// - Process calls an OS API to get CCs for the encryption and authentication keys.
// - OS API returns two encrypted and authenticated payloads.
//
// // Process imports first SCC (for decryption) into C0:
// ace.import C0, [X5]
//
// // Process imports second SCC (for hashing) into C1:
// ace.import C1, [X6]
//
// - Allocate memory for plaintext buffer.
// // Configure vector register file for 128-bit registers and AES.
// vsetvli zero, 4, e32, m1, ta, ma
//
// ace.state C0, #ace_const_decrypt
// ace.error X1,C0
// if (X1 != 0) then { handle error }
//
// ace.state C1, #ace_const_hash_start    // To start hashing
// foreach (i from 0 to ceil(len_in_bytes(ciphertext)/16)-1) {
//   - load V0 from address ciphertext+16*i
//   ace.exec ignore, C1, V0              // Absorb one 128-bit block
// }
//
// ace.state C1, #ace_const_hash_finalize
// ace.exec V1, C1
// // if the hash is longer, then extract the next 16 bytes using `ace.exec V2, C1`
//
// Compare tags. If they do not match, report error.
//
// foreach (i from 0 to ceil(len_in_bytes(ciphertext)/16)-1) {
//   - load V0 from address ciphertext+16*i
//   ace.exec V0, C0, V0				  // Decryption
//   - store V0 at address plaintext+16*i
// }
// ----
//
// Note that invoking `ace.state C1, #ace_const_hash_start` would allow to reuse C1 to compute additional hashes/MACs.

// ///////////////////////////////////////////////////////////////////////////////////////////

<<<

[[ACE-Dependencies]]
=== Impact and Dependency on Other Extensions

While ACE can be implemented with the V extension as a requirement, we note that ACE actually depends on a minimal subset of the RISC-V Vector Extension (RVV), which we call RVV-mini, for correct operation.
Required features include:

* Support for vector registers sufficiently wide to host the block-wise operations required by the algorithms supported by ACE;
* The `vsetvli` instruction with restricted parameters (e.g., "`vsetvli zero, 4, e32, m1, ta, ma`" for 128-bit-side operations); unsupported configurations must generate defined errors;
* Unit-strided vector loads and stores exclusively; and
* Vector bitwise logical operations such as `vxor`, `vand`, and `vor`.

Moreover,

* floating-point, fixed-point, and most arithmetic vector operations are not required and
* more complex operations for some corner-case cryptographic algorithms may be performed in GPRs, with results then inserted in vector registers via `vins`/`vext`.

RVV-mini must maintain full opcode compatibility with RVV to guarantee that ACE code runs unmodified on full RVV implementations.

// ///////////////////////////////////////////////////////////////////////////////////////////

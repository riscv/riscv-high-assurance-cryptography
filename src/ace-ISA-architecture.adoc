[[ACE-architecture]]
== Architecture

ACE is a complex architecture and relies on certain fundamental concepts, which we succinctly introduce here.
While this leads to some repetitions, we believe that it also brings better clarity to the presentation.

[[ACE-concepts]]
=== Fundamental Concepts and Definitions

Cryptographic Context:::
(((Cryptographic Context)))
The *Cryptographic Context* (CC) is the fundamental concept in ACE.
A CC is an indivisible data structure consisting of a *Metadata* section and a *Content* section, and all cryptographic operations performed by ACE execute within the constraints defined by a CC.
The Metadata's format is fixed, and it specifies the cryptographic algorithm associated with the CC and optional usage control policies.
(((Cryptographic Context, Metadata)))
The Content's format is algorithm-specific, and it holds sensitive material such as keys and internal algorithm state.
(((Cryptographic Context, Content)))
The Metadata require integrity, and only part of it requires confidentiality.
The entire Content requires both.
These requirements are architecturally guaranteed by ACE.

Cryptographic Register:::
(((Cryptographic Register)))
Cryptographic Contexts are realized using *Cryptographic Registers* (CRs).
CRs are architectural containers that safeguard CCs.
A CR is *provisioned* by writing Metadata and Content into it: this operation also binds the Metadata and the Content to form a CC.
A CC can be used for cryptographic operations only while resident in a CR.
Only the ACE unit may access or modify a CC, and any modification may occur only when the CC is in a CR, in accordance with the architecture and the algorithm specified in the Metadata.
CR Content cannot be extracted in a manner that compromises its confidentiality.

Sealed Cryptographic Context:::
(((Cryptographic Context, sealed)))
To support context switching while protecting CCs outside architectural state, a CC may be *exported* from a CR as a *Sealed Cryptographic Context* (SCC).
An SCC is an encrypted and authenticated representation of a CC that can later be *imported* into a CR.
SCC import and export use _Context Sealing Keys_ (CSKs), which may be programmable by M-mode and may depend on *Localities* (see below).
A CC sealed with a given CSK cannot be re-imported using a different CSK, enabling cryptographic domain separation across spatial and temporal
domains.

Object-Orientation:::
(((Cryptographic Context, object-oriented)))
CCs act as *objects* exposing a uniform interface across algorithms.
A CC encapsulates algorithm-specific behavior, enabling interchangeable use of different primitives (e.g., AES-128, AES-256, Калина-128, Калина-256, Кузнечик, SM4, and so on) in identical modes (e.g., ECB, GCM-SIV, XEX/XTS) without requiring changes to compiled code.
SCA-resistant variants are supported transparently.

Usage Control Policy:::
(((Cryptographic Context, usage control)))
(((Cryptographic Context, management operations)))
(((Cryptographic Context, usage operations)))
ACE distinguishes between CC/CR *management* and *usage* operations.
(((Cryptographic Context, export)))
Management operations include *configuration* (e.g., CR provisioning, import of an SCC, cloning or key derivation from one CR to another) and *export* of a CR as an SCC.
Usage operations include cryptographic operations and state change;
key derivation is both a configuration and a usage operation.
(((Cryptographic Context, access)))
All operations represent a form of *access* to CRs.
To prevent denial of service scenarios, management operations must _always_ be permitted, unless the CR is in an invalid state.
Accordingly, the _Usage Control_ policies restrict only certain CC/CR usage operations.
Hence, our use of the term _Usage Control_ instead of _Access Control_.

Locality:::
(((Cryptographic Context, Locality)))
Finally, ACE can bind CCs to a *Locality*, i.e., restrict usage to specific devices, device classes, software or hardware configurations, or boot cycles.
This binding uses Metadata when a CC is in a CR, and augments _Root Context Sealing Key_ (CSK) by a Locality-specific _tweak_.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-extensions-overview]]
=== Extensions Overview

[WARNING]
[.red]#This list is an early draft.#

==== Unprivileged

* `Zlio` {implies} Support for `ace.input`/`ace.output` operations.
* `Zleaes128p` {implies} Support for AES-128 encryption and decryption (all applicable modes)—the `p` at the end denotes a primitive.
* `Zleaes192p` {implies} Support for AES-192 encryption and decryption (all applicable modes).
* `Zleaes256p` {implies} Support for AES-256 encryption and decryption (all applicable modes).
* `Zlsm4p` {implies} Support for SM-4 encryption and decryption (all applicable modes).
* `Zlctrm` {implies} Support for counter mode-the `m` at the end denotes a mode.
* `Zlxctrm` {implies} Support for XCTR mode.
* `Zlgcmm` {implies} Support for GCM mode.
* `Zlgcmsivm` {implies} Support for GCM-SIV mode.
* `Zlxexm` {implies} Support for XEX and XTS modes.
* `Zlocbm` {implies} Support for OCB mode.
* `Zlcmacm` {implies} Support for CMAC.
* `Zlesha2h` {implies} Support for SHA-2 (all applicable modes)—the `h` at the end denotes a hash function.
* `Zlesha3h` {implies} Support for SHA-3 (all applicable modes).
* `Zlsm3h` {implies} Support for SM-3 hash function (all applicable modes).
* `Zlhmacm` {implies} Support for HMAC.
* `Zlascon` {implies} Support for the ASCON suite.
* `Zlkned` {implies} NIST Suite: AES Block Cipher. Depends on `Zleaes128` and `Zleaes256`.
* `Zlkn` {implies} NIST Algorithm Suite. Depends on `Zlkned` and `Zlesha2`.
* `Zlv` {implies} Requires V (or a suitable subset thereof). Must support for the following CSRs: `aceerror` and `acestart` (this is a dependency for Zicsr); must support the following instructions: `ace.prov`, all four forms of `ace.exec`, `ace.clear`, `ace.export`, `ace.import`, and `ace.size`; must support `Zleaes128` and `Zleaes256` in ECB and GCM-SIV modes.
* `Zlio` {implies} Must support for the following CSRs: `aceerror`, `acestart` (this is a dependency for Zicsr), `aceiobuflen` and `aceiobuftop`; must support the following instructions: `ace.prov`, Form D of `ace.exec`, `ace.input` and `ace.output`, `ace.clear`, `ace.export`, `ace.import`, and `ace.size`; must support `Zleaes128` and `Zleaes256` in ECB and GCM-SIV modes.
* At least one of `Zlv` or `Zlio` must be implemented. (Note that, currently, we are not considering a version of ACE that uses the GPRs in place of the vectors registers.)

==== Privileged

* If `Zlv` or `Zlio` are implemented: `misa` must implement the `L` bit, `*status` must implement `ACES`.
* `SmaceCSK` {implies} Defines the Root Context Sealing Key CSRs (`macecsk{0..7}`), which are all MRO.
* `SmaceCSKw` {implies} ACE Root Context Sealing Key CSRs are MRW. Depends on `SmaceCSK`.
* `Smaceosscrt` {implies} Defines the ACE OS Secret CSRs (`macePhysBootSecret{0..3}`).
* `Smacebootscrt` {implies} Defines the ACE Boot Secret CSRs (`haceVirtBootSecret0{0..3}`).
* `Smacestatus` {implies} Defines the ACES per CC CSRs (`scrdirty`, `vscrdirty`, `mcrdirty`).

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-dependencies]]
==== Dependencies on Other Extensions

===== Smcsrind/Sscsrind

We use the Indirect CSR access mechanism defined in Smcsrind/Sscsrind.

===== V

There are two non-mutually exclusive ways ACE can be implemented.
The first way is to provide the inputs and outputs of the ACE instructions through vector registers, and the second way uses an architectural input/output buffer which can be loaded from and stored to memory (ACEIOBUF).

If the ACE implementation supports vector registers, it does not require the full V extension; it depends on a minimal subset, which we call RVV-mini.
(((RVV-mini)))
RVV-mini must maintain full opcode compatibility with RVV: Code written against RVV-mini must run with unmodified behavior under RVV.
The required features are:

* Support for vector registers sufficiently wide to host the block-wise operations required by the implemented algorithms;
* The `vsetvli` instruction with restricted parameters (e.g., “```vsetvli zero,4,e32,m1,ta,ma```” for 128-bit-side operations); unsupported configurations must generate defined errors;
* Unit-strided vector loads and stores exclusively; and
* Vector bitwise logical operations such as `vxor`, `vand`, and `vor`.

Moreover, floating-point, fixed-point, and most arithmetic vector operations are not required, and
more complex operations for some corner-case cryptographic algorithms may be performed in GPRs, with results then inserted in vector registers via `vins`/`vext`.

[WARNING]
[.red]#It is not necessary to define RVV-mini before ratification of ACE begins.
This subset can be defined at a later moment and the ACE specification amended to allow RVV-mini in place of V as a requirement.
This will allow to collect more requirements, such as whether to require, for instance, `vclmul.v[vx]` and `vclmulh.v[vx]` from `Zvbc` or not.#

===== Sdtrig

If we implement Filtering at various modes by ID/context, then we reuse the `scontext`, `mcontext`, and `hcontext` CSRs from Sdtrig.
The rest of Sdtrig is not required per se.

// ///////////////////////////////////////////////////////////////////////////////////////////

=== Programmer-Visible Architectural State

[[ACE-cryptographic-registers]]
==== Cryptographic Registers

{empty}
(((Cryptographic Context)))
ACE defines 32 Cryptographic Registers (CRs), identified by numbers from 0 to 31, and called `K0`, ... , `K31`.
They are architectural, i.e., per-hart.
(((Cryptographic Register File)))
CRs reside in a dedicated _CR file_ (CRF), accessible only by the ACE implementation. Each hart has its own CRF.

CRs differ from conventional register in several ways:

* Clear data is loaded into CR using the `ace.prov` instruction (<<ACE-instruction-init>>), but
there is no corresponding store instruction to extract the same data as clear text.

* A CR can be *exported* in an encrypted and authenticated format using the `ace.export` instruction (<<ACE-instruction-export>>).
This creates a +Sealed Cryptographic Context+ (SCC).
An SCC can be later re-*imported* into a CR using the `ace.import` instruction (<<ACE-instruction-import>>)
but the process may fail if the data in memory was altered.
Conventional registers do not provide such functionality—and do not need to.

* The external and internal representations of a CR may have different sizes.
* Whereas conventional registers always contain a value, CRs can be _unconfigured_, meaning they may hold no information.
* The amount of the capacity of the CRF used by a CR depends on the configured algorithm.
  Two CRs can use different amounts of capacity.
  Insufficient residual CRF capacity may prevent the execution of a CR *configuration* instruction, i.e. `ace.prov`, `ace.import`,
   `ace.clone`, (<<ACE-instruction-clone>>) or `ace.derive` (<<ACE-instruction-derive>>).
  In this case, software must free capacity by unconfiguring other CRs.

* ACE instructions can refer to CRs directly, i.e., with a 5-bit immediate in the instruction encoding, but also indirectly, i.e., through a value in a GPR.

* Only few instructions use and possibly modify CRs.
  The most important ones are:
  ** `ace.exec`, used to perform cryptographic operations on data blocks according to the algorithm configured in a CR; and
  ** `ace.state`, used to move between the different stages of modes of operations and hash functions, possibly performing certain state initialization operations.

Accessing a CR that is outside the range [0..31] raises an illegal instruction error.

[NOTE]
====
The management operations include the *configuration* instructions (`ace.prov`, `ace.import`, `ace.clone`, and `ace.derive`) and the export operation (`ace.export`).
====

[NOTE]
====
CRF capacity is implementation-defined.
Implementations must provide sufficient capacity to allow execution of all operations they support.
The CRF must hold at least an instance of the largest possible CR or the largest CR pair for CR cloning or derivation.
An optional, possibly approximated, and implementation-specific mechanism to estimate the required capacity is defined in <<ACE-instruction-size>>.
====

[NOTE]
====
The fact that CRs can be addressed indirectly has two major implications:

. Adding renaming to CRs would add significant complexity to the microarchitecture.
  However, CRs are much less often redefined than integer or floating-point registers, except for internal implied changes, hence CRs can be renamed without performance issues.
. An additional bit in the instruction encoding determines whether a CR number is given by a 5-bit immediate or by the value in a GPR.
====

[WARNING]
====
VM migration can become an issue when the destination machine has a smaller CRF than the source machine.
In this case, migration could fail, or the VM may have to let some processes terminate abnormally once migrated.
Alternatively, a lazy-loading mechanism can be used to load the CRs on demand, cf. <<ACE-lazy-loading>>.
====

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-iobuf]]
==== ACE Input/Output Buffer

The preferred way to provide inputs and ACE operations and collect their outputs is to use the vector register file of the V extension.
However, ACE also defines an optional input/output buffer (ACEIOBUF) that can be used in place of the vector register file, as explained in <<ACE-usage-input-output>>.

The ACEIOBUF, like the CRs, is architectural, and thus it is a per-hart state.
The ACEIOBUF is not part of any CR.
It can be part of the CRF memory or be a separate memory region internal to the ACE state.

The total length of the ACEIOBUF, `aceiobuflen`, can be fixed or variable.

Its size and the range used in cryptographic instructions are determined by the `aceiobuflen` and `aceiobuftop` CSRs,
defined in <<ACE-CSR-aceiobuflen>> and <<ACE-CSR-aceiobuftop>>.

The support for the vector register file and for ACEIOBUF are not mutually exclusive.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-Metadata]]
==== Metadata Format

For software portability and interoperability, ACE defines two external formats for CCs:

. The _Provisioning Input_ (PI) format, which is loaded into a CR to create a C; and
. The _Sealed Cryptographic Context_ (SCC) (<<ACE-provisioning-export-import>>), an encrypted, authenticated format used when exporting a CR to memory for later re-import.

Both formats rely on the same Metadata format, which is described here.
The PI and SCC formats are described in <<ACE-provisioning-export-import>> and <<ACE-provisioning-export-import>>, respectively.

[WARNING]
The Metadata format is in flux, as it is subject to change based on the ARC feedback.
For instance, in the AEAD method for exporting and importing (<<ACE-SCC-AEAD>>), we could exclusively rely on localities used as tweaks, and eliminate the filtering according to the IDs of processes, VMs and Hypervisors/SDs.

{empty}
(((Cryptographic Context,Metadata)))
(((Cryptographic Context,Metadata,Header)))
CCs contain 64 or 128 bits of Metadata.
The first 64 bits are the Metadata Header, defined in <<ACE-Metadata-header>>, which serves as the header of the data formats used in CR provisioning and in SCC export and import.

[[ACE-Metadata-header]]
.Format of the Metadata Header
[width="100%",cols="^9%,^7%,14%,70%",options="header"]
|===
|   Field | Width | Field                    | Description
|   [0:0] |   1   | _Format_                 | Value is 0 for the current version of the Metadata format.
|  [11:1] |  11   | _Algorithm_              | Cryptographic algorithm (such as primitive, mode, or protocol).
| [13:12] |   2   | _DirectionPolicy_        | Selects the allowed direction(s) for the cryptographic operation.
| [15:14] |   2   | _SCProtection_           | Side-Channel Protected Implementation (0 if not protected, 1 if protected).
| [16:16] |   1   | _KeyType_                |
A value of 0 indicates that the key is expressed as an explicit value in the Content.
A value of 1 indicates a system key that the key is given by an index into an internal, system-specific System Keys Table (SKT).
| [20:17] |   4   | _StateNumber_            | Encoding the current state of the state machine of the algorithm as a number.
| [28:21] |   8   | _Locality_               | A field which is either all zeros or determines a Locality Secret.
| [31:29] |   3   | _UCPolicy_               | “UC Policy” means “Usage Control Policy”. If bit 25, 26, resp., 27 is set, it disallows the _usage_ of this CC in User, (V)S-mode, resp., H-mode.
| [45:32] |  14   | _ExtraContent_           | If non-zero, there is an additional segment of data at the end of the Content.
The length of additional segment is _ExtraContent_ 64-bit blocks. (14 bits allow up to 128 kB of additional data.)
| [63:46] |  18   | _ExpirationDate_         | If this field is non-zero, it is an expiration date on this CC.
|===

////

| [35:32] |   4   | _FilterMode_             | Filters:
Bits 0, resp., 2 = enable the filter below S/VS-mode, resp. M-mode.
Bit 3 = expiration date.
If any of these bits is set, the 64-bit block described in <<ACE-Metadata-extension>> (see <<ACE-combined-filters>>) is appended to the Metadata section.
| [49:36] |  14   | _ExtraContent_           | If non-zero, there is an additional segment of data at the end of the Content.
The length of additional segment is _ExtraContent_ 64-bit blocks. (14 bits allow up to 128 kB of additional data.)
| [63:50] |  14   | Reserved +
(or _MFilter_)  | --
|===

If _ExpirationDate_ is not zero, then the provisioning and SCC data formats contain an additional 64-bit block of Metadata, called the _Metadata Extension_, defined in <<ACE-Metadata-extension>>, and the Reserved bits [63:50] contain the _MFilter_ field instead.
(((Cryptographic Context,Metadata,extension)))

[[ACE-Metadata-extension]]
.Format of the optional Metadata Extension
[width="100%",cols="^9%,^7%,14%,70%",options="header"]
|===
|     Field | Width | Field                   | Description
|    [31:0] |  32   | _SFilter_               | Value to match against `scontext` (least significant 31 bits).
|   [63:32] |  32   | _TFilter_               | Value to match against an expiration date.
|===

[WARNING]
Keeping the process filtering based on matching against field values requires a Metadata Extension.
Alternatively, if we use a cryptography base method instead, _ExpirationDate_ can be reduced to just one bit. We then have 31 bits to use.
13 bits could be used for _ExtraContent_, allowing up to 64 Kb of extra data, and
18 bits could be used for an expiration data with a resolution of a hour, which allows for almost 30 years (2^18^ hours) from the base date.
While this is a limited time span, we do not expect other formats to be used unchanged in, say, 10 or 15 years, and longer formats will accommodate larger time spans.
If we choose this option we then need NO Metadata Extension block.

Some fields and their properties need further explanation. This is done in the following sections.
////

//

[[ACE-Algorithm-field]]
===== Algorithm and DirectionPolicy Fields

Algorithms are encoded in an 11-bit field.
Algorithm numbers 0-1535 are architecture-defined and the list of such encodings is maintained by RVI.
See{nbsp}<<ACE-algorithms>> for the currently encoded algorithms.
The remaining values can be used to encode custom algorithms.

For encryption/decryption primitives or modes, the _DirectionPolicy_ field determines whether the CC may be used for encryption (lower bit), decryption (higher bit), or both.

For certain asymmetric primitives, the _DirectionPolicy_ field determines whether they can be used for signature generation (lower bit), verification (higher bit), or both.

The _DirectionPolicy_ field can be used by other primitives to encode additional algorithm identifiers, thereby expanding the available encoding space of the Algorithms field.

//

[[ACE-SCProtection-field]]
===== SCProtection Field

Certain minimal Side-Channel protection levels are defined by the architecture.
[[ACE-SC-protection-levels]]
.Encoding of Side-Channel Protection levels
[%autowidth,float="center",align="center",options="header"]
|===
| Value | Description
|   0   | No protection.
|   1   | DIEL, (first-order) threshold implementation.
|   2   | DIEL, (first-order) threshold, fault-tolerant implementation.
|   3   | Custom, algorithm dependent.
|===

Custom algorithms may offer stronger side channel protection guarantees than those specified in the encoding values 0 to 2.
In such a case, the value of the _SCProtection_ field must be set to 3.

//

[[ACE-StateNumber-field]]
===== StateNumber Field

The _StateNumber_ field must be zero in a PI.

Some values of _StateNumber_ are architected, and are defined in <<ACE-state-constants-fixed>>.
these include _initial_, _invalid_, and _completed_, which correspond to values 0, 14, and 15.
These denote a CC that is ready to operate, it is in an operational state, is in an invalid state, or has finished its operations.

[[ACE-state-constants-fixed]]
.Constants defining CC states
[float="center",align="center",width="100%",cols="^6%,<26%,<16%,<52%",options="header"]
|===
| Value | Mnemonic for the Constant       | State Name          | Description
|   0   |  ace_state_initial              | _initial_           | The context has just been provisioned or reset, and ready for operation.
|  14   |  ace_state_invalid              | _invalid_           | The algorithm has abnormally terminated or provisioning/import have been interrupted.
|  15   |  ace_state_completed            | _completed_         | The algorithm has completed, not necessarily without error.
|===

All states different from _invalid_ are called _valid_.

Unless explicitly stated otherwise in an algorithm's specification, it is always possible to transition from any valid state to State _initial_.

If an algorithm defines 16 or fewer states (including the four architected ones), the current state number may be stored in the _StateNumber_ field.

For algorithms with more than 16 states, an algorithm-specific representation is stored in the Content.
How to use information is up to the algorithm designer, with the following condition:
StateNumber must always be set to _initial_, _invalid_, and _completed_ if the state of the algorithm corresponds to these states, and to some value other than these three (for instance, 1) if it is in a different state.

// The state values for the symmetric algorithms defined in this specification are listed in <<ACE-state-constants-symmetric>>.

During init and import, the _StateNumber_ field is set to _invalid_, and only at the end of the operation is it set to proper value, i.e., _initial_ or the value in the SCC (see <<ACE-provisioning-export-import>>)
This means, by the rules in <<ACE-invalidation>>, that a partially provisioned/imported CR cannot be exported.
In particular, if a context switch occurs, that the more privileged code must unconfigure the CR, and upon resumption, the instruction will be restarted.  Only an invalid CR with an `acestart` different from zero is recognized as an incomplete CR allowing an init or import operation to resume.

This state change to _invalid_ does not occur during `ace.export`.

////
This state change to _invalid_ does not occur during `ace.export`, but operations that could modify the internal state should not be performed on a CR with an interrupted export operation.
The following situation may occur:

. A process is exporting a threshold CC from a CR.
. The process is interrupted for context switching.
. The privileged code saves the context, exporting each multi-share field as a single share.
. Later, the privileged code re-imports the SCC into a CR.
. This means that the shares have been re-imported with a different randomization.
. When the export operation resumes, it will continue to export the values as single shares, i.e., with the same value.

This works because the actual value of the key is not changed.
However, if any value of the state (such as a counter, or a partial hash value) is altered between the interruption and resumption of an export operation, the resumed export may use an incorrect SIV for the remaining SCC data, causing a subsequent import to fail authentication. This is a general issue with CRs, since more privileged code can use them unless blocked by the _UCPolicy_. We do not consider this a security threat: it affects only SCC availability, not confidentiality or integrity,
and privileged code can always deny resources to user processes.
////

//

[[ACE-Localities]]
===== Locality Field

ACE keeps a table of 128-bit Locality Secrets (LS), the Locality Secrets Table (LST).
Some entries of the LST are fixed or configurable only using an implementation-specific authenticated hardware procedure:
These are global and shared across all ACE units in the same system.
Other entries may be programmed by privileged modes and are architectural, i.e., per hart.
Currently, eleven values in the LST are architected.
The first six Localities tie SCCs to the hardware, and are called the HW Binding Group.
Localities 8 to 10 are the SW Filter Group.

More than one Locality can be active at the same time, with restrictions, and Locality secrets may be combined.
The Locality Secrets are prepended to the string used to compute the SIV in the AEAD algorithm used to export and import CCs.
If the _Locality_ Field of a CC is zero, then no value is prepended.

// The 3 lsbs of the Locality field encodes one of the localities with index 0 to 5 into the LST, with an encoding of 1 to 6, respectively, and an encoded value of 0 means that no binding to a hardware locality is done.
// Bits 3 to 5 determine the use of Localities with index 6, 7, and 8 in the table.
// Bits 6 and 7 are currently unused and reserved for future use. They must be set to 0.

<<ACE-locality-indexes>> lists the architected Localities.
For each _Locality_ we provide the following information: its index in the LST; its _domain_, i.e., whether the value is SoC-wide, device-wide, VM-wide, or per-process; its configurability; the bit field it is encoded into and its value in that field. Seven bits out of the eight bits of the Field are defined. Bit 7 is currently undefined and can be used to define additional Localities.

[[ACE-locality-indexes]]
.Architected Localities
[width="100%",cols="^5%,18%,47%,^9%,^9%,^6%,^6%",options="header"]
|===
|  Idx  | Field                   | Description                                                                      | Domain | Config?|  Bits  | Value
2+|   _No HW Binding_             | Independent of Chip, OEM, Device                                                ^|  --   ^|   --   | [2:0]  |   0
|   0   | ChipDesignerSecret      | Identifies the designer of the SoC. Permanent.                                   |  SoC   |   No   | [2:0]  |   1
|   1   | ChipModelSecret         | Identifies specific chip model/family. Permanent.                                |  SoC   |   No   | [2:0]  |   2
|   2   | ChipSecret              | Unique for each SoC. Permanent.                                                  |  SoC   |   No   | [2:0]  |   3
|   3   | OEMSecret               | Provisioned by OEM   to differentiate their products from the competition.
Permanent, or reconfigurable via a custom hardware authenticated mechanism.                                          | Device |   HW   | [2:0]  |   4
|   4   | ProductSecret           | Identifies device/system type/model (product).
Permanent or reconfigurable like OEMSecret.                                                                          | Device |   HW   | [2:0]  |   5
|   5   | DeviceSecret            | Unique device (entire system) secret.
Shared across all harts in a SoC and shareable across multiple SoCs in a single device using an implementation-defined mechanism.
Reconfigurable like OEMSecret.                                      | Device |   HW   | [2:0]  |   6
|   6   | PhysBootSecret          | Unique per the boot session of the host hardware and its firmware stack.
Configured by M-mode during the boot process of the host (see <<ACE-CSR-macePhysBootSecret>>).                       | Device |   M    |   3    |  0/1
|   7   | VBootSecret             | Unique per the boot session of the virtual hardware and its software stack.
Regenerated by H or higher at each virtual boot of a VM (see <<ACE-CSR-haceVirtBootSecret>>).                        |   VM   |  H/M   |   4    |  0/1
2+|   _No Binding at Modes_       | Independent of M-, S-, or VS-mode filters.                                      ^|  --   ^|   --   | [6:5]  |   0
|   8   | MLocality               | Configurable by M to mutually isolate processes in lower-privileged modes.       |  S/HS  |   M    | [6:5]  |   1
|   9   | HLocality               | Configurable by H to mutually isolate processes in lower-privileged modes.       |  VS    |   H    | [6:5]  |   2
|  10   | SLocality               | Configurable by (V)S to mutually isolate processes in U-mode.                    |  U     |  (V)S  | [6:5]  |   3
|===

An implementation is not required to provide values for all the fields in the HW Binding group.
In this case, an undefined value is transparently replaced with the value associated to the immediately _stricter_ Locality, and so on, as follows:

* ChipSecret <- ChipModelSecret <- ChipDesignerSecret, and
* DeviceSecret <- ProductSecret <- OEMSecret,

where an arrow denotes a possible replacement.

HLocality is only active if the H extension is enabled and V=1. Otherwise, it is a shadow of MLocality.

NOTE: Referencing a key by an index into the System Key Table (SKT) may correspond to keys with unrelated purposes on different devices, leading to unspecified behavior.
Implementations shall set usage policies that are at least as strict as the key's own, and possibly provide a suitable _Locality_ field value to the ACE unit during CR provisioning.

[WARNING]
--
Locality Secrets can be combined. Currently, up to three: A HW Binding Locality, one of either PhysBootSecret or VBootSecret, and one from the SW Filter Group.
Two methods to combine them for the purpose of creating the data to prepend to the SIV computation or verification in AES-GCM-SIV
are: to XOR the values; and to concatenate them (the current choice).
--
//127-bit strings instead and multiply the, but
//in the binary field defined by stem:[P(x)=x^{127}+x+1], this would work as well,

//

[[ACE-UCPolicy-field]]
===== UCPolicy Field

Bit 0, 1, resp., 2 of this field is ignored if U-mode, S-mode, resp. H-mode is not supported/enabled.

////
[[ACE-combined-filters]]
===== ExpirationDate and Filter Fields

If the _ExpirationDate_ field is non-zero, an additional 64-bit block is added to the Metadata to implement filtering according to secrets set by S/VS, HS, and M, and expiration date.

To filter by expiration date is a simple comparison between the current time and the expiration time in the Metadata.
The ACE Unit must have access to a secure clock.
When the current time is beyond the expiration time in the Metadata, the ACE Unit invalidates the CR (see <<ACE-invalidation>>), and the `aceerror` CSR takes the value ace_err_expired_CR (see <<ACE-CSR-ace-error>>).

Filtering by process domain is a simple comparison with the corresponding secret.

Currently, we use `scontext`, `mcontext`, and `hcontext` from the Sdtrig extension, which correspond to 31, 14, and 14 bit fields, respectively.
////

[[ACE-extra-content]]
===== ExtraContent Field

The first eight bytes of the additional information store a copy of the CSR `acemarchid` (<<ACE-CSR-acemarchid>>) of the machine that created the data.

The eight bytes containing `acemarchid` are included in the length recorded by the _ExtraContent_ field.

This value is considered by the implementation performing the import, to determine whether the additional data is usable, and which.

[NOTE]
Examples of extra content are: precomputed point multiples (computing them is usually significantly expensive than encrypting and decrypting them), additional data for side-channel protected implementations (in the case the chosen method for computing multiple shares is expensive, so the key is still saved reconstructed, but additional data may be included to provide the key shares or to help reconstruct them).

[[ACE-Metadata-expiration-date]]
==== ExpirationDate Field

If _ExpirationDate_ is not zero, then it contains the expiration date of this CC expressed as number of hours from the base date (January 1st, 2027).
18 bits are used for an expiration date with a resolution of a hour, which allows for almost 30 years (2^18^ hours) from the base date.
While this is a limited time span, we do not expect other formats to be used unchanged in, say, 10 or 15 years, and extended formats (with the _Format_ field equal to 1) will accommodate larger time spans.

// ////////////////////////////////////////////////////////////////////

[[ACE-CSR-summary]]
==== CSR Summary

ACE extends `*status` and `misa`, and adds up to 10 new CSRs and (up to) 28 indirect CSRs.
//, which are listed in <<ACE-CSRs-table>>.

[[ACE-CSRs-table]]
.New ACE CSRs.
[cols="^12%,^12%,<28%,<48%"]
[float="center",align="center",options="header"]
|===
| Address     | Privilege  | Field                       | Description
| 0xXXX       | URW        | `aceerror`                  | Error code of the last ACE instruction
| 0xXXX       | URW        | `acemarchid`                | ID of the microarchitecture of the ACE unit
| 0xXXX       | SRW        | `scrdirty`                  | Per-CR dirtiness tracking
| 0xXXX       | HRW        | `vscrdirty`                 | Per-CR dirtiness tracking
| 0xXXX       | MRW        | `mcrdirty`                  | Per-CR dirtiness tracking
| 0xXXX       | URW        | `acestart`                  | ACE start byte index (see warning below)
| 0xXXX       | URW        | `aceiobuflen`               | ACE input/output buffer length
| 0xXXX       | URW        | `aceiobuftop`               | ACE input/output buffer limit for current transfers
| 0xXXX       | URO        | `acesequence`               | Sequence number of the last ACE instruction
| 0xXXX       | URW        | `aceactivecr`               | Active CR for `ace.input`/`ace.output`
| (Indirect)  | MRW (RZ)   | `macecsk{0..7}`             | ACE Root Context Sealing Key
| (Indirect)  | MRW (RZ)   | `macePhysBootSecret{0..3}`  | Locality: Physical Boot Session Secret
| (Indirect)  | HRW (RZ)   | `haceVirtBootSecret{0..3}`  | Locality: Virtual Boot Session Secret
| (Indirect)  | MRW (RZ)   | `maceLocality{0..3}`        | Locality: Mutually isolate processes below M-mode
| (Indirect)  | SRW (RZ)   | `haceLocality{0..3}`        | Locality: Mutually isolate processes below H-mode
| (Indirect)  | HRW (RZ)   | `saceLocality{0..3}`        | Locality: Mutually isolate U-mode processes
|===

[WARNING]
====
* For the last CSR groups we use the Indirect CSR Access defined in cite:[RISCV-ISA-Priv] instead.
However, if the ARC so desires, these CSRs can also be configured directly and addresses can be allocated for them.

* `acestart` may be overloaded with `vstart`, regardless of whether the V extension is available.
If a vector instruction is interrupted, the CSR would follow the `vstart` semantics-i.e., it would count the number of processed elements- whereas if an ACE instruction is interrupted, the CSR would follow the `acestart` semantics-i.e., it would count the number of processed bytes.
====

//

==== Extension to existing CSRs

[[ACE-ACE-field-in-misa]]
===== ACE field in `misa`

{empty}
(((CSR, ACE field in `misa`)))
Bit `L` (11) in `misa` indicates that ACE is present.

[[ACE-ACES-field-in-mstatus]]
===== ACE Context Status in `mstatus` and `sstatus`

{empty}
(((CSR,ACES field in *status)))
An ACE context status field, ACES, is added to `mstatus`[26:25] and shadowed in `sstatus`[26:25] (but, see <<ACE-CSR-mcrdirty>>).
It tracks the dirtiness of the ACE state, including the CRs, the ACEIOBUF, and all ACE-specific CSRs.
If ACE is implemented, the ACES field shall not be read-only zero.
The meanings of its values are given in <<ACE-aces-encoding>>.

NOTE: ACES is defined analogously to the floating-point context status field, FS, and to the vector context status field, VS.

[[ACE-aces-encoding]]
.Encoding of ACES status field
[float="center",align="center",width="100%",cols="^8%,<8%,<84%",options="header"]
|===
|Status |Name |Meaning
|   0   | Off                | ACE disabled. The entire ACE state is inaccessible. The hart will trap if the user requests to enable the feature.
|   1   | Initial            | ACE enabled.
|   2   | Clean              | ACE enabled. At least one CR or the ACEIOBUF is configured, and the state matches the last context swap.
|   3   | Dirty              | ACE enabled. At least one CR or the ACEIOBUF, or any ACE-specific CSR may have been modified since the last context swap. This includes unconfigured states since switching code needs to act on them, by erasing any stale saved state.
|===

The transitions between these states are the same as in Table “FS, VS, and XS state transitions” of cite:[RISCV-ISA-Priv].

[NOTE]
Accurate setting of `mstatus.ACES` is an optimization.
Software will typically use ACES to reduce context-swap overhead.

When `mstatus.ACES` is set to Off, executing any ACE instruction raises an illegal instruction exception.

When `mstatus.ACES` is set to Initial or Clean, executing any instruction that changes ACE state will change `mstatus.ACES` to Dirty.
Implementations may also change `mstatus.ACES` from Initial or Clean to Dirty at any time, even when there is no change in ACE state.

If `mstatus.ACES` (`sstatus.ACES`) is Dirty, `mstatus.SD` (`sstatus.SD`) is 1; otherwise, `mstatus.SD` (`sstatus.SD`) is set in accordance with existing specifications.

Writes to any ACES field do not modify the CRs, the ACEIOBUF, or any ACE-specific CSRs.
Clearing state is not performed by setting ACES to Off, Initial, or Clean, and it must be explicitly done before changing ACES.

Implementations may have a writable `misa.L` field. Analogous to the way in which the floating-point unit and the vector unit are handled, the `mstatus.ACES` field may exist even if `misa.L` is clear.

//

[[ACE-ACES-field-H]]
===== ACE Context Status in `vsstatus`

When the H extension is present, an ACE context status field, ACES, is added to `vsstatus`[26:25].
It tracks the dirtiness of the ACE state, including the CRs, the ACEIOBUF, and all ACE-specific CSRs.

NOTE: It is defined analogously to the floating-point context status field, FS, and to the vector context status field, VS.

When V=1:

* Both `vsstatus.ACES` and `mstatus.ACES` are in effect.
* Attempts to execute any ACE instruction raises an illegal instruction exception when either field is set to Off.
* If neither `vsstatus.ACES` nor `mstatus.ACES` is set to Off, executing any instruction that changes ACE state changes both `mstatus.ACES` and `vsstatus.ACES` to Dirty.
* Implementations may also change `mstatus.ACES` or `vsstatus.ACES` from Initial or Clean to Dirty at any time, even when there is no change in ACE state.
* If `vsstatus.ACES` is Dirty, `vsstatus.SD` is 1; otherwise, `vsstatus.SD` is set in accordance with existing specifications.

For implementations with a writable `misa.L` field, the `vsstatus.ACES` field may exist even if `misa.L` is clear.

//

[[ACE-CSR-new-unprivileged]]
==== New Unprivileged CSRs

[[ACE-CSR-ace-error]]
===== `aceerror`

The 8-bit `aceerror` CSR records the error code from the most recent ACE instruction.

Reading it may stall execution until the operation completes.

It is writable for context switching.

We say that some event _raises ACE error_ _some_number_ when it causes `aceerror` to take the value _some_number_.
Other actions may be triggered by the same event, such as raising an exception causing a vertical or a horizontal trap:
The value of `aceerror` may be used by the handler to determine the nature of the error and take appropriate action.

Error codes 0–127 are reserved for RVI, and codes 128–255 are error codes reserved for custom algorithms.
The standard error codes are:

[[ACE-error-codes]]
.Error codes and their meanings
[float="center",align="center",width="100%",cols="^7%,<23%,<70%",options="header"]
|===
|Value | Mnemonic                   | Examples (((ACE, error codes)))
|  0   | ace_err_no_error           | No error.
|  1   | ace_err_import_auth        | Authentication failure with `ace.import`.
|  2   | ace_err_unconfigured       | Use of an unconfigured, or partially configured CR as a source in any instruction except `ace.size`. +
Use of ACEIOBUF as an input or an output when it was unconfigured. +
Use of an out of range CR with indirect addressing.
|  3   | ace_err_invalid_CR         | Attempted to use an _invalid_, but not expired, CR.
|  4   | ace_err_expired_CR         | Attempted to use an expired CR.
|  5   | ace_err_memory             | Insufficient CRF memory for configuration instruction.
|  6   | ace_err_unimplemented      | Not implemented algorithm or variant. +
State number not allowed in current algorithm in `ace.state`.
|  7   | ace_err_invalid_value      | Invalid value, except ace_err_unimplemented (see below).
|  8   | ace_err_privilege          | Violation of usage control policies in Metadata (including Filters).
|  9   | ace_err_auth               | Authentication failure in an algorithm.
|===

ACE error ace_err_invalid_value collects various cases, for instance (but, there could be more):

* Invalid Metadata section in `ace.prov` or `ace.import`, other than ace_err_unimplemented, for instance:
 ** Non-zeros in zero fields,
 ** Non-implemented _Locality_ value,
 ** _StateNumber_ is non-zero for `ace.prov`.
* ACE operation issued with invalid or zero ACEIOBUF length `aceiobuftop`-`acestart` (see <<ACE-CSR-aceiobuftop>> and <<ACE-CSR-acestart>>).
* Invalid input to `ace.restrict`.

// Using an incomplete CC in `ace.size` is allowed.

[WARNING]
[.red]#Optional (need more discussion): ACE error code __i__ corresponds to bit number __i__ in a mask CSR (or more than one) that determines whether the error traps instead of being handled directly by the software by checking# `[.red]#ace.error#`[.red]#. This may be also a horizontal trap (see <<ACE-horizontal-exception-handling>>).#

[comment]
--
[[norm:ace_exc_priority]]
.ACE error priority in decreasing priority order.
[float="center",align="center",width="100%",cols="^9%,>7%,<84%",options="header"]
|===
.>|Priority   .>|Error +
Code        .>|Description
.>|_Highest_  | 7             .>| Attempt to use an invalid CR.
|           .>| 6             .>| Unconfigured or partially configured CR
|           .>| 5, 4          .>| Invalid Metadata section in `ace.prov` or `ace.import`, including specifying a not implemented algorithm or side-channel protected variant.
|           .>| 3             .>| Insufficient CRF memory.
|           .>| 2, 1          .>| Access Control Failure or authentication failure with `ace.import`
|           .>| 1             .>| Authentication failure in an algorithm.
.>|_Lowest_ .>| 0             .>|No error
|===
--

//

[[ACE-CSR-acestart]]
===== `acestart`

`acestart` is an XLEN-bit RW CSR, to track progress of long-running interruptible instructions such as `ace.prov`, `ace.import`, `ace.export`, `ace.exec`, as well as `ace.input` and `ace.output`.
(((CSR, acestart)))

Only the instructions explicitly mentioned above support non-zero `acestart` values; other ACE instructions ignore this register, and will be restarted.

Unlike the vector extension’s `vstart`, which tracks element indices, ACE has no _intrinsic_ notion equivalent to that of vector elements.
`acestart` therefore records a “raw” byte offset.

Hardware typically writes to this register. Software may safely write zero to fully restart an operation, and the register can be saved and restored during context switches. Software must not write arbitrary nonzero values, as the hardware is not required to support all such values.
Doing so may cause an exception.

Provisioning, import, and export operations may be interrupted and resumed if no context switch occurs,
as indicated by the value in the `acestart` CSR.  If a context switch occurs, they must be restarted.

////
[NOTE]
====
_A single `acestart` value suffices due to the way the init/import/export instructions operate:_

* `_ace.prov_` _and_ `_ace.import_` _use a single pass: all blocks are processed sequentially._
* `_ace.export_` _uses two passes. However, the first pass to compute the SIV is purely internal, and never accesses memory, so page faults cannot occur.
This first pass is uninterruptible.
The second pass writes Metadata, the SIV, and then the Content to memory.
Only the second pass can cause page faults and may require resumption._

This design obviates the need to separate data transfer from cryptographic processing during import and export operations. A separate transfer phase would require buffering the entire input within the ACE unit before processing, increasing internal resource requirements, whereas the current architecture can process data inline and load it with minimal overhead.
====
////

Another use of `acestart` arises when an `ace.exec` instruction operates on long vectors containing multiple elements, in which case `VL*SEW` is a multiple of the basic processing unit usually denoted by `b` (such as a block size) in the algorithms. In this situation, `ace.exec` can work iteratively on each block of the input, and execution of `ace.exec` may be interrupted and resumed.
Regardless of whether the operations are on vectors or on the ACEIOBUF, `acestart` reflects the number of bytes processed so far.

The semantics and use of `acestart` are described in <<ACE-provisioning-export-import>>.

The two CSRs described next may be used to optimize saving and restoring the ACEIOBUF.

//

[[ACE-CSR-aceiobuflen]]
===== `aceiobuflen`

`aceiobuflen` is an XLEN-bit RW CSR.

`aceiobuflen` is used to program the size of the ACEIOBUF for `ace.input` and `ace.output`.

Reconfiguring `aceiobuflen` will also zero the buffer.

If `aceiobuflen` is zero, the ACEIOBUF is _unconfigured_ (it does not hold any content, similarly to unconfigured CRs, i.e., CRs in state Initial), and `ace.input` and `ace.output` raise ACE error ace_err_unconfigured.

Writing to `aceiobuflen` may fail if the value is larger than the maximum allowed by the architecture, and raises ACE error ace_err_memory.

If the total length of the ACEIOBUF is fixed in the implementation, this can be discovered by writing an “impossible” value to `aceiobuflen`, namely the all-ones length:
ACE error ace_err_memory is raised, but reading `aceiobuflen` will return the actual length, on which software can therefore act.
This will also configure `aceiobuflen` to the maximum length and therefore set `aceiobuftop` (<<ACE-CSR-aceiobuftop>>) accordingly, and `acestart` to zero.

If the total length of the ACEIOBUF is not fixed, the same operation will also raise ACE error ace_err_memory, and cause `aceiobuflen` to read as zero.
`aceiobuftop` and `acestart` will also be set to zero.

//

[[ACE-CSR-aceiobuftop]]
===== `aceiobuftop`

`aceiobuftop` is an XLEN-bit RW CSR.

`aceiobuftop` is used to program the top end of a transfer operation to and from the ACEIOBUF for the `ace.input` and `ace.output` instructions.

`aceiobuftop` must be {le} `aceiobuflen`.
Setting a larger value raises ACE error ace_err_invalid_value.

`aceiobuftop` must be {ge} `acestart`.
Setting a smaller value raises ACE error ace_err_invalid_value.

In conjunction with `acestart`, `aceiobuftop` defines the range of buffer used in the subsequent operations.

Reconfiguring `aceiobuftop` will not invalidate the buffer contents.

Writing to `aceiobuflen` will set `aceiobuftop` to the same value.

Using the ACEIOBUF while `aceiobuftop`-`acestart` is zero (`aceiobuflen` being non-zero) or an invalid value raises ACE error ace_err_invalid_value.

NOTE: The `aceiobuftop` CSR is an optimization to avoid reconfiguring the ACEIOBUF when algorithms require variable-length inputs.
One such situation may occur when, say, processing 4 or 8 blocks at a time, and at the end of a payload there is a smaller residual number of blocks.
Another example is when providing IVs/nonces. Software can configure the buffer to the maximum size it intends to use and then adjust `aceiobuftop` for shorter operations.
Reconfiguring `aceiobuflen`, instead, would necessitate zeroing the buffer to prevent data leakage and could incur a performance penalty if internal resizing occurs.

//

[[ACE-CSR-acesequence]]
===== `acesequence`

This is an XLEN-bit URW CSR (2 bits defined).

Its value is zero if we are using vector registers for the current ACE instruction.
It may take non-zero values only if using `ace.input`/`ace.output` in place of vector registers, as detailed in <<ACE-usage-input-output>>.

//

[[ACE-CSR-aceactivecr]]
===== `aceactivecr`

This is an XLEN-bit URW CSR (5 bits defined).

It serves to tie the `ace.input`, `ace.output`, `ace.exec`, `ace.state` and `ace.derive` instructions to the state of a specific CR.
It can take values 0 to 31, or 32 to disable the tie.

It can only be changed if `acesequence` is zero, otherwise an illegal instruction exception is raised.

If the value is not 32, then the CR in all single-CR instructions, and the source CR in `ace.derive` or `ace.clone` can only have this value, otherwise an illegal instruction exception is raised.
This serves to make sure that the instructions are issued in the correct order.

//

==== New Privileged CSRs

[[ACE-CSR-acemarchid]]
===== `acemarchid`

`acemarchid` is similar to `marchid`, but it refers to the version of the ACE unit.

[[ACE-CSR-scrdirty]]
===== `scrdirty`

The SXLEN-bit register `scrdirty` tracks the dirtiness of CRs on a per-CR basis.

``scrdirty[__i__]`` can take the values Clean (0), and Dirty (1), for CR #__i__.

``scrdirty[SXLEN-1:32]`` bits are WPRI.

When the privilege mode is S, VS, or U, the following holds:
* When ``scrdirty[__i__]`` is set to Clean, executing any instruction that changes the state of CR #__i__ will change ``scrdirty[__i__]`` to Dirty.
* Implementations may also change ``scrdirty[__i__]`` from Clean to Dirty at any time, even when there is no change in CR #__i__ state.
// The main reason for allowing this is to permit implementations that do not
// track the state and make fields read-only Dirty, but we could also require
// precise tracking and hide the CSRs behind an extension, so implementations
// that don't want to do it just don't implement the extension.

NOTE: Context switching code sees only Clean or Dirty states. To establish whether a CR is actually configured, it can use `ace.size` (<<ACE-instruction-size>>) on a CR. If the instruction returns zero, this means that the CR is not configured, and any stale state for it shall be erased and released.

NOTE: The `scrdirty` CSR does not depend on the S extension.  In an M-U system, M-mode can use the CSR to optimize U-mode context switches.

NOTE: `sstatus.ACES` is also in effect.

[[ACE-CSR-vscrdirty]]
===== `vscrdirty`

NOTE: The `vscrdirty` register exists only when the H extension is implemented.

The VSXLEN-bit register `vscrdirty` tracks the dirtiness of CRs on a per-CR basis.

``vscrdirty[__i__]`` can take the values Clean (0) or Dirty (1), for CR #__i__.

``vscrdirty[VSXLEN-1:32]`` bits are WPRI.

When the privilege mode is VS or VU, the following holds:
* `vscrdirty` substitutes for `scrdirty`, so instructions that normally read or modify `scrdirty` actually access `vscrdirty` instead.
* When ``vscrdirty[__i__]`` is set to Clean, executing any instruction that changes the state of CR #__i__ will change ``vscrdirty[__i__]`` to Dirty.
* Implementations may also change ``vscrdirty[__i__]`` from Clean to Dirty at any time, even when there is no change in CR #__i__ state.

NOTE: `sstatus.ACES`, `vsstatus.ACES`, and `scrdirty` are also in effect when V=1.

[#ACE-CSR-mcrdirty,discrete]
===== `mcrdirty`

[WARNING]
====
(((CSR, mcrdirty)))
A separate `mcrdirty` can be defined, _mutatis mutandis_, like `scrdirty` and `vscrdirty`, to allow M-mode to optimize context switches of Supervisor domains.
In this case, the `ACES` field in `sstatus` shall be unshadowed.

(A `ucrdirty` might become useful if the HFI extension gets approved, together with the fields in an additional `ustatus` CSR.)
====

//
[#discrete]
===== Propagation of `*crdirty` Dirtiness Values

CR status propagates from the least privileged modes to the higher privileged ones, like the FS, VS, and ACES fields in `*status`, but there are only two states: Clean and Dirty.
Any instruction that changes bit #__i__ of, say `vscrdirty`, resp., `scrdirty`, to Dirty, will also set the corresponding bit of `scrdirty` and `mcrdirty`, resp., `mcrdirty`.
Consequently, also the ACES fields of `*status` will record the Dirty state.

[[ACE-CSR-macecsk]]
===== `macecsk` Group

This is an optional group of M-Mode WARZ XLEN-bit CSRs used to configure `macecsk`.
(((CSR, `macecsk`)))
In RV32 there are eight CSRs.
In RV64 there are four CSRs.

A write to the __i__-th CSR sets Bits [(_i_+1) XLEN - 1 : _i_ XLEN] of the CSK.

Any access to `macecsk` outside of M-mode causes an illegal instruction exception.

[NOTE]
====
M-mode firmware must be aware of whether the CSK is configurable, ephemeral, or fixed. For configurable CSKs, persistence mechanisms are implementation-specific and must be handled by M-mode firmware.

Migration of a CSK to any other endpoint—such as the M-mode firmware of a different device, a local TPM for hibernation storage, or a cloud-based HSM for in-flight preservation—requires an authenticated public-key key-wrapping mechanism.

Alternative methods for reconfiguring the CSK are allowed. For example, M-mode may utilize an implementation-defined secure IP block, such as Caliptra cite:[caliptra], to configure the CSK and provide a CSK export mechanism.
====

//

[[ACE-CSR-macePhysBootSecret]]
===== `macePhysBootSecret` Group

This is a group of M-Mode WARZ XLEN-bit CSRs used to configure `macePhysBootSecret`.
These are addressed using Indirect CSR Access.
(((CSR, `macePhysBootSecret`)))
In RV32 there are four CSRs.
In RV64 there are two CSRs.

A write to the __i__-th CSR sets Bits [(_i_+1) XLEN - 1 : _i_ XLEN] of `BootSecret`.

Any access to `macePhysBootSecret` outside of M-mode and Debug mode. causes an illegal instruction exception.

//

[[ACE-CSR-haceVirtBootSecret]]
===== `haceVirtBootSecret` Group

This is a group of H- and VS-Mode WARZ XLEN-bit CSRs used to configure `haceVirtBootSecret`.
These are addressed using Indirect CSR Access.
(((CSR, `haceVirtBootSecret`)))
In RV32 there are four CSRs.
In RV64 there are two CSRs.

A write to the __i__-th CSR sets Bits [(_i_+1) XLEN - 1 : _i_ XLEN] of `haceVirtBootSecret`.

Any access to `haceVirtBootSecret` outside of VS-mode and higher causes an illegal instruction exception.

[NOTE]
====
`haceVirtBootSecret` must be reconfigurable in order to support VM reboots which are independent of the boot cycles of the physical host.
====

//

[[ACE-CSR-maceLocality]]
===== `maceLocality` Group

This is a group of M-Mode WARZ XLEN-bit CSRs, used to configure `maceLocality`.
(((CSR, `maceLocality`)))
In RV32 there are four CSRs.
In RV64 there are two CSRs.

A write to the __i__-th CSR sets Bits [(_i_+1) XLEN - 1 : _i_ XLEN] of `maceLocality`.

Any access to `maceLocality` outside of M-mode and Debug mode raises an illegal instruction exception.

//

[[ACE-CSR-haceLocality]]
===== `haceLocality` Group

This is a group of H-Mode WARZ XLEN-bit CSRs, used to configure `haceLocality`.
(((CSR, `haceLocality`)))
In RV32 there are four CSRs.
In RV64 there are two CSRs.

A write to the __i__-th CSR sets Bits [(_i_+1) XLEN - 1 : _i_ XLEN] of `haceLocality`.

This register group must be implemented if the H extension is implemented.
Any access to `haceLocality` outside of H-mode and higher raises an illegal instruction exception.

// This register group can be useful in systems where M-Mode implements hypervisor-like functionality directly.

//

[[ACE-CSR-saceLocality]]
===== `saceLocality` Group

This is a group of (V)S-Mode WARZ XLEN-bit CSRs, used to configure `saceLocality`.
(((CSR, `maceLocality`)))
In RV32 there are four CSRs.
In RV64 there are two CSRs.

A write to the __i__-th CSR sets Bits [(_i_+1) XLEN - 1 : _i_ XLEN] of `saceLocality`.

The register group is only accessible in S/HS-mode, VS-mode, M-mode, and Debug mode.
Any access to `saceLocality` outside of these modes raises an illegal instruction exception.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-instructions-detailed]]
=== Instructions

[WARNING]
The encodings presented here are not final.
We currently use `custom-0` for load-type instructions, `custom-1` for store-type instructions, and `custom-2` for operational instructions), to align with store/load/operational instructions in the base and FP instruction sets.

ACE provides a number of unprivileged instructions, some implemented as CSR read/write operations.
This section specifies the semantics and encodings of these instructions.

The notation `K[Xd]`, for a GPR `Xd`, refers to the CR whose number is contained in `Xd`, and `Kn|K[Xn]` means that there are two different encodings:
one for when the CR number is passed as a 5-bit immediate (`Kn`) and one for when the value is passed in a GPR `Xn`.
When a GPR is used to index a CR, use of the zero register `X0` is not allowed and results in an illegal instruction exception.

For each instruction, we specify whether:

* It _possibly modifies state_;
* It is _usage-controlled_, i.e., whether the instruction is subject to usage control, which determines which software entities can use it (by _UCPolicy_ and non-time-based _*Filter_);
* It is _trappable_, i.e., whether it can be implemented by privileged code as trap-and-emulate; and
* Whether the execution of the instruction itself can be _interrupted_, for instance by context switches or page faults, to be resumed or restarted later.

NOTE: Trappability refers only to the CPU-side of the implementation and it is a distinct concept from _custom implementations of primitives within the ACE unit_.
Implementers may, for instance, incorporate a secure CPU with updatable firmware to support new primitives.
While the architecture does not prohibit this, such an approach substantially expands the attack surface of the ACE unit.

[[ACE-instruction-init]]
==== ace.prov

_Synopsis_::
Provision Metadata and secrets into a CR.

_Mnemonic_::
`ace.prov Kd|K[Xd], %offset(Xs)`
(((ACE, instruction, ace.prov)))

_Encoding_::
`ace.prov` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'context', attr: ['Kd','K[Xd]'] },
    { bits:  3, name: 'ace.prov', attr: [0x4,0x5] },
    { bits:  5, name: 'Xs' },
    { bits: 12, name: 'immed12', attr: ['offset'] },
]}
....

_Description_::
`ace.prov` provisions a CR with Metadata and Content to create a CC.
`Kd` or `K[Xd]` denotes the CR to be provisioned.
`Xs` points to the region of memory containing the Metadata and the key material.
The PI must be stored at an 8-byte aligned address, and its length must be a multiple of 8 bytes.
+
Similarly to vector store instructions, `ace.prov` appears to other harts as a sequence of individual reads.
+
The operation is described in detail in <<ACE-provisioning-export-import>>.

_Properties_::
Possibly modifies state: *YES*. +
Usage-controlled: *NO*. +
Trappable: *YES*. +
Interruptible: *YES*.

NOTE: `ace.prov`, like `ace.import`, `ace.export`, `ace.input`, and `ace.output`, which are described later, can be viewed as special kinds of load and store instructions, and therefore they do not violate the load/store architecture principle.

//

[[ACE-instruction-clear]]
==== ace.clear/ace.reset

_Synopsis_::
Clears and unconfigures a CR, or the ACE state.

_Mnemonic_::
`ace.clear Kd|K[Xd]` +
(((ACE, instruction, ace.clear)))
`ace.reset`
(((ACE, instruction, ace.reset)))

_Encoding_::
`ace.clear`/`ace.reset` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'context', attr: ['Ks','K[Xd]'] },
    { bits:  3, name: 'ace.clear', attr: [0x4,0x5] },
    { bits:  5, name: 0x0 },
    { bits:  5, name: 0x0 },
    { bits:  7, name: 0x0 },
]}
....

_Description_::
`ace.clear` unconfigures the state of the CR `Kd` or `K[Xd]` and releases its resources in the CRF.
+
`ace.reset` unconfigures all the CRs and the ACEIOBUF.
It uses the encoding for `ace.clear` with indirect CR addressing and `Xd` = `X0`.

_Properties_::
`ace.clear` does not make ```*status.ACES``` Dirty. +
`ace.reset` unconfigures the unit. +
Usage-controlled: *NO*. +
Trappable: +
``{fournbsp}ace.clear``: *NO*; +
``{fournbsp}ace.reset``: *YES* (it can be implemented as multiple `ace.clear` and a write to `aceiobuflen`). +
Interruptible: *NO*.

//

[[ACE-instruction-export]]
==== ace.export

_Synopsis_::
Export a CR as a SCC in memory.

_Mnemonic_::
`ace.export %offset(Xd), Ks|K[Xs]`
(((ACE, instruction, ace.export)))

_Encoding_::
`ace.export` is an S-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'immed[4:0]' },
    { bits:  3, name: 'ace.export', attr: [0x0,0x1] },
    { bits:  5, name: 'Xd' },
    { bits:  5, name: 'context', attr: ['Ks','K[Xs]'] },
    { bits:  7, name: 'immed[11:5]' },
]}
....

_Description_::
Exports the CR `Ks` or `K[Xs]` to memory at address `Xd`, using the procedure described in <<ACE-provisioning-export-import>>.
The SCC must be stored at an 8-byte aligned address, and its length must be a multiple of 8 bytes.
+
The instruction must follow the interruptibility rules defined in <<ACE-CSR-acestart>> and <<ACE-provisioning-export-import>>.
+
Similarly to vector register store instructions, `ace.export` appears to other harts as a sequence of individual stores.
+
The operation is described in detail in <<ACE-provisioning-export-import>>.

_Properties_::
Possibly modifies state: *NO*. +
Usage-controlled: *NO*. +
Trappable: *YES*. +
Interruptible: *YES*.

//

[[ACE-instruction-import]]
==== ace.import/ace.import.S

_Synopsis_::
Import a SCC from memory into a CR.

_Mnemonics_::
`ace.import{nbsp}{nbsp}{nbsp}Kd|K[Xd], %offset(Xn)` +
`ace.import.S{nbsp}Kd|K[Xd], %offset(Xn)`
(((ACE, instruction, ace.import)))
(((ACE, instruction, ace.import.S)))

_Encoding_::
`ace.import` is an I- (or R-) type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'context', attr: ['Kd','K[Xd]'] },
    { bits:  3, name: 'ace.import', attr: ['0    0    S','0    1    S'] },
    { bits:  5, name: 'Xn' },
    { bits: 12, name: 'immed12' },
]}
....

_Description_::
`Kd` or `K[Xd]` denotes the CR into which the SCC is to be imported. +
`Xn` is the GPR containing the base address of the buffer with the source SCC.
The SCC base address must be 8-byte aligned. +
The bit S takes the values 0 (false) or 1 (true).
It is set to true if the key is in a system-defined format
(`ace.import.S`)
and not the format defined by the present architecture
(`ace.import`).
+
`ace.import` must follow the interruptibility rules defined in <<ACE-CSR-acestart>> and <<ACE-provisioning-export-import>>.
Similarly to vector register load instructions, `ace.import` appears to other harts as a sequence of individual loads.
+
The behavior of `ace.import.S` is implementation-defined.
+
The operation is described in detail in <<ACE-provisioning-export-import>>.

NOTE: The instruction encoding includes a single bit to indicate a system-defined format.
If multiple system-defined formats are supported, the system is responsible for distinguishing them.
These formats do not necessarily include the key value itself, they may contain a “recipe” for an implementation-defined mechanism to generate the key.
Such system generated heys are also system-specific. In place of the PI, the provisioning operation reads a system-specific “recipe”, which is not portable.  After internal key generation, the actual key value—not the recipe—is stored in the CR and SCC.
For all keys provisioned using `ace.import.S`, the _KeyType_ field in the Metadata is 0, denoting a key represented by its value.

NOTE: The `ace.export` instruction does not have an `ace.export.S` analog to `ace.import.S`.
This means that system-specific dynamically generated keys can be imported but not exported in the same form: they must be exported in the format architected here for ACE CCs.

_Properties_::
Possibly modifies state: *YES*. +
Usage-controlled: *NO* +
Trappable: *YES*. +
Interruptible: *YES*.

//

[[ACE-instruction-exec]]
==== ace.exec

_Synopsis_::
Perform a cryptographic operation in the ACE unit.

_Mnemonic_::
The `ace.exec` instruction admits four Forms, namely
(((ACE, instruction, ace.exec)))

[upperalpha]
. `ace.exec  Vd, Kn|K[Xn], Vs` {nbsp}{nbsp} takes an input vector and writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}{nbsp}Kn|K[Xn], Vs` {nbsp}{nbsp} takes an input vector but does not write to an output vector.
. `ace.exec  Vd, Kn|K[Xn]{nbsp}{nbsp}{nbsp}{nbsp}` {nbsp}{nbsp} does not take an input but writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}{nbsp}Kn|K[Xn]{nbsp}{nbsp}{nbsp}{nbsp}` {nbsp}{nbsp} does not take an input vector and does not write to an output vector.

// Without this comment, the next part is not properly formatted...

_Encoding_::
`ace.exec` is an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'rd', attr: ['Vd','—','Vd','—'] },
    { bits:  3, name: 0x0, attr: ['ace.exec'] },
    { bits:  5, name: 'rs1', attr: ['Kn|K[Xn]'] },
    { bits:  5, name: 'rs2', attr: ['Vs','Vs','—','—'] },
    { bits:  1, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  1, name: 0x0 },
    { bits:  2, name: 'Form', attr: ['0    0','0    1','1    0','1    1'] },
    { bits:  2, name: 0x0 },
]}
....
+
Bit `r` (i.e., bit 26) takes the value 0 if the context is encoded as an immediate, and it takes the value 1 if a
GPR (scalar integer value) is used to reference it.
+
For the four Forms A–D above, the encodings are:
+
[upperalpha]
. `Form` = `0b00`.
. `Form` = `0b01` and `rd` = `0b00000`.
. `Form` = `0b10` and `rs2` = `0b00000`.
. `Form` = `0b11` and `rs2` = `rd` = `0b00000`.

// To make indent in next line correct

_Description_::
Performs a cryptographic operation such as an encryption or decryption, absorbing a value in a hash,
an elliptic curve point addition or scalar multiplication, etc., and possibly returning a value.
+
If the V extension register file is not implemented, only Form D is supported
(the derived Forms used to define other instructions are still supported) and `ace.input`, `ace.output` must be used to
provide inputs and extract outputs from `ace.exec`.
<<ACE-usage-input-output>> describes how this is done.

_Properties_::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *NO*. +
Interruptible: See interruptibility rules in <<ACE-generic-rules>>.

//

[[ACE-instruction-state]]
==== ace.state

_Synopsis_::
Change the state of the algorithm encoded in the CC in a CR.

_Mnemonic_::
The `ace.state` instruction admits three Forms, namely
(((ACE, instruction, ace.state)))

[upperalpha]
. `ace.state Kd|K[Xd], #immed7{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}` with no auxiliary input.
. `ace.state Kd|K[Xd], #immed7, Xs{nbsp}{nbsp}` with an auxiliary input in a GPR.
. `ace.state Kd|K[Xd], #immed7, Vs{nbsp}{nbsp}` with an auxiliary input in a vector register.

//

_Encoding_::
`ace.state` is an R-type instruction.
+
[wavedrom, ,svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Kd|K[Xd]' },
    { bits:  3, name: 'ace.state', attr: ['0    0    1','0    1    0','0    1    1'] },
    { bits:  5, name: 0x0 },
    { bits:  5, name: 'rs1', attr: ['—','Xs','Vs'] },
    { bits:  7, name: 'immed7' },
]}
....
+
The encodings for the three Forms are:
[upperalpha]
. `ace.state` = `0b001`.
. `ace.state` = `0b010`.
. `ace.state` = `0b011`.

//

_Description_::
The instruction is used to control the state machine of the cryptographic algorithm in CR `Kd` or `K[Xd]`.
The `#immed` operand is a constant from a set of admissible values defined for each algorithm.
The new state number, if allowed, is written into the _StateNumber_ field of the Metadata, unless the algorithm requires more than 16 states, in which case an ad hoc field must be defined in the context (for both internal representation and SCCs).
Optionally, `Xs` or `Vs` contains an auxiliary input.

_Properties_::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *NO*. +
Interruptible: *NO*.

The state numbers used in this specification are defined in <<ACE-state-constants-fixed>> and <<ACE-state-constants-symmetric>>.

It is allowed to repeat `ace.state` instructions to the current state.
When the algorithm needs to prevent this, it will automatically transition to a different state after completing `ace.state`.

//

[[ACE-instruction-error]]
==== ace.error

_Synopsis_::
Return an error code from the ACE unit.

_Mnemonic_::
`ace.error Xd`
(((ACE, instruction, ace.error)))

_Encoding_::
The operations is a CSR read operation.

_Description_::
The ACE Unit may be in an error state due to the previous operation.
`ace.error` is implemented as a read from CSR `aceerror`, which may cause the hart to wait if the error code is not yet available (<<ACE-CSR-ace-error>>).
The error code is written into GPR `Xd`.
The architected error codes are given in <<ACE-error-codes>>.

_Properties_::
Possibly modifies state: *NO*. +
Usage-controlled: *NO*. +
Trappable: *NO*. +
Interruptible: *NO*.

//

[[ACE-instruction-size]]
==== ace.size

_Synopsis_::
Return the size of a CC.

_Mnemonics_::
There are four Forms of the `ace.size` instruction:
(((ACE, instruction, ace.size)))

[upperalpha]
. `ace.size Xd, Ks|K[Xs]` - Size from a context.
. `ace.size Xd, Xs` - Size from Metadata Header.
. `ace.size.internal Xd, Xs` - Internal capacity estimate for a CR.
. `ace.size.iobuf Xd, Xs` - Internal capacity estimate for the ACEIOBUF.

// Without this comment, the next part is not properly formatted...

_Encoding_::
The encoding shares `func3` with `ace.exec`, however with bit 25 (the lsb of `func7`) equal to 1 and the two msbs of `func7` equal to 0.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x0, attr: ['ace.exec'] },
    { bits:  5, name: 'Ks/K[Xs]/Xs' },
    { bits:  5, name: 0x0 },
    { bits:  1, name: 0x1 },
    { bits:  1, name: 'r' },
    { bits:  1, name: 0x0 },
    { bits:  2, name: 'F' },
    { bits:  2, name: 0x0, attr: ['func2'] },
]}
....
+
The `F` field and the `r` bit may assume the following values:

* `F` = `0b00`, `r` = `0` {implies} Form A: Size from a context given as `Ks`.
* `F` = `0b00`, `r` = `1` {implies} Form A: Size from a context given indirectly as `K[Xs]`.
* `F` = `0b01`, `r` = `0` {implies} Form B: Size from Metadata Header.
* `F` = `0b10`, `r` = `0` {implies} Form C: Internal capacity of a CR.
* `F` = `0b11`, `r` = `0` {implies} Form D: Internal capacity of the ACEIOBUF.

_Description_:: {empty}

* Form A `ace.size` returns the total size (in bytes) of the memory buffer that would be necessary to store the exported SCC.
Knowing this size is necessary for any feature that relies on `ace.export`, including context switching.
The instruction returns 0 if the CR is unconfigured.

* Form B `ace.size` returns the total size (in bytes) of an SCC having the Metadata section given in `Xn` into GPR `Xd`, and 0 if the algorithm is not supported.
+
On RV32, `Xs` contains bits [31:0] of the Metadata.  This suffices since they contain all fields required to determine the size of the SCC.

* Form C `ace.size` returns the amount of internal CRF capacity used by a CR with Metadata section matching `Xn` on the _Algorithm_, _SCProtection_, and _KeyType_ Metadata fields. In this case, all other bits must be zero.
If the combination of _Algorithm_, _SCProtection_, and _KeyType_ fields is not supported, `ace.size` returns 0.
If, instead, only the _StateNumber_ is non-zero and its value is 15, resp., 14, `ace.size` returns the total, resp., the remaining internal capacity of the CRF. +
All the values returned by the instruction are expressed in terms of implementation-dependent units, and in principle cannot be compared across different implementations.
+
On RV32, `Xs` contains bits [31:0] of the Metadata (as for the Metadata type instruction).

* Form D: The source register contains the desired byte length of the buffer to be allocated, and the destination register contains the size of the buffer in the ACE unit.

NOTE: In general. no correlation may be assumed between the size of a PI, the corresponding CR's usage of internal resources, and the size of the SCC.
// The size of the SCC can differ significantly from the internal resource usage to store the CC's data in a CR.
// On one hand, there is an overhead due to the SIV.
// On the other hand, in case of threshold implementations, where keys are exported in reconstructed form, or in modes where some derived keys are not exported, the SCC may be smaller than the internal resource usage.

_Properties_::
Possibly modifies state: *NO*. +
Usage-controlled: *NO*. +
Trappable: *NO*. +
Interruptible: *NO*.

//

[[ACE-instruction-available]]
==== ace.avail

_Synopsis_::
Verify whether an algorithm is supported.

_Mnemonic_::
`ace.avail Xd, Xs`
(((ACE, instruction, ace.avail)))

_Encoding_::
`ace.avail` is an alias to Form B of `ace.size`, as the latter returns 0 if the algorithm is not supported.

_Properties_::
Same as `ace.size`.

//

[[ACE-instruction-restrict]]
==== ace.restrict

_Synopsis_::
Restrict the policies encoded in a CC in a CR.

_Mnemonic_::
`ace.restrict{nbsp}{nbsp}Kd|K[Xd], Xs1`
// `ace.restrict{nbsp}{nbsp}Kd|K[Xd], Xs1, Xs2`
(((ACE, instruction, ace.restrict)))

// Without this comment, the next part is not properly formatted...
_Encoding_::
The encoding shares `func3` with `ace.exec`, however with bit 25 equal to 1 and `func2` equal to 1.
It is thus an R-type instruction.
The source register field encodes a GPR and not a vector register.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Kd|K[Xd]' },
    { bits:  3, name: 0x0, attr: ['ace.exec'] },
    { bits:  5, name: 0x0 },
    { bits:  5, name: 'Xs1' },
    { bits:  1, name: 0x1 },
    { bits:  1, name: 'r' },
    { bits:  3, name: 0x0 },
    { bits:  2, name: 0x1, attr: ['func2'] },
]}
....
+
Bit r (i.e., bit 26) takes the value 0 if the context is encoded as an immediate in Bits [11:7], and it takes the value 1 if a
GPR (also encoded in [11:7]) is used to reference it.

// comment

_Description_::
+
--
This instruction can be used to:

* Activate the side-channel protection of the CC or increase it;
* Restrict the use of encryption or decryption in a CC that allows both;
* Restrict the usage of a CC (as stored in a CR) to specific modes or to a specified Filter; and
* Add a Locality.

Let `M` be the Metadata field of the CC in the destination CR.

On RV64, the semantics of the instruction are:

* `Xs` inherits its format from the first 64-bit block of the Metadata section.
Only the fields _DirectionPolicy_, _SCProtection_, _Locality_, _UCPolicy_, and _ExpirationDate_ may be defined.
All other fields must be 0, else ACE error ace_err_invalid_value is raised.

* `Xs`._DirectionPolicy_ is used to set the new _DirectionPolicy_ of the CR.
No operation may be enabled, any attempt to do so raises ACE error ace_err_invalid_value.
In some cases, a zero value is not permitted, such as disabling both encryption and decryption.

* `Xs`._SCProtection_ is used to turn on side-channel protection or raise its level, if such protection is implemented.
Attempting to remove or downgrade side channel protection, or to set a non-implemented level raises ACE error ace_err_invalid_value.

* If `Xs`._Locality_ is non-zero, then it can be used to restrict the Locality. Then, when the CR is exported as a CR, it will use the new tweak in the AEAD mode. Generalizing the Locality is not permitted. Attempting to do so raises ACE error ace_err_invalid_value.

* A zero in any of the three bits `Xs`._UCPolicy_ means that the corresponding policy is _not_ changed. +
A one in any of the three bits `Xs`._UCPolicy_ means that usage by the corresponding mode is not allowed, and the corresponding bit in the Metadata of the destination CC is set to 1.

* A zero value in `Xs`._ExpirationDate_ means that the corresponding policy in `M`._ExpirationDate_ is _not_ changed. +

* A non-zero value in `Xs`._ExpirationDate_ will be copied to `M`._ExpirationDate_, but only if that policy was not already programmed, otherwise error ACE error ace_err_invalid_value is raised.

// If `Xs`._ExpirationDate_ is non-zero, then
// The value `s2` is even and both `Xs2` and `X[s2+1]` are read as the 128-bit value `X[s2+1] @ Xs2`.
// `X[s2+1] @ Xs2` has the Metadata Extension format described in <<ACE-Metadata-extension>>, where only the fields corresponding to the filters actually added are considered.
// and the remaining bits are ignored.

// If `Xs`._ExpirationDate_ is non-zero when `M`._ExpirationDate_ is zero, if the `ace.restrict` operation is successful, an exported SCC will contain the additional Metadata Extension, where previously it would not have been included. Thus, the size of the SCC may be larger than a previous version.
--
+
On RV32:

* `s` must be even, the register pair `X[s]` and `X[s+1]` are read, and `(X[s+1] @ X[s])` replaces `Xs` in the RV64 description.
// * `s2` is a multiple of 4 and both `Xs2`, `X[s2+1]`, `X[s2+2]`, and `X[s2+3]` are read as the 128-bit value `X[s2+3] @ X[s2+2] @ X[s2+1] @ Xs2`, which replaces `X[s2+1] @ Xs2` in the RV64 description.

_Properties_::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *NO*. +
Interruptible: *NO*.

//

[NOTE]
====
This instruction enables several practical use cases:

*   Enabling side-channel protection when supported by the microarchitecture, even if the original CC was not configured with it.
*   Allowing privileged code to give a CC to several processes in a fine-grained manner.
This can be achieved by cloning the CR and customizing the Filter for each clone to an authorized process, or by exporting it with a per-process _SSecret_ Locality.
*   Similarly, enabling privileged code to split a CC capable of both encryption and decryption into two CCs, one only capable of encryption and the other only capable of decryption, thereby creating a one-way channel between processes.

The ability to perform such customizations saves both time and computational resources by avoiding additional round-trips to trusted environments.
====

//

[[ACE-instruction-clone]]
==== ace.clone

_Synopsis_::
Copy a CR into another CR.

_Mnemonic_::
`ace.clone Kd|K[Xd], Ks|K[Xs]`
(((ACE, instruction, ace.clone)))

_Encoding_::
The encoding shares `func3` with `ace.exec`, however with bit 25 equal to 1 and `func2` equal to 2.
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Kd|K[Xd]' },
    { bits:  3, name: 0x0, attr: ['ace.exec'] },
    { bits:  5, name: 'Ks|K[Xs]' },
    { bits:  5, name: 0x0 },
    { bits:  1, name: 0x1 },
    { bits:  2, name: 'R' },
    { bits:  2, name: 0x0 },
    { bits:  2, name: 0x2, attr: ['func2'] },
]}
....
+
Bits [27:26], i.e., field `R`, take the following values depending on how the CRs are given:
+
[upperalpha]
. `00`{nbsp}{nbsp} if the source and the output CRs are both encoded as immediate values.
. `01`{nbsp}{nbsp} if the source CR is encoded as immediate and the output CR is selected using a GPR.
. `10`{nbsp}{nbsp} if the source CR is selected using a GPR and the output CR is encoded as an immediate value.
. `11`{nbsp}{nbsp} if the source and the output CRs are both selected using the values of GPRs.

// Comment to ensure proper indentation in the next Description

_Properties_::
Possibly modifies state: *YES*. +
Usage-controlled: *NO*. +
Trappable: *YES*, it can be implemented as an export followed by an import in a handler. +
Interruptible: *NO*.

_Description_::
Clones source CR `Ks` (or the CR indexed by `Xs`) into destination CR `Kd` (or the CR indexed by `Xd`).

//

[[ACE-instruction-derive]]
==== ace.derive

_Synopsis_::
Derive a CR from a source CR, such as a key derivation.

_Mnemonic_::
The `ace.derive` instruction admits three Forms, namely
(((ACE, instruction, ace.derive)))
[upperalpha]
. `ace.derive Kd|K[Xd], Ks1|K[Xs1] {fournbsp}{nbsp}{nbsp}{nbsp}` with no auxiliary input.
. `ace.derive Kd|K[Xd], Ks1|K[Xs1], Xs2{nbsp}{nbsp}` with an auxiliary input in a GPR.
. `ace.derive Kd|K[Xd], Ks1|K[Xs1], Vs2{nbsp}{nbsp}` with an auxiliary input in a vector register.

//

_Encoding_::
The encoding shares `func3` with `ace.exec`, however with bit 25 equal to 1 and `func2` equal to 3.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x6b, attr: ['custom-2'] },
    { bits:  5, name: 'Kd|K[Xd]' },
    { bits:  3, name: 0x0, attr: ['ace.exec'] },
    { bits:  5, name: 'Ks1|K[Xs1]' },
    { bits:  5, name: 'rs2'},
    { bits:  1, name: 0x1 },
    { bits:  2, name: 'R' },
    { bits:  1, name: 'v' },
    { bits:  1, name: 'g' },
    { bits:  2, name: 0x3, attr: ['func2'] },
]}
....
+
This encoding differs from Form A `ace.exec` by having bit 25 set to 1.
Bits [27:26], i.e., field `R`, is encoded exactly as for `ace.clone` (<<ACE-instruction-clone>>).
Bit 28 determines whether a vector register (or register group) is used to pass an auxiliary parameter to the key derivation mechanism or not.
Bit `v` (i.e., bit 28) is 0 for Forms A and B and 1 for Form C. +
Bit `g` (i.e., bit 29) is used to distinguish Form A, with `g` = 0, from Form B, with `g` = 1. +
The value (`g`,`v`) = (1,1) is currently an illegal instruction and reserved for future use.

_Description_::
Derive a new context from an existing one, with its own opaque key material, for instance using a key derivation mechanism.
The behavior of the instruction is not expected to be deterministic.
It can be used multiple times, to generate multiple derived contexts.

_Properties_::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *NO*. +
Interruptible: *NO*.

//

[[ACE-instruction-input]]
==== ace.input

_Synopsis_::
Load data into the ACEIOBUF.

_Mnemonic_::
`ace.input %offset(Xs), Xl`
(((ACE, instruction, ace.input)))

_Encoding_::
`ace.input` is an S-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'immed[4:0]' },
    { bits:  3, name: 0x4, attr: ['ace.input'] },
    { bits:  5, name: 'Xl' },
    { bits:  5, name: 'Xs' },
    { bits:  7, name: 'immed[11:5]' },
]}
....

_Description_::
In all cases where the vector registers are not sufficiently long, or not implemented, inputs can be read directly from memory and written directly to memory.
For this reason, the architecture defines `ace.input` and `ace.output` (cf. next section).
`ace.input` reads `Xl` bytes from memory starting at address `%offset(Xs)` and copies them to the input buffer, starting at offset `acestart`.
+
If `Xl` == 0, the operation is a NOP. +
`Xl` may not be greater than `aceiobuftop` - `acestart`. +
If `Xl` is greater than `aceiobuftop` - `acestart`, ACE error ace_err_invalid_value is raised.
+
The intended usage of `ace.input` and `ace.output` is explained in detail in <<ACE-usage-input-output>>. +

`ace.output` (see below) and `ace.input` can be used to save and restore the contents of the ACEIOBUF freely as long as ``aceactivecr``'s value is 32, for instance by
context switching code. Also, these operations start at the offset specified in `acestart`, so the state of the buffer can easily be saved and restored with the same approach used for vectors.

_Properties_::
Possibly modifies state: *YES*. +
Usage-controlled: *YES* +
Trappable: *YES*. +
Interruptible: *YES*.

//

[[ACE-instruction-output]]
==== ace.output

_Synopsis_::
Save the contents of the ACEIOBUF to memory.

_Mnemonic_::
`ace.output %offset(Xd), Xl`
(((ACE, instruction, ace.output)))

_Encoding_::
`ace.output` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-0'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x4, attr: ['ace.output'] },
    { bits:  5, name: 'Xl' },
    { bits: 12, name: 'immed' },
]}
....

_Description_::
This is the output operation corresponding to `ace.input`.
`ace.output` writes the contents of the input buffer, starting at offset `acestart`, to memory starting at address `%offset(Xs)`.
+
If `Xl` == 0, the operation is a NOP. +
`Xl` may not be greater than `aceiobuftop` - `acestart`. +
If `Xl` is greater than `aceiobuftop` - `acestart`, ACE error ace_err_invalid_value is raised.

_Properties_::
Possibly modifies state: *YES*. +
Usage-controlled: *YES*. +
Trappable: *YES*. +
Interruptible: *YES*.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-provisioning-export-import]]
=== Provisioning, Export and Import of Cryptographic Contexts

The length of a PI must be a multiple of 8 bytes.
The first 8 bytes contain the Metadata Header, as defined in <<ACE-Metadata>>.
The subsequent bytes form the *Content*—the key material and any algorithm-specific data—whose format and length are specified in <<ACE-algorithms>> for all architected algorithms. The PI Content's size is entirely determined by the _Algorithm_ and _KeyType_ fields within the Metadata.

System Keys are given by an index into an internal, system-specific System Keys Table (SKT), and therefore, in a PI, in place of the key value itself, a 64-bit field is used to store the index.

{empty}
(((Cryptographic Context, Sealed)))
The SCC format is used when exporting a CC from a CR and also to re-import the CC into a CR.
Its size must be a multiple of 8 bytes.
It is dependent on the algorithm being used.
// For the purpose of exporting, the optional Metadata Extension is prepended to the Content.
// The purpose of this separation is to keep the SIV in the same relative place in an SCC.

Format of SCC::: {empty}
`bytes{nbsp}[{nbsp}{nbsp}0 .. 7{nbsp}{nbsp}{nbsp}{nbsp}]{nbsp}{nbsp}` Metadata Header, not encrypted. +
`bytes{nbsp}[{nbsp}{nbsp}8 .. 23{nbsp}{nbsp}{nbsp}]{nbsp}{nbsp}` SIV produced by the encryption method (128 bits). +
`bytes{nbsp}[{nbsp}24 .. u+23{nbsp}]{nbsp}{nbsp}` Encrypted Serialized Content of the CR.

The entire Metadata and Content are authenticated, but only the Content is encrypted.
The AEAD method used for this purpose is described in <<ACE-SCC-AEAD>>.

The Metadata of an SCC-both Header and Extension-follows the same fixed architectural format as the Metadata of the PI.
The Content format—and consequently its length—are algorithm-specific (<<ACE-algorithms>>) and are determined solely by the _Algorithm_, _KeyType_, and _DirectionPolicy_ fields in the Metadata.

For a system key, its actual value is never included in exported Content.
The SCC contains just the index of the key in the SKT, like for the PI.

For threshold implementations, ACE may copy the key material from the SKT into the CR and expand it into multiple shares.

It is permissible to include some of the shares of a system key in a threshold implementation in the optional Additional Data of the content in order to accelerate share reconstruction, provided that the key cannot be reconstruced from these shares.

The Serialized Content section under Data Structures in an algorithm specification (<<ACE-algorithms>>) defines the structure of the `content[]` array.
Architecturally, `content[]` is the serialization of the content of a CR for export as an SCC.

[NOTE]
--
While `content[]` provides a view of (certain fields of) the content of a CR that matches the serialized SCC format, it need not be converted to and from the internal representation and explicitly stored in the ACE unit's memory before export and after import.
`content[]` is a virtual representation: its byte ordering does not imply physical contiguity within the CR, nor is there a direct byte-for-byte correspondence. Changes to `content[]` are reflected in the underlying CR representation (except for excluded fields), and vice versa.

In a threshold implementation, a single key byte in `content[]` may correspond to multiple bytes across the key shares within the CR. Reading that byte may return the XOR of the corresponding bytes in the shares; writing to it may distribute the value across the corresponding bytes in the shares such that their XOR equals the input. These operations may be deferred until the end of an provisioning or import instruction: writing to `context[]` may initially write only to the first share of a key, and at the end of the provisioning or import instruction, the other shares would be generated.
--

[[ACE-size-functions]]
==== Size Functions

Let `mh` be a Metadata Header.
The implementation provides the following functions and constants or an equivalent mechanism:

. `MH_size(mh)` returns the byte length of the Metadata Header. +
In the current specification, it is always 8.
. `PI_content_size(mh)` returns the byte length of the content section of a PI.
//   It does not include the length of the optional Metadata Extension block.
   It depends only on `mh`._Algorithm_, `mh`._DirectionPolicy_, and `mh`._KeyType_.
. `SCC_content_size(mh)` returns the byte length of the fixed part of the content section of an SCC.
   It depends only on  `mh`._Algorithm_, `mh`._DirectionPolicy_, and `mh`._KeyType_.
   It does not include the length of the variable part of the content of length _ExtraContent_ * 8 bytes.
// nor the length of the optional Metadata Extension block.
//.  `ME_size(mh)` returns the byte length of the Metadata Extension. +
//    In the current specification, it is 0 when `mh`._ExpirationDate_ is 0, and it is 8 otherwise.

The total size in bytes of a PI is therefore

`{fournbsp}{fournbsp} MH_size(mh)` + `PI_content_size(mh)`,
// `{fournbsp}{fournbsp} MH_size(mh)` + `ME_size(mh)` + `PI_content_size(mh)`,

and the total size in bytes of an SCC is

`{fournbsp}{fournbsp} MH_size(mh)` + 16 `SCC_content_size(mh)` + _ExtraContent_ * 8.
// `{fournbsp}{fournbsp} MH_size(mh)` + 16 + `ME_size(mh)` + `SCC_content_size(mh)` + _ExtraContent_ * 8.

[[ACE-interruption-points]]
==== Interruption Points

Memory read or write operations are the only admissible points of interruption the provisioning, export and import operations.
The instructions may be interrupted because of a memory exception, and any other type of interrupt must wait for the next memory read or write.
They may resume from the point of interruption only if the control flow is returned to them immediately after the interrupt handler has completed.
The privileged interrupt handler must ensure that the instruction is restarted only in this situation, and in any other circumstance, including context switching, the instruction must be restarted, in which case if the instruction is `ace.prov` or `ace.import` it must also clear the CR.
The implementation will also restart any operation if the internal state of the CR is not in a valid interrupted state.

[WARNING]
====
The initial cryptographic phase of `ace.export` is currently architected to be uninterruptible.
Even if this phase is executed concurrently with other operations, an interrupt handler may need to wait for it to complete before proceeding with any access to the CR.
A very long such phase could become a performance bottleneck for very long SCCs, or cause timing issues. To address this, we could allow the SIV computation to be interrupted and use odd, or negative, values in `acestart` to denote this.
====

//

[[ACE-provisioning]]
==== Provisioning

We start with the algorithm performed by `ace.prov`, which reads a PI and uses it to provision a CR.

[[ACE-provisioning-listing]]
.Provisioning a CR with Metadata and content
[]
----
M : array of bytes // in memory

// PREEMPTIBLE WITH `acestart` IN [0 .. 7]
Metadata : bits(64) = M[0 .. 7]
z ← PI_content_size(Metadata[31:0]);

if (z == 0) { error ace_err_unimplemented; }
if (there is not enough memory for the algorithm encoded in the Metadata) then
   { error ace_err_memory; }
if (Metadata is inconsistent) { error ace_err_invalid_value; }

- Complete Metadata parsing.
// NEXT OPERATION PREEMPTIBLE WITH `acestart` IN [8 .. Z+7]
- Sequentially read and parse the z bytes at M+8.
----

[[ACE-SCC-AEAD]]
==== Export and Import

To export and import CRs we use a the AES-GCM-SIV algorithm cite:[DBLP-journals-iacr-GueronLL17,RFC8452].

[WARNING]
AES-GCM-SIV has been chosen because it only required single passes of data in main memory, reducing the number of external memory accesses.
GCM uses also a single pass but requires separate nonce and tag values, increasing the size of the exported data by one block.

We define the Key Derivation (<<ACE-SCC-RFC8452-derivation>>) function first.
// It is essentially the same function as in RFC8452, but the zeros in each AES256 call are replaced by the 125-bit Locality Secrets.
// (or 126 with <<ACE-SCC-alt-derivation>>).
The generation of an SCC from a CR (<<ACE-SCC-export>>) and the import of an SCC into a CR (<<ACE-SCC-import>>) are defined next.

[[ACE-SCC-RFC8452-derivation]]
.RFC8452 Key Derivation
[]
----
function RFC8452_KeyDeriv(key : bits(256)) = {
  struct {
    AESE256(key, (zeros(125) @ 0b101))[63:0] @ AESE256(key, (zeros(125) @ 0b100))[63:0] @
    AESE256(key, (zeros(125) @ 0b011))[63:0] @ AESE256(key, (zeros(125) @ 0b010))[63:0],
    AESE256(key, (zeros(125) @ 0b001))[63:0] @ AESE256(key, (zeros(125) @ 0b000))[63:0]
  }
}
----

////
An alternative key derivation (<<ACE-SCC-alt-derivation>>) method halves the number of AES256 calls by using, essentially, a CMAC based random generation.
// The scheme is secure for up to 2^126^ encryption key generations with the same CSK.

[[ACE-SCC-alt-derivation]]
.Alternative Key Derivation
[]
----
function double(S : bits(128)) = {
  if (S[127] == 0) {
    (S << 1)[127:0]
  } else {
    (S << 1)[127:0] xor (zeros(120) @ 0x1B)
  }
}

function RFC8452_KeyDeriv(key : bits(256), L : bits(126)) = {
  t ← double(AESE256(key, zeros(128))) // Precomputed
  struct {
     AESE256(key, (L @ 0b00) xor t) @ AESE256(key, (L @ 0b01) xor t),
     AESE256(key, (L @ 0b10) xor t)
  }
}
----
////

NOTE: Due to the computational cost of the derivation functions, implementations may cache recently used derived keys indexed by Locality.

For a Metadata Header `mh`,
`get_localities(mh)` returns a variable length array with zero or more 128-bit values, corresponding to the active localities, ordered by increasing index value, as defined in <<ACE-Localities>>. These are used as a variable length prefix to the POLYVAL computation, to create unique SIV values. Using these as a prefix allows some degree of pre-computation.

The export operation maintains a per-CR flag indicating that an export is in progress.
The reason is that operations that modify the internal state may be performed on a CR with an interrupted export operation pending.
In this case, resuming the export operation may use an incorrect SIV for the remaining SCC data, causing a subsequent import to fail authentication.
Therefore, any operations that modifies the internal state of the CR will also unset this flag.
If an export operation resumes with this flag cleared, it is restarted instead.

[[ACE-SCC-export]]
.Generation of an SCC from a CR
[]
----
& mh : bits(64) = CR.Metadata_header;         // from the CR
CR.exporting : bool;                          // "hidden" per-CR ACE unit state
local SIV : bits(128);
local tmp : bits(128);
local enc_key : bits(256);
local auth_key : bits(128);

// CR.exporting is always false except during export.
CR.exporting = true;

// Note: CR.content[] includes the optional extra content at the end

z : int ← SCC_content_size(mh);
z ← z + mh.ExtraContent * 8;
CR.content : array[z] of bytes;

// In external memory: Metadata Header, then SIV, then Content
M : array[MH_size(mh) + 16 + z] of bytes;
let last_block_fractional : Boolean ← z % 16 != 0;
let num_blocks : int ← ceil(z / 16);

{enc_key, auth_key} ← RFC8452_KeyDeriv(CSK);
L : list ← {} if (mh.Locality == 0) else get_localities(mh.Locality);

// Include Locality "prefix" (zero or more 128-bit blocks)
tmp ← POLYVAL(auth_key, L @ zeros(64) @ mh @ CR.content[]);
SIV ← AESE(enc_key, 0 @ tmp[126:0]);

// FOLLOWING MEMORY WRITE PREEMPTIBLE, `acestart` FROM 0 TO 7
M[0 .. 7] ← mh;

// FOLLOWING MEMORY WRITE PREEMPTIBLE, `acestart` FROM 8 TO 23
M[8 .. 23] ← SIV;

foreach(i from 0 to num_blocks - 1) {
   if ((i == num_blocks - 1) and last_block_fractional)
      // FOLLOWING MEMORY WRITE PREEMPTIBLE, `acestart` FROM 24+i*16 TO 31+i*16
      M[24+i*16 .. 31+i*16] ← CR.content[i*16 .. 7+i*16]
         xor AESE(enc_key, 1 @ SIV[126:32] @ (SIV[31:0] + bin(i, 32) % 2**32)[63:0];
   else
      // FOLLOWING MEMORY WRITE PREEMPTIBLE, `acestart` FROM 24+i*16 TO 39+i*16
      M[24+i*16 .. 39+i*16] ← CR.content[i*16 .. 15+i*16]
         xor AESE(enc_key, 1 @ SIV[126:32] @ (SIV[31:0] + bin(i, 32) % 2**32);
}

CR.exporting ← false;
----

The import algorithm needs some special care:

* The first block read from memory by the operation is the Metadata Header `mh`:
 ** If strictly fewer than 4 bytes are read before the instruction is interrupted, ACE leaves `acestart` at 0, and the instruction will be restarted upon resumption.
 ** If 4 bytes or more have been read, the value of `mh.StateNumber` in the SCC is known. In this case, the instruction may be restarted with `acestart` {ge} 4 recording the amount of data read.

* During the import operation, the hardware saves the `StateNumber` value in the metadata and sets
`mh.StateNumber <- ace_state_invalid` instead until the end of the import operation, where `mh.StateNumber` is set to the correct value.
// ** The flag is also used by the implementation to raise error ace_err_unconfigured instead of ace_err_invalid_CR upon an attempt to use the partially imported CR.
** Since context switching code cannot export a partially imported CR when saving the state, it will clear the CR instead, forcing the hardware to restart the import operation.
** Exceptions that immediately return to the interrupted operation, such as memory exceptions, may cause the hardware to resume the operation instead, if the CR was touched.

// *** The hardware will only resume the import operation if the flag is set, otherwise it will restart the operation.
// CR.importing is always false except during import.
// During import, the original StateNumber is saved and temporarily replaced in the CR
// with ace_state_invalid to prevent any USAGE operations.  Any operation that writes
// to the CR will set CR.importing to false: this allows context switching code to reuse
// the CR and, upon returning to the interrupted import, the hardware will detect
// CR.importing == false and restart the import instead of resume it.  OTOH, if the
// interrupt was caused by a memory exception, the instruction can be resumed.

[[ACE-SCC-import]]
.Importing an SCC into a CR
[]
----
M : array of bytes;         // from memory
CR.saved_SN : bits(4);      // this is a "hidden" per-CR ACE unit state

local enc_key : bits(256);
local auth_key : bits(128);
local SIV : bits(128);
local tmp : bits(128);

// FOLLOWING MEMORY READ PREEMPTIBLE, `acestart` FROM 0 TO 7
tmp[63:0] ← M[0 .. 7]; // read Metadata Header

CR.saved_SN : bits(4) ← tmp[63:0].StateNumber;
CR.Metadata_header ← tmp[63:0];
CR.Metadata_header.StateNumber ← ace_state_invalid;

& mh = CR.Metadata_header;

z ← SCC_content_size(mh);
z ← z + mh.ExtraContent * 8;

if (z == 0) { error ace_err_unimplemented; }
if (there is not enough memory for the algorithm encoded in the Metadata) then
    error ace_err_memory;

num_blocks ← ceil(z / 16);
last_block_fractional : Boolean ← (z % 16 != 0);

{enc_key, auth_key} ← RFC8452_KeyDeriv(CSK);

// Absorb Locality "prefix" (zero or more 128-bit blocks)
tmp ← zeros(128);
L : list ← {} if (mh.Locality == 0) else get_localities(mh.Locality);
foreach(i from 0 to length(L)-1) {
  tmp ← tmp xor L[i];
  tmp ← Montmul(tmp, auth_key);
}

// FOLLOWING MEMORY READ PREEMPTIBLE, `acestart` FROM 8 TO 23
SIV ← M[8 .. 23];
tmp ← tmp xor zeros(64) @ mh;
tmp ← Montmul(tmp, auth_key);

foreach(i from 0 to num_blocks - 1) {
   if ((i == num_blocks - 1) and last_block_fractional) {
      // FOLLOWING MEMORY READ PREEMPTIBLE, `acestart` FROM 24+i*16 TO 31+i*16
      content[i*16 .. 7+i*16] ← M[24+i*16 .. 31+i*16]
         xor AESE(enc_key, 1 @ SIV[126:32] @ (SIV[31:0] + bin(i, 32) % 2**32)[63:0];
      tmp[63:0] ← tmp[63:0] xor content[i*16 .. 7+i*16];
   } else {
      // FOLLOWING MEMORY READ PREEMPTIBLE, `acestart` FROM 24+i*16 TO 39+i*16
      content[i*16 .. 15+i*16] ← M[24+i*16 .. 39+i*16]
         xor AESE(enc_key, 1 @ SIV[126:32] @ (SIV[31:0] + bin(i, 32) % 2**32);
      tmp ← tmp xor content[i*16 .. 15+i*16];
   }
   tmp ← Montmul(tmp, auth_key);
}
tmp ← AESE(enc_key, 0 @ tmp[126:0]);

if (tmp != SIV) { error ace_err_import_auth; }

- Now the content can be deserialized.
- This includes computing any derived values not saved as part of the SCC,
- as well as creating shares for threshold implementations.

// FINALLY, restore the StateNumber from the SCC
mh.StateNumber ← CR.saved_SN;
----

//

[[ACE-invalidation]]
=== Invalid Inputs and Operations, CR Invalidation

{empty}
(((ACE, algorithm, invalid state)))
(((Cryptographic Register, invalidation)))
In certain cases where an invalid input is provided to any ACE instruction, or an instruction that is not explicitly allowed in a given state is executed, while processing the algorithm in CR, say, `Kn`, then `Kn` is *invalidated*. This means that the following happens:

* `Kn` is put into State _invalid_;
* For instructions that refer to `Kn`:
 ** `ace.prov`, `ace.clear`, `ace.reset`, `ace.import`, `ace.export`, `ace.size` and `ace.avail` work normally;
 ** `ace.exec`, `ace.clone`, `ace.derive`, and `ace.restrict` raise an ACE error ace_err_invalid_CR;
 ** `ace.input` and `ace.output` raise an ACE error ace_err_invalid_CR when `aceactivecr` is `Kn`;
 ** `ace.state` raises an ACE error ace_err_invalid_CR, unless it is used to return to State _initial_;
 ** `ace.error` always returns error ace_err_invalid_CR after any operation involving the CR except for `ace.import` and `ace.export`, `ace.clear`, `ace.prov`, and `ace.size`, which all work normally, and using `ace.state` to return to State _initial_.
* The current instruction is terminated.

In State _completed_, only `ace.prov`, `ace.export`, `ace.import`, `ace.clear`, and `ace.error` are permitted.

//

[[ACE-trappable-insns-support]]
=== Trappable (Emulated) Operations

_This section is currently non-normative._

Instructions `ace.prov`, `ace.export`, `ace.import`, `ace.input`, and `ace.output` support long inputs and outputs.
To reduce hardware complexity, these operations can be trapped and emulated in software.
(((ACE, trappable instruction)))
Upon a trap, the handler identifies the trapped instruction and uses `ace.size` on the Metadata to determine the size of the data to be transferred.
Then, the emulation uses custom instructions to move data between the ACE unit and the CPU.
Three types of supporting operations are required:

 * An “`ace.mv`” instruction that loads a specified number of bytes from a GPR or vector register into the state of a CR or in the input buffer within the ACE unit.
   Initially, `ace.size` returns the total payload length to transfer.
   After each move, this value is updated to reflect the remaining bytes.
   The instruction also updates the `acestart` CSR to follow the internal progress.
 * A corresponding “`ace.mv`” instruction that exports a specified number of bytes from a CR or from the input buffer to a GPR or vector register.
   The behavior of `ace.size` will be similar to that of the `ace.mv` instruction, but it will count the number of bytes to be exported.
 * An “`ace.close`” instruction to suspend or finalize the procedure.
   If executed before all bytes are transferred, the CR state matches that of an interrupted monolithic instruction, including any special value of the _StateNumber_ Metadata field and the value of `acestart`. If executed after all bytes are transferred, it also performs any final cryptographic operations, such as authenticating the CR.

All three instructions can be implemented as CSR RW instructions, for instance:

 * `acedest`, XLEN bits wide, determines what architectural state we are transferring to or from: 0..31 for the CRs and, say, 32 for the ACEIOBUF.
 * `acestart`, XLEN bits wide, holds the offset within the CR's virtually serialized `content[]` or the ACEIOBUF.
 * `acecontent`, XLEN bits wide, to which we write the content of the CR or the ACEIOBUF or from which we read the current content.
  A write to `acecontent` increases `acestart` by XLEN/8.

// Interrupting the firmware implementation of `ace.prov`, `ace.export`, `ace.import`, `ace.input`, or `ace.output` must leave the architectural state indistinguishable from the state expected from interrupting a monolithic implementation of the instructions.
// In particular, they need to respect the value of `acestart` and update it in accordance with the expected architected behavior of the emulated instructions.
// The supporting instructions themselves must be uninterruptible.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-horizontal-exception-handling]]
=== Error Handling via Horizontal Traps

_This section is currently informative and non-normative._

ACE has been architected so that in properly written code, the most common executed instructions, namely `ace.exec` and `ace.state`, rarely have to deal with errors.
Errors should occur mostly with configuration operations, caused by insufficient CRF capacity or while authenticating SCCs.

However, revocation of localities or reached expiration dates may cause a CR to suddenly become invalid just before executing an `ace.exec` or `ace.state` instruction.
Requiring software to check for errors after each operation
would impose significant burden on the software and possibly degrade performance.

Horizontal traps can be used to implement a try/catch mechanism:

. At the start of a subroutine that performs a cryptographic protocol, two CSRs are configured with the address of the “catch” code and with a mask with the error types to catch.
. The code is written without considering the exceptions to be caught, usually only ace_err_invalid_CR or ace_err_expired_CR.
. If the code runs without such errors, then the two CSRs are reset and the routine returns normally.
. If, say, an ace_err_invalid_CR or ace_err_expired_CR error is raised, the horizontal trap diverts the control flow to the catch code, which usually cleans up, and returns to the caller of the subroutine, not to the routine itself, with an error code.

The main application of such code is when revocation or expiration cause a CR to become invalid.
In such contexts, it is not the duty of the cryptographic subroutine to resolve the issue, but of the code that makes use of the latter, as the keys may have to be renegotiated, and this may need user intervention.

[WARNING]
From the point of view of the ACE architecture, we need only to define two CSRs and their behaviors.
For this, we may either need to follow the development of the HFI extension or implement a solution that traps to S-mode first and then immediately returns to the catch code. We will discuss this with the ARC.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-algorithms]]
=== Algorithms

_This section is normative._

This section specifies the behavior of the ACE instructions for the supported cryptographic algorithms.
Some specifications define algorithm families that can be instantiated with any primitive meeting the required properties, typically the block size `b` and the key size `k`—such as GCM or GCM-SIV, which are well defined not only with AES but also with other block ciphers, such as SM4.
By contrast, the specifications for other algorithm suites are specific to certain primitives, for instance, Ascon.

==== Definition of an Algorithm in ACE

Each algorithm is fully defined by the following information:

Parameters:::
+
--
These include:

* The _block size_ `b`, which is the size of the basic unit of information processed by the algorithm, usually the block size of the main underlying primitive;
* The _key size_ `k`, for keyed algorithms; and
* Any other parameter (for instance, counter size) that is necessary to instantiate the algorithm with compatible primitives.
--
+

Data Structures:::
+
--
These include:

. *Provisioning Input*:
The data following the Metadata Header in the PI to `ace.prov`, such as keys and other required secrets.
Fields are listed in the order they appear in the PI, each with its length.

. *Internal State*:
Information that must be maintained in the internal state of a CC, besides the information provided by the metadata.
The fields are unordered and their lengths may differ from those listed, for example in threshold or fault-tolerant implementations where redundancy is added.

. *Serialized Content*:
The data that follows the Metadata Header in the plaintext portion of an SCC.
The fields are listed in the order they appear in an SCC, each with its length.
//If there is a Metadata Extension block, it is prepended to the serialized content.
--
+

Algorithm-Specific Functions:::
Any other function that is specific to the algorithm.

State Machine:::
+
--
This includes:

. A list of *states* in which the internal state machine of the logic is executed, together with their representation, either as a number in the range [0..15] or by more complex structures. The values for the architected algorithms conform to <<ACE-state-constants-fixed>> and <<ACE-state-constants-symmetric>>.
. A complete list of the *allowed state transitions*, including the conditions under which each transition is allowed.
. The enumeration of the *allowed instructions* at each state and their *behavior*.
--
+

//

The instructions permitted in each algorithm state are typically `ace.exec` and `ace.state`, though this is not a general rule.
For `ace.exec`, only one of its forms (see <<ACE-instruction-exec>>) is allowed per state, along with the corresponding replacement sequence defined in <<ACE-replacement-instructions>>.
If a Form of `ace.exec`, `ace.state` or `ace.derive` that is not non explicitly allowed in the current algorithm state is used, then an illegal instruction exception is raised.

If a non-allowed state transition is requested in `ace.state`, including requesting encryption or decryption from a CC not allowing it, an ACE error ace_err_unimplemented is raised.  This also invalidates the CR.

Pseudocode is provided to illustrate the software implementation of ACE-supported algorithms using the ACE ISA.
For clarity, the pseudocode generally uses fixed parameters and omits the `ace.exec` Forms A-C replacement sequences.
The examples are non-normative.

[NOTE]
====
In many algorithms, an `ace.exec` or `ace.state` operation could logically imply a state change.
For example, after setting an IV or nonce in an AEAD mode, the instruction might naturally transition to a subsequent state.

To ensure consistent behavior, the ACE architecture favors explicit state transitions via separate instructions, even if this adds instruction count. It is always permissible to issue an `ace.state` instruction that transitions to the current state.

Deviations from these behaviors may be necessary to avoid security issues.
An example is given by the automatic transitions from hash finalization to verification, or from hash verification to the _completed_ state (<<ACE-algorithms>>).
====

//

[[ACE-generic-rules]]
==== Generic Rules

[[ACE-usage-input-output]]
===== Usage of `ace.input` and `ace.output` to Replace Vector Inputs and Outputs

In all algorithms, any occurrence of the “Original Instructions” in <<ACE-replacement-instructions>> may be substituted by the corresponding “Replacement Sequence” where `ace.input` and `ace.output` instructions are used to replace the vector register inputs and outputs.
We do not explicitly write the alternative use of such replacement sequences in the algorithm descriptions for brevity—but they are always allowed if ACEIOBUF is implemented.

// Forms A-C of `ace.exec`, the auxiliary inputs of Form C `ace.state` or of Form C of `ace.derive` in any algorithm, to the point that an implementation of ACE without the V extension or a subset thereof is possible.
// Forms A, B, and C of `ace.exec`, as well as Forms C of both `ace.derive` and `ace.state`, can be replaced by using `ace.input` and `ace.output` instructions together with a Form D `ace.exec`, a Form A `ace.state`, or a Form A `ace.derive` instruction as follows:

[[ACE-replacement-instructions]]
.Replacement sequences for `ace.exec` and `ace.derive` using `ace.input` and `ace.output`
[float="center",align="center",width="100%",cols="<21%,<41%,<38%",options="header"]
|===
| Instruction and Form | Original Instruction          | Replacement Sequence
| `ace.exec`, Form A   | `ace.exec{nbsp}{nbsp}{nbsp}Vd, Kn\|K[Xn], Vs` | `1: ace.input{nbsp}{nbsp}Xl, Vs` +
`2: ace.exec{nbsp}{nbsp}{nbsp}Kn\|K[Xn]` +
`3: ace.output{nbsp}Vd,  Xl`
| `ace.exec`, Form B   | `ace.exec{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}Kn\|K[Xn], Vs`     | `1: ace.input{nbsp}{nbsp}Xl, Vs` +
`2: ace.exec{nbsp}{nbsp}{nbsp}Kn\|K[Xn]`
| `ace.exec`, Form C   | `ace.exec{nbsp}{nbsp}{nbsp}Vd, Kn\|K[Xn]`     | `1: ace.exec{nbsp}{nbsp}{nbsp}Kn\|K[Xn]` +
`2: ace.output{nbsp}Vd,  Xl`
| `ace.state`, Form C  | `ace.state{nbsp}{nbsp}Kd\|K[Xd], #immed, Vs` | `1: ace.input{nbsp}{nbsp}Xl, Vs` +
`2: ace.state{nbsp}{nbsp}Kd\|K[Xd], #immed`
| `ace.derive`, Form C | `ace.derive Kd\|K[Xd], Ks1\|K[Xs1], Vs2` | `1: ace.input{nbsp}{nbsp}Xl, Vs2` +
`2: ace.derive{nbsp}Kd\|K[Xd], Ks1\|K[Xs1]`
|===

The only operations performed by `ace.input` and `ace.output` is to provide the inputs and read out the output of the operations.
The entirety of the computations and internal state changes of the `ace.exec`, `ace.derive`, and `ace.state` operations remains in the `ace.exec`, `ace.derive`, and `ace.state` operations

`ace.input` and `ace.output` may be used if enabled and `aceiobuflen` is non-zero, otherwise an ACE error ace_err_unconfigured is raised.
If `aceiobuflen` is non-zero, and the range size `aceiobuftop` - `acestart` is zero or an invalid size for the algorithm, the `ace.exec` operation is not performed and ACE error ace_err_invalid_value is raised.

In all cases, the `ace.input` and `ace.output` instructions must be temporarily tied to a specific context in order to properly determine the allowed sequences.
This is done by setting the `aceactivecr` CSR (<<ACE-CSR-aceactivecr>>) first. The user must not forget to set it back to 32 after the sequence is completed.

The architecture uses the `acesequence` CSR to track the progress of the replacement sequences.
// of the ACEIOBUF in place of the vector registers to provide the inputs and outputs to ACE instructions.
The initial value of `acesequence` is 0. It remains zero while we are using the forms of `ace.exec`, `ace.derive`, and `ace.state` as their are written in the algorithm specifications.
As soon as one of the following events happens:

. An `ace.input` is completed in place of a Form A or B `ace.exec`, Form C `ace.derive`, or Form C `ace.state`; or
. A Form D `ace.exec` is completed in place of a Form C `ace.exec`,

`acesequence` is set to 1, to denote that the first instruction in the replacement sequence has completed
Then, `acesequence` keeps track of how many instructions of the replacement sequence have been completed.
At the end of the replacement sequence, `acesequence` is reset to 0.

The ordering of the instructions in a replacement sequence is enforced by the architecture according to the value of `acesequence` and the state number of the CR configured in `aceactivecr`.
Not following the instruction ordering raises an illegal instruction exception and invalidates the CR.

`acesequence` can be freely read and written in all modes. For instance, this may allow to repeat `ace.exec` or `ace.state` instructions, but it will not allow the user to manipulate the internal state of the algorithms in a way to compromise it, provided that the algorithm is correctly designed.

In particular, `acesequence` may be saved and restored by privileged code at context switch together with `acestart`.

//

[[ACE-interruptibility]]
===== Interruptibility

Operations performed by `ace.state` are uninterruptible, except when reading vector inputs, where the vector read operation may be interrupted and resumed.

The operation of `ace.exec` on a basic processing unit, in any state of any algorithm, is uninterruptible, even when described as a sequence of instructions.

If the operation accepts an input that is an integer multiple of the basic processing unit, each block is processed uninterruptibly, but the instruction may be interrupted between blocks; the hardware sets `acestart` to the interruption point.

An implementation must wait before accessing a CR that is still asynchronously being written to.

//

[[ACE-notation]]
===== Notation in the Algorithm Descriptions

* `INPUT`: The input data to be processed by the following instructions: `ace.exec`, `ace.state`, `ace.derive`.
   This can be the input vector register, or the ACEIOBUF, as described in <<ACE-usage-input-output>>.

* `OUTPUT`: The output data produced by `ace.exec`.
   This can be the output vector register, or the ACEIOBUF, as described in <<ACE-usage-input-output>>.

* `IOLEN`: Either `VL*SEW` or the length `aceiobuftop` of the ACEIOBUF in bytes, depending on whether vector registers are used or the ACEIOBUF is used.

//

[[ACE-rules-threshold-implementations]]
===== Single-Share Key Export Rule for Threshold implementations

Any CC with its algorithm implemented as a threshold will always provision, import and export _all_ its keys and secrets as _single_, _reconstructed_ _shares_.

The PI and SCC formats will be the same as for the non-threshold implementation variants of the same algorithm, with the only difference being the value of the Side Channel Protection bits in the Metadata.

For the purpose of architecture specification, all values are also always represented as a single share in this document.
Threshold implementations are simply implementation variants of the exact same algorithm.
(((ACE, algorithm, threshold variants)))

NOTE: This rule assumes that reconstructing or re-randomizing a key is a fast operation, such as an ``xor`` with random values.
This requires the ACE execution unit to have access to a random number generator.
Besides ensuring the compactness of an SCC, this rule also guarantees key portability across architectures
that implement side-channel protection in different ways.

//

[[ACE-rules-system-keys]]
===== Representation of System Keys in the Data Structures

System Keys will change all the algorithms described here in the following way:

. In a PI and in an SCC, the key field will contain the index of the key in the SKT in place of the value.
. This field is reduced from the original key size to a 64-bit value. This saves space in an SCC and allows for faster export and import operations.
. For algorithms that require more than one key, such as XEX/XTS, a single index is still used to refer toan entry in the SKT that contains multiple keys—and thus a single 64-bit value in the PI and SCC.

//

==== States for Symmetric Algorithms

The following table, together with <<ACE-state-constants-fixed>>, defines the state names and numbers used by the symmetric algorithms in this specification.

[[ACE-state-constants-symmetric]]
.Constants defining CC states for symmetric algorithms
[float="center",align="center",width="100%",cols="^6%,<26%,<16%,<52%",options="header"]
|===
| Value | Mnemonic for the Constant       | State Name          | Description
.2+| 1  |  ace_state_operate              |  _operate_          |Generic operational state.
<|  ace_state_hash_absorb                 | _hash_absorb_       | Start and initialize a hash function of the tag/MAC part of an algorithm and start absorbing blocks of data (in the case of an AEAD algorithm, this usually is the associated data).
|   2   |  ace_state_hash_last_block      | _hash_last_block_   | In this state additional data may be absorbed, such as partial blocks and lengths, if the hash/tag algorithm processes the last block of its input or of the associated data part of its input in a different way from the other blocks.
|   3   |  ace_state_hash_finalize        | _hash_finalize_     | Finalize the internal state of a hash/tag function.
|   4   |  ace_state_hash_verify          | _hash_verify_       | Compare the internal hash/tag value to the provided one.
|   5   |  ace_state_hash_output          | _hash_output_       | Enter the hash output phase of a hash/tag function.
|   6   |  ace_state_encrypt              | _encrypt_           | In this state encryption is performed, and an update to the tag computation if part of the algorithm.
|   7   |  ace_state_decrypt              | _decrypt_           | In this state decryption is performed, and an update to the tag computation if part of the algorithm.
|   8   |  ace_state_enc_last_block       | _enc_last_block_    | For the encryption path of authenticated encryption modes of operation to process the last block separately.
|   9   |  ace_state_dec_last_block       | _dec_last_block_    | For the decryption path of authenticated encryption modes of operation to process the last block separately.
|  10   |  ace_state_enc_tag_finalize     | _enc_tag_finalize_  | Finalize the tag computation for AE mode encryption.
|  11   |  ace_state_dec_tag_finalize     | _dec_tag_finalize_  | Finalize internal tag computation for AE mode decryption, verify the value.
|  12   |  ace_state_set_aux_value        | _set_aux_value_     | Set a public/auxiliary value in an algorithm.
|===

The value of 1 may indicate both states _operate_ and _hash_absorb_.

NOTE: The `ace.state` instruction used to transition to states _hash_absorb_, _encrypt_, or _decrypt_ often also sets a public value.
For algorithms requiring multiple public values or additional parameters (e.g., tag length), these can be set by transitioning to State _set_aux_value_ using a Form of `ace.state` with an auxiliary argument, i.e., Form B or C.

Algorithms that differ substantially from those described in <<ACE-algorithms>> and are not meant to be handled by the same code may reuse the state values in [1..12] with their own mnemonics and names for their states.

//

[[ACE-ECB-mode]]
==== Electronic Codebook Modes (Direct Encryption/Decryption)

ECB mode cite:[nist-SP-800-38A-1] is the simplest way to use a block cipher.
(((ACE, algorithm, ECB)))

===== Specification

Parameters:::

* `b` = block size (8|`b`). `IOLEN` must be a multiple of `b` (including `b`).
* `k` = key size (8|`k`).

Data Structures:::
* *Provisioning Input*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | `k`/8 or 8      | Key or System Key index
|===
--
+

 * *Internal State*:
 ** `key`: `k` bits.

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
|  Pos. | Size in Bytes   | Field
|   i   | `k`/8 or 8      | Key or System Key index
|===
--
+

Algorithm-Specific Functions:::
* `enc_blk(K,p) -> c` encrypts plaintext block `p` using the key `K`, and returns the ciphertext result `c`.
* `dec_blk(K,c) -> p` decrypts ciphertext block `c` using the key `K`, and returns the plaintext result `p`.

State Machine:::

* *States:*
 ** _initial_: The CC is ready.
 ** _encrypt_: Encrypting blocks of input.
 ** _decrypt_: Decrypting blocks of input.

* *Allowed State Transitions:*
 ** From any valid state to _encrypt_, if encryption is allowed.
 ** From any valid state to _decrypt_, if decryption is allowed.

* *Behavior:*
 ** In State _initial_, no `ace.exec` instruction is allowed.
 ** In States _encrypt_ or _decrypt_, we can only issue Form A `ace.exec` instructions, i.e., +
     “`ace.exec OUTPUT, Kn|K[Xn], INPUT`.”
  *** If the state is _encrypt_, then `OUTPUT <- enc_blk(key, INPUT)`.
  *** If the state is _decrypt_, then `OUTPUT <- dec_blk(key, INPUT)`.
  *** If `IOLEN` > `b`, then “`ace.exec OUTPUT, Kn|K[Xn], INPUT`” encrypts/decrypts block-by-block.
      Here, and in the rest of this document, this means from the blocks in the least significant positions to the most significant positions:
      . `foreach(i from 0 to IOLEN-b by b)` {
      ..   `OUTPUT[i+b-1:i] <- enc_blk(key, INPUT[i+b-1:i])` }

//

[NOTE]
====
Supporting vector lengths smaller than a cipher's block size would not only complicate both the architecture and its implementation, but it would also burden the software using the feature. Therefore, in this case either the user suitably reconfigures the vector lengths, or uses the `ace.input` and `ace.output` instructions.
====

===== Usage

The following pseudocode illustrates how to use an ECB CC to encrypt a block of data using a block cipher with a width of 128 bits (`IOLEN` is also 128).

[[ACE-pseudocode-ECB-encryption]]
.Simple Example: Encryption with no Authentication
----
- Call OS API to get the necessary SCC. Assume X5 points to the SCC.
- Allocate memory for ciphertext buffer.

vsetvli zero, 4, e32, m1, ta, ma           // Use 128-bit vectors
ace.import K0, (X5)                        // Import the SCC into CR K0
ace.error X1                               // Read error from a CSR
if (X1 != 0) then { handle error }         // ACE may fail to validate SCC, algorithm may
                                           // be not supported, or CRF memory may be full
ace.state K0, #ace_state_encrypt           // Configure CR for encryption
ace.error X1                               // Read error from a CSR
if (X1 != 0) then { handle error }         // Error if encryption not allowed

foreach(i from 0 to len_in_bytes(plaintext)/16-1) { // assume plaintext in whole blocks
   V0 ← plaintext[16*i .. 16*i+15]
   ace.exec V0, K0, V0                     // Encrypt one block of the plaintext
   ciphertext[16*i .. 16*i+15] ← V0
}
----

//

[[ACE-chaining]]
==== Chaining/Feedback Modes

There is no need to explicitly architect the behavior of chaining modes, such as Cipher Block Chaining (CBC), Cipher Feedback (CFB) and Output Feedback (OFB) (all defined in cite:[nist-SP-800-38A-1]) as they are easily in software implemented on top of the ECB, with no intermediate value requiring confidentiality.

//

[[ACE-keystream-modes]]
==== CTR/LFSR/XCTR/XLFSR Keystream Generation

In the “non-X” modes, i.e., CTR mode and its analog with an LFSR replacing the arithmetic counter, the sum of the lengths of IV and counter/LFSR equals the block size of the underlying keyed PRP or PRF. IV and counter/LFSR are concatenated to form the input to the latter.
(((ACE, algorithm, keystream generation)))

In the “X” modes, both IV and counter/LFSR have the same size as the block size of the underlying keyed PRP or PRF.
IV and counter/LFSR are ``xor``ed together to form the input to the keyed PRP or PRF.

===== Specification

Parameters:::
* `b` = block size (8|`b`). For this algorithm `IOLEN` must be a multiple of `b`.
* `k` = key size (8|`k`).
* `j` = counter size (8|`j`).
* `n` = IV size (8|`n`).
* If the mode is CTR or LFSR, it is `b = n + j`, else it is `b = n = j`.

Data Structures:::
* *Provisioning Input*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | `k`/8 or 8      | `key` or System Key index
|===
--
+

* *Internal State*:
 ** `key`: `k` bits.
 ** `IV`: `n` bits.
 ** `ctr`: `j` bits.

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
|  Pos. | Size in Bytes   | Field
|    i  | `k`/8 or 8      | `key` or System Key index
|   ii  | `n`/8           | `IV`
|  iii  | `j`/8           | `ctr`
|===
--
+

Algorithm-Specific Functions:::
* `keystream_block(p) -> c` -- usually an encryption function.
* `tick_ctr()` -- updates the `ctr` (either by a modular increment or a LFSR).

State Machine:::
* *States:*
  ** _initial_: The CC is ready.
  ** _operate_: In this state the CC will produce a keystream.

* *Allowed State Transitions:* any.

* *Behavior:*
 ** In State _initial_, the `ctr` and `IV` fields are set to 0 (`ctr` is set to 1 if the algorithm is LFSR-based).

 ** To transition to State _operate_, a Form C ``ace.state`` instruction must be issued.
  *** This sets the value of `IV` to `INPUT`.
  *** If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.

  ** In State _operate_, only Form C ``ace.exec`` instructions are allowed. +
     “```ace.exec OUTPUT, Kn|K[Xn]```” performs:
+
--
  . If in a CTR or LFSR mode then `tmp ← keystream_block(IV @ ctr)`, +
    else (i.e., if in a XCTR or XLFSR mode) `tmp ← keystream_block(IV xor ctr)`,
  . `tick_ctr()`, and
  . `OUTPUT ← tmp`.
--
+
If `IOLEN` is a multiple of `b`, the above three commands are applied to each of the `IOLEN/b` `b`-bit blocks of `INPUT`, producing the corresponding `b`-bit block of `OUTPUT` each time.
// If the number `x` of blocks to be processed in an entire run of the algorithm is not a multiple of `IOLEN`/`b`, `VL` can be set to the remainder of the division of `x` by `IOLEN`/`b` for the last instruction.

Note that if `ace.state` is issued to return to State _initial_, the CC can be reused with a new IV.

===== Usage

Example pseudocode is given in <<ACE-pseudocode-keystream-modes>> (for the case `b` = `IOLEN` = 128).

[[ACE-pseudocode-keystream-modes]]
.Encrypt with Keystream Generation
----
// Acquire payload, initialize
- Info: plaintext = *PT
- Process gets a Keystream Generation CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)

// The next operations set the nonce
V1 ← nonce
ace.state K0, #ace_state_operate, V1

// Compute keystream, use it to encrypt plaintext
foreach(i from 0 to len_in_bytes(PT)/16-1) {
   V0 ← PT[16*i .. 16*i+15]
   ace.exec V1, K0
   V1 ← V1 xor V0
   CT[16*i .. 16*i+15] ← V1
}
----

[[ACE-XEX-XTS-modes]]
==== XEX/XTS modes (one or two keys)

The XTS mode was designed for storage confidentiality cite:[DBLP-journals-ieeesp-Martin10]
and made into a Recommendation by NIST in 2010 cite:[nist-SP-800-38E].
XTS is based on the XEX construction, formalized by Phillip Rogaway cite:[DBLP-conf-asiacrypt-Rogaway04], to design _Tweakable Block Ciphers_ cite:[DBLP-conf-crypto-LiskovRW02].
A Tweakable Block Cipher (TBC) is a block cipher which, besides the key and the plaintext or ciphertext, also takes a tweak as input.
The tweak is used together with the key to select the permutation computed by the block cipher.

The XEX construction builds a TBC `Ẽ` from a block cipher `E`, with key `K`, tweak `T`, and plaintext `P`,  as follows: +
 +
`{fournbsp}{fournbsp}`
`Ẽ(K, T, P) = E(K, P xor M) xor M` `{nbsp}{nbsp}` where `{nbsp}{nbsp}` `M = E(K, T)` `{nbsp}{nbsp}` is called a _mask_. +
 +
In XEX mode, once a mask is computed, it is then updated by using a Galois Multiplication for any successive block instead of updating the tweak and encrypting it again.

The NIST standard uses two different keys, one for the data encryption path and one for the encryption of the tweak.
The use of a single key or two independently sampled keys is determined by the algorithm, and it is not a configuration parameter for the algorithm.
We first define XEX mode functionality.
(((ACE, algorithm, XEX)))

===== Specification

Parameters:::

* `b` = block size (8|`b`). For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = key size (8|`k`).

Data Structures:::

* *Provisioning Input*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
|  Pos. | Size in Bytes   | Field
|   i   | `k`/8 or 8      | `key1` or System Key index
|  ii   | `k`/8 or 0      | `key2` or System Key index for `key1` given
|===
--
+

* *Internal State*:
 ** `key1`: `k` bits.
 ** `key2`: `k` bits -- omitted if only one key is used or if both keys come from an entry in the SKT.
 ** `mask`: `b` bits.

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | `k`/8 or 8      | `key1` or System Key index
|  ii  | `k`/8 or 0      | `key2` or System Key index for `key1` given
| iii  | `b`/8           | `mask`
|===
--
+

Algorithm-Specific Functions:::

* `enc_blk(K, p) -> c` encrypts block `p` using the key `K`, and returns the result `c`.
* `dec_blk(K, c) -> p` decrypts block `c` using the key `K`, and returns the result `p`.
* `update_mask(mask) -> mask` updates the mask by a Galois Field multiplication in GF(2^b^).

State Machine:::

* *States:* _initial_, _encrypt_, and _decrypt_ (defined as before, cf. <<ACE-ECB-mode>>).

* *Allowed State Transitions:*
 ** _initial_ -> _encrypt_, if encryption is allowed.
 ** _initial_ -> _decrypt_, if decryption is allowed.
 ** _encrypt_, _decrypt_ -> _initial_.

* *Behavior:*
 ** In State _initial_:
  *** The `mask` field is set to zero.
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
 ** The ``ace.state`` instruction to transition to either _encrypt_ or _decrypt_ must be of Form C. +
    It sets the tweak, and the `mask` field is used to store it: `mask <- INPUT`.
  *** If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.
  *** Then, the following operations are performed:
  . if two independent keys are used then
  .. `mask <- enc_blk(key2, mask)`
  . else
  ..  `mask <- enc_blk(key1, mask)`
  ..  `mask <- update_mask(mask)`.

  ** In States _encrypt_ and _decrypt_, only ``ace.exec`` instructions of Form A are allowed. +
    “```ace.exec OUTPUT, Kn|K[Xn], INPUT```” performs the following operations:
+
--
  . In State _encrypt_, it computes `OUTPUT = mask xor enc_blk(key1, INPUT xor mask)`. +
    In State _decrypt_, it computes `OUTPUT = mask xor dec_blk(key1, INPUT xor mask)`.
  . `mask <- update_mask(mask)`.
--
+
If `IOLEN` is a multiple of `b`, the above commands are executed `IOLEN/b` times, processing each `b`-bit block of `INPUT` into a `b`-bit block of `OUTPUT`.

//

Note that if `ace.state` is issued to return to State _initial_, the CC can be reused with a new tweak.

===== Usage

We provide only encryption pseudocode, decryption is similar
(also this example assumes `b` = `IOLEN` = 128).

[[ACE-pseudocode-basic-IV-mode]]
.Pseudocode for encryption in any IV-based non-authenticated mode without associated data
----
// Acquire payload and SCC, initialize
- Info: plaintext = *PT
- Call an API to get the corresponding SCC. Assume X5 is the pointer to it.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma          // Use 128-bit vectors
ace.import K0, (X5)

V0 ← IV
ace.state K0, #ace_state_encrypt, V1      // Configure CR for encryption
foreach(i from 0 to ceil(len_in_bytes(PT)/16)-1) {
   V0 ← PT[16*i .. 16*i+15]
   ace.exec V0, K0, V0                    // Encrypt one block of the plaintext
   CT[16*i .. 16*i+15] ← V0
}
----

To implement the XTS mode, the ciphertext stealing part is easy to realize using the XEX algorithm together with vector masking and shifting operations.
(((ACE, algorithm, XTS)))

//

[[ACE-tweakable]]
==== Generic Tweakable Block Ciphers

The specification of a generic tweakable block cipher is similar to that of a non-tweakable block cipher in ECB mode.
Since `ace.exec` does not admit variants with two inputs, and we have a single input buffer, we set the tweak with a separate instruction.
If block and tweak sizes are different, a reconfiguration of the vector length may be required between operations, unless the tweak is shorter than the block size, in which case the instruction setting the tweak will only consider the necessary bits.

Some commonly used TBCs are `Deoxys` cite:[Deoxys-141], `Skinny` cite:[DBLP-conf-crypto-BeierleJKL0PSSS16], `QARMA` cite:[DBLP-journals-tosc-Avanzi17], and ```QARMA```{empty}```v2``` cite:[DBLP-journals-tosc-AvanziBDEGNR23].

===== Specification

Parameters:::

* `b` = block size (8|`b`). For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = key size (8|`k`).
* `t` = tweak size (8|`k`).

Data Structures:::

* *Provisioning Input*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|  i   | `k`/8 or 8      | `key` or System Key index
|===
--
+

* *Internal State*:
 ** `key`: `k` bits.
 ** `tweak`: `t` bits.

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | `k`/8 or 8      | `key` or System Key index
|  ii  | `t`/8           | `tweak`
|===
--
+

State Machine:::

* *States:*
 ** _initial_, _encrypt_, and _decrypt_ defined as before.
 ** _set_aux_value_, for setting the tweak value in the next encryption or decryption operation.

* *Allowed State Transitions:*.
 ** _initial_ -> _set_aux_value_
 ** _set_aux_value_ -> _encrypt_, if encryption is allowed.
 ** _set_aux_value_ -> _decrypt_, if decryption is allowed.

 * *Behavior:*
  ** In State _initial_:
   *** Upon entering the state, the `tweak` field is cleared.
  ** In each state, we can issue Form C `ace.state` instructions, which perform:
   . `tweak` <- `INPUT`, and
   . _Instead of transitioning to state set_aux_value, the state remains unchanged (can be initial, encrypt, or decrypt)._
  ** In State _encrypt_, resp., _decrypt_, besides Form C `ace.state` instructions, only ``ace.exec`` instructions of Form A are allowed, where
     “```ace.exec OUTPUT, Kn|K[Xn], INPUT```” encrypts, resp., decrypts `INPUT` into `OUTPUT`.

This algorithm does not automatically update the tweak value.

[[ACE-GCM-mode]]
==== GCM Mode

The GCM mode was designed by David McGrew and John Viega cite:[DBLP-conf-indocrypt-McGrewV04]
and was made into a NIST Recommendation in 2007 cite:[nist-SP-800-38D].
(((ACE, algorithm, GCM)))

===== Specification

Parameters:::

* `b` = block size (8|`b`). For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = key size (8|`k`).

Data Structures:::

* *Provisioning Input*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | `k`/8 or 8      | `key` or System Key index
|===
--
+

* *Internal State*:
 ** `key`: `k` bits.
 ** `ctr`:  `b` bits.
 ** `auth_key`, `tag`: `b` bits.

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
|  Pos. | Size in Bytes   | Field
|   i   | `k`/8 or 8      | `key` or System Key index
|  ii   | `b`/8           | `ctr`
| iii   | `b`/8           | `tag`
|===
--
+

NOTE: There are no fields for the lengths of the AD and of the plaintext, as they are maintained by the calling software.
Also, `hash_key` is not serialized, and thus it is recomputed upon `ace.import`.

Algorithm-Specific Functions:::

* `enc_blk(key, p) -> c` encrypts block `p` using the key, and returns the result `c`.

* `absorb(data)` absorbs data into the hash function by performing:
  . `tag <- tag xor INPUT`.
  . `tag <- Galoismul(tag, hash_key)`.

State Machine:::

* *States:*
 ** _initial_: The CC is ready.
 ** _hash_absorb_: Process Associated Data (AD) into the tag.
 ** _encrypt_: Encrypt the plaintext and absorb the ciphertext into the tag.
 ** _enc_tag_finalize_: Finalize the encryption tag, prepare to return its value.
 ** _decrypt_: Absorb the ciphertext into the tag and decrypt it.
 ** _dec_tag_finalize_: Finalize the encryption tag and keep it internally.
 ** _hash_verify_: Compare the tag against a user supplied value.
 ** _completed_: The algorithm has completed its operation correctly.

* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_.
 ** _hash_absorb_ -> _encrypt_, if encryption is allowed.
 ** _hash_absorb_ -> _decrypt_, if decryption is allowed.
 ** _encrypt_ -> _enc_tag_finalize_ -> _completed_.
 ** _decrypt_ -> _dec_tag_finalize_ -> _hash_verify_ -> _completed_.

* *Behavior:*
 ** In State _initial_ :
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
  *** The following initialization operations are performed:
   . `hash_key <- enc_blk(key, zeros(b))`,
   . `tag <- zeros(b)`, and
   . `ctr <- zeros(b)`.

 ** To transition to State _hash_absorb_:
 the ``ace.state`` instruction must be a Form C to set the IV, i.e., the fixed part of the counter.
 Then:
   . `ctr <- INPUT @ (b/4-1)b'0 @ 1`, i.e., the `b/4` most significant bits of `INPUT` are ignored, and the `b/4` least significant bits of `ctr` represent the integer 1.
  *** If the ``ace.state`` instruction is repeated, it will just update the counter again.
  *** If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.

 ** If the AD is empty, the transition to State _hash_absorb_ is necessary to initialize the counter.

 ** In State _hash_absorb_, only  ``ace.exec`` instructions of Form B are allowed.
 “```ace.exec Kn|K[Xn], INPUT```” absorbs a data block in `tag`, i.e.:
+
--
 . `absorb(INPUT)`.
--
+
If `IOLEN` > `b`, the above operation is executed `IOLEN/b` times.

** In State _encrypt_, only ``ace.exec`` instructions of Form A are allowed.
   “```ace.exec OUTPUT, Kn|K[Xn], INPUT```” encrypts `INPUT` into `OUTPUT`, and absorbs `OUTPUT` into the `tag`, namely:
+
--
  . If `ctr[b/4-1:0] = 0`, then
  ..  the CR is *invalidated*.
  . else
  .. `tmp <- INPUT xor enc_blk(key, ctr)`.
  .. `absorb(tmp)`.
  .. `ctr[b/4-1:0] <- ctr[b/4-1:0] + 1 % 2^b/4^`.
  .. `OUTPUT <- tmp`.
--
+
If `IOLEN` is a multiple of `b`, the above operations are executed `IOLEN/b` times, encrypting each `b`-bit block of `INPUT` into the corresponding `b`-bit block of `OUTPUT`.

** To transition to State _enc_tag_finalize_, a Form C `ace.state` instruction must be used to provide
the following value, which must be set by the software:
+
--
[none]
* `INPUT <- bin(bit_length(AD), b/2) @ bin(bit_length(plaintext), b/2){nbsp}` .

The authentication tag is computed as follows:

. `absorb(INPUT)`.
  . `tag <- tag xor enc_blk(key, ctr[b-1,b/4] @ zeros(b/4))`.

Finally, `tag` is returned in `OUTPUT`, and the state is changed to _completed_. +
If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.
--
+

** In State _enc_tag_finalize_, only ``ace.exec`` instructions of Form C are allowed. +
  “```ace.exec OUTPUT, Kn|K[Xn]```” writes the `tag` to `OUTPUT`, and the state transitions to _completed_.

** In State _decrypt_, only  ``ace.exec`` instructions of Form A are allowed. +
 ```ace.exec OUTPUT, Kn|K[Xn], INPUT``` absorbs the ciphertext `INPUT` into the `tag`, then decrypts `INPUT` into `OUTPUT`, namely:
+
--
  . If `ctr[b/4-1:0] == 0`, then
  .. the CR is *invalidated*.
  . else
  .. `absorb(INPUT)`.
  .. `OUTPUT  <- INPUT xor enc_blk(key, ctr)`.
  .. `ctr[b/4-1:0] <- ctr[b/4-1:0] + 1`.
--
+
If `IOLEN` is a multiple of `b`, the same behavior applies as in State _encrypt_, namely
the above operations are executed `IOLEN/b` times, decrypting each `b`-bit block of `INPUT` into the corresponding `b`-bit block of `OUTPUT`.

** To transition to State _dec_tag_finalize_, a Form C ``ace.state`` instruction must be used to provide
the following value, which must be set by the software:
+
--
[none]
* `INPUT <- bin(bit_length(AD), b/2) @ bin(bit_length(plaintext), b/2)`

The authentication tag is computed as follows:

. `absorb(INPUT)`.
  . `tag <- tag xor enc_blk(key, ctr[b-1,b/4] @ zeros(b/4))`.
--
+
If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.

** To transition to State _hash_verify_, a Form C ``ace.state`` instruction must be used to provide
the value against which the internally computed tag must be compared:
   If the values match, then `aceerror` is set to ace_err_no_error,
   else an ACE error ace_err_auth is raised.
   The state transitions to _completed_.

** Upon completion of `ace.import`, the ACE unit recomputes `hash_key`, i.e.:
  . `hash_key <- enc_blk(key, zeros(b))`.

//

===== Usage

In <<ACE-pseudocode-GCM-encryption>> we show pseudocode for GCM encryption (again with `b` = `IOLEN` = 128).
The code assumes that both AD and plaintext (or the ciphertext for the decryption) are zero-padded to a multiple of `b` bits, in this case 128 bits.

[[ACE-pseudocode-GCM-encryption]]
.GCM Encryption
----
// Acquire payload, initialize
- Info: authenticated data = *AD, plaintext = *PT
- Process gets a GCM encryption CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)     //  Import, and compute the derived Authentication Key.

// The next operations set the nonce
ace.state K0, #ace_state_set_aux_value
V0 ← nonce
ace.exec K0, V0

// Compute AD contribution to Auth Data
ace.state K0, #ace_state_hash_absorb
foreach(i from 0 to len_in_bytes(AD)/16-1) {
   V0 ← AD[16*i .. 16*i+15]
   ace.exec K0, V0                              // Absorb it into hash
}

// Encrypt plaintext and continue computation of tag
ace.state K0, #ace_state_encrypt
foreach(i from 0 to len_in_bytes(PT)/16-1) {
   V0 ← PT[16*i .. 16*i+15]
   ace.exec V1, K0, V0
   CT[16*i .. 16*i+15] ← V1
}

// Finally, we absorb the lengths into tag, finalize it, and output it
V1 ← bin(len_in_bits(AD), 64) @ bin(len_in_bits(PT), 64)
ace.state K0, #ace_state_enc_tag_finalize, V1
ace.exec V2, K0                                 // V2 contains the finalized hash
----

GCM decryption differs from encryption as follows:
the roles of `PT` and `CT` are reversed,
states _encrypt_ and _enc_tag_finalize_ are replaced by states _decrypt_ and _dec_tag_finalize_,
and the last lines are as follows:

[[ACE-pseudocode-GCM-decryption-difference]]
.GCM Decryption
----
// Finally, we absorb the lengths into tag, finalize it, and verify it
ace.state K0, #ace_state_dec_tag_finalize
V1 ← bin(len_in_bits(AD), 64) @ bin(len_in_bits(CT), 64)
ace.exec V2, K0, V1                             // V2 contains the finalized hash

V1 ← tag_from_payload
ace.state K0, #ace_state_hash_verify, V1
ace.error X1
if (X1 != 0) then { handle error }       // do not use the plaintext if error occurred
----

//

[NOTE]
====
GCM security is not compromised if `H` is revealed.
Consequently, an implementation based on a simpler ECB mode CC is possible, as shown below (for encryption only -- decryption is similar).

However, this significantly increases code size and requires support for carry-less multiplication.
Adding a dedicated mode to the ACE unit is a minor effort, and it allows internal logic to optimize execution beyond the capabilities of, for instance, a compiler on an in-order CPU. It also means that the CPU does not have to implement the carry-less multiplication (<<ACE-dependencies>>), and only a shared ACE unit has to, which saves hardware costs when several small cores share a single ACE unit.

Furthermore, a GCM implementation is necessary to support the use case where the IV is also set in advance and not modifiable by the user.
Thus, we need to be able to configure a GCM CC with both secret key and the IV.
This is described in the next section.
====

////
[[ACE-pseudocode-GCM-encryption-alternate]]
.Implementing GCM encryption using an ECB CC
----
// Acquire payload, initialize
- Info: authenticated data = *AD, plaintext = *PT
- Process gets an ECB encryption CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)                              // Imports SCC into CR K0
V5[127:32] ← IV
V5[31:0] ← zeros(31) @ 1

V3 ← zeros(b)                                    // “Auth Data 1”
ace.exec V4, K0, V3                              // compute H
foreach(i from 0 to ceil(len_in_bytes(AD)/16)-1) {
   V1 ← AD[16*i .. 16*i+15]
   V3 ← V3 xor V1                                // Horner's scheme addition
   V3 ← Galoismul(V4, V3)                        // Horner's scheme multiplication
}

counter ← 1                                      // a 32-bit integer value
foreach(i from 0 to ceil(len_in_bytes(PT)/16)-1) {
   V5[32:0] ← counter
   V1 ← PT[16*i .. 16*i+15]
   ace.exec V2, K0, V5                           // create mask by encrypting the counter
   V1 ← V1 xor V2                                // CTR encrypt
   V3 ← V3 xor V1                                // Horner's scheme addition
   V3 ← Galoismul(V4, V3)                        // Horner's scheme multiplication
   CT[16*i .. 16*i+15] ← V1
   counter ← counter + 1
}

V3 ← V3 xor (len_in_bits(AD) @ len_in_bits(PT))  // Horner's scheme addition
V3 ← Galoismul(V4, V3)                           // Horner's scheme multiplication
V5[31:0] ← zeros(31) @ 1                         // Prepare IV @ 1 for tag encryption
ace.exec V2, K0, V5
tag ← V3 xor V2                                  // Last Horner's scheme add
----
////

[[ACE-GCM-with-IV-mode]]
==== GCM with Set IV

The mode of operation “GCM with a set IV” is a variant of the GCM mode where the initialization vector (IV) is predefined and not generated randomly.
This variant _cannot_ be emulated with an ECB CC because it would reveal the internal data.

The differences between GCM and GCM with Set IV start with the format of the Provisioning Input:

* *Provisioning Input*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
|  Pos. | Size in Bytes   | Field
|   i   | `k`/8 or 8      | `key` or System Key index
|  ii   | 3``b``/32       | `IV`, i.e., bits [b-1:b/4] of the counter
|===
--
+

* *Internal State*:
Same as for GCM.

* *Serialized Content*:
Same as for GCM.

* *State Machine Behavior:*

 ** To transition to State _hash_absorb_:
 the ``ace.state`` instruction must be of Form A, i.e., _without any additional inputs_, since the IV is already included in the PI.

NOTE: For all the following IV- or nonce-based modes, versions with a set IV or nonce (such as for GCM-SIV) can also be similarly defined.
For instance, for GCM-SIV (<<ACE-GCM-SIV-mode>>), `nonce` would be included in the PI exactly as `IV` is included in the PI for GCM, and the transition to _hash_absorb_ would also use a Form A ``ace.state``.
All other semantics would be unchanged.

[[ACE-GCM-SIV-mode]]
==== GCM-SIV Mode

The GCM-SIV mode is described in cite:[DBLP-journals-iacr-GueronLL17] and cite:[RFC8452].

////
The GCM-SIV mode's main differences with GCM are that:

. Both encryption and authentication keys are derived from the main key, whereas in GCM the main key is used also for encryption;
. It is a MAC-then-Encrypt mode, whereas GCM is an Encrypt-then-MAC mode;
. Encryption requires two passes over the plaintext, since the tag computed on the AD and plaintext is used also as the initialization vector for the CTR encryption.
(((ACE, algorithm, GCM-SIV)))

The third difference affects the state machine.
////

While GCM-SIV's decryption state machine is similar to the GCM's, the encryption state machine is different:

* During encryption, the _hash_absorb_ state absorbs the entire associated data and plaintext. The _enc_tag_finalize_ state then absorbs the lengths and produces the SIV/tag. Finally, the _encrypt_ state performs a second pass to encrypt the plaintext using the SIV/tag as the initialization vector.
* During decryption, the _hash_absorb_ state absorbs only the associated data. The _decrypt_ state decrypts the ciphertext and simultaneously absorbs the plaintext into the hash. Finally, the _dec_tag_finalize_ state absorbs the lengths, produces the SIV/tag, and internally compares it to the provided SIV/tag.

===== Specification

Parameters:::

* `b` = block size, (64|`b`). For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = key size (64|`k`).
* It must be `k = b` or `k = 2b`.
* It must be established by the algorithm whether the authentication tag is `b` or `3b/4` bits long.
  In other words, there can be two variants.

Data Structures:::

* *Provisioning Input*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | `k`/8 or 8      | `key` or System Key index
|===
--
+

* *Internal State*:
 ** `key`, `enc_key`: `k` bits.
 ** `auth_key`: `b` bits.
 ** `nonce`: `3b/4` bits.
 ** `ctr`: `b/4` bits.
 ** `tag`: `b` bits.
 ** `SIV`: `b` or `3b/4` bits.
+
A `b`-bit `SIV` is computed by clearing the most significant bit of `tag` and encrypting it. +
For a `3b/4`-bit `SIV`, a full `b`-bit `tag` value is kept while absorbing data.
The public `SIV` value is computed by clearing the most significant bit of `tag`, encrypting it, and then removing the `b/4` least significant bits.

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
|  Pos. | Size in Bytes   | Field
|    i  | `k`/8 or 8      | `key` or System Key index
|   ii  | 3``b``/32       | `nonce`
|  iii  | `b`/32          | `ctr`
|   iv  | `b`/8           | `tag`
|    v  | `b`/8           | `SIV`
|===
--
+

NOTE: The internal state fields `enc_key` and `auth_key` are not serialized, and must be recomputed upon each `ace.import`.

//

Algorithm-Specific Functions:::

* `enc_blk(key, p) -> c` encrypts block `p` using the key, and returns the result `c`.
* `absorb(data)` absorbs data into the hash function by performing a step of (a variant of) GHASH or POLYVAL as specified by the algorithm
   (for instance, AES-GCM-SIV uses POLYVAL):
  . `tag <- tag xor INPUT`.
  . `tag <- Montmul(tag, hash_key)` or `Galoismul(tag, hash_key)`, depending on the algorithm.

State Machine:::
* *States:*
 ** _initial_: The CC is ready.
 ** _set_aux_value:_ Set the value of `nonce`.
 ** _hash_absorb_: Set the SIV and process AD and, if encrypting, also the plaintext into the tag.
 ** _encrypt_: Encrypt the plaintext.
 ** _enc_tag_finalize_: Finalize the tag with the AD and PT lengths, prepare to return its value.
 ** _decrypt_: Absorb the ciphertext into the tag and decrypt it.
 ** _dec_tag_finalize_: Finalize the tag with the AD and CT lengths, then compare it against the `SIV`.
 ** _completed_: The algorithm has completed its operation.

* *Allowed State Transitions:*
 ** _initial_ -> _set_aux_value_ -> _hash_absorb_.
 ** For encryption: _hash_absorb_ -> _enc_tag_finalize_ -> _encrypt_.
 ** For decryption: _hash_absorb_ -> _decrypt_ -> _dec_tag_finalize_ -> _completed_.
 ** Transition to _encrypt_ possible only if encryption is allowed.
 ** Transition to _decrypt_ possible only if decryption is allowed.

* *Behavior:*
 ** In State _initial_ :
  *** Upon entering the state, the following initialization operations are performed:
   . (`enc_key`, `auth_key`) `<-` `RFC8452_RFC8452_KeyDeriv(key)`,
   . `nonce`, `ctr`, `tag`, `SIV <- 0`.
 *** No {nbsp}``ace.exec``{nbsp} operation is allowed.

 *** Upon issuing a Form C ```ace.state Kn|K[Xn], #ace_state_set_aux_value, INPUT``` :
  *** The value of `nonce` is set to `INPUT`.
  *** (If the instruction is repeated, there is no harm, since it just overwrites the `nonce` before any other operation is performed.)

  ** In State _set_aux_value:
*** Upon issuing a Form C ```ace.state Kn|K[Xn], #ace_state_hash_absorb, INPUT```:
+
--
**** The value of `SIV` is set to `INPUT`.
--
+
NOTE: This version of the instruction is meant to be used during decryption.
      It is harmless to invoke it during encryption, however, as the `SIV` field will be overwritten later with the correct synthetic value.

*** Upon issuing a Form A ```ace.state Kn|K[Xn], #ace_state_hash_absorb```:
+
--
**** The `SIV` is not modified (it is assumed to be already zero).
--
+
NOTE: This version of the instruction is meant to be used during encryption.
      If used during decryption, by leaving the `SIV` to zero it will most likely lead to an authentication error.

 ** In State _hash_absorb_, only ``ace.exec`` instructions of Form B are allowed.
   This instruction absorbs its `INPUT` in the `tag`, i.e., it performs `absorb(INPUT)`. +
   If `IOLEN` is a multiple of `b`, `absorb()` is executed on each of the `IOLEN/b` blocks in `INPUT`.

** In State _enc_tag_finalize_, only an {nbsp}``ace.exec``{nbsp} instruction of Form A is allowed.
The value
+
--
[none]
  *** `INPUT <- bin(bit_length(AD), b/2) @ bin(bit_length(plaintext), b/2)`,
--
+
is set by the user.
Then, “```ace.exec```” finalizes the SIV/tag computation by performing:
+
--
  . `absorb(INPUT)`.
  . `tmp <- enc_blk(enc_key, 0 @ (tag xor N)[b-2:0])`
  . If tag length is `b` bits, then
   .. `SIV <- tmp` and `OUTPUT <- tmp`,
  . else (tag length is `3b/4` bits)
   .. `SIV <- tmp[b-1:b/4]` and `OUTPUT <- (tmp >> b/4)`.
--
+

If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.

 ** In State _encrypt_, only  ``ace.exec`` instructions of Form A are allowed, namely “```ace.exec OUTPUT, Kn|K[Xn], INPUT```,” to encrypt `INPUT` into `OUTPUT` as follows:
+
--
. If `ctr == 0`, then the CR is *invalidated*.
   . If the `SIV` is `b`-bits long, then
     .. ``OUTPUT <- INPUT `` +
        ``{fournbsp}{fournbsp}xor enc_blk(enc_key, 1 @ SIV[b-2:b/4] @ (SIV[b/4-1:0] + ctr % 2^b/4^)),``
   . else (the `SIV` is `3b/4`-bits long)
      .. ``OUTPUT <- INPUT xor enc_blk(enc_key, 1 @ SIV[3b/4-2:0] @ ctr``.
   . `ctr <- ctr + 1`.
--
+
If `IOLEN` > `b`, the above operations are applied to each of the `IOLEN/b` blocks in `INPUT`.

 ** In State _decrypt_,  only Form A ``ace.exec`` instructions are allowed. “```ace.exec OUTPUT, Kn|K[Xn], INPUT```” decrypts `INPUT` into `OUTPUT` and then absorbs the plaintext `OUTPUT` into the `tag`:
+
--
     . If `ctr == 0`, then the CR is *invalidated*.
     . If the `SIV` is `b`-bits long, then +
       .. ``OUTPUT <- INPUT `` +
          ``{fournbsp}{fournbsp}xor enc_blk(enc_key, 1 @ SIV[b-2:b/4] @ (SIV[b/4-1:0] + ctr % 2^b/4^))``,
     . else (it is `3b/4`-bits long) +
       .. ``OUTPUT <- INPUT xor enc_blk(enc_key, 1 @ SIV[3b/4-2:0] @ ctr``.
     . `absorb(OUTPUT)`.
     . `ctr <- ctr + 1`.
--
+
If `IOLEN` > `b`, the above operations are applied to each of the `IOLEN/b` blocks in `INPUT`.

 ** In State _dec_tag_finalize_,
   only an ``ace.exec`` instruction of Form B, is allowed,
   namely “```ace.exec Kn|K[Xn], INPUT```,” where it is the responsibility of the user to set
+
--
[none]
  ***  `INPUT <- bin(bit_length(AD), b/2) @ bin(bit_length(plaintext), b/2)`.
--
+
``ace.exec`` then performs the following operations:
+
--
  . `absorb(INPUT)` (which modifies `tag`).
  . `tmp <- enc_blk(enc_key, 0 @ (tag xor N)[b-2:0])`.
  . If tag length is `b` bits, then
     .. `tag <- tmp`,
  . else (tag length is `3b/4` bits)
     .. `tag <- tmp[3b/4-1:0] @ zeros(b/4)`.
     .. If `tag` and `SIV` match, then
     ... `aceerror` <- ace_err_no_error,
     .. else
     ... `aceerror` <- ace_err_auth.
  . The state transitions to _completed_.
--
+
If `IOLEN` > `b`, only the `b` least significant bits of `INPUT` are considered.

 ** Upon completion of `ace.import`, the ACE unit recomputes `enc_key` and `auth_key`, i.e.:
  . (`enc_key`, `auth_key`) <- `RFC8452_RFC8452_KeyDeriv(key)`.

//

===== Usage

We show in <<ACE-pseudocode-GCM-SIV-encryption>> how to perform AEAD encryption with a GCM-SIV CC (with `b` = `IOLEN` = 128).
<<ACE-pseudocode-GCM-SIV-decryption>> is the corresponding pseudocode for decryption.

[[ACE-pseudocode-GCM-SIV-encryption]]
.GCM-SIV Encryption
----
// Acquire payload, initialize
- Info: authenticated data = *AD
- Info: plaintext = *PT
- Call an API to get the corresponding key from a key management applet or HW block.
- The API returns the SCC. Assume X5 is the pointer to it.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)

// Set the nonce (and the derived Authentication Key).
ace.state K0, #ace_state_set_aux_value
V0 ← nonce
ace.exec K0, V0

foreach(i from 0 to len_in_bytes(AD)/16-1) {
   V0 ← AD[16*i .. 16*i+15]                      // Load a block of associated data
   ace.exec K0, V0                               // Absorb it into hash
}

foreach(i from 0 to len_in_bytes(PT)/16-1) {
   V0 ← PT[16*i .. 16*i+15]                      // Load a block of plaintext
   ace.exec K0, V0                               // Absorb it into hash
}

V0 ← bin(len_in_bits(AD), 64) @ bin(len_in_bits(PT), 64)
ace.exec K0, V0                                  // Absorb lengths into hash

// Finalize the SIV computation, set and return it
ace.state K0, #ace_state_enc_tag_finalize
ace.exec V2,K0
tag ← V2

// Encrypt the plaintext
ace.state K0, #ace_state_encrypt
foreach(i from 0 to len_in_bytes(PT)/16-1) {
   V0 ← PT[16*i .. 16*i+15]                      // Load a block of plaintext
   ace.exec V1, K0, V0                           // Encrypt the block
   CT[16*i .. 16*i+15] ← V1                      // Store a block of ciphertext
}
----

[[ACE-pseudocode-GCM-SIV-decryption]]
.GCM-SIV Decryption
----
// Acquire payload, initialize
- Info: authenticated data = *AD
- Info: ciphertext = *CT
- Call an API to get the corresponding key from a key management applet or HW block.
- The API returns the SCC. Assume X5 is the pointer to it.
- Allocate memory for plaintext buffer PT (if not same as CT).

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)

// The next operations set the nonce and SIV.
V0 ← nonce
ace.state K0, #ace_state_set_aux_value, V0

// Compute AD contribution to Auth Data
V0 ← SIV
ace.state K0, #ace_state_hash_absorb, V0
foreach(i from 0 to len_in_bytes(AD)/16-1) {
   V0 ← AD[16*i .. 16*i+15]
   ace.exec K0, V0                               // Absorb it into hash
}

// Decrypt ciphertext and continue computation of tag
foreach(i from 0 to len_in_bytes(CT)/16-1) {
   V0 ← CT[16*i .. 16*i+15]
   ace.exec V1, K0, V0
   PT[16*i .. 16*i+15] ← V1
}

// Finally, we absorb the lengths of AD and plaintext into tag AND verify
ace.state K0, #ace_state_enc_tag_finalize
V0 ← bin(len_in_bits(AD), 64) @ bin(len_in_bits(PT), 64)
ace.exec K0, V0
ace.error X1
if (X1 != 0) then { handle error }     // do not use the plaintext if error occurred
----

[[ACE-OCB-mode]]
==== OCB Mode

We only architect the OCB3 variant of OCB as specified in RFC{nbsp}7253 cite:[RFC7253] and cite:[DBLP-journals-joc-KrovetzR21].
While this algorithm is asymptotically more efficient than GCM and GCM-SIV, it has a much heavier setup and its exported state requires significantly more memory than the other modes.
On the other hand, since it uses only a single key and no derived keys, with ciphers with an expensive key expansion
like the AES it may use fewer internal resources.

The state machine of this algorithm closely follows RFC{nbsp}7253 (except for the numbering of the bit fields, which is big endian in the RFC).
The algorithm is identical to the RFC for 128-bit-wide block ciphers, with a straightforward generalization to other widths according to the security proof of the original algorithm and a lower bound on nonce length following cite:[cryptoeprint-2023-326].

===== Specification

Parameters:::
+
--
* `b` = block size. `b` is a power of two, and {ge} 64. For OCB, we require `IOLEN` to be an integer multiple of `b`.
* `k` = key size, `b`|`k`.
--
+
Also, define `g` = `log_2(b)`.

Data Structures:::

* *Provisioning Input*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | `k`/8 or 8      | `key` or System Key index
|===
--
+

* *Internal State*:
 ** `key`: `k` bits.
 ** `N`: `u+1` bits (at most `u` bits are all used).
 ** `L`, `offset`, `hash_A`, `hash_P` : `b` bits.
 ** `N_len`, `tag_len`, `last_blk_len`: `g` bits.

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
|  Pos. | Size in Bytes          | Field
|    i  | `k`/8 or 8             | `key` or System Key index
|   ii  |  `b`/8                 | `N`
|  iii  |  `b`/8                 | `L` (only `u+1` bits used)
|   iv  |  `b`/8                 | `offset`
|    v  |  `b`/8                 | `hash_A`
|   vi  |  `b`/8                 | `hash_P`
|  vii  |  `2`                   | `tag_len`
| viii  |  `2`                   | `last_blk_len`
|   ix  |  `2`                   | `N_len`
|    x  |  `2`                   | Padding
|===
--
+

//

Algorithm-Specific Functions:::

* `enc_blk(K,p) -> c` encrypts block `p` using the key `K` and returns the result `c`.
* `dec_blk(K,c) -> p` decrypts block `c` using the key `K` and returns the result `p`.
* `double(S)`:
Let `C` be  `0x1B` for `b` = 64, `0x87` for `b` = 128, and `0x425` for `b` = 256, then:
+
[none]
** If S[`b`-1] == 0, then { `double(S)` <- `S << 1` } else { `double(S)` <- `(S << 1) xor C` } .

State Machine:::
* *States:*
 ** _initial_: The CC is ready.
 ** _set_aux_value:_ Set the length and the value of the nonce.
 ** _hash_absorb_: Set the tag length, and process the AD.
 ** _hash_finalize_: Set the length of the final block of the AD and process it.
 ** _encrypt_: Process the plaintext by absorbing it into the tag and encrypting it.
 ** _enc_last_block_: Provide the length of the last block of the plaintext, then absorb it into the tag and encrypt it.
 ** _enc_tag_finalize_: Return the tag.
 ** _decrypt_: Process the ciphertext by decrypting it and absorbing the plaintext into the tag.
 ** _dec_last_block_: Provide the length of the last block of the ciphertext, then decrypt it and absorb the plaintext into the tag.
 ** _hash_verify_: Compare a user-provided value with the internally computed tag.
 ** _completed_: The algorithm has completed its operation.

* *Allowed State Transitions:*
 ** _initial_ -> _set_aux_value_ -> _hash_absorb_ -> _hash_finalize_
 ** _hash_finalize_ -> _encrypt_, if encryption is allowed.
 ** _hash_finalize_ -> _decrypt_, if decryption is allowed.
 ** _encrypt_ -> _enc_last_block_ -> _enc_tag_finalize_ -> _completed_.
 ** _decrypt_ -> _dec_last_block_ -> _hash_verify_ -> _completed_.

* *Behavior:*
** In State _initial_ :
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
  *** The following initialization operations are performed:
   . `N <- 1 @ zeros(u)`.
   . `hash_A <- zeros(b)`
   . `hash_P <- zeros(b)`

** To move to _set_aux_value_, a Form B `ace.state` must be used, where the auxiliary argument `Xs` sets the nonce length `N_len`.
 `N_len` must be at least `g-1`. If not, ACE error ace_err_invalid_value is raised, and the CR is *invalidated*.

** In State _set_aux_value_, only  ``ace.exec`` instructions of Form B, “```ace.exec Kn|K[Xn], INPUT```”, are allowed, whereby `N` is set to `INPUT`, namely
     `N <- zeros(u-N_len) @ INPUT[N_len-1:0]`
  *** If “```ace.exec Kn|K[Xn], INPUT```,” is repeated, it will rewrite `N`.
  *** If no such `ace.exec` is issued, `N` is not changed, which means that its most significant bit is 1.
      This condition results in an error when transitioning to _hash_absorb_.

** To move to _hash_absorb_, a Form B `ace.state` must be used, where the auxiliary argument `Xs` sets the tag length `tag_len`.
  *** If this argument (interpreted as an unsigned value) is larger than `b` or is equal to `0` (the latter occurs also if `X0` is passed as the auxiliary argument), an ace_err_invalid_value error is raised, and the CR is *invalidated*.
  *** If `N[u] == 1`, this means that `N` was not set in State _set_aux_value_. We do not allow code that skips nonce setting, as this mode is not secure under nonce reuse, therefore in this case ACE error ace_err_invalid_value is raised, and the CR is *invalidated*.
  *** Following operations are performed:
  . `tag_len` <- `Xs`.
  . `offset <- zeros(b)`
  . `L <- enc_blk(key, zeros(b))`
  . `L <- double(double(L))`

** In State _hash_absorb_, only  ``ace.exec`` instructions of Form B are allowed:
  “```ace.exec Kn|K[Xn], INPUT```” absorbs a data block in `tag`, i.e.:
+
--
    . `L <- double(L)`
    . `offset <- offset xor L`
    . `hash_A <- hash_A xor enc_blk(key, INPUT xor offset)`
--
+
If `IOLEN` > `b`, the above operation is executed `IOLEN/b` times.

** To move to _hash_finalize_, a Form B `ace.state` operation sets the length of the final block of the AD in `last_blk_len`.

** In State _hash_finalize_, only one `ace.exec` instruction of Form B is allowed if `last_blk_len` != `0`.
 “```ace.exec Kn|K[Xn], INPUT```” which absorbs the last data block in `tag`, i.e.:
+
--
  * `tmp : bits(b)`

[]
  . `offset <- offset xor enc_blk(key, zeros(b))`
  . `tmp <- (zeros(b-last_blk_len-1) @ 1 @ INPUT[last_blk_len-1:0]) xor offset`
  . `hash_A <- hash_A xor enc_blk(K, tmp)`
--
+
If `last_blk_len` == 0, however, no `ace.exec` can be executed, and only an `ace.state` instruction is allowed to enter State _encrypt_ or _decrypt_.

** Upon entering states `_encrypt_` or `_decrypt_`, the “setup” and “init” stages of the OCB algorithm are performed:
+
--
 * `N_ext : bits(b)` (`N_ext` means “N, extended”)
 * `Stretch : bits(3b/2)`
 * `bot : bits(g-1)`
 * `Ktop : bits(b)`

[]
 . `offset <- zeros(b)`
 . `L <- enc_blk(key, zeros(b))`
 . `L <- double(double(L))`
 . `N_ext <- N[N_len-1:0] @ 1 @ zeros(b-g-1-N_len) @ bin(tag_len,g)`
 . `bottom <- int(N_ext[b-1:b-g+1])`  // Rogaway numbers the bits in the opposite order.
 . `Ktop <- enc_blk(key, zeros(g-1) @ N_ext[b-g:0])`
 . `Stretch <- (Ktop[b/2-1:0] xor Ktop[b/2+7:8]) @ Ktop`
 . `offset <- Stretch[b+bottom:bottom]`
--
+
** In State _encrypt_, only ``ace.exec`` instructions of Form A are allowed:
   “```ace.exec OUTPUT, Kn|K[Xn], INPUT```” absorbs the plaintext `INPUT` into the `tag` and encrypts `INPUT` into `OUTPUT`, namely:
+
--
 . `L <- double(L)`
 . `offset <- offset xor L`
 . `hash_P <- hash_P xor INPUT`
 . `OUTPUT <- offset xor enc_blk(key, INPUT xor offset)`
--
+
If `IOLEN > b`, the above operation sequence is executed `IOLEN/b` times, encrypting each `b`-bit block of `INPUT` into the corresponding `b`-bit block of `OUTPUT`.

** To move to _enc_last_block_, a Form B `ace.state` instruction must be used to set the bit length of the final block of the plaintext in `last_blk_len`.

** In State _enc_last_block_, only an ``ace.exec`` instruction of Form A “```ace.exec OUTPUT, Kn|K[Xn], INPUT```,” is allowed if `last_blk_len` is nonzero.
In this case, following operations are performed:
+
--
 * `tmp : bits(last_blk_len)`
 * `tmp2 : bits(b)`
 * `aux : bits(b)`

[]
 . `aux <- enc_blk(key, zeros(b))`
 . `offset <- offset xor aux`
 . `tmp <- enc_blk(key, offset)[last_blk_len-1:0]`
 . `tmp <- INPUT[last_blk_len-1:0] xor tmp`
 . `OUTPUT <- zeros(b-last_blk_len) @ tmp`
 . `tmp2 <- (zeros(b-last_blk_len-1) @ 1 @ tmp) xor offset`
 . `aux <- double(aux)`
 . `hash_P <- enc_blk(key, hash_P xor tmp2 xor offset xor aux) xor hash_A`
--
+
On the other hand, if `last_blk_len` is zero, only an ``ace.exec`` instruction of Form D, “```ace.exec Kn|K[Xn]```,” is allowed, which performs:
+
--
* `aux : bits(b)`

[]
  . `aux <- enc_blk(key, zeros(b))`
  . `aux <- double(aux)`
  . `hash_P <- enc_blk(key, hash_P xor offset xor aux) xor hash_A`
--
+
In both cases the state then transitions to _enc_tag_finalize_.

** In State _enc_tag_finalize_, only an ``ace.exec`` instruction of Form C, “```ace.exec OUTPUT,Kn|K[Xn]```,” is allowed, which
performs `OUTPUT <- zeros(b-tag_len) @ hash_P[tag_len-1:0]`.

** In State _decrypt_, only ``ace.exec`` instructions of Form A are allowed.
    Such an ``ace.exec`` decrypts `INPUT` into `OUTPUT`, and absorbs the plaintext `OUTPUT` into the `tag`, namely:
+
--
  * `tmp : bits(b)`

[]
  . `L <- double(L)`
  . `offset <- offset xor L`
  . `tmp <- offset xor enc_blk(key, INPUT xor offset)`
  . `hash_P <- hash_P xor tmp`
  . `OUTPUT <- tmp`
--
+
If `IOLEN` > `b`, the same behavior applies as in State _encrypt_.

** To move to State _dec_last_block_, a Form B `ace.state` operation must be used to also contextually set the bit length of the final block of the ciphertext in `last_blk_len`.

** In State _dec_last_block_, only an ``ace.exec`` instruction of Form A “```ace.exec OUTPUT, Kn|K[Xn], INPUT```,” is allowed if `last_blk_len` is nonzero.
In this case, the same operations as in State _enc_last_block_ are performed except for Line 6, which is instead
+
--
[start=6]
. `tmp2 <- (zeros(b-last_blk_len-1) @ 1 @ INPUT[last_blk_len-1:0]) xor offset`
--
+
and the state is changed to _hash_verify_.
+
If `last_blk_len` is zero, only an ``ace.exec`` instruction of Form D, “```ace.exec Kn|K[Xn]```,” is allowed, which performs the same operations as in State _enc_last_block_, except for the final state transition, which also in this case is to _hash_verify_.

** To complete the algorithm in the decryption branch, a Form C ``ace.state`` operation must be used to (confirm the)
transition to State _hash_verify_ and compare the `tag_len` least significant bits of `INPUT` with the `tag_len` least significant bits of `hash_P`:
+
--
  . If the values match, then `aceerror` is set to ace_err_no_error,
  . else `aceerror` is set to ace_err_auth.
  . The state transitions to _completed_.
--
+

//

===== Usage

Pseudocode for OCB encryption is given in <<ACE-pseudocode-OCB-encryption>> (again with `b` = `IOLEN` = 128).

[[ACE-pseudocode-OCB-encryption]]
.OCB Encryption
----
// Acquire payload, initialize
- Info:
 - authenticated data = *AD with bit length AD_len
 - plaintext = *PT with bit length PT_len
 - nonce N with bit length N_len
 - tag length tag_len

- Process gets an OCB encryption CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero,4,e32,m1,ta,ma                        // Use 128-bit vectors
ace.import K0, (X5)

// The next operations set the nonce
X1 ← N_len
ace.state K0, #ace_state_set_aux_value, X1
V0 ← N
ace.exec K0, V0

// The next state change also sets the tag length
X1 ← tag_len
ace.state K0, #ace_state_hash_absorb, X1

AD_fullblocks ← floor(AD_len/128)
PT_fullblocks ← floor(PT_len/128)

// Compute AD contribution to tag
foreach(i from 0 to AD_fullblocks-1) {
   V0 ← AD[16*i .. 16*i+15]
   ace.exec K0, V0                                 // Absorb it into hash
}
X1 ← AD_len mod 128                                // Can be zero
ace.state K0, #ace_state_hash_finalize, X1
if (X1 mod 128 != 0) then {
   V0 ← zeros(128)
   V0 ← AD[AD_fullblocks*16 .. AD_fullblocks*16+ceil(X1/8)]
   ace.exec K0, V0                                 // Absorb it into hash and encrypt
}

// Encrypt plaintext and continue computation of tag
ace.state K0, #ace_state_encrypt
foreach(i from 0 to PT_fullblocks-1) {
   V0 ← PT[16*i .. 16*i+15]
   ace.exec V1, K0, V0
   CT[16*i .. 16*i+15] ← V1
}
X1 ← PT_len mod 128                                // Can be zero
ace.state K0, #ace_state_last_block, X1
if (X1 mod 128 != 0) then {
   V0 ← zeros(128)
   V0 ← PT[PT_fullblocks*16 .. PT_fullblocks*16+ceil(X1/8)]
   ace.exec V1, K0, V0                             // Absorb it into hash and encrypt
   CT[PT_fullblocks*16 .. PT_fullblocks*16+ceil(X1/8)] ← V1
} else
   ace.exec K0

ace.exec V1, K0                                    // output tag
----

OCB decryption differs from encryption as follows:
the roles of `PT` and `CT` are reversed,
states _encrypt_ and _enc_tag_finalize_ are replaced by states _decrypt_ and _dec_tag_finalize_,
and the last lines are as follows:

[[ACE-pseudocode-OCB-decryption-difference]]
.OCB Decryption
----

V1 ← tag
ace.state K0, #ace_hash_verify, V1
ace.error X1
if (X1 != 0) then { handle error }       // do not use the plaintext if error occurred
----

[[ACE-CMAC-mode]]
==== CMAC Functions

{empty}
(((ACE, algorithm, CMAC)))
CMAC is an algorithm for message authentication codes constructed from a block cipher.

It was designed by Tetsu Iwata and Kaoru Kurosawa and became a NIST Recommendation in May 2005 cite:[nist-SP-800-38B].

===== Specification

Parameters:::

* `b` = block size (8|`b`).  For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = key size (8|`k`).

Data Structures:::

* *Provisioning Input*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | `k`/8 or 8      | `key` or System Key index
|===
--
+

* *Internal State*:
 ** `key`: `k` bits.
 ** `hash`: `b` bits.
 ** `last_block_len`: 64 bits.

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
|  Pos. | Size in Bytes   | Field
|    i  | `k`/8 or 8      | `key` or System Key index
|   ii  | `b`/8           | `hash`
|  iii  | `8`             | `last_block_len`
|===
--
+

//

Algorithm-Specific Functions:::

* `enc_blk(key, p) -> c` encrypts block `p` using the key `key`, and returns the result `c`.
* `gen_subkeys(K) -> (K1,K2)` generates subkeys `K1` and `K2` from the master key `K` as follows: +
Let `C` be `0x1B` for `b` = 64, `0x87` for `b` = 128, and `0x425` for `b` = 256, then

 . `L <- enc_blk(K, zeros(b))`
 . if (`msb(L){nbsp}{nbsp}== 0`) then
   { `K1 <- L{nbsp}{nbsp}<< 1` }
   else
   { `K1 <- (L{nbsp}{nbsp}<< 1) xor C` }.
 . if (`msb(K1){nbsp}== 0`) then
   { `K2 <- K1{nbsp}<< 1` }
   else
   { `K2 <- (K1{nbsp}<< 1) xor C` }.
 . return ```(K1, K2)```.

State Machine:::

* *States:*
 ** _initial_: The CC is ready.
 ** _hash_absorb_: Absorb data into the CMAC function.
 ** _hash_last_block_: Set the length of the last block to absorb, then absorb it.
 ** _hash_output_: Output the CMAC.
 ** _completed_: The CC has completed the CMAC operation.

* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_ -> _hash_last_block_ -> _hash_output_ -> _completed_.
 ** From any valid state to State _initial_.
* *Behavior:*
 ** In State _initial_:
  *** `last_block_len <- zeros(64)`
  *** `hash <- zeros(b)`
  *** No {nbsp}```ace.exec```{nbsp} operation is allowed.

 ** In State _hash_absorb_, we can only issue ``ace.exec`` instructions of Form B. +
 “```ace.exec Kn|K[Xn], INPUT```,” absorbs the data block `INPUT` into the hash as follows:
+
--
   . `hash <- enc_blk(key, hash xor INPUT)`.
--
+
If `IOLEN` > `b`, then the above operations are applied to each `b`-bit block of `INPUT`.

 ** Upon issuing a Form B “```ace.state Kn|K[Xn], #ace_state_hash_last_block, Xs```” where `Xs` contains the bit length of the last block, the following happens:
   . if `last_block_len` != 0, then the CR is *invalidated*. (The previous block is not complete.)
   . if `Xs > b` then the CR is *invalidated*.
   . `last_block_len <- Xs`.

 ** In State _hash_last_block_,  we can only issue a single ``ace.exec`` instruction of Form B, i.e., “```ace.exec Kn|K[Xn], INPUT```”, to absorb the data block `INPUT`. If `IOLEN` > `b`, only the least significant `b` bits of `INPUT` are considered.
+
--
  . `(K1, K2) <- gen_subkeys(key)`.
  . if `last_block_len` == `b`, then {
    .. `tmp <- hash xor INPUT xor K1`
  . } else {
    .. `tmp <- INPUT`
    .. Remove the `b` - `last_block_len` most significant bits of `tmp` and pad the resulting value with a `1` and sufficiently many `0` bits to make it `b` bits long.
    .. `tmp <- hash xor tmp xor K2` }
  . `hash <- enc_blk(key, tmp)`
  . The state is changed to _hash_output_.
--
+

** In State _hash_output_, we can issue one ``ace.exec`` instruction of Form C, i.e., “```ace.exec OUTPUT, Kn|K[Xn]```”, to output the hash into `OUTPUT`.
   If `IOLEN` > `b`, only the bits of `OUTPUT` beyond the `b`-th are cleared.
   Upon issuing that instruction, the CC transitions to State _completed_ with no error.

//

===== Usage

[[ACE-pseudocode-CMAC]]
.CMAC Computation
----
- Info: CMAC input = *M with bit length M_len
- Process gets a CMAC CC from an API. Assume X5 is the pointer to the CC.

vsetvli zero, 4, e32, m1, ta, ma                 // Use 128-bit vectors
ace.import K0, (X5)

ace.state K0, #ace_hash_absorb
blocks = floor(M_len/128)
remainder = M_len % 128
if remainder == 0 then
   blocks ← blocks - 1
   remainder ← 128

foreach(i from 0 to blocks-1) {
   V0 ← M[16*i .. 16*i+15]
   ace.exec K0, V0
}

X1 ← remainder
ace.state K0, #ace_hash_last_block, X1
V0 ← M[16*blocks .. 16*blocks+15]
ace.exec K0, V0

ace.state K0, #ace_hash_hash_finalize
ace.exec V0, K0  // this is the value of the CMAC
----

[[ACE-hash-functions]]
==== Hash and MAC Functions, and XOFs

{empty}
(((ACE, algorithm, general hashing)))
(((ACE, algorithm, MAC functions)))
(((ACE, algorithm, XOF)))
This section defines an interface for hash and MAC functions.
Because of the vast variety of such functions, we cannot define a completely general interface.
However, the interface defined here is sufficiently general to allow describing most commonly used and standardized functions, such as the SHA2 cite:[nist-fips-180-4], SHA3 and SHAKE cite:[nist-fips-202], as well as HMAC cite:[nist-fips-198-1], and many other constructions.

===== Specification

Parameters:::

* `b` = block size (8|`b`). This is the size of an absorbed block and may be different from the size of the internal state that is kept by the function. For a sponge function, this value is the _rate_.
* `t` = tag len (8|`t`). This is the size of the digest, or of the block that is output each time in a XOF. The present description assumes `t` {le} `b`.
* `n` = size of the internal state that is kept by the function (8|`n`).  For a sponge function, `n-b` is the _capacity_ of the function.
Either the block size is an integer multiple of the vector length or the vector length is an integer multiple of the block size.
* `k` = key size (8|`k`). Present only if keyed, i.e., a MAC.

Data Structures:::

* *Provisioning Input*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes            | Field
|   i  | If keyed: `k`/8 or 8     | `key` or System Key index
|===
--
+

* *Internal State*:
 ** `key`: `k` bits. Present only if keyed, i.e., a MAC.
 ** `state`: `n` bits.
 ** `last_block_len`: int. Present only if this Hash/MAC has special internal treatment for a fractional last block that goes beyond padding and appending the length, which are handled by user software  (field size at most 16 bits).
 ** `input_base`: int. Offset within input/output to read from/write to (field size at most 16 bits).
 ** `block_base`: int. Length of absorbed data so far for the current block (field size at most 16 bits). Only if used by the algorithm.
 ** `cumul_len`: int. Cumulative length of data absorbed so far (if the algorithm must process and incorporate it in the hash on its own).
 ** `block`: `b` bits.  Included only if a partial block must be maintained—for instance when the inputs are not directly absorbed into `state`.

* *Serialized Content*:
+
--
[cols="^6%,^19%,<25%,<50%",options="header"]
|===
|  Pos. | Size in Bytes            | Field                       | Notes
|    i  | If keyed: `k`/8 or 8     | `key` or System Key index   | --
|   ii  | `n`/8                    | `state`                     | --
|  iii  | `2`                      | `last_block_len`            | Only if this Hash/MAC has special internal treatment for a fractional last block that goes beyond padding and appending the length, which are handled by user software. Otherwise, this is zero.
|   iv  | `2`                      | `block_base`                | Amount of data stored so far into `block`.  Only if used by the algorithm, else zero padding.
|    v  | `4`                      | `cumul_len`                 | Cumulative length of all data absorbed so far. Only if the algorithm must process and incorporate it in the hash on its own, else zero padding.
|   vi  | `b`/8                    | `block`                     | It is included it the SCC only if there is a partial block, and the block must be stored separately from the `state`, and exclude it when not.
We reuse the most significant bit of the `state` field to store this information.
(In theory, we could include only the part filled so far, but this would complicate the parsing of an SCC.)
|===
--
+

//

NOTE: Regarding the `last_block_len`/`block_base`/`cumul_len` group: if any of these fields is not used, it is replaced by a corresponding padding block.
If all three are not used by the hashing algorithm, then the 64-bit block is omitted, and `block` (if included) follows immediately `state`.

Algorithm-Specific Functions:::

* `absorb()`: process `block` into the hash or MAC. This may include, for instance, state update operations.
* `absorb_last_block()`: process `block` into the hash or MAC, using the function for the last block.
* `finalize()`: process the `state` into the digest value. We assume this either re-uses `block` (the entire digest, or a unit of XOF output should not be bigger than that) or the digest will be part of `state`
* `update()`: updates the `state` during the digest output stage.

State Machine:::

* *States:* _initial_, _hash_absorb_, _hash_last_block_, _hash_output_ and _completed_.

 ** _initial_: The CC is ready.
 ** _hash_absorb_: Absorb data into the hash function.
 ** _hash_last_block_: Set the length of the last block to absorb, then absorb it.
 ** _hash_output_: Output the hash.
 ** _completed_: The CC has completed the operation (XOFs do not have this state).

* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_ -> _hash_last_block_ -> _hash_output_ -> _completed_.
 ** From any valid state to State _initial_.

* *Behavior:*
 ** In State _initial_:
  *** `last_block_len`, `block_base` and `block` are set to zero.
  *** `state`: the initial value is set as specified by the algorithm.
  *** Any `ace.exec` will result in the CR being *invalidated*.

 ** In State _hash_absorb_, we can only issue ``ace.exec`` instructions of Form B, i.e., +
 “```ace.exec Kn|K[Xn], INPUT```”, to absorb the data block `INPUT` into the hash as follows.
+
--
  . `input_base <- 0` // or `acestart` upon resumption
  . while `(input_base < IOLEN)` do { // as long as we have input to process
  .. `amount <- min(IOLEN-input_base, b-block_base)`
  .. ``block[block_base + amount - 1 : block_base] <-`` +
      ``{nbsp}{nbsp}{nbsp}{nbsp} <- INPUT[input_base + amount - 1 : input_base]`` +
        ``{nbsp}{nbsp}``(If there is no `block` field, could also be something like +
        ``{fournbsp}state[block_base + amount - 1 : block_base] <- `` +
        ``{fournbsp}{fournbsp}{nbsp}<- state[block_base + amount - 1 : block_base] + `` +
        ``{fournbsp}{fournbsp}{nbsp}+ INPUT[input_base + amount - 1 : input_base]`` , +
        ``{nbsp}{nbsp}{nbsp}``it could directly replace part of `state`, or some other function.)
  .. `input_base <- input_base + amount`
  .. `block_base <- block_base + amount`
  .. if (`block_base` == `b`) then { // it's time to absorb the block
  ... `absorb()`
  ... `block_base <- 0`
  ... *Here* the instruction may be interrupted, with `acestart <- input_base`.

[none]
  . }``{nbsp}{nbsp}`` }
--
+

//
 ** Upon issuing a Form B “`ace.state Kn|K[Xn], #ace_state_hash_last_block, Xs`” where `Xs` contains the length of the last block, the following happens:
+
--
 . if `block_base` != 0, then the CR is *invalidated*. (The previous block is not complete.)
 . if `Xs > b`, then the CR is *invalidated*.
 . if `Xs == 0`, then the CR is *invalidated*.
 . `last_block_len <- Xs`.
--
+
Then, state transitions to _hash_last_block_ as expected.

 ** State _hash_last_block_ is very similar to _hash_absorb_, the differences being:
  *** `last_block_len` is used in place of `b` throughout.
  *** `absorb_last_block()` is called instead of `absorb()` in Step 3.d.i.
  *** The instruction is terminated after `absorb_last_block()`—only one block is absorbed—and the state transitions to _hash_output_.

 ** In State _hash_output_ we have two possible situations: we are in a hash function or a XOF.
  *** Upon entering the state, the following operations are first performed:
  . `block[t - 1 : 0] <- finalize()`
  . `block_base <- 0`
 *** For each Form C `ace.exec` instruction “`ace.exec OUTPUT, Kn|K[Xn]`”, the following operations are performed:
+
--
    * `amount : int`, `{nbsp}` amount of data to copy from `block` to `OUTPUT`
    * `#define output_base input_base`

[]
   . `output_base <- 0` // or `acestart` upon resumption
    . while (`output_base` < `IOLEN`) do { // as long as there is room in the OUTPUT
     .. `amount` <- `min(IOLEN - output_base, t - block_base)`
     .. ``OUTPUT[output_base + amount - 1 : output_base] <- `` +
           ``{fournbsp}{fournbsp}<- block[block_base + amount - 1 : block_base + amount]``
     .. `output_base <- output_base + amount`
     .. `block_base <- block_base + amount`
     .. if (`block_base` == `t`) then {
      ... if we are in a Hash function, transition to _completed_, and return.
      ... `update()`
      ... `block_base <- 0`
      ... *Here* the instruction can be interrupted, with `acestart <- output_base`.

[none]
      . }``{nbsp}{nbsp}`` }
--
+

//

[[ACE-SHA-3]]
==== SHA-3 Family Specific Rules

{empty}
(((ACE, algorithm, SHA-3)))
We describe here the algorithms for the primitives in the SHA-3 family, which currently includes SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128 and SHAKE256.
These primitives are designed around a special parameter choice of KECCAK cite:[DBLP-conf-eurocrypt-BertoniDPA13] standardized by NIST cite:[nist-fips-202].
These are instantiations of the algorithm specified in <<ACE-hash-functions>>, and we need to
describe only the differences with respect to the behavior described there.

Parameters:::

* `b` = rate (8|`b`). It can be 1600 - `c` with `c` = 448, 512, 768, or 1024 being the capacity.
* `n` = 1600
* `t` = `c/2`

Data Structures:::

* *Provisioning Input*: Only the Metadata Header.

//

* *Internal State*:
 ** `state`: `n` bits.
 ** `last_block_len`: int.
 ** `input_base`: int.
 ** `block_base`: int.

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | 200             | `state`
|  ii  | 2               | `last_block_len`
| iii  | 2               | `block_base`
|  iv  | 4               | Padding
|===
--
+

//

Algorithm-Specific Functions:::
 * `P()`: computes `KECCAK-p[1600, 24]` on `state`.
 * `absorb()`: in this case there is no explicit operation to copy data into `state`, as the inputs will be directly XORed into it, however `absorb` applies `P()` to the state.
 * `absorb_last_block()`: this is a NOP.
 * `finalize()`: this is a NOP.
 * `update()`: updates the `state` during the digest output stage.  It applies `P()` to the state.

State Machine:::
* *States:* _initial_, _hash_absorb_, _hash_last_block_, _hash_finalize_, _hash_output_ and _completed_.

* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_ -> _hash_last_block_ -> _hash_finalize_ -> _hash_output_ -> _completed_.
 ** From any valid state to State _initial_.

* *Behavior:*
 ** In State _initial_, `state` is zeroed.
 ** In State _hash_absorb_, the input data is directly XORed to `state`.
 ** In State _hash_last_block_, the input data is directly XORed to `state`.
 ** Upon transitioning to State _hash_output_:
  . The suffix and padding string `S` is generated.
  . If the bit length of `S` is `b-block_base`:
   .. `S` is directly XORed to rate part of the state, and
   .. `P()` is applied.
  . If the bit length of `S` is `2b-block_base`:
   .. The first `b-block_base` bits are XORed to the rate part of the state,
   .. `P()` is applied,
   .. the remaining `b` bits are XORed to the rate part of the state, and
   .. `P()` is applied again.

The rest of the algorithm follows <<ACE-hash-functions>>.

//

[[ACE-Ascon]]
==== Ascon Specific Rules

{empty}
(((ACE, algorithm, Ascon)))
We now describe the state machines of the various Ascon-based cite:[DBLP-journals-joc-DobraunigEMS21] algorithms standardized by the NIST cite:[nist-SP-800-232].

[WARNING]
====
In all ASCON algorithms, the ordering of the bits must be verified!
====

[[ACE-Ascon-AEAD128]]
===== Ascon-AEAD128

In this mode it is the responsibility of the user to apply proper padding to the AD and plaintext.
The inputs are therefore assumed to be properly padded.
Similarly, it is the responsibility of the user to remove the padding from the decryption of the ciphertext to recover the original plaintext.

Parameters:::

* `b` = 128. For this algorithm we require `IOLEN` to be an integer multiple of `b`.
* `k` = 128.

Data Structures:::

* *Provisioning Input*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | 16 or 8         | `key` or System Key index
|===
--
+

* *Internal State*:
 ** `key`: 128 bits, or 64 bits if it is a System Key index.
 ** `state[0 .. 4]`: five 64-bit words, i.e., 320 bits.
 ** `tag_len`: 8 bits as int.
 ** `last_block_len`: 9 bits as int.
 ** `AD_empty`: Boolean;

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|    i | 16 or 8         | `key` or System Key index
|   ii | 8               | `state`[0]
|  iii | 8               | `state`[1]
|   iv | 8               | `state`[2]
|    v | 8               | `state`[3]
|   vi | 8               | `state`[4]
|  vii | 2               | `last_block_len`
| viii | 2               | `tag_len`
|   ix | 4               | Padding
|===
--
+

Algorithm-Specific Functions:::

* `ASCON(p)` applies `p` rounds of ASCON to the `state`.

State Machine:::

* *States:*
 ** _initial_: The CC is ready.
 ** _hash_absorb_: Set the nonce, and process the AD.

 ** _encrypt_: Encrypt the plaintext.
 ** _enc_last_block_: Encrypt the last block of the plaintext.
 ** _hash_output_: Return the tag.

 ** _decrypt_: Decrypt the ciphertext.
 ** _dec_last_block_: Decrypt the last block of the ciphertext.
 ** _hash_verify_: Compare a user-provided value with the internally computed tag.

 ** _completed_: The algorithm has completed its operation.

* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_.
 **  _hash_absorb_ -> _encrypt_, if encryption is allowed.
 **  _hash_absorb_ -> _decrypt_, if decryption is allowed.
 ** _encrypt_ -> _enc_last_block_ -> _hash_output_ -> _completed_.
 ** _decrypt_ -> _dec_last_block_ -> _hash_verify_ -> _completed_.

* *Behavior:*
** In State _initial_ :
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
  *** The following initialization operations are performed:
   . `state[0] <- 0x00001000808c0001`
   . `state[1] <- key[63:0]`
   . `state[2] <- key[127:64]`
   . `state[3] <- zeros(64)`
   . `state[4] <- zeros(64)`
   . `tag_len <- 128`
   . `AD_empty` <- `true`

** To transition to State _hash_absorb_, a Form C ``ace.state`` must be used, whose `INPUT` sets the nonce of the algorithm as follows:
+
--
  . `state[3] <- INPUT[63:0]`
    . `state[4] <- INPUT[127:64]`
    . `ASCON(12)`
    . `state[3] <- state[3] xor key[63:0]`
    . `state[4] <- state[4] xor key[127:64]`
--
+
If `IOLEN` > 128, only the 128 least significant bits of `INPUT` are considered.

** In State _hash_absorb_, only  ``ace.exec`` instructions of Form B are allowed.
 “```ace.exec Kn|K[Xn], INPUT```” absorbs a data block into the state, i.e.:
+
--
 . `AD_empty` <- `false`
 . `ASCON(8)`
 . `state[0] <- state[0] xor INPUT[63:0]`
 . `state[1] <- state[1] xor INPUT[127:64]`
--
+
If `IOLEN` > 128, this sequence of four operations is executed `IOLEN/128` times, once for each 128-bit block of `INPUT`.
** Upon entering State _encrypt_ or _decrypt_, the following domain separation operation is performed:
 . `lsb(state[4]) <- lsb(state[4]) xor 1`

** In State _encrypt_, only ``ace.exec`` instructions of Form A are allowed.
   “```ace.exec OUTPUT, Kn|K[Xn], INPUT```” encrypts `INPUT` into `OUTPUT`, namely:
+
--
 . `state[0] <- state[0] xor INPUT[63:0]`
 . `state[1] <- state[1] xor INPUT[127:64]`
 . `OUTPUT <- state[1] @ state[0]`
 . `ASCON(8)`
--
+
If `IOLEN` is a multiple of 128, these operations are executed `IOLEN/128` times, encrypting each 128-bit block of `INPUT` into the corresponding 128-bit block of `OUTPUT`.

** In State _enc_last_block_, only one ``ace.exec`` instruction of Form A, to encrypt the last block is allowed.
“```ace.exec OUTPUT, Kn|K[Xn], INPUT```”  performs
+
--
 . `state[0] <- state[0] xor INPUT[63:0]`
 . `state[1] <- state[1] xor INPUT[127:64]`
 . `OUTPUT <- state[1] @ state[0]` // only the 128 lsbs of `OUTPUT` are written to.
 .  The state machine then transitions to State _hash_output_.
--
+
In this state only one 128-bit block is processed. +
The differences between the operation of `ace.exec` in this state and in State _encrypt_ are the absence of the final `ASCON(8)` and the automatic transition to State _hash_output_.

** In State _hash_output_, only one ``ace.exec`` instruction of Form C is allowed, to compute the tag.
“```ace.exec OUTPUT, Kn|K[Xn]```”  performs
+
--
 . `state[2] <- state[2] xor key[63:0]`
 . `state[3] <- state[3] xor key[127:64]`
 . `ASCON(12)`
 . `state[3] <- state[3] xor key[63:0]`
 . `state[4] <- state[4] xor key[127:64]`
 . `OUTPUT <- state[4] @ state[3]` // only the 128 lsbs of `OUTPUT` are written to.
 . The state machine then transitions to State _completed_.
--
+
In this state only one 128-bit block is processed.

** In State _decrypt_, only  ``ace.exec`` instructions of Form A are allowed, i.e.,
 `ace.exec OUTPUT,Kn|K[Xn],INPUT`. This operation performs:
+
--
* `tmp : bits(128)`

[]
. `tmp <- (state[0] xor INPUT[63:0]) @ (state[1] xor INPUT[127:64])`
. `state[0] <- INPUT[63:0]`
. `state[1] <- INPUT[127:64]`
. `ASCON(8)`
. `OUTPUT <- tmp`
--
+
If `IOLEN` is a multiple of 128, these operations are executed `IOLEN/128` times, decrypting each 128-bit block of `INPUT` into the corresponding 128-bit block of `OUTPUT`.

** In State _dec_last_block_, only a Form A ``ace.exec`` instruction is allowed.
“```ace.exec OUTPUT, Kn|K[Xn], INPUT```” performs:
+
--
* `tmp : bits(128)`

[]
. `tmp <- (state[1] xor INPUT[127:64]) @ (state[0] xor INPUT[63:0])`
. `state[0] <- INPUT[63:0]`
. `state[1] <- INPUT[127:64]`
. The state machine transitions to State _hash_verify_
. `OUTPUT <- tmp`
--
+

** In State _dec_tag_finalize_, a Form B `ace.state Kn|K[Xn], #ace_state_dec_tag_finalize, Xs` instruction may be executed, setting
the tag len `tag_len` to the value of `Xs`, provided it is not smaller than 32 and not larger than 128.
If the value is out of bounds, the instruction raises ACE error ace_err_invalid_value and the CR is *invalidated*.

** In State _hash_verify_, only one ``ace.exec`` instruction of Form D is allowed, to verify the tag.
“```ace.exec Kn|K[Xn], INPUT```” performs
+
--
. `state[2] <- state[2] xor key[63:0]`
. `state[3] <- state[3] xor key[127:64]`
. `ASCON(12)`
. `state[3] <- state[3] xor key[63:0]`
. `state[4] <- state[4] xor key[127:64]`
. `INPUT[tag_len-1:0]` is compared to `(state[4] @ state[3])[tag_len-1:0]`.
. If the values match, then `aceerror` is set to ace_err_no_error,
  else ACE error ace_err_auth is raised. The state is changed to _completed_.
--
+

//

[[ACE-Ascon-AEAD128-wsn]]
===== Ascon-AEAD128 with set Nonce

Similarly to GCM with Set IV, Ascon-AEAD128 can also be made into a version with a set nonce.
In this case the State _set_aux_value_ is skipped, and the PI has the following form.

* *Provisioning Input*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | 16 or 8         | `key` or System Key index
|  ii  | 16              | `nonce`
|===
--
+

In State _initial_, words 3 and 4 of `state` are initialized thus:

. `state[3] <- nonce[63:0]`
. `state[4] <- nonce[127:64]`

Once in State _completed_, the CC cannot be brought back to State _initial_.

//

[[ACE-Ascon-AEAD128-N-masking]]
===== Ascon-AEAD128 with Nonce Masking

The NIST specification also describes a version of Ascon-AEAD128 with _Nonce Masking_.
This variant is described as follows:

* *Provisioning Input*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
| Pos. | Size in Bytes   | Field
|   i  | 16 or 8         | `K1` or System Key index
|  ii  | 16 or 0         | `K2` or System Key index in `K1`
|===
--
+

* *Internal State*:
 . `K1`: 128 bits, or 64 bits if it is a System Key index.
 . `K2`: 128 bits, omitted if a System Key is used.
 ** `state[0 .. 4]`: five 64-bit words, i.e., 320 bits.
 ** `tag_len`: 8 bits.

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
|  Pos. | Size in Bytes   | Field
|    i  | 16 or 8         | `K1` or System Key index
|   ii  | 16 or 0         | `K2` or System Key index in `K1`
|  iii  | 8               | `state`[0]
|   iv  | 8               | `state`[1]
|    v  | 8               | `state`[2]
|   vi  | 8               | `state`[3]
|  vii  | 8               | `state`[4]
| viii  | 2               | `tag_len`
|   ix  | 6               | Padding
|===
--
+

The algorithm has the same states as Ascon-AEAD128 as described in <<ACE-Ascon-AEAD128>>, with the key `key` equal to `K1` and the nonce `N` replaced throughout by `N xor K2`.

For encryption and decryption with both nonce masking and a set nonce, the algorithm described in <<ACE-Ascon-AEAD128-wsn>> is used, giving `K1` as the key `key` and providing `N xor K2` as the nonce value.

[[ACE-Ascon-Hash256]]
===== Ascon-Hash256

In this mode it is the responsibility of the user to apply proper padding to the inputs.

Parameters:::

* `b` = 64. For this algorithm we require `IOLEN` to be an integer multiple of `b`.

Data Structures:::

* *Provisioning Input*: Only the Metadata Header.

* *Internal State*:
 ** `state[0 .. 4]`: five 64-bit words, i.e., 320 bits.
 ** `countdown` : integer going from 3 down to 0.

* *Serialized Content*:
+
--
[%autowidth,cols="^,<,<",options="header"]
|===
|  Pos. | Size in Bytes   | Field
|    i  | 8               | `state`[0]
|   ii  | 8               | `state`[1]
|  iii  | 8               | `state`[2]
|   iv  | 8               | `state`[3]
|    v  | 8               | `state`[4]
|   vi  | 1               | `countdown` (from 3 down to 0)
|  vii  | 7               | Padding
|===
--
+

Algorithm-Specific Functions:::

* `ASCON(p)` applies `p` rounds of ASCON to the `state`.

State Machine:::

* *States:* _initial_, _hash_absorb_, _hash_finalize_, and _completed_.

* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_ -> _hash_finalize_ -> _completed_.

* *Behavior:*
 ** In State _initial_ :
  *** No {nbsp}``ace.exec``{nbsp} operation is allowed.
  *** The following initialization operations are performed:
   . `state[0] <- 0x0000080100cc0002`
   . `state[1] <- zeros(64)`
   . `state[2] <- zeros(64)`
   . `state[3] <- zeros(64)`
   . `state[4] <- zeros(64)`
   . `ASCON(12)`

  ** In State _hash_absorb_, only  ``ace.exec`` instructions of Form B are allowed.
 “```ace.exec Kn|K[Xn], INPUT```” absorbs a data block into the state, i.e.:
+
--
 . `state[0] <- state[0] xor INPUT`
 . `ASCON(12)`
--
+
If `IOLEN` > `64`, these operations are executed `IOLEN/64` times, once for each `64`-bit block of `INPUT`.

** Upon entering _hash_finalize_, `countdown` is set to 3.

** In State _hash_finalize_, at most four ``ace.exec`` instructions of Form C are allowed.
To compute the tag, “```ace.exec OUTPUT, Kn|K[Xn]```”  performs
+
--
. `ASCON(12)`
. `OUTPUT <- state[0]`
. if `countdown == 0` then transition to State _completed_.
. `countdown <- countdown - 1`
--
+
If `IOLEN` {ge} `128`, these operations are executed `IOLEN/64` times, writing to `OUTPUT`[63:0] the first time,
then `OUTPUT`[127:64], `OUTPUT`[191:128] and `OUTPUT`[255:192].
If more than one ``ace.exec`` instructions are required, writing restarts from `OUTPUT`[63:0].
If `countdown` reaches zero before the entire output registers is written to, the state of the unwritten bits is undefined: for instance
this may occur if `IOLEN` = `192` or `IOLEN` > `256`.
This is usually not a problem, since the output vectors will be usually configured for 64-bit, 128-bit, or 256-bit blocks, in which case
four, two, or one ``ace.exec`` instructions are required, respectively.

//

NOTE: There is no need to provide “keyed” versions of this algorithm.
This can be done by a trusted entity by providing a CC after absorbing some secret content in it first.

===== Ascon-XOF128

The algorithm is the same as Ascon-Hash256 (<<ACE-Ascon-Hash256>>) with the following differences:

. The IV written to `state[0]` in State _initial_ is `0x0000080100cc0002`.
. There is no `countdown` field (and therefore also no padding: the last 8 bytes of the serialized content of Ascon-Hash256 are not present).
. As much output as desired can be produced in State _hash_finalize_, and the algorithm never transitions to State _completed_.

===== Ascon-CXOF128

Ascon-CXOF128 differs from Ascon-XOF128 in that the message is prepended with the customization string.
Except for the initialization of the state, Ascon-CXOF128 is identical to Ascon-XOF128 with customization string and message concatenated.
The IV for Ascon-CXOF128 is `0x0000080000cc0004` (in place of `0x0000080000cc0003`), and it is set by the algorithm.
The states and their semantics are otherwise identical to Ascon-XOF128, and the management of the customization string is left to the user.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-ECC]]
==== Elliptic Curve Asymmetric Algorithms

[WARNING]
This section needs finalization.
The EdDSA signature formats are missing (same for Brainpool and SM2).
ECC based KEMs are also missing, or at least instructions on how to implement them with the basic functionality offered.
Also, we need to support the elliptic curves that are actually used in practice, such as:

* secp256r1 (a.k.a. prime256v1, NIST P-256)
* secp384r1 (a.k.a. prime384v1, NIST P-384)
* secp521r1 (a.k.a. prime521v1, NIST P-521)
* ed25519
* ed448
* Brainpool Curves?
* SM2 Curves?

We only define scalar multiplication with known and unknown base point and ECDSA/EdDSA sign/verify for the NIST curves.

NOTE: Further curves can be defined later.

For secp256r1 the size `b` of the main fields (coordinates, signature R and S fields, scalars) is 256 bits.
The length `h` of the hash used in the signature scheme is 256 bits.
The random number (the nonce in signature generation) is a `h`-bit string as well.

For secp384r1, `b` is 384 bits, and `h` is 384 bits.

For secp521r1, `b` is 576 bits, of which only 521 are used, and `h` is 512 bits.

Data Structures:::

* *Provisioning Input*: Only the Metadata Header.

NOTE: In the Metadata, _only_ the curve is embedded in Algorithm.
The _DirectionPolicy_ field determines whether signature generation (bit 12) and signature verification (bit 13) are allowed
All four combinations are admissible.

* *Internal State*:
 ** `HasGenerator`: Bool.
 ** `HasScalar`: Bool.
 ** `HasPublicKey`: Bool.
 ** `HasHash`: Bool.
 ** `HasSignature`: Bool.
 ** `HasRandomNumber`: Bool.
 ** `Progress`/input_base: integer.
 ** `block_base`: integer.
 ** `Generator` (X coordinate, Y coordinate): two `b`-bit strings representing the X and Y coordinates.
 ** `Scalar`: `b`-bit string.
 ** If signature generation or verification is allowed:
  *** `PublicKey` (X coordinate, Y coordinate): two `b`-bit strings representing the X and Y coordinates.
  *** `Signature` (R,S): two `b`-bit strings representing the `R` and `S` components.
  *** `Hash`: a `h`-bit string representing the hash.
  ** If signature generation is allowed:
  *** `RandomNumber`: a `h`-bit string representing the random number.
 ** Additional data, for instance precomputed multiples of the Generator.

* *Serialized Content*:
+
--
[cols="^5%,<32%,<60",width="100%",options="header"]
|===
|  Pos. | Size in Bytes   | Field
|   i   | 2               |  Bit 0: `HasGenerator` +
Bit 1: `HasScalar` +
Bit 2: `HasPublicKey` +
Bit 3: `HasHash` +
Bit 4: `HasSignature` +
Bit 5: `HasRandomNumber`
|   ii  | 2               | `Progress`/`input_base`
|  iii  | 2               | `block_base`
|  iv   | 2               | Padding
|  v    | 2``b``/8        | `Generator`, X coordinate
|  vi   | 2``b``/8        | `Generator`, Y coordinate
|  vii  | `b`/8           | `Scalar`: `b`-bit string. Can be the private key.
|===

`SCC_content_size()` returns only the length of the content from Position i to Position vii.

The size of following fields is included in the _ExtraContent_ field of the Metadata Header.

[cols="^5%,<32%,<60",width="100%",options="header"]
|===
|  Pos. | Size in Bytes                             | Field
| viii  | If `mh`._ExtraContent_ != 0: 8, else: 0   |  `acemarchid`
|   ix  | If `HasPublicKey`: `b`/8, else: 0         | `PublicKey`, X coordinate.
|    x  | If `HasPublicKey`: `b`/8, else: 0         | `PublicKey`, Y coordinate.
|   xi  | If `HasSignature`: `b`/8, else: 0         | `Signature`, R value.
|  xii  | If `HasSignature`: `b`/8, else: 0         | `Signature`, S value.
| xiii  | If `HasHash`: `h`/8, else: 0              | `Hash`: a `h`-bit string representing the hash.
|  xiv  | If `HasRandomNumber`: `h`/8, else: 0      | `RandomNumber`.
|   xv  | (variable)                                | Additional data from the *Internal State*..
|===

The `HasRandomNumber` flag is set and the `RandomNumber` field is used only during signature generation.
`RandomNumber` is exported only if the signature operation is interrupted.

The size in bytes of Fields vii to xiv is:

`{fournbsp}{fournbsp}` `varlen` <- 8 + (`HasPublicKey` != 0) {interpunct} 2``b``/8 + (`HasSignature` != 0) {interpunct} 2``b``/8 + +
`{fournbsp}{fournbsp}{fournbsp}{fournbsp}{fournbsp}{fournbsp}{fournbsp}` + (`HasHash` != 0) {interpunct} ``h``/8 + (`HasRandomNumber` != 0) {interpunct} ``h``/8.

If _ExtraContent_ > `varlen`, Position xvi contains the microarchitectural dependent part.

EdDSA formats are similar, but in the formats, the public key is represented as a single `b`-bit string.
--
+

State Machine::: {empty}
+
--
* *States:*

 ** _initial_ (0)
 ** _set_generator_ (1)
 ** _set_scalar_ (2)
 ** _point_mul_ (3)
 ** _point_mul_transient_ (11)
 ** _sign_generate_ (4)
 ** _sign_generate_transient_ (12)
 ** _sign_verify_ (5)
 ** _sign_verify_transient_ (13)
 ** _set_hash_ (6)
 ** _set_publickey_ (7)
 ** _set_signature_ (8)
 ** _output_ (9)
 ** _completed_ (15)

[none]
* The “*_transient_” states are used during long operations.
If the operations are interrupted, they are in the transient state.
When they are completed, they are in the non-transient state.
In this state, these states may require to save additional data.
* The format of the additional data is implementation defined. The data itself is saved at Position xvi in the content, and its length is included in the _ExtraContent_ field of the Metadata Header.
* If there is a `acemarchid` mismatch, both `RandomNumber` (Position xv) andthe additional data at Position xvi are discarded, and the operation is restarted.
--
+

+
--
* *Allowed State Transitions:*

 ** _initial_ -> _set_generator_, _set_scalar_, _set_hash_, _set_publickey_, _sign_generate_, _set_signature_
 ** It is allowed to freely transition between _set_generator_, _set_scalar_, _set_hash_, and _set_publickey_.
 ** From any of _initial_, _set_generator_, _set_scalar_, _set_hash_, _set_publickey_:
 *** -> _point_mul_ only if `HasGenerator` & `HasScalar`
 *** -> _sign_generate_ only if `HasGenerator` & `HasPublicKey` & `HasHash`
 *** -> _sign_verify_ only if `HasGenerator` & `HasScalar` & `HasPublicKey` & `HasHash` & `HasSignature`
 ** _point_mul_ -> _output_ -> _initial_
 ** _sign_generate_ -> _output_ -> _completed_
 ** _sign_verify_ -> _completed_

[none]
* In State _set_generator_ we can set a group generator.
* In State _set_scalar_ we can either set a scalar for scalar multiplication or private key.
* For each __Var__ {in} {`Generator`, `Scalar`, `Hash`, `PublicKey`, `Signature`},
the Boolean variable ``Has``__Var__ is set when all operations required in State _set_Var_ have been successfully executed.
--
+

* *Behavior:*
 ** Upon returning to State _initial_, if a Form B `ace.state` is used, the parameter `Xs` will determine whether the fields
 `Generator`, `Scalar`, and `PublicKey` are erased or kept for further operations. This is determined by Bits 0, 1, and 2 of `Xs` as follows: If Bit 0, 1, resp., 2 is set, then `Generator`, `Scalar`, and `PublicKey` is erased, and the corresponding Booleans `HasGenerator`, `HasScalar`, resp., `HasPublicKey` are unset as well.
 A Form A `ace.state` does not modify these states.
 `Signature` and the corresponding Boolean `HasSignature` are always reset.

 ** All the “set” and “output” operations work like the input and output of blocks in the Hash functions, in other words, they use input_base to track the parsing of the `INPUT` and block_base for the fill level of any information to be provisioned.

// ///////////////////////////////////////////////////////////////////////////////////////////

=== Annexes

[[ACE-CSK-vs-ID]]
==== Programmable CSKs vs. ID-based Usage Control vs. Localities

_This section is informative and non-normative._

ACE provides a layer of usage control based on the use of Localities.

- We can suppose to add an optional Metadata Extension block that contains values of `scontext` and `mcontext` to match against, or alternative values based on other CSRs, perhaps defined ad-hoc.
+
This is a lightweight mechanism.
Since filtering at one mode is inactive when the hart is in a higher mode, context switching can be performed without modifying the CSK.

. A programmable CSK can restrict not only the usage, but even the import of CCs.
This offers stronger security by also preventing unauthorized `ace.import` operations, but incurs higher overhead as it typically requires an `ecall` to modify the CSK, and
increases pressure on the ACE unit's internal resources in case keys derived from the most recent CSK values are caches.

. Localities programmable at M/H/S could be used instead.
Since these Localities can be combined with the HW Binding localities, this would be as flexible as context-based filtering, but based on significantly longer strings.

The envisioned usage model employs context-based filtering at the User level, and also at the (Virtual) Supervisor level in high-performance systems where migration is not required (e.g., automotive applications).
Cryptographic domain separation via the CSK or Localities is intended for Virtual Machines, Supervisor Domains, Worlds, and TEEs, as these demand stronger security guarantees.

Although the architecture does not prevent assigning unique CSKs to U-mode processes, doing so would impose a substantial burden on system software due to per-context-switch `ecall` overhead.
Hardware support—such as automatic CSK switching based on contexts could alleviate this burden.
Such a mechanism is not under consideration due to its architectural complexity, inflexibility, and hardware cost.
For example, it would necessitate secure management of large CSK tables, including saving, restoring, and potentially migrating entire CSK blocks.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-lazy-loading]]
==== Lazy-Loading CRs

_This section is informative and non-normative._

[WARNING]
Architecting this feature requires careful consideration—there may be further corner cases, so both architectural states and expected software behavior need to be analyzed in depth. Focusing on the core features of ACE is more important and designing lazy-loading is a secondary concern.

Lazy loading defers loading a value until it is needed, improving performance and managing limited CRF capacity. It may also be required to support migration to systems with smaller CRFs:
If capacity is insufficient for lazy loading, the software reimporting an offloaded CR must be able to offload other CRs to free space. Requiring software to check for errors after each operation would impose significant burden on the software and possibly degrade performance.

We assume that besides `scrdirty`, `vscrdirty` and `mcrdirty`, we have three more CSRs `scrlazy`, `vscrlazy` and `mcrlazy` that can be used to mark a CR as lazy, in particular CR number __i__ is *LAZY* if `*crlazy`[__i__] is set and `*crdirty`[__i__] is not set.
// Alternatively, we can define *crdirty to be a 64 bit register and reserve
// the upper 32 bits for lazy.
// We can define the crdirty to be a two bit per CR, just split over two
// 32 bit blocks, a two bit per-CR field would be 32+X and X.
// There might be even a slight case to make the upper 32 bits read-only-1 now, so we
// could pretend to encode the Clean (0b10) and Dirty (0b11) consistently with
// the previous format.
A CR marked *LAZY* is Unconfigured. An authoritative value is saved for lazy loading in one of the parent modes.
Unconfiguration and configuration operations on this CR work normally.
// This allows lazy loads, but lazy stores are also potentially useful.
// If we don't expect a context to use the CR, we could just keep the value
// of another context there, which would allow us to preserve the CR for the
// original context and avoid both save and load.
// More traps would even allow for more evil optimizations, like giving just 8
// CRs to a context, and keeping up to 4 contexts in the file, provided parent
// mode also gets traps when there isn't enough memory to import.

If an *Export* or *Usage* operation is issued at U-mode, then the system traps to the higher-privileged mode that holds the authoritative SCC, which must import it into the CR.
This may require freeing space by making another CR *LAZY*.

Identifying the correct higher-privileged mode is typically straightforward.
There is however one complex case, which occurs when:

  . U‑mode is preempted by the hypervisor (HV).
  . HV saved the CR, cleared it and then marked it *LAZY* to be loaded on demand later.
  . If the CR was *CLEAN*, an SCC in VS-mode would be authoritative, and if there were no SCC in VS-mode, the value in HS would be authoritative, so retrieving the value from the parent first, and grandparent otherwise, works well.
  . _However, if the CR was *DIRTY*, the authoritative value resides in HS, while VS‑mode may hold a stale copy_.
  Therefore, the prior dirtiness information must be consulted to retrieve the authoritative SCC from HS rather than from S‑mode.
  This is addressed by using the fourth possible CR status, which is encoded as ``*crlazy``[__i__] = ``*crdirty``[__i__] = 1, which we call **LAZY/DIRTY**.

 . After the import, the CR is set to *CLEAN* and the interrupted operation is restarted.

This is a corner case and it would _not_ happen in the most common case which is:

*** The OS at VS-mode may implement lazy loading.
*** Hypervisors and M _always_ save _and_ restore the _entire_ state.
*** We do not migrate a VM if the CRF capacity at the destination machine is insufficient (the only case that would actually force the hypervisor to not restore everything but making at least some CRs lazy).

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-architectural-model]]
==== Architectural Model

ACE is architected as an _attached_ unit.
This allows both implementations within each core and as a block which is shared by multiple cores, with a single instance of the hardware and one separate architectural state for each hart.
The present specification mandates only its behavior, not its implementation.

Consequently, ACE instructions behave as messages over a tightly coupled coprocessor interface.
The ACE unit accepts operations, executes them independently of the issuing hart, and later returns results.
To enforce this decoupling, the ACE unit may lock certain architectural states, for instance Cryptographic Registers and CSRs, causing the hart to wait when attempting to read them.

This design permits a certain degree of concurrency: ACE operations may proceed even while the control flow of the hart is preempted, and long-running cryptographic computations are allowed. Certain interrupts, however, may be permitted to suspend ACE operations.

For example, consider a U-mode process executing an ACE instruction that updates only internal state, such as a vector register.
If the process is preempted for a context switch, the ACE unit could continue its work until the context-switching handler needs to access the affected vector register, in which case the hart would wait until the operation completes.
Alternatively, an implementation may choose a more precise exception model, halting the ACE unit and setting `acestart` (the ACE analog of `vstart`) to enable later resumption, possibly at an earlier point.
An implementation may also decide to wait only a certain amount of time before halting the ACE unit.
All these approaches are architecturally permissible, and we architect the behavior of certain ACE instructions when interrupted at admissible points.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-threat-model]]
==== Threat Model

_This section is informative and non-normative._

The ACE threat model is straightforward.

**Assets** consist of _keys_ and any other information that could aid an adversary in recovering plaintext or forging ciphertext. This includes items such as masks in tweakable XEX modes and derived keys in AES-GCM-SIV. The critical properties of these assets are their _confidentiality_ and _integrity_.
Protecting the _Availability_ of the keys is not a goal of the architecture.

**Adversaries** are assumed capable of compromising processes by exploiting software vulnerabilities.
They are also able to gain access to memory contents, for instance, by abusing hardware interfaces or by SoC/memory interposition.
The model does not include adversaries capable of sophisticated hardware attacks, such as using
a Focused Ion Beam/Scanning Electron Microscope (FIB/SEM) to tamper with the hardware's functionality.

Side channel attacks are addressed optionally. ACE offers interfaces to both SCA-unprotected and SCA-protected implementations of cryptographic algorithms, if these options are provided by the designer.

Threats can be addressed in four ways:

[horizontal]
**C:**:: _Control_ the threat by implementing full or partial mitigations.
**A:**:: _Accept_ the threat and its associated risks.
**T:**:: _Transfer_ the threat to another party better suited to address it.
**S:**:: _Suppress_ the features that give rise to the threat.

ACE is designed to avoid the “*A*” and “*S*” options (as much as possible). It _controls_ threats through its own mechanisms and _transfers_ residual risk—specifically, the risk of key extraction from the privileged or trusted software and hardware environments that manage keys—to those same environments. For example, trusted software environments may employ control-flow integrity, memory encryption with integrity protection, and anti-replay mechanisms, while hardware key-management blocks can be hardened to protect entrusted keys.

Direct plaintext leakage, memory corruption attacks against the ACE-using process, and Release of Unverified Plaintext (RUP) attacks on the cryptographic algorithms are considered out of scope. These threats cannot be mitigated by ACE because the processed information resides within the user execution context. Consequently, these threats are _accepted_.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-architecture]]
== Architecture

[[ACE-concepts]]
=== Fundamental Concepts

Opaque Key:::
The fundamental concept of ACE is the _opaque key_, i.e., a cryptographic key whose value remains hidden to software even while being used in cryptographic operations.

Cryptographic Context:::
ACE implements the concept of opaque key through _Cryptographic Contexts_ (CCs), architectural containers that protect sensitive information.
Each CC consists of a *metadata section* and of a *content section*.
The metadata section defines the cryptographic algorithm and optional usage policies, while the content section comprises sensitive material—including keys, other secrets, and internal algorithm state.
The confidentiality and integrity of CC content is enforced by restricting modifications and access to architectural mechanisms that enforce rules defined by the configured algorithm.

Object-Oriented Architecture:::
CCs are _objects_ that may expose a uniform interface despite implementing different algorithms.  A CC (or SCC) encapsulates its own behavior, allowing, for instance, AES-128, AES-256, Калина-128, Калина-256, and SM4 instances in ECB mode to be used interchangeably without code changes.  Similarly, modes such as GCM-SIV or XEX/XTS, that can be instantiated with any of these algorithms would also offer the same binary interface, as long as the code supports variable SCC sizes, which can be dynamically discovered. Side-channel-resistant variants would also be supported transparently.

Sealed Cryptographic Context:::
Only the ACE implementation can access CC content.
For protection outside the architectural state, a CC can be exported as a _Sealed Cryptographic Context_ (SCC), i.e., an encrypted and authenticated package containing metadata, a nonce, and authentication tag, and encrypted content.
SCCs can be reimported into CCs when needed.
These operations use a _Context Transport Key_ (CTK).
The most commonly used CTK is the _Root Context Transport Key_ (RCTK), which is stored in an MM-only CSR.
MM manages the RCTK unless it is hardwired or hardware-generated.
Besides the keys in a CC, also the keys in an SCC are called _opaque keys_.

Usage Control Policy:::
An important distinction in ACE is between the _import_ and _export_ operations on CCs, and the _use_ of CCs in cryptographic operations.
It must be always possible to import and export SCCs, and also to clear and overwrite CCs for the purpose of managing cryptographic operations, otherwise a process may be prevented from performing cryptographic operations by clobbering all the CCs.
Therefore, the _Usage Control policies_ in the metadata section may optionally restrict only the operations that perform algorithms that are configured by a CC's metadata, including modifying its state, to specified Modes, ASIDs and VMIDs.

Locale:::
In addition to Usage Control policies,
ACE can bind opaque keys to a _Locale_, restricting their usage to a specific device, device class, software or hardware configuration, or boot cycle.
This binding uses both metadata and a _Derived CTK_ (DCTK) derived from the RCTK and a locale-specific secret via a key derivation function for the purpose of importing and exporting opaque keys.
The system maintains a _Locale Secrets Table_ (LST) containing both system-wide values which are fixed, values that can be configured in an externally defined way,
and fields that can be programmed by MM.
The metadata stores the Locale as an index into this table. See <<ACE-locales>> for more details.

[.red]#*Discussion point:* _Can optional limitations even to import and export make sense and be useful?#_

[.red]#*Discussion point:* _Everything in this specification is still valid if the number of CCs is reduced to, say, 8. Immediate values to refer to CCs are still 5 bits long because the same field can also be used to refer to a GPR, but the only valid values for the CC number are 0 to 7._#

// ///////////////////////////////////////////////////////////////////////////////////////////

=== ACE Programmer's Model

[[ACE-instructions-overview]]
==== Instructions Overview

ACE provides a number of unprivileged instructions.
Some are implemented as CSR reads or writes.
The non-standard notation `C[Xd]`, for a GPR Xd refers to the CC whose number is contained in `Xd`,
and `Cn|C[Xn]` means that there are two different encodings for when the operand is `Cn` or `C[Xn]`.

.The ACE instructions
[width="100%",cols="16%,24%,60%",options="header",subs="+macros"]
|===
| Instruction     | Operands                        |  Description
| `ace.enable` +
`ace.disable`     |                                 |  Enables/Disables the feature in the current mode.  CSRW pseudo-operation.
| `ace.init`      | `Cd\|C[Xd], %offset(Xs)`         |  Sets the metadata and key(s) for the CC.
| `ace.clear`     | `Cd\|C[Xd]`                      |  Clears a CC and marks it as no longer in use and clean.
| `ace.export`    | `%offset(Xn), Cs\|C[Xs]`         |  Securely exports the content of a CC to memory.
| `ace.import` +
`ace.import.S`
| `Cd\|C[Xd], %offset(Xn)`      |  Authenticates and imports a SCC from memory into a CC. +
 `ace.import.S` provides optional support for system defined formats.
| `ace.exec`
| A. {nbsp}{nbsp} `Vd, Cn\|C[Xn], Vs` +
  B. {nbsp}{nbsp} `Cn\|C[Xn], Vs` +
  C. {nbsp}{nbsp} `Vd, Cn\|C[Xn]` +
  D. {nbsp}{nbsp} `Cn\|C[Xn]`
| Performs a cryptographic operation. The instruction may also modify the internal state of the CC. This instruction admits four _forms_, depending on whether it accepts an input or not, and whether it produces an output or not.
| `ace.size`
| `Xd, Cs\|C[Xs]` +
 `Xd, Xs`          |  Returns the size in bytes of the package exported from a specified CC, or from a metadata block.
| `ace.available` | `#immed`                        |  Informs whether a given algorithm is supported by the microarchitecture.
| `ace.clone`     | `Cd\|C[Xd], Cs\|C[Xs]`            |  Clones a CC into a second CC.
| `ace.derive`    | `Cd\|C[Xd], Cs\|C[Xs]`            |  Optional. Uses the source CC to configure the destination CC. Used if the source CC is, for instance, a KEM that configures the destination CC with a symmetric key. Then, the SW can clear the source CC to release resources.
| `ace.state` +
`ace.dir`
| `Cd\|C[Xd], #immed`              |  Triggers transitions in the state of the algorithm (such as the different stages of hash functions or modes of operation) or provide additional information.  `ace.dir` is an alias for `ace.state`.
| `ace.restrict` +
  `ace.harden`    | `Cd\|C[Xd], Xs`                  |  This instruction is used to narrow the Usage Policies of a CC and to turn on or increases the level of the side-channel protection of the algorithm in the CC, if the microarchitecture supports it.
  Removing or weakening existing Usage Policies and reducing the level of side-channel protection are not permitted.
   `ace.harden` is an alias for `ace.restrict`.
| `ace.input`     | `Cd\|C[Xd], %offset(Xs)`         |  Optional. Provides an input to the algorithm configured in the CC `Cd` or `CC[Xd]`, in place of providing it through the `ace.exec` instruction. Useful when the inputs are very long, such as the inputs to certain public key schemes. Mandatory only if required by some algorithms.
| `ace.output`    | `%offset(Xd), Cs\|C[Xs]`         |  Optional. Writes the output of an algorithm configured in the CC `Cs` or `CC[Xs]`, in place of providing it through the `ace.exec` instruction. Useful when the outputs are very long, such as the outputs of certain public key schemes. Mandatory only if required by some algorithms.
| `ace.error`     | `Xd, Cs\|C[Xs]`                  |  A CC Cs (or indexed by Xs) may be in an error state due to the previous operation. The error value is written into GPR Xd.
|===

NOTE: Instructions `ace.init`, `ace.import`, `ace.export`, `ace.input`, and `ace.output` perform direct memory accesses.
This does not violate the RISC-V load/store architecture principles, as ACE is architected as an _attached_ unit, which may have its own interfaces.

// ///////////////////////////////////////////////////////////////////////////////////////////

==== Cryptographic Contexts

The atomic cryptography extension does not add a traditional register file.
Rather, it defines 32 Cryptographic Contexts (CCs) for storing cryptographic keys and metadata.
Each CC is identified by a number from 0 to 31, which the ACE unit uses to access its contents.

Cryptographic Contexts (CCs) reside in a dedicated internal _context file_ (CF) that is inaccessible to any entity outside the ACE implementation, including software, other hardware blocks, and invasive debug interfaces. The CF's memory capacity is implementation-defined and may be as large as 32 times the size of the largest possible CC; however, a smaller amount of memory may be used in practice. At a minimum, the CF must be capable of holding either a single instance of the largest possible CC or the largest CC pair in which the first CC derives the second (via `ace.derive`).

The size of each CC is dynamic, determined by the cryptographic algorithm with which it is configured.
This is an important difference with respect to GPRs and vector registers, which always have the same size.
ACE returns an error ace_err_memory when insufficient memory prevents `ace.init` and `ace.import` operations, requiring the software to free memory by exporting or clearing a different CC. Implementations must provide sufficient CF memory to prevent infinite `ace.export`/`ace.import` loops.

A further difference between CCs and registers is that CCs
are not only addressable via static 5-bit immediate addressing (as normal registers), but also indirectly, i.e., via a value from 0 to 31 in any general-purpose register.
This has two major implications:

. Adding renaming to CCs would add significant complexity to the microarchitecture.
  However CCs are much less often redefined than, say, integer or floating point registers, except for internal implied changes, and therefore we can assume that CCs are not renamed without performance issues.
. An additional bit in the instruction encoding determines whether a CC number is given by a 5-bit immediate or by the value in a GPR.

[[ACE-registers]]
==== Registers

The atomic cryptography extension adds some unprivileged CSRs to a base scalar RISC-V ISA -- as well some privileged CSRs.
It also requires a subset of the V extension to be implemented, including the vector register file.

[[ACE-CSR-enable]]
===== aceenable

`aceenable` is a single-bit CSR.

Enabling ACE in any mode is done by writing a 1 to `aceenable`.
Disabling ACE is done by writing a zero to `aceenable`, which also clears the CCs, as described in <<ACE-tracking-cc-dirtiness>>.

While the standard floating-point and vector extensions do not support User Mode disable/enable instructions, the ACE unit can be enabled and disabled in User Mode, instead of using an OS call or trapping.
However, if the ACE unit contains state from a different process, and its interface is disabled for the current one, enabling it will trap to the Supervisor (as described in <<ACE-ACES-field>>) to allow the latter to first save the state in case it was not saved before and then clear it (lazy context switch).

When a process that has ACE enabled is preempted, the parent modes inherit the state to be able to export and
re-import the CCs. Hence, `aceenable` is not cleared, and the `*status.ACES` fields (see <<ACE-ACES-field>>) of the parent domains will take the value Enabled.
Tracking the CCs which are active, resp., dirty is done on an individual basis and is described in <<ACE-tracking-cc-dirtiness>>.


[[ACE-ACES-field]]
===== ACES field in *status

An ACE context status field, ACES, is added to `mstatus`[26:25], and it is shadowed in `sstatus`[26:25] and in `vsstatus`[26:25] if the hypervisor extension is present.
Like the FS and VS fields, it can be used to optimize context switching.
//Its status encoding differs from the FS, VS, and XS fields (which are defined in <<fsxsencoding>>).
Its possible values are described in <<ACE-fsxsencoding>>.

[[ACE-fsxsencoding]]
.Encoding of ACES[1:0] status field
[float="center",align="center",width="100%",cols="^7%,<18%,<75%",options="header"]
|===
|Status |Name |Meaning
|   0   | Disabled-Clean     | ACE ISE not enabled, software assumes no context being configured for this hart. +
The ACE unit will erase all contexts if ACE is enabled by writing to the `aceenable` CSR.
|   1   | Disabled-Clobbered | ACE ISE not enabled, software assumes there are configured contexts left for this hart from other environments.
The hart will trap if ACE ISE is enabled by writing to the `aceenable` CSR. To be used only if explicitly supported in system SW stack, otherwise Disabled-Clean must be used.
|   2   | Enabled            | ACE ISE enabled.
|   3   | Invalid            | Reserved.
|===

The Disabled-Clean and Disabled-Clobbered states are set by the parent mode.
Disabled-Clobbered is used when the parent-mode software stack does not save Cryptographic Contexts before transferring control to a process that does not (yet) have enabled ACE. If that process later enables ACE by writing to `aceenable`, the hart traps to the parent mode, allowing lazy context save; the parent must then manually reset all Cryptographic Contexts. In contrast, a software stack that always saves the contexts of a switched-out process must configure only the Disabled-Clean state.
The Disabled-Clobbered state is primarily intended for small devices where thread migration between harts is infrequent, and possibly only one process may be dealing with cryptographic operations.

NOTE: It is responsibility of the exception handler to properly handle the contents of the CCs when the feature is enabled while ACES=Disabled-Clobbered, as
described in <<ACE-tracking-cc-dirtiness>>.

Writes to ACES do not affect the contents of the CCs.
Setting ACES=Disabled-Clean or Disabled-Clobbered does not destroy the state, nor does setting ACES=Enabled clear the contents.

Fine-grained tracking activeness and dirtiness of individual CCs uses the `aceccactive` and `aceccdirty` CSRs, cf.{nbsp}<<ACE-tracking-cc-dirtiness>>.

===== aceerror

The `aceerror` CSR contains only as many bits as needed to encode the error status.

// All other bits are reserved for future use.
// It is not a complete analogue of `fcsr` or `vcsr` since, for instance, it does not have to encode information such as rounding modes.
// Also, the error status is a field and not a set of distinct condition codes.

[[ACE-tracking-cc-dirtiness]]
===== Tracking CC dirtiness

This is done by using two CSRs, which track the use and dirtiness of the CCs individually:

[arabic]
. `aceccactive`: 32 bits, with a bit per CC to denote whether the register is in use or not (cleared contextually to CC erasure to dispose of the key). Read-only.
. `aceccdirty`: 32 bits, with a bit per CC to track whether the corresponding CC has been modified since the last time the same bit has been cleared. +

If the _i_-th bit of `aceccdirty` is set, then the _i_-th bit of `aceccactive` must also be set.

Two types of actions can modify a CC and thus must update also `aceccdirty`:

* An explicit initialization/configuration/import; and
* Certain cryptographic operations, such as absorbing information in a hash function, that modify the internal state.

It is also possible to directly write to `aceccdirty` to optimize context switching.

Implementations are required to track the dirtiness of any CC precisely and individually.
This is different from the tracking of the dirtiness of the floating-point state, for instance.

Context-switching code must save CC number _i_ if the _i_-th bit of `aceccdirty` is set.
However, it can clear `aceccdirty` when returning control to the same process after restoring its ACE state.
This indicates to the context-switching code that there is no need to save the CC number _i_ again at the next context switch out of that process unless it has been modified again thus setting the _i_-th bit of `aceccdirty` anew.

Upon a write to `aceenable` that changes its value, the following happens to `aceccvalid` and `aceccdirty`:

* If `aceenable`'s value is changed to 0, then all CCs are cleared, both `aceccvalid` and `aceccdirty` are set to 0, and `*status.ACES` is set to Disabled-Clean.
* If `aceenable`'s value is changed to 1, and if the parent domain's `*status.ACES`=Disabled-Clean, then we simply assume that the parent process has cleared the CC and set both `aceccvalid` and `aceccdirty` to 0 before transferring the control flow to the current process.
* If `aceenable`'s value is changed to 1, and if the parent's `*status.ACES`=Disabled-Clobbered, then the hart traps to allow the parent domain responsible for handling context-switched to finish saving the state and ensure that both `aceccvalid` and `aceccdirty` are set to 0, and finally set `*status.ACES`=Disabled-Clean.
// [.red]#This behavior should be restricted only to User mode.#

[[ACE-ccstart-definition]]
===== ccstart

`ccstart` is an XLEN-bit CSR that serves a similar role in ACE as `vstart` does in the V extension.

The instructions `ace.init`, `ace.import`, `ace.export`, `ace.input`, and `ace.output` may require significant execution time and can be interrupted mid-instruction by interrupts or memory exceptions.
In such cases, implementations may set `ccstart` to a non-zero value, enabling the instruction to resume from the interruption point rather than restart from the beginning.
Since ACE does not have the concept of the length of an element,
`ccstart` represents a byte offset rather than an element index as in `vstart`.
Specifically, a load-type instruction was interrupted after reading _and_ processing `ccstart` bytes of input in the state,
and a store-type instruction was interrupted after computing and writing `ccstart` bytes of output.

NOTE: The `ccstart` value is given in bytes, even though payload sizes are always multiples of 8 bytes. This design accommodates piecewise execution via traps for the `ace.init`, `ace.clear`, `ace.export`, `ace.import`, `ace.input`, and `ace.output` operations, which involve `mv` operations at long-word, quad-word, or vector-register granularity, cf.{nbsp}<<ACE-trappable-insns-support>> for more details.
This is also compatible with the fact that `ace.size` returns a size in bytes.

Like `vstart`, `ccstart` is a standard read/write CSR; however, software must not write arbitrary non-zero values to it.
Normally, hardware sets this register on trap.
Software may safely write 0 to restart operations completely, and the register can be saved and restored during context switches.
Writing an arbitrary non-zero value may raise an illegal-instruction exception, as hardware is not required to support all values.
If no exception is raised and an invalid value is written, authentication will fail upon import because portions the content are replaced with arbitrary values, or exports will produce unauthenticatable output.  Only `ace.init` may still create a valid context, but since the key values were already in plaintext within the same domain, this does not expand the attack surface.

Only the instructions explicitly mentioned above support non-zero `ccstart` values; other ACE instructions ignore this register if set by software, and will be restarted.

[[ACE-why-restarting,Remark {counter:remark}]]
*Remark {counter:remark}.*
_A single `ccstart` value suffices due to the authenticated encryption algorithm used. The operations behave as follows:_

* `_ace.init_` _(formerly `ace.config`) is a single-pass operation: the metadata section is read first, determining the payload length. If sufficient memory is available, subsequent blocks are read sequentially and passed to a deserialization circuit to populate the CC._
* `_ace.import_` _operates similarly to `ace.init`: the metadata section is read first to determine the payload length. If sufficient memory is available, the remaining blocks are read, decrypted, and passed to a deserialization circuit to populate the CC._
* `_ace.export_` _involves two passes, but the first pass is entirely internal to the ACE unit. Hence, the first pass cannot cause a page fault, and is easily restarted. Specifically, it computes the SIV by applying POLYVAL to the serialized CC content. Subsequently, the serialized metadata, the nonce, and the SIV are written out, followed by the CC content serialized, encrypted and written out block by block. It is this last part that may cause page faults, and that may require resumption._

_Although these operations are inherently complex, the ACE unit is architected to function like a separate machine executing simpler instructions sequentially. State machines (one per CPU hart connected to the ACE unit, potentially in a 1-to-1 configuration) receive commands from the CPU and break them into smaller steps._

_Therefore, separating data transfer from cryptographic operations in import/export is unnecessary. Otherwise, the loaded payload would need to be stored within the ACE unit rather than processed inline with minimal overhead, and this may lead to higher internal resource requirements_

_Finally, resuming requires at least as many cryptographic operations as restarting if the trapped domain also saves and resumes partial SCCs. Memory accesses may be reduced, but since data read from memory initially (for `ace.init` or `ace.export`) may no longer reside in the caches, resuming may offer better performance on some systems. Additionally, resuming avoids potential circular page-fault issues, as opposed to restarting._

[.red]#*TBD* Specify the exact semantics of `ccstart` and define the points at which various operations can be interrupted.#

===== Reuse of ASID and VMID (to be verified).

We reuse the CSRs for `ASID`, resp., `VMID`
(i.e., the CSR fields `satp`.ASID and `hgatp`.VMID).
to give only certain User processes and Supervisor processes access to certain key spaces.
The maximal bit length of `ASID` is 9 for Sv32 addresses or 16 for Sv39, Sv48, and Sv57 addresses.
The maximal bit length of `VMID` is 7 for Sv32x4 or 14 for Sv39x4, Sv48x4, and Sv57x4 addresses.
In the metadata section, `ASID` and `VMID` are always zero padded to the maximal lengths of 16 and 14 bits, respectively.

[.red]#However, we need a mechanism to make sure that if the system is not configured to insert `ASID`, resp., `VMID` into the GVAs/GPAs, we can still usage them for the purpose of policing the usage of CCs.#

[[ACE-providing-keys,Remark {counter:remark}]]
*Remark {counter:remark}.* _The software in each World/Supervisor Domain is normally responsible to generate or obtain their own keys, and if a process (applet) in one World/Supervisor Domain is responsible to provide keys to other Worlds/Supervisor Domains, it is the responsibility of the MM to perform an appropriate sequence of import, switch the CTK, then export operations._


===== Privileged Registers

====== ACE field in misa

The `misa.ACE` field uses bit `L` (11) to indicate that the ACE extension is implemented.
//This bit is chosen because the extension goes _beyond_ the cryptographic extension, which will likely use bit `K` (10).

====== acerctk

If the RCTK can be programmed, it can only be programmed by MM.
For this purpose, we need eight 32-bit CSRs are available, called `acerctk0`, `acerctk1` .. `acerctk7`, where register `acerctk{i}` contains bits [stem:[31+32\,i:32\,i]] of the RCTK.
No exception is raised if software running in any other mode tries to write to the `acerctk` block, such writes are simply ignored.
The `acerctk` block always reads as zero.

NOTE: Discoverability of whether the RCTK can be configured or not is not critical, since this is information known by the MM firmware.
[.red]#We can use the data structure pointed by `mconfigptr` in order to track optional features of ACE including whether the `acerctk` CSR block is implemented, and if not whether whether the value is ephemeral or fixed.# +
 +
User mode, and even operating systems and hypervisors, need not be aware of the `acerctk` block. Other mechanisms could have been chosen to program the CTK, such as an MM-exclusive dedicated hardware interface or memory-mapped interface.

====== Re-configurable Locales

Two groups of four consecutive 32-bit CSRs, programmable by MM, are used to define two reconfigurable locales
(cf.{nbsp}<<ACE-concepts>>).
These groups are:
`ace_OS_Secret{i}`, for `i` in [0..3], to configure the "OS Secret" entry,
and `ace_Boot_Session{i}`, for `i` in [0..3], to configure the "Boot Session" entry (cf.{nbsp}<<ACE-locales>>).

The reason `ace_Boot_Session*` must be reconfigurable is that it must change in a VM if the latter's virtual hardware is re-booted, and this can happen independently from the underlying host and other VMs. For instance, a VM may be frozen, then the host may be rebooted, and then the VM may be resumed, in which case no boot session occurred in the VM, while it happened in the host hardware.

NOTE: User mode, and even operating systems and hypervisors, need not be aware of the `ace_OS_Secret{i}` and `ace_Boot_Session{i}` blocks. Other mechanisms could have been chosen to program the "OS Secret" and  "Boot Session" entries, such as an MM-exclusive dedicated hardware interface or memory-mapped interface.

==== Data Structures

ACE defines two distinct representations of cryptographic information: the CC configuration format, and the encrypted, authenticated SCC format. These two  formats are architected for software portability and interoperability.
//, enabling virtual-machine migration across heterogeneous hardware—for example, between cloud or consumer devices with CPUs from different vendors.
The internal CC representation, on the other hand, is implementation-specific.

All data formats are little-endian.

NOTE: Mechanisms for persisting Context Transport Keys (CTKs) across reboots or transferring them between devices are outside the scope of the present ACE architecture. These are system-specific and belong to MM firmware. For cross-device migration, the use of a public-key key-encapsulation mechanism (KEM) is recommended.

[[ACE-metadata]]
===== Metadata Section Format

The metadata section is 64 bits long and its format described in <<ACE-metadata-standard>>.
This format is used for CC initialization, export and import purposes.
The internal representation is implementation specific.
// To initialize a CC, the first 64 bits of the input buffer contain the metadata in entirely in cleartext.
// The metadata is in cleartext also in exported SCCs.
// The entire metadata section is included in the computation of the authentication tag.
// The details are described in <<ACE-formats>>.

[#ACE-metadata-standard]
.Format of the Metadata Section
[width="100%",cols=">9%,^7%,17%,67%",options="header"]
|===
|   Field | Width | Name                  | Description
|     [0] |   1  | Format                 | 0 for the current metadata format. +
Future format will have a 1 in this position and may be longer than 64 bits.
|   [8:1] |   8  | Algorithm              | Algorithm (such as primitive or mode). 0 means the CC is invalid.
|  [10:9] |   2  | SC_Protection          | Level of Side Channel Protection, encoded as per <<ACE-SC-protection-levels>>.
| [12:11] |   2  | Direction_Policy       | Determines whether the CC may be used for encryption (bit 11 set), decryption (bit 12 set), or both (bits 11 and 12 set).
Valid only for encryption/decryption primitives or modes, and ignored, for instance, for hash functions.
| [14:13] |   2  | Key_Type               | By explicit value / Immutable (index) / Internally generated.
| [18:15] |   4  | Locale                 | Field which is either -1 or an index into the Locale Secrets Table.
| [20:19] |   2  | Completion             | Defined in <<ACE-CC-complete>>.
Used to determine whether an operation must be restarted.
| [24:21] |   4  | Stage (also Direction) | Encoding the current state of the state machine of the algorithm as a number (also called the "stage" of the algorithm).
It must be zero upon configuration, otherwise algorithm specific.
If, for the algorithm encoded in the CC, the number of states is less than 16, then this number is stored in this field, cf. <<stage-field>>,
otherwise an algorithm-specific representation is used in the content, and this field only admits the values 0 (initial) and 1 (anything else).
The values must conform to <<ACE-stage_constants>>.
| [28:25] |   4  | UC_Policy_1            | "UC Policy" means "Usage Control Policy". +
Disallow the _usage_ of this CC in User, (Virtual) Supervisor, Hypervisor, resp., MM if bit 25, 26, 27, resp. 28, is set. Cf. <<stage-no-H-no-VMID>>.
| [30:29] |   2  | UC_Policy_2            | If bit 29, resp., 30, is set, then restrict the usage by `ASID`, resp., `VMID`. Restriction by `ASID` ignored if in S Mode or higher. Cf. <<stage-no-H-no-VMID>>.
|    [31] |   1  | Reserved               | Undefined.
| [47:32] |  16  | UC_Policy_3            | Zero if bit 29 unset, else `ASID` to enforce.
| [63:48] |  16  | UC_Policy_4            | Zero if bit 30 unset, else `VMID` to enforce. Cf. <<stage-no-H-no-VMID>>.
|===

Algorithms are encoded in a 8 bit field.
A zero in the algorithm field means the CC is invalid.
Algorithm numbers 1-127 are architecture-defined and the list of such encodings is maintained by RVI.
See <<ACE-Algorithms>> for the currently encoded algorithms.
Algorithm numbers 128-255 are reserved for custom algorithms.

[[ACE-SC-protection-levels]]
.Encoding of Side-Channel Protection levels
[float="center",align="center",width="76%",cols="^8%,<68%",options="header"]
|===
| Value | Description
|   0   | No protection.
|   1   | Data independent timing, first-order threshold implementation.
|   2   | Data independent timing, first-order threshold, fault tolerant implementation.
|   3   | Custom, algorithm dependent.
|===

Custom algorithms may offer stronger side channel protection guarantees than those specified in the encoding values 0 to 2.
In such a case, the value of the SC_Protection field must be set to 3.

[[ACE-key-type]]
.Encoding of Key Type
[float="center",align="center",width="76%",cols="^8%,<68%",options="header"]
|===
| Value | Description
|   0   | Explicit value.
|   1   | Internal table. System specific. For each algorithm as specified in <<ACE-Algorithms>>, the part of the content that normally contains the key(s) is replaced by a 64-bit value which is an index into the internal Immutable System Keys Table (ISKT) --- for both Configuration Input and the SCCs. The actual value of the key is never included in exported content. For threshold algorithms, ACE may copy the key material from the ISKT into the CC and expand it into multiple shares.
|   2   | Internally generated key. System specific.  In the Configuration Input, the part of the content that normally contains the key(s) is replaced by a "recipe" in a system-specific format. The format is not specified by the ISA and may not be portable to other systems. Once the key material has been internally generated, the value is included in the SCC as part of the content - not the "recipe" - as for any other key(s) for the same specified algorithm.  Even in the SCC, however, the Key_Type field of the metadata, both internally and in the SCC, will keep the value 2.
|   3   | Invalid.
|===

[[ACE-CC-complete]]
.Encoding of Completion field
[float="center",align="center",width="58%",cols="^8%,<50%",options="header"]
|===
| Value | Description
|   0   | No `ace.init`, `ace.input`, `ace.output`, `ace.import` or `ace.export` operation currently incomplete.
|   1   | `ace.init`, `ace.input`, or `ace.output` was interrupted.
|   2   | `ace.import` was interrupted.
|   3   | `ace.export` was interrupted.
|===

NOTE: The information in the Completion field is in principle known to the system software/firmware stack, we duplicate it into the metadata to ensure that it remains accessible after nested interrupts, i.e., after switching partially configured/imported or exported CCs in or out. While authentication also guarantees the integrity of the SCCs and of their import, this is both a robustness measure and serves to simplify system stacks.


// Whether the CC is complete (00) or interrupted while being configured (01), imported (10) or exported (11). Necessary to know whether to restart operations.

[[stage-field,Remark {counter:remark}]]
*Remark {counter:remark}.* _The "state" field accommodates modes of operation with a small number of states.
For algorithms with more complex state machines, machine state information can be stored in a custom data section of the CC._

[[state-no-H-no-VMID,Remark {counter:remark}]]
*Remark {counter:remark}.* _If the H extension is not enabled, bit 27 must be set to 1, and bits 30 and [63:48] must be set to 0.
The "UC_Policy_4" field is 16 bits long for compatibility with architectures employing 16-bit `VMID` fields (for instance, in heterogeneous systems).
While interoperability cannot be guaranteed when this policy is used, this ensures that the two top bits are not used for other purposes. +
Filtering usage by Supervisor Domain or World ID is not supported, and not only because of lack of space in a 64-bit metadata section:
Reconfiguring the RCTK is a better approach for such isolation requirements, whereas isolation by `ASID` and `VMID` is a weaker security feature._

[[ACE-locales]]
===== Locales

Internally, ACE keeps a table of 128-bit Locale Secrets (LS), the Locale Secrets Table (LST).
Some of these entries are fixed, other values may be configurable only using an implementation-specific authenticated hardware procedure, and the remaining may be programmed by MM (*Note:* _we need to define the corresponding CSRs_).
The LST is a global table shared across all ACE units with some fields which can be MM-programmed and are architectural (i.e., per hart).
//Currently, the only two values that may be overridden by architectural values, in order to support multiple VMs/Supervisor Domains/Worlds are System_Secret and Boot_Session.

If the Locale Field of a context (CC/SCC) is -1 (all ones), then the RCTK is used.
Otherwise, this value is used as an index _i_ in the HST, and a derived key computed from RCTK and LST[_i_] is used for import/export in place of the RCTK.
The encryption and authentication keys are then derived from the DCTK.

In <<ACE-binding-indices>>, we list the mandatory entries.
Column "MM-Config." indicates whether MM may be allowed to configure the entry.
We also specify the domain of each Locale Secret, i.e., whether the value is
chip-wide (should be the same across all chiplets in the same SoC, two distinct SoCs the same decide may have different values),
device-wide, or (usually) OS-wide.
//The first two Locale Secrets are chip-wide, and should be the same across all chiplets in the same SoC -- a separate chip in the same system may have different values.
//Three further Locale Secrets must be the same across the entire device, and the Locale Secrets at indexes 5 and 6 can be reprogrammed by MM.

[[ACE-binding-indices]]
.Mandatory Locale Values
[width="100%",cols="17%,49%,^8,^8%,^8%",options="header"]
|===
.>| Name .>| Description .>| Domain | MM-Config. .>| Value +
(Index)
| No locale binding         | No CTK derivation. CC bound to BCTK only. | -- | -- | -1 (15)
| Chip_Manufacturer         | Identifies the manufacturer of the SoC. Permanent. | SoC | N | 0
| Chip_Model                | Identifies specific chip model/family. Permanent. | SoC | N | 1
| OEM_Secret                | Provisioned by OEM to differentiate their products from the competition.
                              Can be permanent in a device — optional reconfiguration using impdef HW authenticated mechanisms. | Device | N | 2
| Product                   | Identifies device/system type/model (product). Not necessarily permanent. Reconfigurable like OEM_Secret. | Device | N | 3
| Device                    | Unique device (entire system) secret (not the device ID such as a serial number, but it can be derived from it, for instance by hashing).
                               Shared across all harts in a Soc and shareable across multiple SoCs in a single device. Sharing mechanism impdef, i.e., not architected.
                               Reconfigurable like OEM_Secret. | Device | N | 4
| OS_Secret                 | Identifies Operating System (or System Stack). +
                              Not permanent, must be configured during (virtual) boot. | OS | Allowed | 5
| Boot_Session              | Regenerated at each (virtual) boot. | OS | Allowed | 6
| Reserved                  | Reserved for future use (RZ if not defined). | Impdef | Impdef | 7-14
|===

The constant LOCALES_MAX is the maximum number of locales supported by the system.

// [[ACE-virtual-reboot,Remark {counter:remark}]]
// *Remark {counter:remark}.* _We need to mention what to do in case there is a reboot of a VM.
NOTE: MM has the responsibility to virtualize the OS_Secret and Boot_Session Locale Secrets.

// , since some VMs may reboot while others may not.
// Also, do we want to allow a VM to have a different virtual hardware? Or does it always declare the same configuration as the underlying hardware?_
// In principle, all this can be done by calling into MM. MM would need to keep track of the locale binding values and ensure that they are updated correctly when necessary.

*Example*: _If a key's metadata specifies a Locale field value of "2", the key for import/export operations is derived from the RCTK and the "OEM Secret".
Consequently, while `ace.export` remains functional on the same device to support context switching, an `ace.import` of the resulting SCC on a device from a different OEM will trigger an authentication failure (provided that the OEM Secrets are, in fact, different)._


NOTE: _In a CC, a key may be referred to using an index into an internal, system defined key table, the System Key Table (STK). If some of these keys are device specific, they will not work as intended on a second device.
If the Locale of this CC is not restricted, the internal key index may be interpreted as an internal key on a different device, with unspecified behavior.
Hence the implementation of the STK must also provide the proper Locale metadata to the ACE implementation to configure a CC._

[[ACE-formats]]
===== Formats of Configuration Inputs and Sealed Configuration Contexts

The format of the input to `ace.init` is simple: the first 8 bytes must contain the 64-bit metadata section, followed by any key and additional information in a format specified by the algorithm. The total length of this input must be a multiple of 8 bytes.
The lengths of the configuration payload, of the content section, and of SCCs is given in bytes.

Each algorithm must provide following functions:

* `metadata_serialize(CC) -> byte array`: Serializes the internal metadata into a 64-bit block for export.
* `metadata_deserialize(CC,byte array) -> CC.metadata`: Takes a metadata block formatted as described in <<ACE-metadata>> and deserializes it to the internal representation of the metadata section.
* `initial_content_deserialize(CC,byte array) -> CC.content`:
Reads the information provided to `ace.init` as the byte array that follows the metadata, and deserializes it for the internal representation.
It must be the same as the format used for the SCC except for some omitted fields.
* `content_serialize(CC) -> byte array`: Serializes a CC's content to a byte array to be encrypted for export.
* `content_deserialize(CC,byte array) -> CC.content`:
Takes the decrypted byte array, that comes after the metadata, nonce and authentication tag, and deserializes it into a CC's content.
The format depends on the algorithm which is specifiedx in metadata information.

See <<ACE-Algorithms>> for algorithm specific details.

The size of a SCC, and thus of all byte arrays read or written by the above 5 functions, is always a multiple of 8 bytes.

Format of Configuration Input:::
The first 8 bytes must contain the 64-bit metadata section as specified in <<ACE-metadata>>,
followed by the key(s) and possibly other information as specified by the algorithm.

Plaintext Format of SCC:::
bytes[7:0]{nbsp}{nbsp} contain the 64-bit metadata section, +
bytes[19:8]{nbsp}{nbsp} contain the nonce (96 bits) +
bytes[31:20] {nbsp}{nbsp} contain the SIV (96 bits) +
bytes[u+31,32]{nbsp}{nbsp} contain `content_serialize(CC.content)`, which has a byte length of u.

Only the serialization of the content is encrypted, while both metadata and content are included in the computation of the authentication tag, as described next.

//[[ACE-AEAD]]
//==== Authenticated Encryption of a Context

To describe how a SCC generated, we first define the RFC8452 Key Derivation and the DCTK Derivation functions.

.RFC8452 Key Derivation
[source,sail]
----
function RFC8452_KeyDeriv(K) = {
  struct {
    AESE256(K, (0[125:0] @ 0b101))[63:0] @ AESE256(K, (0[125:0] @ 0b100))[63:0] @
    AESE256(K, (0[125:0] @ 0b011))[63:0] @ AESE256(K, (0[125:0] @ 0b010))[63:0],
    AESE256(K, (0[125:0] @ 0b001))[63:0] @ AESE256(K, (0[125:0] @ 0b000))[63:0]
  }
}
----

.Derived Key Derivation
[source,sail]
----
function DCTK_KeyDeriv(K,L) = {
  AESE256(K, L ^ (0[125:0] @ 0b011))[63:0] @ AESE256(K, L ^ (0[125:0] @ 0b010))[63:0] @
  AESE256(K, L ^ (0[125:0] @ 0b001))[63:0] @ AESE256(K, L ^ (0[125:0] @ 0b000))[63:0]
}
----

We can now define the generation of the SCC from a CC.

.Generation of the SCC from a CC
[source,sail]
----
metadata : bits(64);
last_block_fractional : bits(1);
content : array[num_blocks] of bits(128);
M : array[num_blocks+2] of bits(128);
let N : bits(96) = random(96 bits);
Kenc : bits(256);
Kauth : bits(128);

if (metadata.Locale == 15) then {
    CTK = RCTK;
} else {
    CTK = DCTK_KeyDeriv(RCTK, LST[metadata.Locale]);
}

{Kenc, Kauth} = RFC8452_KeyDeriv(CTK);
let SIV : bits(96) = POLYVAL(Kauth, N, metadata @ content)[95:0];

M[0][127:0] = N[63:0] @ metadata[63:0];
M[1][127:0] = SIV[95:0] @ N[95:64];
if (last_block_fractional) then last = num_blocks - 1 else last = num_blocks - 2
foreach(i from 0 to last) {
    M[i + 2][127:0] = content[i] xor AESE(Kenc, SIV @ (binary(i)[31:0]));
}
if (last_block_fractional) then {
    M[last + 1][63:0] = content[last + 1]
                        xor AESE(Kenc, SIV @ (binary(last + 1)[31:0]))[63:0];
}
----

NOTE: Due to the computational cost of the derivation functions, implementations may cache recently used derived keys for both the Root RCTK and locale-derived keys.

//NOTE: This simplification of AES-GCM-SIV does not require appending the lengths of metadata and content to the hash, as these lengths are already implied by the cleartext bits of the metadata, which are included in the authentication tag computation.

NOTE: Certain format details are fixed across algorithms. All pure ciphers use a single key, regardless of whether they employ a normal or threshold implementation; threshold implementations are always reduced to a single key. Some modes follow the same convention, while others require algorithm-specific state formatting.

// The total output length must be a multiple of 64 bits. If the combined metadata and content do not meet this requirement, the final block is zero-padded.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-constants]]
==== Constants

[[ACE-error-codes]]
===== Error Codes

ACE error codes are 8-bit values.
The range [0..127] is reserved for RVI.
Error codes specific to custom algorithms may be freely defined in the range [128..255], and are allowed to overlap between algorithms.

[.red]#(May still be incomplete.)#
In <<ACE-error-values>>, we define the mandatory error codes.

[[ACE-error-values]]
.Error values and their meanings
[float="center",align="center",width="100%",cols="^6%,<24%,<70%",options="header"]
|===
|Value | Mnemonic                  | Examples
|  0   | ace_err_ok                | No error.
|  1   | ace_err_authentication    | Authentication failure in `ace.import`, but can also follow `ace.exec` with certain algorithms.
|  2   | ace_err_privilege         | `ace.exec`, `ace.state`, `ace.derive`, `ace.spawn` failed because the access control policies in the metadata prevent usage in the current architectural state.
|  3   | ace_err_invalid           | Invalid input or operation. +
Examples:
the metadata section passed to `ace.init` is invalid;
encryption, resp., decryption is requested from a CC only configured for decryption, resp., encryption, and more generally
the current state of the CC does not expect the used form of `ace.exec`;
the requested change of state in `ace.state` is not permitted;
the change in usage policies in `ace.restrict` is not permitted because it would either downgrade or overwrite the current restrictions in the CC;
a request to clone a CC violates the re-initialisation policies of the source CC;
software tried to use an incomplete CC as a source in a `ace.exec`, `ace.state`, `ace.input`, `ace.output`, `ace.clone`, `ace.derive`, `ace.harden`, `ace.restrict` operations.
|  4   | ace_err_unimplemented     | The requested algorithm is not implemented. May be triggered also on algorithm variants, for instance if `ace.harden` is issued on an algorithm for which a non-side channel protected version is not implemented.
|  5   | ace_err_memory            | The free internal CF memory is not sufficient to perform the `ace.init`, `ace.exec`, `ace.clone`, or `ace.derive`.
The implementation must make sure this cannot happen with any other operation.
If algorithms that support `ace.derive` are implemented, the implementation must make sure that both the input and output CCs of this operation can be allocated.
|  6   | ace_err_unallocated_CC    | Software tried to use an unallocated CC as a source in a `ace.exec`, `ace.state`, `ace.input`, `ace.output`, `ace.clone`, `ace.derive`, `ace.harden`, `ace.restrict` operations. +
This can be used in low CF memory situations to trigger a lazy re-load of that CC.
|===

===== Supported Algorithms

[.red]#Add algorithm numbers!#

We architect support for several algorithms, and also define a minimal subset (current suggestion):

* AES-128 and AES-256 encryption and decryption.
* AES-CTR, AES-GCM, AES-GCM-SIV, AES-XTS using AES-128/256.
* AES-CMAC using AES-128/256.
* SHA-2, SHA-2-HMAC.

The list of other architected algorithms is TBD, but it must include at least

* AES-192, alone and with the above modes.
* SM4 Block Cipher.
* The Ascon suite (Ascon-128/128a-AEAD, Ascon-Hash, Ascon-XOF, Ascon-80pq).
* SHA-3, SHA-3-HMAC.
* SM3 Secure Hash.

===== Other Constants

[.red]#(May still be incomplete.)#
In addition to error codes and algorithms encodings, ACE defines a few more constants, such as
those in <<ACE-stage_constants>> which are used in `ace.state`/`ace.dir` to change the state of a CC.

[[ACE-stage_constants]]
.Constants defining messages sent to a CC through `ace.state`/`ace.dir` operations
[float="center",align="center",width="100%",cols="^6%,<29%,<65%",options="header"]
|===
|Value | Mnemonic                      | Examples
|  0   | ace_const_initial             | The context is initialized and ready for operation.
|  1   | ace_const_encrypt +
ace_const_operate
| Encryption is requested. +
Algorithm is ready to process.
|  2   | ace_const_decrypt             | Decryption is requested.
|  3   | ace_const_hash_start          | Start (and initialize) a hash function or the sub-function of an algorithm.
|  4   | ace_const_hash_finalize       | Finalize the internal state of a hash function and prepare it for outputting the result.
|  5   | ace_const_hash_update         | Update the internal state of a hash function with new data.
|  6   | ace_const_set_public_value    | Set a public value (like a nonce or an IV) in an algorithm. Some algorithms require more than one public value (for instance, they may admit a re-useable hash of some associated data and a unique nonce), in which case the second public value can be set using the next message.
|  7   | ace_const_set_public_value_2  | Set the second public value in an algorithm.
|===

// ///////////////////////////////////////////////////////////////////////////////////////////
// ///////////////////////////////////////////////////////////////////////////////////////////

=== Instructions

We now give detailed descriptions of the instructions, including their semantics and encoding.

NOTE: These encodings are just examples, and may not be final.
They serve as a starting point for discussion and refinement as
well as a proof that, at the time of this writing, the ACE instruction set
can be encoded.

NOTE: ACE is an ideal candidate for the Composable Custom Extensions framework,
even though our aim is to make it into a ratified extension.


==== ace.enable/ace.disable

`ace.enable` +
`ace.disable`

Description::
Enable/Disable the feature in the current process domain and (*TBD* determine
how many contexts we need).
`ace.enable` must be issued before using any ACE operation.
 +
This is a pseudo-operation for a write to a WARL CSR. +
See <<ACE-CSR-enable>> and <<ACE-ACES-field>> for more details.

// When disabling:
//
// * Care is necessary in the design to allow a locking disablement without
//   erasing the registers when a parent gives control back to a child process
//   that does not use the feature.

==== ace.init

`ace.init Cd|C[Xd], %offset(Xs)`

Encoding::
`ace.init` is an I-type instruction.
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Cs','C[Xd]'] },
    { bits:  3, name: 'ace.init', attr: [0x4,0x5] },
    { bits:  5, name: 'Xs' },
    { bits: 12, name: 'imm', attr: ['offset'] },
]}
....

Description::
`Cd` is the source CC to be configured (encoded as a 5-bit immed). +
`Xd`, alternatively, is a GPR containing a number from 0 to 31 to select the context
to be configured. +
GPR `Xs` points to the region of memory containing the metadata and the key material.

Configures a CC with metadata and content.

// [.red]#(TBdetermined whether it is secure)# This instruction is trappable and may also be resumed or restarted.

==== ace.clear

`ace.clear Cd|C[Xd]`

Encoding::
`ace.clear` is an I-type instruction.
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Cs','C[Xd]'] },
    { bits:  3, name: 'ace.clear', attr: [0x6,0x7] },
    { bits:  5, name: 0x0 },
    { bits: 12, name: 0x0 },
]}
....

Description::
`Cd` is the source CC to be cleared (encoded as a 5-bit immed). +
`Xd` alternatively, is a GPR containing a number from 0 to 31 to select the context to be cleared. +

==== ace.export

`ace.export %offset(Xd), Cs|C[Xs]`

Encoding::
`ace.export` is an S-type instruction.
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'imm[4:0]' },
    { bits:  3, name: 'ace.export', attr: [0x0,0x1] },
    { bits:  5, name: 'Xd' },
    { bits:  5, name: 'context', attr: ['Cs','C[Xs]'] },
    { bits:  7, name: 'imm[11:5]' },
]}
....

Description::
Exports the contents of CC `Cs` or `C[Xs]` to memory, starting at address `Xd`, using
the procedure described in <<ACE-formats>>.
If the context `Cs` is clear, or `Xs` is out of range,
the operation will report error ace_err_invalid.

The instruction must be resumable in case of interrupts.
Similarly to entire-vector-register store instructions, `ace.export` appears to other harts as
sequences of individual stores.




// [.red]#(TBdetermined whether it is secure)# This instruction is trappable and may also be resumed or restarted.

==== ace.import

`ace.import Cd|C[Xd], %offset(Xn)` +
`ace.import.S Cd|C[Xd], %offset(Xn)`

Encoding::
`ace.import` is an I-type instruction.
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Cd','C[Xd]'] },
    { bits:  3, name: 'ace.import', attr: ['0    0    S','0    1    S'] },
    { bits:  5, name: 'Xn' },
    { bits: 12, name: 'imm' },
]}
....

Description::
`Cd` is the destination CC to be imported, as an immed (5-bit). Alternatively,
the number of context into which import the SCC is stored in the GPR `Xd` as a
number from 0 to 31. `Xn` is the GPR containing the base address of the buffer
with the SCC. +
 +
The instruction must be resumable in case of interrupts.
Similarly to entire-vector-register load instructions, `ace.import` appears to other harts as
sequences of individual loads. +
 +
The bit S takes the values 0 (false) or 1 (true).
It is set to true if the key is in a system defined format
(`ace.import.S`)
and not the format defined by the present architecture
(`ace.import`). +

NOTE: There is no further specification as to
what the system defined format is in the encoding of the instruction, and in
case more than one system defined format is defined, the data format itself
must distinguish between them.  In other words, it is the responsibility of
the system to augment all the system defined formats with a unique identifier
that can be used to distinguish between them. +

NOTE: The `ace.export` instruction does not have a `ace.export.S` analogue of `ace.import.S`.
This means that system HW dynamically generated keys can be imported but not
exported in the same form: they must be exported in the format architected in
this specification.
// If the value cannot be transported to other devices or to
// other Locale states of the same device, the internal logic must bind them to a
// specific DCTK). The instruction imports them like software keys and sets
// the appropriate policies.

// [.red]#(TBdetermined whether it is secure)# This instruction is trappable and may also be resumed or restarted.

==== ace.exec

The instruction admits four Forms, namely

[upperalpha]
. `ace.exec  Vd, Cn|C[Xn], Vs` {nbsp}{nbsp} takes an input vector and writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}{nbsp}Cn|C[Xn], Vs` {nbsp}{nbsp} takes an input vector but does not write to an output vector.
. `ace.exec  Vd, Cn|C[Xn]{nbsp}{nbsp}{nbsp}{nbsp}` {nbsp}{nbsp} does not take an input but writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}{nbsp}Cn|C[Xn]{nbsp}{nbsp}{nbsp}{nbsp}` {nbsp}{nbsp} does not take an input vector and does not write to an output vector.

Form D instructions perform internal processing only in the CC.

// Without this comment, the next part is not properly formatted...
Encoding::
`ace.exec` is an R-type instruction.
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Vd', attr: ['rd'] },
    { bits:  3, name: 'ace.exec' },
    { bits:  5, name: 'Cn|C[Xn]', attr: ['rs1'] },
    { bits:  5, name: 'Vs', attr: ['rs2'] },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....

Bit `r` (i.e., bit 27) takes the value 0 if the context is encoded as an immediate,
and it takes the value 1 if a GPR (scalar integer value) is used to reference it.
For the four Forms A-D above, the encodings are:

[upperalpha]
. `ACE.exec` = `0b000`.
. `ACE.exec` = `0b001` and `rs2`=`0b00000`.
. `ACE.exec` = `0b010` and `rd`=`0b00000`.
. `ACE.exec` = `0b011` and `rs2`=`rd`=`0b00000`.

Furthermore, we admit variants of Forms B and D, which we call Form B', resp., Form D',
with non-zero values in `rd`, resp., `rs2`,
to encode additional instructions.

// To make indent in next line correct

Description::
Performs a cryptographic operation such as an encryption or decryption,
absorbing a value in a hash, and possibly returning a value.
An `ace.exec` instruction may modify the internal state of the CC.

==== ace.size

===== Context Variant

`ace.size Xd, Cs|C[Xs]`

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus is an R-type instruction.
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x3, attr: ['ace.exec', '(Form D\')'] },
    { bits:  5, name: 'Cs|C[Xs]' },
    { bits:  5, name: 0x1, attr: ['ace.size'] },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....

Bit `r` (i.e., bit 27) is 0 if the context is encoded as an immediate, and 1 if a GPR is used to reference it.

Description::
This instruction writes the size of the SCC corresponding to CC `Cs`, or the CC
whose number is in `Xs`) into GPR `Xd`, and zero if the algorithm is not supported.

Knowing the size of the SCC serves to properly implement any feature that
relies on `ace.export`, for instance context switching.

NOTE: The value can significantly differ from the internal resource usage ot the CC —
it can be larger (for simple primitives, because of the nonce/SIV overhead) but
also smaller (for keys split into shares for threshold implementations, but saved
externally in reconstructed form).

===== Metadata Variant

`ace.size Xd, Xs`

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus is an R-type instruction.
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x3, attr: ['ace.exec', '(Form D\')'] },
    { bits:  5, name: 'Xs' },
    { bits:  5, name: 0x2, attr: ['ace.size'] },
    { bits:  7, name: 0x0 },
]}
....

Description::
This instruction writes the size of a SCC having the metadata section given in `Xn` into GPR `Xd`, and zero if the algorithm is not supported.
Only the Algorithm and SC_Protection fields of the metadata section of a CC are considered.

==== ace.available

`ace.available Xd, Xs`

The instruction is an alias to the Metadata Variant of `ace.size`, as the latter returns zero if the algorithm is not supported.

[[ACE-instruction-clone]]
==== ace.clone

`ace.clone Cd|C[Xd], Cs|C[Xs]`

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus is an R-type instruction.
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Cd|C[Xd]' },
    { bits:  3, name: 0x3, attr: ['ace.exec','(Form D\')'] },
    { bits:  5, name: 'Cs|C[Xs]' },
    { bits:  5, name: 0x3, attr: ['ace.clone'] },
    { bits:  1, name: 0x0 },
    { bits:  2, name: 'R' },
    { bits:  4, name: 0x0 },
]}
....

Bits [27:26], i.e., field `R`, take following values depending on how the contexts are
referred:

[upperalpha]
. `0b00` if the source and the output contexts are both encoded as immediates.
. `0b01` if the source context is selected using a GPR and the output context is encoded as an immediate.
. `0b10` if the source context is encoded as immediate and the output context is selected using a GPR.
. `0b11` if the source and the output contexts are both selected using the values of GPRs.

// Comment to ensure the proper indentation in th next Description

Description::
Clones source CC `Cs` (or the CC indexed by `Xs`) into destination CC `Cd` (or
into the CC indexed by `Xd`).

// NOTE: The `ace.clone` instruction is an optimization for the sequence `ace.export` followed by `ace.import`. While reusing cryptographic state (e.g., encrypting with the same counter) can enable certain attacks, this risk cannot be eliminated by omitting `ace.clone`, as a state can be exported and re‑imported multiple times.

==== ace.derive (optional)

`ace.derive Cd|C[Xd], Cs|C[Xs]`

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus is an R-type instruction.
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Cd|C[Xd]' },
    { bits:  3, name: 0x3, attr: ['ace.exec','(Form D\')'] },
    { bits:  5, name: 'Cs|C[Xs]' },
    { bits:  5, name: 0x4, attr: ['ace.derive'] },
    { bits:  1, name: 0x0 },
    { bits:  2, name: 'R' },
    { bits:  4, name: 0x0 },
]}
....

Bits [27:26], i.e., field `R`, is encoded exactly as for `ace.clone` (cf.{nbsp}<<ACE-instruction-clone>>).

Description::
The instruction is used to derive a new context from an existing one.
It is similar to `ace.clone`, but the derived context is not a copy of the source context,
rather, it is a new context that is derived from it.

NOTE: This instruction is useful to create opaque derived keys in their own contexts.
It can be used multiple times, to generate multiple derived contexts.
If the derived keys need additional inputs, these can be provided by using
`ace.state`, then the output-less versions of `ace.exec` with an appropriate message, and
finally `ace.derive` according to rules defined in the specification of the algorithm
encoded in the source context.

[[ACE-instruction-state]]
==== ace.state/ace.dir

`ace.state Cd|C[Xd], #immed` +
`ace.dir Cd|C[Xd], #immed`

Encoding::
`ace.state`/`ace.dir` is an I-type instruction.
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Cd|C[Xd]' },
    { bits:  3, name: 0x4, attr: ['ace.state'] },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
    { bits: 12, name: 'imm' },
]}
....

Bit `r` (i.e., bit 15) is 0 if the context is encoded as an immediate, and 1 if a GPR is used to reference it.

Description::
Two pseudo-instructions that map to the same instruction. +
`Cn` is the CC in which to set the stage (i.e., state number) of the internal state. +
`Xn` is a GPR containing a number from 0 to 31 to dynamically address the
context in which to change the stage of the internal state. +
The `#immed` is a constant from a set of admissible values that are defined for
each algorithm, to manage an internal state machine of said algorithm in case
more stages are needed.

[[ACE-instruction-restrict]]
==== ace.restrict/ace.harden

`ace.restrict   Cd|C[Xd], Xs` +
`ace.harden     Cd|C[Xd], Xs`

// Without this comment, the next part is not properly formatted...
Encoding::
The encoding uses `ace.exec` Form B', with bit 7 (which is in the `rd` field) set.
It is thus a variant of an R-type instruction. +
The source register field encodes a GPR and not a vector register. +
If bit `r` (i.e., bit 27) is 0, the 5-bit destination field [11:7] contains the destination context number,
else it determines the GPR that contains the context number.
 +
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 0x1 },
    { bits:  3, name: 0x1, attr: ['ace.exec', '(Form B\')'] },
    { bits:  5, name: 'Cd|C[Xd]' },
    { bits:  5, name: 'Xs' },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....

// comment

Description::
This instruction restricts the usage of a CC to specific modes or to a specified `ASID` or `VMID`. +
It can also increase the side-channel protection level of the CC. +
Let `m` be the metadata field in the destination CC. The instruction works as follows:

* Bits [10:9] and [63:25] of the input register `Xs` have the same format as the corresponding bits of the metadata.
* Bits [8:0], [24:11] and 31 of the input register `Xs` are ignored.
* Bits [10:9] can be used to turn on or increase the level of the side-channel protection of the algorithm in the CC, if the microarchitecture supports the corresponding implementation. The levels are defined in <<ACE-SC-protection-levels>>. Downgrading side-channel protection is not permitted, and attempting to do so will result in error ace_err_invalid (cf.{nbsp}<<ACE-error-codes>>).
* A zero in any of the six bits `Xs`[30:25] means that the corresponding policy is not changed.
* A one in the any of the four bits `Xs`[28:25] means that usage by the corresponding mode is forbidden, and the corresponding bit in the metadata of the destination CC is set to 1.
* If `Xs`[29] is set and `m`[29] is NOT set, then Usage_Policy_3, i.e., `m`[47:32], is set to `Xs`[47:32].
* If `Xs`[30] is set and `m`[30] is NOT set, then Usage_Policy_4, i.e., `m`[63:48], is set to `Xs`[63:48].
* If `Xs`[29] and `m`[29] are both set and `Xs`[47:32] <> `m`[47:32], or if `Xs`[30] and `m`[30] are both set and `Xs`[63:48] <> `m`[63:48], then the error field of `acecsr` is set to ace_error_invalid.

==== ace.input (optional)

`ace.input Cd|C[Xd], %offset(Xs)`

Encoding::
`ace.input` is an I-type instruction.
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Cd','C[Xd]'] },
    { bits:  3, name: 'ace.input', attr: [0x4,0x5] },
    { bits:  5, name: 'Xs' },
    { bits: 12, name: 'imm' },
]}
....

// [.red]#(TBdetermined whether it is secure)# This instruction is trappable and may also be resumed or restarted.

==== ace.output (optional)

`ace.output  %offset(Xd), Cs|C[Xs]`

Encoding::
`ace.output` is an S-type instruction.
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'imm[4:0]' },
    { bits:  3, name: 'ace.output', attr: [0x4,0x5] },
    { bits:  5, name: 'Xd' },
    { bits:  5, name: 'context', attr: ['Cs','C[Xs]'] },
    { bits:  7, name: 'imm[11:5]' },
]}
....

// [.red]#(TBdetermined whether it is secure)# This instruction is trappable and may also be resumed or restarted.

==== ace.error

`ace.error Xd, Cs|C[Xs]`

Description::
A CC `Cs` (or indexed by `Xs`) may be in an error state due to the previous
operation. The corresponding error value is written into GPR `Xd`.
This is implemented as a CSR read operation, reading the error field of
`acecsr` and masking it.
The error value list is architected and given in <<ACE-error-codes>>.

// ==== ace.vr_busy
//
// `ace.vr_busy   Vd`
//
// Can be CSR read operation.
// It will return 1 or 0 whether there is at least one running ACE operation expected to write on the vector register `Vd`.
//
// ==== ace.cc_busy
//
// `ace.cc_busy   Cd|C[Xd]`
//
// Can be CSR read operation.
// It will return 1 or 0 whether there is at least one running ACE operation using the given CC.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-trappable-insns-support]]
==== Support for Trappable Operations

Instructions `ace.init`, `ace.export`, `ace.import`, `ace.input`, and `ace.output` support arbitrarily long inputs and outputs.
To reduce hardware complexity, these operations can be trapped and emulated in software using custom instructions.

Upon a trap, the handler identifies the trapped instruction and uses the Algorithm field of the metadata block
`ace.size` to determine the size of the data to be transferred.

In order to support interrupts of the emulation libraries, such instructions need to respect the value of `ccstart` and update it in accordance with the expected architected behavior the trapped instructions.  We provide here non-normative definition for such a set of instructions in <<ACE-trappable-insns-support>>.
Three types of supporting operations are required:

* A `mv` instruction that loads a specified number of bytes from a GPR or vector register into a CC within the ACE unit.
  Initially, `ace.size` returns the total payload length to transfer.
  After each move, this value is updated to reflect the remaining bytes.
  The instruction also updates the `ccstart` CSR to follow the internal progress.
* A corresponding `mv` instruction that exports a specified number of bytes from a CC to a GPR or vector register.
  The behavior of `ace.size` will be similar to that of the move instruction, but it will count the number of bytes to be exported.
* A “`close`” instruction to suspend or finalize the procedure.
  If executed before all bytes are transferred, the CC state matches that of an interrupted monolithic instruction, including the Completion metadata field and the `ccstart` value. If executed after all bytes are transferred, it also performs any final cryptographic operations, such as authenticating the CC, if needed.

These instructions must be non-interruptible.

The initial cryptographic step of `ace.export` and the authentication step of `ace.import` are assumed to be non-interruptible.
Even if these parts are executed concurrently with other operations, the handler may need to wait for these steps to complete before proceeding with memory operations.
These instructions are not explicitly defined in the architecture. They just need to be supported by to implementation-specific firmware.
Interrupting the execution of this firmware between instructions must leave the architectural state indistinguishable from interrupting a monolithic instruction, as specified in this document.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-Algorithms]]
=== Data Formats and Instruction Semantics for Various Algorithms

In this chapter we describe the behavior of Cryptographic Contexts for various cryptographic algorithms.
Some of these descriptions are generic, others pertain to certain algorithms.

Each algorithm is fully defined by the following information:

Internal State:::
Information that must be in the internal state of a CC, in the order it is serialized to create the SCC.

Block Size:::
Size of the basic unit of information processed by the algorithm, usually the block size of the main underlying primitive.

Generic Functions:::
If necessary, overload generic functions that apply to all contexts, such as :
Each algorithm must provide the functions described in <<ACE-formats>>.

Algorithmic-Specific Functions:::
Any other function that is specific to the algorithm.

State Machine:::
This includes:

. A list of *States* in which the internal state machine of the logic is executed, together with their representation, either as a number in the range [0..15] or by more complex structures. The values must conform to <<ACE-stage_constants>>.
. A complete list of the *Allowed State Transitions*, including the conditions under which each transition is allowed.
. The *Behaviour* of all ACE instructions at each state.


==== Generic Rules

For modes of operations that can be instantiated with different primitives, we can specify more general rules, where the differences between instantiations in some cases are limited to the widths of their inputs and outputs of the primitive.

Recall that the architecture views CC as a structure with two fields: the metadata (currently 64 bits), which has a unique specification, and the content (variable length), which is algorithm-specific.

In the descriptions of the algorithms below, we do not need to redefine these two functions if they are not changed, i.e., if there are no changes to the metadata format.

If the number of states of the algorithm is at most 16, we assume that the `stage` of the metadata is used to store this value.
Otherwise, the specification of the algorithm must include a suitable field in the content section of the CC/SCC.

[[ACE-ECB-mode]]
===== Electronic Codebook Modes (Direct Encryption/Decryption)

While listing the rules for the ECB mode is in principle easy, it does display all the rules that are required to describe an arbitrarily complex mode.

// . The fields of the internal state, with their sizes in bits, in the order they would be serialized `content_serialize` and deserialized by `content_deserialize`.
// . The width of unit processed by the algorithm, which also corresponds to the configured vector size, called _block size_.
// . The descriptions of the generic functions of the algorithm, in case they differ from the default ones.
// . Any algorithm-specific function.
// . A description of the state machine, including a list of the possible states, their transitions, and the operations that are allowed at each state.

// comment to reset formatting

Internal state:::

* *Metadata*: 64 bits.
* *Content Fields*:
** key: k bits (8|k, in fact it is almost always 128|k)

Block Size:::

* b = block size in bits, (8|b)

Generic Functions:::

* `initial_content_deserialize`. Length = k/8 bytes. input[k/8-1:0] = key.

Algorithm-Specific Functions:::

* `encrypt_block(p) -> c` encrypts plaintext block `p` using the key, and returns the ciphertext result `c`.
* `decrypt_block(c) -> p` decrypts ciphertext block `c` using the key, and returns the plaintext result `p`.

State Machine:::

* *States:* _initial_ (0), _encrypt_ (1), and _decrypt_ (2)
* *Allowed State Transitions:*
 ** From any state to encrypt, if metadata allows encryption, else `error(ace_error_invalid)`.
 ** From any state to decrypt, if metadata allows decryption, else `error(ace_error_invalid)`.
* *Behavior:*
 ** In the "initial" state, any `ace.exec` will cause an ace_error_invalid error.
 ** In the "encrypt" state,
  *** If{nbsp} `ace.exec Vd, Cn|C[Xn], Vs` {nbsp}is issued, then {nbsp} `Vd = encrypt_block(Vs)`.
  *** If any other form of `ace.exec` is issued, then `error(ace_error_invalid)`.
 ** In the "decrypt" state,
  *** If{nbsp} `ace.exec Vd, Cn|C[Xn], Vs` {nbsp}is issued, then {nbsp} `Vd = decrypt_block(Vs)`.
  *** If any other form of `ace.exec` is issued, then `error(ace_error_invalid)`.

[[ACE-chaining]]
===== Chaining/Feedback Modes

There is no need to architect the behaviour of chaining modes,
such as
Cipher Block Chaining (CBC),
Propagating Cipher Block Chaining (PCBC),
Cipher Feedback (CFB) and
Output Feedback (OFB)
as they can be easily implemented on top of the ECB functionality in software.

[[ACE-keystream-modes]]
===== CTR/LFSR/XCTR/XLFSR Modes to Produce a Keystream

The "X" modes have both IV and counter/LSFR of the same size as the block size of the underlying keyed PRP or PRF:
IV and counter/LFSR are `xor`ed together to form the input to the keyed PRP or PRF.

In the "non-X" modes the sums of the lengths of IV and counter/LSFR equal the block size of the underlying keyed PRP or PRF:
IV and counter/LFSR are concatenated to form the input to the keyed PRP or PRF.

//

Internal state:::

* *Metadata*: 64 bits.
* *Content Fields*:
 ** key: k bits (8|k).
 ** IV: n bits (8|n).
 ** counter: j bits (8|j).

Block Size:::

* b = block size in bits, (8|b):
 ** If not an "X" mode, then b = n+j.
 ** If an "X" mode, then b=n=j.

Generic Functions:::

* `initial_content_deserialize`. Length = k/8 bytes. input[k/8-1:0] = key.

Algorithm-Specific Functions:::

* `keystream_block(p) -> c` -- usually an encryption function.
* `tick_counter()` -- updates the counter (either by a modular increment or a LFSR).

State Machine:::

* *States:* _initial_ (0), _set_public_value_ (1), and _operate_ (2).
* *Allowed State Transitions:*
 ** _initial_ -> _set_public_value_.
 ** _set_public_value_ -> _initial_, _set_public_value_.
* *Behavior:*
 ** In the _initial_ state, any `ace.exec` will result in `error(ace_error_invalid)`.
 ** Upon entering _set_public_value_, the counter field is set to 0 (or to 1 if LFSR).
 ** In _set_public_value_ state, we can only issue an `ace.exec` of the form{nbsp}{nbsp} `ace.exec Cn|C[Xn], Vs`,{nbsp}{nbsp} which sets the IV value to `Vs`
    (there is no harm if this instruction is issued more than once).
  *** Other forms of `ace.exe` not allowed, will cause `error(ace_error_invalid)`.
 ** In _operate_ state, we can only issue an `ace.exec` of the form `ace.exec Vd, Cn|C[Xn]`, which
  *** If in a "not-X" mode, `tmp = keystream_block(IV @ counter)`, `tick_counter`, `Vd = tmp`.
  *** If in an "X" mode, `tmp = keystream_block(IV xor counter)`, `tick_counter`, `Vd = tmp`.
  *** Other forms of `ace.exe` not allowed, will cause `error(ace_error_invalid)`.


[[ACE-XEX-XTS-modes]]
===== XEX/XTS modes (one or two keys)

Note that the use of a single key or two independently sampled keys is determined by the algorithm field, and it is not determined by a configuration parameter for the same algorithm.
We first define XEX mode functionality.

Internal state:::

* *Metadata*: 64 bits.
* *Content Fields*:
 ** key1: k bits (8|k).
 ** key2: k bits (8|k) (omitted if only one key is used).
 ** mask: b bits (8|n).

Block Size:::

* b = block size in bits, (8|b).

Generic Functions:::

* `initial_content_deserialize`:
 ** Length = k/8 bytes.
 ** input[k/8-1:0] = key1.
 ** input[2k/8-1:k/8] = key2.
* `content_serialize`:
 ** Length = (2k+b)/8 bytes, or (k+b)/8 bytes if only one key is used.
 ** output[k/8-1:0] = key1.
 ** output[2k/8-1:k/8] = key2 -- omitted if only one key is used.
 ** If two keys are used: output[(2k+b)/8-1:2k/8] = mask.
 ** If only one key is used, then output[(k+b)/8-1:k/8] = mask.
* `content_deserialize` converts the output of `content_serialize` back to the original input format.

Algorithm-Specific Functions:::

* `encrypt_block(key,p) -> c` encrypts block `p` using the key, and returns the result `c`.
* `decrypt_block(key,c) -> p` decrypts block `c` using the key, and returns the result `p`.
* `update_mask(mask) -> mask` -- updates the mask by a Galois Field multiplication in GF(2^b^)

State Machine:::

* *States:* _initial_ (0), _set_public_value_ (6), _encrypt_ (1), and _decrypt_ (2).
* *Allowed State Transitions:*
 ** _initial_ -> _set_public_value_.
 ** _set_public_value_ -> any state.
 ** _set_public_value_ -> _encrypt_, if metadata allows encryption, else `error(ace_error_invalid)`.
 ** _encrypt_, _decrypt_ -> _initial_.
* *Behavior:*
 ** In the "_initial_" state, any `ace.exec` will result in `ace.error` returning ace_error_invalid.
 ** In the "_set_public_value_" state, we can only issue the `ace.exec` form{nbsp}{nbsp} `ace.exec Cn|C[Xn], Vs`{nbsp}{nbsp} to set the mask value to `Vs`
    (there is no harm if this instruction is issued more than once).
  *** First, `mask <- encrypt_block(key2,Vs)`.
  *** If only one key is used then update mask: `mask <-update_mask(mask)`.
  *** Other forms of `ace.exe` not allowed, will cause `error(ace_error_invalid)`.
 ** In _encrypt_ and _decrypt_ states, we can only issue `ace.exec Vd, Cn|C[Xn], Cs` which:
  *** If the state is _encrypt_, computes `Vd = mask xor encrypt_block(Vs xor mask)` ...
  *** If the state is _decrypt_, computes `Vd = mask xor decrypt_block(Vs xor mask)` ...
  *** ... and updates the mask: `mask <- update_mask(mask)`.

To implement the XTS mode, the ciphertext stealing part is easy to realize using the XEX algorithm together with vector masking and shifting operations.

[[ACE-GCM-mode]]
===== GCM mode

[.red]#TBD#

[[ACE-GCM-SIV]]
===== GCM-SIV mode

[.red]#TBD#

==== Rules for Threshold implementations

Any CC with its algorithms implemented as threshold implementation will always initialize, import and export _all_ its keys and secrets as single, reconstructed shares.
The Configuration and SCC Formats will be the same as for the non-threshold implementations variants of the same algorithm, with the only difference being the value of the Side Channel Protection bits in the metadata.
For the purpose of architecture specification, all values are also always represented as a single share in this document.
Threshold implementations are simply implementation variants of the exact same algorithm.

NOTE: This assumes that reconstructing a key or re-randomizing it are fast operations, such as ``xor``s with random values.
This in turn implies that ACE execution unit must have access to a source of randomness, or at least a PRNG that is seeded at hardware boot.

This ensures not only the compactness of a SCC, but also that the key can be ported across architectures.
In fact, some threshold implementations may have a different number of shares even if they claim the same order of side-channel protection.

==== Specific Rules

[.red]#TBD#

// //////////////////////////////////////////////////////////////////////////////////////////

[[ACE-examples]]

=== Examples

==== Key Management and Provisioning Applications

Software environments that implement key management operations for other domains require their own RCTK. A system may contain multiple such software environments.

A Key Management Applet (KMA) will

[arabic]
. Generate or retrieve a key matching a request.
. Configure a CC with this key and its associated metadata.
. Export this CC to a SCC in memory.
. Relinquish control to the MM.

The MM, which controls the CTK, can the

[arabic, start=5]
. Set the RCTK to the KMA’s RCTK.
. Re-import the SCC into a CC
. Change the RCTK to match the requester domain's RCTK.
. Export the key for the Requester's use.
. Relinquish control to the Requester.

This is the most generic approach and allows each piece of software to use a CC of choice to generate and import SCCs.
Furthermore, it protects the key from other SW environments that may be crossed while transferring control between the Requester process, the MM, and the Key Management application.

// Various optimizations are possible, which can be interesting for embedded environments: Steps 3., 5., and 6. can be omitted if the CC used for these operations is fixed and no intermediate SW environments modify that CC.

[comment]
--
.Simple Example: Encryption, no Authentication
[%linenums,C]
----
Call OS API to get the necessary SCC. X5 points to the SCC.
Allocate memory for ciphertext buffer.
ace.import C0, [X5]                  // Import the SCC into CC C0
ace.error X1,C0
if (X1 != 0) then { handle error }
Configure vector unit to use 128-bit vectors.
ace.state C0, #ace_const_encrypt
ace.error X1,C0
if (X1 != 0) then { handle error }
   // If encryption is not allowed
for i = 0 to ceil(len_in_bytes(plaintext)/16)-1 do
    load V0 from address plaintext+16*i
    ace.exec V0, C0, V               // Encrypt one block of the plaintext
    store V0 at address ciphertext+16*i
----
--

==== Decryption and Authentication, encrypt–then–MAC

This example assumes a keyed hash function (MAC) where the CC/SCC includes the key.
With the hash function programmed in CC C1, `ace.state C1, #ace_const_hash_start` initializes or resets the function to compute a new hash with the same key.
`ace.state C1, #ace_const_hash_finalize` finalizes the operation, allowing the hash value to be extracted via one or more `ace.exec V0, C1, ignore` instructions.
`#ace_const_hash_start` is always valid and resets the state, whereas `#ace_const_hash_finalize` is valid only after initialization, and it can be called also with an empty payload.

Following `#ace_const_hash_start`, only Form B `ace.exec` instructions are permitted.
Following `#ace_const_hash_finalize`, only Form C `ace.exec` instructions are permitted. Attempting to extract data beyond the full hash length results in zero output and raises an error.

.Decryption and Authentication, encrypt–then–MAC

[C]
----
- Process obtains an AES-encrypted, hashed, payload (the ciphertext) from a service.
- Process calls an OS API to get CCs for the encryption and authentication keys.
- OS API returns two encrypted and authenticated payloads.

// Process imports first SCC (for decryption) into C0:
ace.import C0, [X5]

// Process imports second SCC (for hashing) into C1:
ace.import C1, [X6]

- Allocate memory for plaintext buffer.
// Configure vector register file for 128-bit registers and AES.
vsetvli zero, 4, e32, m1, t?, ma

ace.state C0, #ace_const_decrypt
ace.error X1,C0
if (X1 != 0) then { handle error }

ace.state C1, #ace_const_hash_start   // To start hashing
foreach (i from 0 to ceil(len_in_bytes(ciphertext)/16)-1) {
  - load V0 from address ciphertext+16*i
  ace.exec ignore, C1, V0		      // Absorb one 128-bit block
}

ace.state C1, #ace_const_hash_finalize
ace.exec V1, C1, ignore
// if the hash is longer, then extract the next 16 bytes using `ace.exec V2, C1, ignore`

Compare tags. If they do not match, report error.

foreach (i from 0 to ceil(len_in_bytes(ciphertext)/16)-1) {
  - load V0 from address ciphertext+16*i
  ace.exec V0, C0, V0				  // Decryption
  - store V0 at address plaintext+16*i
}

ace.state C1, #ace_const_hash_start   // Hygiene
----

Note that invoking `ace.state C1, #ace_const_hash_initialize` would allow to reuse C1 to compute additional hashes/MACs.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-Dependencies]]
=== Impact and Dependency on Other Extensions

While ACE can be implemented with the V extension as a requirement, we note that ACE actually depends on a minimal subset of the RISC-V Vector Extension (RVV), which we call RVV-mini, for correct operation.
Required features include:

* Vector registers of 128 bits or wider;
* The `vsetvli` instruction with restricted parameters (e.g., "`vsetvli zero, 4, e32, m1, ta, ma`" for 128-bit-side operations); unsupported configurations must generate defined errors;
* Unit-strided vector loads and stores exclusively; and
* Vector bitwise logical operations such as `vxor`, `vand`, and `vor`.

Moreover,

* floating-point, fixed-point, and most arithmetic vector operations are not required and
* more complex operations for some corner-case cryptographic algorithms may be performed in GPRs, with results then inserted in vector registers via `vins`/`vext`.

RVV-mini must maintain full opcode compatibility with RVV to guarantee that ACE code runs unmodified on full RVV implementations.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-architecture]]
== Architecture

ACE is a complex architecture and relies on certain fundamental concepts, which we first introduce together in a short section.
While this leads to some repetitions, we believe that it also brings better clarity to the presentation of the architecture.

// the clarity gained from this approach outweighs the potential drawbacks.

[[ACE-concepts]]
=== Fundamental Concepts

Cryptographic Contexts:::
The _Cryptographic Context_ (CC) is the fundamental concept in ACE.
(((Cryptographic Context)))
All cryptographic operations performed by ACE execute within the constraints defined by a CC.
A CC is an indivisible data structure comprising a *metadata* section and a *content* section.
The metadata specifies the cryptographic algorithm associated to the CC and optional usage-control policies.
(((Cryptographic context, metadata)))
The content holds sensitive material such as secrets and internal algorithm state.
(((Cryptographic context, content)))
The metadata has a fixed architectural format, while the content format is algorithm-dependent.
Metadata requires integrity but not confidentiality; content requires both confidentiality and integrity.
These properties are enforced architecturally by ACE.

Cryptographic Register:::
(((Cryptographic Register)))
Cryptographic Contexts are realized architecturally using _Cryptographic Registers_ (CRs).
CRs are architectural, i.e., per-hart, containers that safeguard CCs.
A CR is _initialized_ by writing metadata and content into it, which are thusly bound to form a CC.
A CC can be used for cryptographic operations only while resident in a CR.
Only the ACE unit may access or modify CC contents, in accordance with the architecture and the programmed algorithm.
CC content cannot be extracted in a manner that compromises its confidentiality.

Sealed Cryptographic Context:::
(((Cryptographic Context, sealed)))
To support context switching while protecting CCs outside architectural state, a CC may be exported from a CR as a _Sealed Cryptographic Context_ (SCC).
An SCC is an encrypted and authenticated representation of a CC that can later be reimported into a CR.
SCC import and export use _Context Sealing Keys_ (CSKs), which may be programmable by M-mode and may depend on _Localities_ (see below).
A CC sealed with a given CSK cannot be reimported using a different CSK, enabling cryptographic domain separation across spatial and temporal
domains.

Object-Orientation:::
CCs act as _objects_ exposing a uniform interface across algorithms.
A CC encapsulates algorithm-specific behavior, enabling interchangeable use of different primitives (e.g., AES-128, AES-256, Калина-128, Калина-256, and SM4, and so on) in identical modes (e.g., ECB, GCM-SIV, XEX/XTS) without requiring changes to compiled code.
Side-channel-resistant variants are supported transparently.

// NOTE: This flexibility allows, for example, a content distribution network to use different ciphers (AES in US/EU, SM4 in China, etc.) for GCM payloads using the same binary interface. The CC encapsulates the cipher, and the binary supports all GCM variants (see <<ACE-GCM-mode>>).

Usage Control Policy:::
(((Cryptographic context, Usage Control)))
ACE distinguishes between CR management (e.g., import/export) and CC usage (cryptographic operations).
To prevent denial-of-service scenarios, CR management operations must always be permitted.
Accordingly, the optional _Usage Control_ policies restrict only cryptographic operations and state modifications, not CR or SCC management.
For this reason, the term Usage Control is used instead of Access Control.

Locality:::
(((Cryptographic context, Locality)))
ACE can bind CCs to a _Locality_, restricting usage to specific devices, device classes, software or hardware configurations, or boot cycles.
This binding uses metadata and a _Derived Context Sealing Key_ (DCSK) derived from the _Root Context Sealing Key_ (RCSK) and a Locality-specific secret.
The system maintains a _Locality Secrets Table_ (LST) with fixed, hardware-configured, and MM-programmable values.
Metadata stores the Locality as an index into this table (see <<ACE-Localities>>).

// ///////////////////////////////////////////////////////////////////////////////////////////


=== Programmer-Visible Architectural State

ACE requires a subset of the V extension, including the vector register file (see <<ACE-V-dependency>>).
[.darkred]#Discussions are still ongoing on what subset will be required, and if a dependency on just the GPRs can be designed as well.#

[[ACE-instructions-overview]]
==== Instructions Overview

ACE provides a number of unprivileged instructions, some implemented as CSR read/write operations.
The notation `K[Xd]`, for a GPR `Xd`, refers to the CR whose number is contained in `Xd`,
and `Kn|K[Xn]` means that there are two different encodings for when the CR number is passed as an immediate (`Kn`) or in `Xn`.

.The ACE instructions
[width="100%",cols="17%,25%,58%",options="header",subs="+macros"]
|===
| Instruction         | Operands                         |  Description
| `ace.enable` +
`ace.disable`         |                                  |  Enables/Disables ACE.
| `ace.reset`         |                                  |  Resets ACE.
| `ace.init`          | `Kd\|K[Xd],%offset(Xs)`          |  Sets a CR's metadata and content.
| `ace.clear`         | `Kd\|K[Xd]`                      |  Clears a CR and marks it as no longer in use and clean.
| `ace.export`        | `%offset(Xn),Ks\|K[Xs]`          |  Securely exports the content of a CR to memory.
| `ace.import{.S}`    | `Kd\|K[Xd],%offset(Xn)`          |  Authenticates and imports an SCC from memory. +
 `ace.import.S` provides optional support for system-defined formats.
| `ace.exec`
| A. {nbsp}{nbsp} `Vd,Kn\|K[Xn],Vs` +
  B. {nbsp}{nbsp} `{nbsp}{nbsp}{nbsp}Kn\|K[Xn],Vs` +
  C. {nbsp}{nbsp} `Vd,Kn\|K[Xn]` +
  D. {nbsp}{nbsp} `{nbsp}{nbsp}{nbsp}Kn\|K[Xn]`
| Performs a cryptographic operation. These instructions may modify CC state. This instruction admits four _Forms_, depending on whether it accepts an input or not, and whether it produces an output or not.
| `ace.size`
| `Xd,Ks\|K[Xs]` +
`Xd,Xs` .2+|  Returns the SCC size in bytes for CR `Ks`/`K[Xs]` or for an algorithm with metadata `Xs`.
Returns zero if the algorithm is unsupported.
`ace.available` is an alias for `ace.size`.
| `ace.available`     | `Xd,Xs`
| `ace.clone`         | `Kd\|K[Xd],Ks\|K[Xs]`            |  Clones a source CR to a destination CR.
| `ace.derive`        | `Kd\|K[Xd],Ks\|K[Xs]` +
`Kd\|K[Xd],Ks\|K[Xs],Vs2` +
|  Optional. Configures destination CR using source CR (e.g., the source CR could hold a KEM, and derive symmetric keys).
| `ace.state` +
`(ace.dir)`
| `Kd\|K[Xd],#immed` +
`Kd\|K[Xd],#immed,Xs` |  Modifies algorithm state (e.g., phase transitions). `ace.dir` is an alias for `ace.state`.
| `ace.restrict` +
  `(ace.harden)`      | `Kd\|K[Xd],Xs`                   |  Narrows Usage Policies and enables/increases side-channel protection.
   Weakening Usage Policies and SCA protection is not permitted. `ace.harden` is an alias for `ace.restrict`.
| `ace.input`         | `Kd\|K[Xd],%offset(Xs)`          |  Optional. Provides input to the algorithm (for long inputs).
| `ace.output`        | `%offset(Xd),Ks\|K[Xs]`          |  Optional. Writes output from the algorithm (for long outputs).
| `ace.error`         | `Xd`                             |  Writes the ACE unit error code to GPR `Xd`.
|===

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-cryptographic-registers]]
==== Cryptographic Registers

ACE defines 32 Cryptographic Registers (CRs).
Each CR is identified by a number from 0 to 31, and written in assembly as `K0`, `K1`, ... , `K31`.
(((Cryptographic Context)))

CRs reside in a dedicated _CR file_ (CRF), accessible only by the ACE implementation.
(((Cryptographic Register File)))

CRs differ from conventional register in several ways:

* In place of load and store instructions, CRs can be *initialized* with clear data, but only *exported* using an AEAD algorithm, for later re*import*.
** The initialization instruction is a load-type instruction that reads clear text into a CR, but there is no corresponding "store" instruction.
** Exporting uses a nonce, so repeated export of the same content may result in different ciphertexts.
** Import may fail if the authentication tag cannot be verified.
* Unlike conventional registers, which always contain a value, CRs can be _unconfigured_, meaning they may hold no information.
* The amount of the capacity of the CRF used by a CR depends on the configured algorithm.
  Two CRs can use different amounts of capacity.
* ACE instructions can refer to CRs directly, i.e., with a 5-bit immediate in the instruction encoding, but also indirectly, i.e., through a value in the range [0 .. 31] in a GPR.

ACE returns _ace_err_memory_ if insufficient memory prevents successful execution of any instruction that can configure a CR.
If this happens, software needs to free memory by choosing another CR, possibly exporting it if necessary, and then clearing it.

[NOTE]
====
CRF capacity is implementation-defined, but implementations must provide sufficient CRF memory to allow all operations
allowed by the architecture to be performed.
For instance, the CRF must hold at least an instance of the largest possible CR or the largest CR pair for CR cloning or the derivation of a new CC from an existing one.
====

//Exporting/importing loops.
//`ace.export`/ `ace.import`

[NOTE]
====
The fact that CRs can be addressed indirectly two major implications:

. Adding renaming to CRs would add significant complexity to the microarchitecture.
  However CRs are much less often redefined than, say, integer or floating-point registers, except for internal implied changes, and therefore we can assume that CRs are not renamed without performance issues.
. An additional bit in the instruction encoding determines whether a CR number is given by a 5-bit immediate or by the value in a GPR.
====

// ///////////////////////////////////////////////////////////////////////////////////////////
//==== Cryptographic Contexts

[[ACE-metadata]]
==== Metadata Section Format

For software portability and interoperability, ACE defines two external formats for CCs:
an _Initialization Input_ format, which is loaded into a CR to create a CC,
and an encrypted, authenticated format used when exporting a CR to memory for later re-import:
the Sealed Cryptographic Context (SCC) (cf. <<ACE-format-SCC>>).
Both formats rely on the same metadata section format, which is described here.
The formats of the Initialization Input and of the SCC are described in <<ACE-format-initialization>> and <<ACE-format-SCC>>, respectively.


The metadata section is 64 bits long and its format is described in <<ACE-metadata-standard>>.
The metadata section is used as the header of the data formats used in CR initialization, and CC export and import functions.
// The internal representation of the metadata in a CC  is implementation specific.
(((Cryptographic Context,metadata,format)))

[[ACE-metadata-standard]]
.Format of the Metadata Section
[width="100%",cols="^9%,^7%,17%,67%",options="header"]
|===
.>|   Field .>| Width +
(bits) .>| Name                  .>| Description
|   [0:0] |   1  | Format                 | 0 for the current metadata format. +
Future format will have a 1 in this position and may be longer than 64 bits.
|   [1:1] |   1  | Reserved               | 0 for the current metadata format.
|   [9:2] |   8  | Algorithm              | Algorithm (such as primitive or mode). 0 means the CC is invalid.
| [11:10] |   2  | SC_Protection          | Level of Side Channel Protection, encoded as per <<ACE-SC-protection-levels>>.
| [13:12] |   2  | Direction_Policy       | Determines whether the CC may be used for encryption (bit 12 set), decryption (bit 13 set), or both (bits 12 and 13 set).
Valid only for encryption/decryption primitives or modes, and ignored, for instance, for hash functions.
| [15:14] |   2  | Key_Type               | By explicit value / Immutable (index) / Internally generated.
| [16:16] |   1  | Completion             | 1 if any operation involving the CC has been interrupted and may have to be resumed.
Used to determine whether an operation must be restarted.
| [17:17] |   1  | Reserved               | Reserved for future use.
| [21:18] |   4  | State (also Direction) | Encoding the current state of the state machine of the algorithm as a number.
The value must be zero in the initialization data.
If the algorithm encoded in the CC has at most 16 states
(including _initial_, _completed_, and _invalidated_, cf. <<ACE-state-constants>>), then this number is stored in this field,
otherwise an algorithm-specific representation is used in the content, and this field only admits the values 0 (initial), 14 (invalidated), 15 (completed) or 1 (any other operational state). The values must conform to <<ACE-state-constants>>.
| [25:22] |   4  | Locality               | A field which is either -1 or an index into the Locality Secrets Table.
| [29:26] |   4  | UC_Policy_1            | "UC Policy" means "Usage Control Policy". +
Disallow the _usage_ of this CC in User, (Virtual) Supervisor, Hypervisor, or M-mode if bit 26, 27, 28, or 29 is set.
| [31:30] |   2  | UC_Policy_2            | If bit 30, respectively, 31, is set, then restrict the usage by `ASID`, respectively, `VMID`. Restriction by `ASID` ignored if in S Mode or higher.
| [47:32] |  16  | UC_Policy_3            | Zero if bit 30 unset, else `ASID` to enforce.
| [63:48] |  16  | UC_Policy_4            | Zero if bit 31 unset, else `VMID` to enforce.
|===

Algorithms are encoded in an 8-bit field.
Algorithm numbers 0-191 are architecture-defined and the list of such encodings is maintained by RVI.
See <<ACE-algorithms>> for the currently encoded algorithms.
Algorithm numbers 192-255 are reserved for custom algorithms.

[[ACE-SC-protection-levels]]
.Encoding of Side-Channel Protection levels
[float="center",align="center",width="76%",cols="^8%,<68%",options="header"]
|===
| Value | Description
|   0   | No protection.
|   1   | Data-independent timing, first-order threshold implementation.
|   2   | Data-independent timing, first-order threshold, fault-tolerant implementation.
|   3   | Custom, algorithm dependent.
|===

Custom algorithms may offer stronger side channel protection guarantees than those specified in the encoding values 0 to 2.
In such a case, the value of the SC_Protection field must be set to 3.

[[ACE-key-type]]
.Encoding of Key Type
[float="center",align="center",width="76%",cols="^8%,<68%",options="header"]
|===
| Value | Description
|   0   | Explicit value.
|   1   | Internal table. System specific. For each algorithm as specified in <<ACE-algorithms>>, the part of the content that normally contains the key(s) is replaced by a 64-bit value which is an index into an internal System Keys Table (SKT)-for both Initialization Input and the SCCs. The actual value of the key is never included in exported content. For threshold implementations, ACE may copy the key material from the SKT into the CR and expand it into multiple shares.
|   2   | Internally generated key. System specific.  In the Initialization Input, the part of the content that normally contains the key(s) is replaced by a "recipe" in a system-specific format. The format is not specified by the ISA and may not be portable to other systems. Once the key material has been internally generated, the value is included in the SCC as part of the content - not the "recipe" - as for any other key(s) for the same specified algorithm.  The Key_Type field of the metadata in all representations of the CC, will keep the value 2.
|   3   | Invalid.
|===

// [[ACE-CR-complete]]
// .Encoding of Completion field
// [float="center",align="center",width="58%",cols="^8%,<50%",options="header"]
// |===
// | Value | Description
// |   0   | No `ace.init`, `ace.input`, `ace.output`, `ace.import` or `ace.export` operation currently incomplete.
// |   1   | `ace.init`, `ace.input`, or `ace.output` was interrupted.
// |   2   | `ace.import` was interrupted.
// |   3   | `ace.export` was interrupted.
// | Value | Description
// |   0   | No instruction operating on this CR was interrupted.
// |   1   | An  instruction operating on this CR was interrupted.
// |   2   | `ace.import` was interrupted.
// |   3   | `ace.export` was interrupted.
// |===

NOTE: The information in the Completion field is necessary to make sure that any cryptographic operation attempted on a CR containing an incomplete CC results in an error or is trapped.

// is in principle known to the system software/firmware stack, we duplicate it into the metadata to ensure that it remains accessible after nested interrupts, i.e., after switching partially configured/imported or exported CCs in or out. While authentication also guarantees the integrity of the SCCs and of their import, this is both a robustness measure and serves to simplify system stacks.[.darkred]#Do we really need it?#

NOTE: The "state" field accommodates modes of operation with a small number of states.
For algorithms with more complex state machines, machine state information can be stored in a custom data section of the CC.

If the H extension is not enabled, bit 28 must be set to 1, and bits 31 and [63:48] must be set to 0.
The "UC_Policy_4" field is 16 bits long for compatibility with architectures employing 16-bit `VMID` fields (for instance, in heterogeneous systems).
While interoperability cannot be guaranteed when this policy is used, this ensures that the two top bits are not used for other purposes.

NOTE: Restricting usage by Supervisor Domain or World ID is not supported, and not only because of a lack of space in a 64-bit metadata section:
Reconfiguring the RCSK is a better approach for such isolation requirements, whereas isolation by `ASID` and `VMID` is a weaker security feature.

[[ACE-Localities]]
====== Localities

Internally, ACE keeps a table of 128-bit Locality Secrets (LS), the Locality Secrets Table (LST).
Some entries of the LST are fixed or configurable only using an implementation-specific authenticated hardware procedure, and these are
global and shared across all ACE units in the same system or in the same SoC.
A few entries may be programmed by M-mode and are architectural, i.e., per hart.

If the Locality Field of a CC is -1 (all ones), then the RCSK is used.
Otherwise, this value is used as an index _i_ in the LST, and the actual CSK is derived from the RCSK and LST[_i_].

In <<ACE-locality-indexes>>, we list the architected Localities and whether M-mode can configure them.
We specify the domain of each Locality Secret, i.e., whether the value is chip-wide
(i.e., the same across all chiplets in the same SoC, note that two distinct SoCs on the same device may have different values),
device-wide, or (usually) OS-wide.

[[ACE-locality-indexes]]
.Architected Locality Values
[width="100%",cols="23%,45%,^9%,^14%,^9%",options="header"]
|===
.>| Name .>| Description .>| Domain | M-mode +
Configurable .>| Value +
(Index)
| (No Locality binding)     | No CSK derivation. CC bound to Root CSK only. | -- | -- | -1 (15)
| ChipManufacturerSecret    | Identifies the manufacturer of the SoC. Permanent. | SoC | N | 0
| ChipModelSecret           | Identifies specific chip model/family. Permanent. | SoC | N | 1
| ChipUniqueSecret          | Unique for each SoC. Permanent. | SoC | N | 2
| OEMSecret                 | Provisioned by OEM to differentiate their products from the competition.
                              Can be permanent, or optionally reconfigurable by impdef HW authenticated mechanisms. | Device | N | 3
| ProductSecret             | Identifies device/system type/model (product). Not necessarily permanent. Reconfigurable like OEMSecret. | Device | N | 4
| DeviceSecret              | Unique device (entire system) secret (_not_ the device ID such as a serial number). Shared across all harts in a SoC and shareable across multiple SoKs in a single device. Sharing mechanism impdef, i.e., not architected. Reconfigurable like OEMSecret. | Device | N | 5
| OSSecret                  | Identifies Operating System (or System Stack).
                              Not permanent, must be configured at (virtual) boot. | OS | Allowed | 6
| BootSecret                | Regenerated at each (virtual) boot. | OS | Allowed | 7
| Reserved                  | Reserved for future use (RZ if not defined). | Impdef | Impdef | 8-14
|===

The constant Localities_MAX is the maximum number of Localities supported by the system.

NOTE: M-mode is responsible for virtualizing the OSSecret and BootSecret Locality Secrets.

*Example*: _If a key's metadata specifies a Locality field value of 2, the key for import/export operations is derived from the RCSK and the OEM Secret. If we generate an SCC on a first device, importing it on a second device will trigger an authentication failure if the OEM Secrets differ._

NOTE: A CC may reference a key via an index into the System Key Table (SKT).
A device-specific SKT entry may correspond to a different key on another device.
Using the latter may lead to unspecified behavior.
Implementations of the SKT *must* provide a suitable Locality to the ACE unit during CR configuration, and set usage policies that are at least as strict as the key's own.

[[ACE-format-initialization]]
==== Cryptographic Contexts and Initialization Inputs

The Initialization Input is used to initialize a CR and thus create a Cryptographic Context (CC).
Its size must be a multiple of 8 bytes.

The first 8 bytes of the Initialization Input contain the metadata section as specified in <<ACE-metadata>>.

This is followed by the _content_, i.e., the key(s) and possibly other algorithm-specific information, in a format that is algorithm-specific.

See <<ACE-algorithms>> for algorithm-specific details of the content part of the initialization input.

[[ACE-format-SCC]]
==== Sealed Cryptographic Contexts

The format of the SCCs is used when exporting a CC from a CR and is used also to reimport the CC into a CR.
It is dependent on the algorithm being used.
Its size must be a multiple of 8 bytes.

Format of SCC:::
(((Cryptographic context, SCC plaintext)))
`bytes 0 .. 7  {nbsp}{nbsp}{nbsp}{nbsp}{nbsp}` metadata section, +
`bytes 8 .. 19  {nbsp}{nbsp}{nbsp}{nbsp}` nonce used in the encryption (96 bits), +
`bytes 20 .. 31  {nbsp}{nbsp}{nbsp}` tag produced by the encryption method (96 bits), and +
`bytes 32 .. u+31  {nbsp}` encryption of the serialization of the content of the CR, with a byte length of `u`.
+
Only the serialization of the content is encrypted, while both metadata and content are included in the computation of the authentication tag, as described next.

See <<ACE-algorithms>> for algorithm-specific details on the format of the plaintext of the content of the SCC.


[[ACE-CSR]]
==== CSRs

ACE extends `*status` and `misa`. and adds 20 new CSRs (of which 16 are optional and M-mode exclusive) to manage its execution environment.
// It also requires a subset of the V extension CSRs (see <<ACE-V-dependency>>).

.New ACE CSRs
[cols="<16%,^11%,<24%,<49%"]
[float="center",align="center",options="header"]
|===
| Address        | Privilege | Name                     | Description
| 0xXXX          | URW       | `aceerror`               | Error code of the last ACE instruction
| 0xXXX          | URO       | `aceccstatus`            | Array of two-bit fields (similar to ACES state, but per CR)
| 0xXXX          | URW       | `acestart`               | ACE start byte index
| 0xXXX--0xXXX   | MRW (RZ)  | `macercsk{0..7}`         | ACE Root Context Sealing Key
| 0xXXX--0xXXX   | MRW (RZ)  | `maceOSSecret{0..3}`     | ACE OS Secret
| 0xXXX--0xXXX   | MRW (RZ)  | `maceBootSecret0{0..3}`  | ACE Boot Secret
|===

===== Extension to existing CSRs

[[ACE-ACE-field-in-misa]]
====== ACE field in `misa`

Bit `L` (11) in `misa` indicates that ACE is present.
(((CSR, ACE field in `misa`)))

[[ACE-ACES-field-in-status]]
====== ACES field in `*status`

The ACES field (bits 26:25) is added to `mstatus` and shadowed in `sstatus` and `vsstatus` (if the hypervisor extension is present).
(((CSR,ACES field in *status)))
Similarly to the FS and VS fields, it is used to optimize context switching.

If ACE is implemented, ACES shall not be read-only zero.
Its possible values are given in <<ACE-aces-encoding>>.

[[ACE-aces-encoding]]
.Encoding of ACES status field
[float="center",align="center",width="100%",cols="^8%,<8%,<84%",options="header"]
|===
|Status |Name |Meaning
|   0   | Off                | ACE disabled. CRs are inaccessible. The hart will trap if the user requests to enable the feature.
|   1   | Initial            | ACE enabled. No CR is configured.
|   2   | Clean              | ACE enabled. The state matches the last context swap (Clean).
|   3   | Dirty              | ACE enabled. Some CRs may have been modified since last Clean.
|===

Writes to ACES do not affect CR contents.
Clearing state is not performed by setting ACES to Off, Initial, or Clean, and it must be explicitly done by privileged code before changing ACES.

In <<fsxsstates-copy>> we describe the transitions between states.

//

[[fsxsstates-copy]]
.ACES state transitions
[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
|Current State |Off |Initial |Clean |Dirty
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|At context save in privileged code

|Save state? +
Next state
|No +
Off
|No +
Initial
|No +
Clean
|Yes +
Clean
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|At context restore in privileged code

|Restore state? +
Next state
|No +
Off
|Yes, to initial +
Initial
|Yes, from memory +
Clean
|N/A +
N/A
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|*Execute instruction that possibly modifies state,* +
*including configuration, import, cloning, and derivation*

|Action? +
Next state
|Exception +
Off
|Execute +
Dirty
|Execute +
Dirty
|Execute +
Dirty
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^| Export

|Action? +
Next state
|Exception +
Off
|Execute +
Initial
|Execute +
Clean
|Execute +
Dirty
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|Execute instruction to unconfigure unit

|Action? +
Next state
|Exception +
Off
|Execute +
Initial
|Execute +
Initial
|Execute +
Initial
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|Execute instruction to disable unit

|Action? +
Next state
|Execute +
Off
|Execute +
Off
|Execute +
Off
|Execute +
Off
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|Execute instruction to enable unit

|Action? +
Next state
|Execute +
Initial
|Execute +
Initial
|Execute +
Initial
|Execute +
Initial
|===

===== New CSRs

====== `aceccstatus`

The CSR `aceccstatus` tracks the configuration and dirtiness of CRs on a per-CR basis, so that privileged context switching code needs to save only the dirty CRs, and restore only the configured ones, unless the latter are lazy-loaded:

. For RV64, `aceccstatus` has a size of 64 bits,
``aceccstatus[``2__i__+1,2__i__``]`` can take the values Off, Init, Clean, Dirty as defined for `*status.ACES` for CR #__i__.
. For RV32, there are two 32-bit registers `aceccstatush` and `aceccstatusl` (collectively referred to as `aceccstatus` in the following)
where
``aceccstatus[``2__i__+1,2__i__``]`` can take the values Off, Init, Clean, Dirty as defined for `*status.ACES` for CR #__i__
and
``aceccstatus[``2__i__+1,2__i__``]`` for CR #__i__+16.

We describe now the semantics of the `aceccstatus` bitfields:

// Dlist Item:: Dlist item description
// ** Nested bulleted list item 1
// ** Nested bulleted list item 2

// *LAZY* (value: 0):: {empty}
// +
// --
// *Description:* CR unconfigured, but value saved for lazy loading. NB: It uses the FS/VS/ACES encoding for "OFF", but it does _not_ mean that the ISE is not active.
//
// ** *Usage/Export:* Traps to OS for lazy load. Restarted instruction operates starting from state *CLEAN*.
// ** *Configuration:* Works as expected; sets status to *DIRTY*.
// --
// +

* *INITIAL* (value: 1), i.e., CR unconfigured; no saved value in the context switching state.
+
--
** *Usage:* Error _ace_err_unconfigured_ (no trap).
** *Configuration:* does not trap, works as expected-including errors with *export* or *clone*-sets the status to *DIRTY*.
--
+

* *LAZY* (value: 0), i.e., CR unconfigured, but value saved for lazy loading.
+
--
** *Usage/Export:* Traps to OS for lazy load. Restarted instruction operates starting from state *CLEAN*.
** *Configuration:* Works as expected; sets status to *DIRTY*.

While the *LAZY* status reuses the FS/VS/ACES encoding for "OFF", this it does _not_ mean that the ISE is not active.
The encoding for *OFF* is suitable though, since it would be the natural one to use in case state must be lazily loaded.
If all CRs were either unconfigured or to be lazy-loaded, the ACES field would be set to *CLEAN* and not to *OFF*.
--
+

* *CLEAN* (value: 2), i.e., CR configured and loaded; unchanged since switch.
+
--
** *Usage:* Unrestricted; modification sets status to *DIRTY*.
** *Configuration:* Works as expected; sets status to *DIRTY*.
--
+

* *DIRTY* (value: 3), i.e. CR configured and loaded; potentially changed since last switch.
+
--
** *Usage:* Unrestricted.
** *Configuration:* Works as expected; status unchanged.
--
+

//

[[ACE-CSR-ace-error]]
====== `aceerror`

The 8-bit `aceerror` CSR records the error code from most recent ACE instruction.
Reading it may stall the hart until the operation completes.
It is writable for context switching.

Error codes 0-127 are reserved for RVI, 128-255 for custom algorithms.
The standard error codes are:

[[ACE-error-codes]]
.Error codes and their meanings
[float="center",align="center",width="100%",cols="^6%,<24%,<70%",options="header"]
|===
|Value | Mnemonic                | Examples (((ACE, error codes)))
|  0   | ace_err_ok              | No error.
|  1   | ace_err_authentication  | Authentication failure (`ace.import` or `ace.exec`).
|  2   | ace_err_privilege       | Access control failure (`ace.exec`, `ace.state`, etc.).
|  3   | ace_err_invalid         | Invalid input/operation. +
Examples:
invalid metadata passed to `ace.init` is invalid;
encryption, resp., decryption is requested from a CC only configured for decryption, resp., encryption;
a Form of `ace.exec` is used which is not allowed in the current state of the algorithm;
the requested change of state in `ace.state` is not permitted;
the change in usage policies in `ace.restrict` is not permitted;
software tried to use an incomplete CC in a CR as a source in an `ace.exec`, `ace.state`, `ace.input`, `ace.output`, `ace.clone`, `ace.derive`, `ace.harden`, or `ace.restrict` operation.
|  4   | ace_err_unimplemented   | Algorithm or algorithm variant not implemented.
|  5   | ace_err_memory          | Insufficient CRF memory to perform `ace.init`, `ace.exec`, `ace.clone`, or `ace.derive`.
|  6   | ace_err_unconfigured    | Usage of unconfigured CR in `ace.exec`, `ace.state`, `ace.input`, `ace.output`, `ace.clone`, `ace.derive`, or `ace.harden`/`ace.restrict`. Can trigger lazy reload.
|===

[[norm:ace_exc_priority]]
.ACE error priority in decreasing priority order.
[%autowidth,float="center",align="center",cols="<,>,<",options="header",]
|===
.>|Priority   .>|Exception +
Code        .>|Description
.>|_Highest_  |6               |Unconfigured CR
|           .>|5             .>|Insufficient CRF memory
|           .>|3             .>|Invalid input/output operation with `ace.exec`, `ace.state`, +
                                `ace.input`, `ace.output`, `ace.clone`, `ace.derive`, +
                                `ace.harden`, or `ace.restrict` (used incomplete CC as source)
|           .>|3             .>|Invalid input/output operation with `ace.init` (invalid metadata)
|           .>|2, 1          .>|Access Control Failure or authentication failure with `ace.import`
|           .>|1             .>|Authentication failure with `ace.exec`
|           .>|3             .>|Invalid input/output operation with `ace.exec` +
                                (form not allowed in current algorithm), +
                                `ace.state` (state change not allowed), +
                                or `ace.restrict` (change of usage policy is not allowed)
|           .>|4             .>|Algorithm or algorithm variant not implemented.
.>|_Lowest_ .>|0             .>|No error
|===

If executing an `ace.init`, `ace.import`, `ace.export`, `ace.input`, or `ace.output` triggers a
trap, as specified in the privileged architecture, `aceerror` remains unchanged.


[[ACE-acestart-definition]]
====== `acestart`

`acestart` is an XLEN-bit RW CSR, similar to `vstart`, tracking progress of long-running interruptible instructions `ace.init`, `ace.import`, `ace.export`, `ace.input`, and `ace.output`.
(((CSR, acestart)))

Unlike the vector extension’s `vstart`, which tracks element indices, ACE has no notion equivalent to that of vector elements;
`acestart` therefore records a byte offset.
For a load-type instruction (e.g., `ace.init`, `ace.import`, `ace.input`), this offset indicates how many bytes of input have already been read and processed. For a store-type instruction (e.g., `ace.export`, `ace.output`), it indicates how many bytes of output have already been computed and written.
The value includes all payload bytes (metadata, content, nonce, tag) and accommodates piecewise execution via traps (see <<ACE-trappable-insns-support>>).

This register is typically written by hardware.
Software may safely write 0 to fully restart an operation, and the register can be saved and restored during context switches.
However, software must not write arbitrary nonzero values to it, as this may result in an illegal-instruction exception, as the hardware or a trapped implementation are not required to support all possible values.
Only the instructions explicitly mentioned above support non-zero `acestart` values; other ACE instructions ignore this register, and will be restarted.

[NOTE]
====
_A single `acestart` value suffices due to the way the init/import/export instructions operate:_

* `_ace.init_` _and_ `_ace.import_` _use a single pass: all blocks are processed sequentially._
* `_ace.export_` _uses two passes. However, the first pass to compute the SIV is purely internal, and never accesses memory, so page faults cannot occur. This first stage is uninterruptible. The second pass writes metadata, nonce, SIV, then encrypted content to memory. Only the second pass can cause page faults and requires resumption._

This design obviates the need to separate data transfer from cryptographic processing during import and export operations. A separate transfer phase would require buffering the entire input within the ACE unit before processing, increasing internal resource requirements, whereas the current architecture can process data inline and is loaded with minimal overhead.
====

The exact semantics of `acestart` are defined in <<ACE-SC-AEAD>> and [.red]#TBD#.

[[ACE-CSR-macercsk]]
====== `macercsk`

Eight 32-bit WARL CSRs may be defined in RV32 and four 64-bit WARL CSRs in RV64 to configure `macercsk`.
(((CSR, `macercsk`)))
These are: `macercsk0`, `macercsk1`, `macercsk2`, and `macercsk3` in RV64,
and `macercsk0` to `macercsk7` in RV32.
A write to `macercsk{i}` set Bits [(_i_+1) XLEN - 1 : _i_ XLEN] of the RCSK.

Any access to the `macercsk` block outside of M-mode will cause an illegal instruction exception.

NOTE: We assume that M-mode firmware knows if RCSK is configurable, ephemeral, or fixed.
RCSK cannot be assumed to be preserved across power cycles, unless it is fixed.
If the RCSK is reconfigurable, mechanisms for RCSK persistence and cross-device transfer to assist VM migration are system-specific and belong to M-mode firmware.
Cross-device RCSK migration must use a public-key key wrapping mechanism.
Since M-mode FW cannot just trust any external entity claiming to be a trusted device:
all receiving end points, whether they are the M-mode FW of another trusted device, a TPM for temporary storage of a VM's CSK during device hibernation, or an HSM for intermediate CSK storage, must authenticate themselves.

====== Re-configurable Localities

Two groups of M-mode WARL CSRs are used for two reconfigurable Localities (cf.{nbsp}<<ACE-concepts>>).
These are:

* CSRs `maceOSSecret0` and `maceOSSecret1`, to configure the "OSSecret" entry in RV64, to which RV32 adds `maceOSSecret2` and `maceOSSecret3`.
(((CSR, `maceOSSecret*`)))
* CSRs `maceBootSecret0` and `maceBootSecret1`, to configure the "BootSecret" entry in RV64, to which RV32 adds `maceBootSecret2` and `maceBootSecret3` (cf.{nbsp}<<ACE-Localities>>).
(((CSR, `maceBootSecret*`)))

[NOTE]
====
`maceBootSecret*` must be reconfigurable in order to support VM reboots which are independent of the boot cycles if the physical host.
====

===== Reuse of `(v)satp`.ASID and `hgatp`.VMID

ACE reuses `(v)satp`.ASID and `hgatp`.VMID to optionally restrict the usage of CCs to a specific process or virtual machine.
// The maximal bit length of `ASID` is 9 for Sv32 addresses or 16 for Sv39, Sv48, and Sv57 addresses.
// The maximal bit length of `VMID` is 7 for Sv32x4 or 14 for Sv39x4, Sv48x4, and Sv57x4 addresses.
In the metadata section, `ASID` and `VMID` are always zero padded to the maximal lengths of 16 and 14 bits, respectively.
//[.darkred]#Verification needed: Ensure we can use ASID/VMID to restrict usage even if not used in address translation.#

NOTE: The software in each World/Supervisor Domain is normally responsible to generate or obtain their own keys, and if a process (applet) in one World/Supervisor Domain is responsible to provide keys to other Worlds/Supervisor Domains, it is the responsibility of the M-mode formware to perform an appropriate `ace.import`/RCSK switch/`ace.export` sequence.


[[ACE-SC-AEAD]]
=== Semantics of Initialization, Export and Import of Cryptographic Contexts

==== Initialization

==== Authenticated Encryption of Sealed Cryptographic Contexts

We first define the RFC8452 Key Derivation and the DCSK Derivation functions.

.RFC8452 Key Derivation
[]
----
function RFC8452_KeyDeriv(key) = {
  struct {
    AESE256(key, (125`b0 @ 0b101))[63:0] @ AESE256(key, (125`b0 @ 0b100))[63:0] @
    AESE256(key, (125`b0 @ 0b011))[63:0] @ AESE256(key, (125`b0 @ 0b010))[63:0],
    AESE256(key, (125`b0 @ 0b001))[63:0] @ AESE256(key, (125`b0 @ 0b000))[63:0]
  }
}
----

.Derived Key Derivation
[]
----
function DCSK_KeyDeriv(key,L) = {
    AESE256(key, L ^ (127'b0 @ 1'b1)) @ AESE256(key, L ^ (127'b0 @ 1'b0))
}
----

NOTE: Due to the computational cost of the derivation functions, implementations may
cache recently used derived keys for both the Root RCSK and Locality-derived keys.

We can now proceed to define the generation of the SCC from the CC in a CR.
In the pseudocode listings, we mark code blocks with
`UNINTERRUPTIBLE_BLOCK_START` and `UNINTERRUPTIBLE_BLOCK_END`.
Execution may only be interrupted before a `UNINTERRUPTIBLE_BLOCK_START` or after a `UNINTERRUPTIBLE_BLOCK_END`, and when an interrupted export or import operation is resumed, it will resume at the point of interruption.  The part before the first `UNINTERRUPTIBLE_BLOCK_START` consists only of type declarations or of information that is trivial to reconstruct (for instance, once the metadata is known, the size of the content and some values derived from it).
`SERIALIZE()` and `DESERIALIZE()` as the names imply, serialize and deserialize the content of a CR as defined in <<ACE-algorithms>>.

[[ACE-export]]
.Generation of the SCC from a CR Using AES-GCM-SIV (RFC8452)
[]
----
metadata : bits(64); // from the CR
N, SIV : bits(96);
tmp : bits(128);
Kenc : bits(256);
Kauth : bits(128);
content : array[z] of bytes,      // from the CR's metadata
where z : int = size(content);    // content is serialized, size derived from metadata
ASSERT(8 divides z);
M : array[32 + z] of bytes;       // information
let last_block_fractional : boolean = z % 16 != 0;
let num_blocks : int = ceil(z / 16);

UNINTERRUPTIBLE_BLOCK_START
|   N = random(96 bits);
|
|   if (metadata.Locality == 15) then
|       CSK = RCSK;
|   else
|       CSK = DCSK_KeyDeriv(RCSK, LST[metadata.Locality]);
|
|   {Kenc, Kauth} = RFC8452_KeyDeriv(CSK);
|
|   - If some internal operations are needed to make the content available,
|   - such as reconstructing threshold keys/values into a single share, these
|   - must be computed at this point. Starting with the following POLYVAL operation
|   - content will refer to the resulting data as architected for non-threshold
|   - implementations.
|   content = SERIALIZE();
|
|   tmp = POLYVAL(Kauth, 64'b0 @ metadata @ content);
|   SIV = AESE(Kenc, 1'b0 @ (tmp[126:0] xor (31'b0 @ N)))) >> 32;
UNINTERRUPTIBLE_BLOCK_END

// preemptible here, with `acestart` from 0 to 15
UNINTERRUPTIBLE_BLOCK_START
|   M[0 .. 15] = N[63:0] @ metadata[63:0];
UNINTERRUPTIBLE_BLOCK_END

// preemptible here, with `acestart` from 16 to 31
UNINTERRUPTIBLE_BLOCK_START
|   M[16 .. 31] = SIV[95:0] @ N[95:64];
UNINTERRUPTIBLE_BLOCK_END

foreach(i from 0 to num_blocks - 1) {
    // next instruction preemptible, with `acestart` from 32+i*16 to 39+i*16 or 47+i*16
    UNINTERRUPTIBLE_BLOCK_START
    |   if ((i == num_blocks - 1) and last_block_fractional)
    |       M[32+i*16 .. 39+i*16] = content[i*16 .. 7+i*16] xor
    |                       AESE(Kenc, 1'b1 @ SIV[94:0] @ (binary(i)[31:0]))[63:0];
    |   else
    |       M[32+i*16 .. 47+i*16] = content[i*16 .. 15+i*16] xor
    |                       AESE(Kenc, 1'b1 @ SIV[94:0] @ (binary(i)[31:0]));
    UNINTERRUPTIBLE_BLOCK_END
}
----

NOTE: It can happen that we export an incomplete CR, for instance, M-mode or HS-mode code is saving a CR that was only partially configured in U-mode when the U-mode process was interrupted. In this case, the Completion field shall reflect this, and the CR is exported as usual, with all the empty fields or not-yet complete parts of these fields filled with arbitrary data (implementations may choose to fill them with zeros). If the incomplete SCC is later imported, upon resuming these fields or parts thereof will be overwritten.  Whenever the export of a CR, configuration of a CR, or the import of a SCC into a CR, is interrupted, it is the responsibility of the interrupt handler to save the value of `acestart` and then restore it for that CR. This allows for multiple interruptions.
[.red]#TBD: we need to make sure that doubly interrupted operations will be handled correctly, for instance, by not not configuring as complete a CR that is actually incomplete. This can probably be done by taking into account the values of `acestart` if set up correctly. We need to make sure also that we cannot create a random or zero key, at least not more easily than what more privileged levels can do already.#

[[ACE-import]]
.Importing a SCC into a CR Using AES-GCM-SIV (RFC8452)
[]
----
M : array of bytes // from memory
Kenc : bits(256);
Kauth : bits(128);
N, SIV : bits(96);
tmp : bits(128);
tag : bits(96);

// next instruction preemptible, with `acestart` from 0 to 7
UNINTERRUPTIBLE_BLOCK_START
|   metadata : bits(64) = M[0 .. 7]
|   if (there is not enough memory for the algorithm encoded in the metadata)
|       error ace_err_insufficient_memory
UNINTERRUPTIBLE_BLOCK_END

UNINTERRUPTIBLE_BLOCK_START
|   z = size(content according to metadata);
|   content = internal buffer for z bytes;
|   num_blocks = ceil(z / 16);
|   last_block_fractional : boolean = (z % 16 != 0);
|
|   if (metadata.Locality == 15) then
|       CSK = RCSK;
|   else
|       CSK = DCSK_KeyDeriv(RCSK, LST[metadata.Locality]);
|
|   {Kenc, Kauth} = RFC8452_KeyDeriv(CSK);
|
|   // next instruction preemptible, with `acestart` from 8 to 19
|   N = M[8 .. 19]
UNINTERRUPTIBLE_BLOCK_END

// next instruction preemptible, with `acestart` from 20 to 31
UNINTERRUPTIBLE_BLOCK_START
|   SIV = M[20 .. 31]
|   tmp = 64'b0 @ metadata;
|   tmp = tmp * Kauth;  // * = Montgomery multiplication
UNINTERRUPTIBLE_BLOCK_END

foreach(i from 0 to num_blocks - 1) {
    // next instruction preemptible, with `acestart` from 32+i*16 to 39+i*16 or 47+i*16
    UNINTERRUPTIBLE_BLOCK_START
    |   if ((i == num_blocks - 1) and last_block_fractional) {
    |       content[i*16 .. 7+i*16] = M[32+i*16 .. 39+i*16] xor
    |                     AESE(Kenc, 1'b1 @ SIV[94:0] @ (binary(i)[31:0]))[63:0];
    |       tmp[63:0] = tmp[63:0] xor content[i*16 .. 7+i*16];
    |   } else {
    |       content[i*16 .. 15+i*16] = M[32+i*16 .. 47+i*16] xor
    |                     AESE(Kenc, 1'b1 @ SIV[94:0] @ (binary(i)[31:0]));
    |       tmp = tmp xor content[i*16 .. 15+i*16];
    |   }
    |   tmp = tmp * Kauth;  // * = Montgomery multiplication
    UNINTERRUPTIBLE_BLOCK_END
}

// if preempted here, `acestart` will be z + 32

UNINTERRUPTIBLE_BLOCK_START
|   tag = AESE(Kenc, 1'b0 @ (tmp[126:0] xor (31'b0 @ N)))) >> 32;
|   if (tag != SIV) then { error ace_err_authentication; }
|   - Now the content can be deserialized.
|   - This includes computing and derived values not saved as part of the SCC,
|   - as well as creating shares for threshold implementations.
|   DESERIALIZE(content)
UNINTERRUPTIBLE_BLOCK_END
----


//

==== Incomplete CCs

[.red]#*TBD*#

[comment]
--
* Any number of bytes can be initialized or imported in a CR, and exported from it, before the operation is preempted, depending on the alignment of the data.
* `acestart` counts all the bytes of the payload, including the metadata for all inputs and outputs, and the nonce and the tag as well for SCCs.
* The internal state shall always assumes that all internal operations that would be performed in the algorithms above are performed as follows
 ** `ace.init`:
  *** Once the metadata (8 bytes) has been read, is must be completely processed and imported in the CR.
  *** Whenever 8+16__i__ bytes have been read, also _i_ blocks of content must be processed and imported in the CR.
   For instance, if 28 bytes have been read in, the incomplete state has processed the metadata and the first content block, and knows 4 further bytes.
  *** If the operation is preempted, `acestart` will be the number of bytes read.
  *** The corresponding exported SCC will include an 8-byte block in clear after the metadata with the `acestart` value, followed by the nonce and the tag, and the content will only contain the payload imported and read so far, zero padded up to a multiple of 8 bytes. This content is of course encrypted.
  The AEAD algorithm will use `(length_of_payload)[64] @ metadata` in place of `0[64] @ metadata`.
  *** in the worst case, a SCC will be 8 bytes longer than the standard size for a complete exported CR for the same algorithm.#

 ** `ace.export` [.red]#TBD#
 ** `ace.import` [.red]#TBD#
--

[.red]#TBD: define the SCC formats for incomplete CCs.#

// ///////////////////////////////////////////////////////////////////////////////////////////

=== Supported Algorithms

[.darkred]#At the end we must add algorithm numbers!#

ACE architects support for several algorithms, and also defines a minimal required subset [.red]#(current suggestion)#:

* AES-128 and AES-256 encryption and decryption.
* AES-CTR, AES-GCM, AES-GCM-SIV, AES-XTS using AES-128/256.
* AES-CMAC using AES-128/256.
* SHA-2, SHA-2-HMAC.

The list of other architected algorithms is subject to change, but it includes at least:

* AES-192, alone and with the above modes.
* SM4 Block Cipher.
* The Ascon suite (Ascon-128/128a-AEAD, Ascon-Hash, Ascon-XOF, Ascon-80pq).
* SHA-3, SHA-3-HMAC.
* SM3 Secure Hash.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-instructions-detailed]]
=== Instructions

This section specifies the semantics and encodings of the ACE instructions.

NOTE: The encodings presented here are just examples, and may not be final.
They serve as a starting point for discussion and refinement as
well as a proof that, at the time of this writing, the ACE instruction set
can be encoded.

NOTE: ACE is an ideal candidate for the Composable Custom Extensions framework,
even though our aim is to make it into a ratified extension.

When a GPR is used to index a CR, use of the zero register `X0` is reserved and results in an illegal instruction exception.

[.darkred]#TBD: Add to each instruction whether it may be usage-controlled or not.#

[[ACE-instruction-enable-enable]]
==== ace.enable/ace.disable/ace.reset

`ace.enable` +
`ace.disable` +
`ace.reset`
(((ACE, instruction, ace.enable)))
(((ACE, instruction, ace.disable)))
(((ACE, instruction, ace.reset)))

Encoding::
+
--
This is an I-type instruction.

[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 0x0, attr: ['invalid GPR'] },
    { bits:  3, name: 'ace.clear', attr: [0x7] },
    { bits:  5, name: 0x0 },
    { bits: 12, name: 'immed12' },
]}
....

NOTE: This instruction shares its encoding with `ace.clear` with `3b'111` as instruction code (use a GPR to select the CR).
However, the zero in the source field [11:7] for indirect CR indexing is defined as invalid/special, and this allows to define this instruction.#
--
+

Description::
+
--
Enable, disable, or reset ACE in the current execution context:

* If the `immed12` = 1, then the feature is enabled. The alias for this instruction is `ace.enable`.
* If the `immed12` = 0, then the feature is disabled. The alias for this instruction is `ace.disable`.
* If the `immed12` = `0xa11`, then all CRs are cleared and the new state of the ACE unit is Clear.
The alias for this instruction is `ace.reset`.

`ace.enable` must be execute before any other ACE instruction, i.e. `ace.config` passing the immediate 1.

NOTE: The advantage of `ace.reset` with respect to a loop that clears all CRs is that the entire CRF memory is cleared without the need for compaction/management between the separate `ace.clear` operations and this operation cannot be interrupted, reducing potential wasteful context saves.

The instruction will trap in the following cases: [.red]#TBD#.
--
+



// [.darkred]#Proposal: With the immediate `0xa11` (all), all CRs will be cleared, as if `ace.clear` had been called on each of them, but the feature is not disabled.



See
//<<ACE-CSR-enable>> and
<<ACE-ACES-field-in-status>> for more details.

[[ACE-instruction-init]]
==== ace.init

`ace.init Kd|K[Xd],%offset(Xs)`
(((ACE, instruction, ace.init)))

Encoding::
`ace.init` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Ks','K[Xd]'] },
    { bits:  3, name: 'ace.init', attr: [0x4,0x5] },
    { bits:  5, name: 'Xs' },
    { bits: 12, name: 'imm', attr: ['offset'] },
]}
....

Description::
`ace.init` initializes a CR with metadata and content to create a CC.
`Kd` is the source CR to be initialized, encoded as a 5-bit immediate.
`Xd`, alternatively, is a GPR containing a number from 0 to 31 to select the context
to be initialized.
`Xs` points to the region of memory containing the metadata and the key material.

NOTE: `ace.init`, as well as `ace.import`, `ace.export`, `ace.input`, and `ace.output` as described later, perform direct memory accesses.
This does not violate the RISC-V load/store architecture principles,
since `ace.init`, `ace.import` and `ace.input` can be seen as special kinds of load instructions and
`ace.export` and `ace.output` as special store instructions.
// as ACE is architected to behave like an _attached_ unit, which may have its own interfaces.

NOTE: The operation follows the two-phases processing model defined in <<ACE-format-initialization>>.
In the first phase, the metadata block is read, which determines the length of the remaining information.
Then, in the second phase, the configuration material is read and processed.

// [.darkred]#(TBdetermined whether it is secure)# This instruction is trappable and may also be resumed or restarted.

[[ACE-instruction-clear]]
==== ace.clear

`ace.clear Kd|K[Xd]`
(((ACE, instruction, ace.clear)))

Encoding::
`ace.clear` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Ks','K[Xd]'] },
    { bits:  3, name: 'ace.clear', attr: [0x6,0x7] },
    { bits:  5, name: 0x0 },
    { bits: 12, name: 0x0 },
]}
....

Description::
`Kd` identifies the CR to be cleared, encoded as a 5-bit immediate. +
`Xd` alternatively, is a GPR containing a number from 0 to 31 to select the context to be cleared. +

[[ACE-instruction-export]]
==== ace.export

`ace.export %offset(Xd),Ks|K[Xs]`
(((ACE, instruction, ace.export)))

Encoding::
`ace.export` is an S-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'imm[4:0]' },
    { bits:  3, name: 'ace.export', attr: [0x0,0x1] },
    { bits:  5, name: 'Xd' },
    { bits:  5, name: 'context', attr: ['Ks','K[Xs]'] },
    { bits:  7, name: 'imm[11:5]' },
]}
....

Description::
Exports the CRs `Ks` or `K[Xs]` to memory at address `Xd`, using the procedure described in <<ACE-format-SCC>>.
If the context `Ks` is clear, or `Xs` is out of range,
the operation will report error ace_err_invalid.

The instruction must follow the interruptibility rules defined in <<ACE-acestart-definition>>.
Similarly to entire-vector-register store instructions, `ace.export` appears to other harts as sequences of individual stores.

The initial cryptographic phase of `ace.export`, as well as the authentication phase of `ace.import`, must be uninterruptible.
Even if these parts are executed concurrently with other operations, an interrupt handler may need to wait for these steps to complete before proceeding with any memory accesses.


[[ACE-instruction-import]]
==== ace.import

`ace.import Kd|K[Xd],%offset(Xn)` +
`ace.import.S Kd|K[Xd],%offset(Xn)`
(((ACE, instruction, ace.import)))
(((ACE, instruction, ace.import.S)))

Encoding::
`ace.import` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Kd','K[Xd]'] },
    { bits:  3, name: 'ace.import', attr: ['0    0    S','0    1    S'] },
    { bits:  5, name: 'Xn' },
    { bits: 12, name: 'imm' },
]}
....

Description::
`Kd` is the destination CR into which the SCC is imported, as an immediate (5-bit).
Alternatively, the number of the CR into which to import the SCC is stored in
the GPR `Xd` as a number from 0 to 31. `Xn` is the GPR containing the base address
of the buffer with the source SCC. +
The bit S takes the values 0 (false) or 1 (true).
It is set to true if the key is in a system defined format
(`ace.import.S`)
and not the format defined by the present architecture
(`ace.import`).

The instruction must follow the interruptibility rules defined in <<ACE-acestart-definition>>.
Similarly to entire-vector-register load instructions, `ace.import` appears to other harts as sequences of individual loads.

NOTE: The operation can be conceptually split into two phases.
In the first phase, the metadata
block is read, which determines the length of the remaining information.
Then, in the second phase, the rest of the SCC is read and processed.

NOTE: The instruction encoding includes a single bit to indicate a system-defined format. If multiple such formats are supported, the data format itself must incorporate a unique identifier to differentiate them. The system is therefore responsible for embedding these identifiers within all system-defined formats.

NOTE: The `ace.export` instruction does not have an `ace.export.S` analogue of `ace.import.S`.
This means that system-specific dynamically generated keys can be imported but not exported in the same form: they must be exported in the format architected here for ACE CCs.


[[ACE-instruction-exec]]
==== ace.exec

The `ace.exec` instruction admits four Forms, namely
(((ACE, instruction, ace.exec)))

[upperalpha]
. `ace.exec  Vd,Kn|K[Xn],Vs` {nbsp}{nbsp} takes an input vector and writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}Kn|K[Xn],Vs` {nbsp}{nbsp} takes an input vector but does not write to an output vector.
. `ace.exec  Vd,Kn|K[Xn]{nbsp}{nbsp}{nbsp}` {nbsp}{nbsp} does not take an input but writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}Kn|K[Xn]{nbsp}{nbsp}{nbsp}` {nbsp}{nbsp} does not take an input vector and does not write to an output vector.

Form D instructions perform internal processing only in the CC in the given CR.

// Without this comment, the next part is not properly formatted...
Encoding::
`ace.exec` is an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Vd', attr: ['rd'] },
    { bits:  3, name: 'ace.exec' },
    { bits:  5, name: 'Kn|K[Xn]', attr: ['rs1'] },
    { bits:  5, name: 'Vs', attr: ['rs2'] },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....
+
Bit `r` (i.e., bit 27) takes the value 0 if the context is encoded as an immediate,
and it takes the value 1 if a GPR (scalar integer value) is used to reference it.
For the four Forms A-D above, the encodings are:
+
[upperalpha]
. `ACE.exec` = `0b000`.
. `ACE.exec` = `0b001` and `rs2`=`0b00000`.
. `ACE.exec` = `0b010` and `rd`=`0b00000`.
. `ACE.exec` = `0b011` and `rs2`=`rd`=`0b00000`.

NOTE: We admit variants of Forms B and D, which we call Form B', resp., Form D',
with non-zero values in `rd`, resp., `rs2`, to encode additional instructions.

// To make indent in next line correct

Description::
Performs a cryptographic operation such as an encryption or decryption, absorbing a value in a hash, and possibly returning a value.

NOTE: In many algorithms, the next state is often implied by the preceding operation.
//For example, in AEAD algorithms, setting an IV or nonce could implicitly transition to the state for absorbing associated data.
However, to ensure consistency, ACE requires explicit state transitions even when this incurs additional instructions.
Exceptions are made only when strictly necessary for security, such as automatic transitions from hash finalization to verification,
or to the _completed_ or _invalidated_ states (see <<ACE-state-constants>> and <<ACE-algorithms>>).

[[ACE-instruction-size]]
==== ace.size

`ace.size` returns the size of the memory buffer that would be necessary to store the exported SCC.
(((ACE, instruction, ace.size)))
Knowing this size is necessary for any feature that relies on `ace.export`, including context switching.

===== Context Variant

`ace.size Xd,Ks|K[Xs]`

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x3, attr: ['ace.exec', '(Form D\')'] },
    { bits:  5, name: 'Ks|K[Xs]' },
    { bits:  5, name: 0x1, attr: ['ace.size'] },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....
+
Bit `r` (i.e., bit 27) is 0 if the CR is encoded as an immediate, and 1 if the CR's number is given in a GPR.

Description::
Returns the size of the SCC corresponding to the source CR,
and zero if the algorithm is not supported.

NOTE: The value can significantly differ from the internal resource usage to store the CC's data in a CR —
it can be larger (for simple primitives, because of the nonce/SIV overhead) but
also smaller (for keys split into shares for threshold implementations, but saved
externally in reconstructed form).

===== Metadata Variant

`ace.size Xd,Xs`

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x3, attr: ['ace.exec', '(Form D\')'] },
    { bits:  5, name: 'Xs' },
    { bits:  5, name: 0x2, attr: ['ace.size'] },
    { bits:  7, name: 0x0 },
]}
....

Description::
This instruction writes the size of a SCC having the metadata section given in `Xn` into GPR `Xd`, and zero if the algorithm is not supported.
Only the Algorithm and SC_Protection fields of the metadata section of a CC are considered.

[[ACE-instruction-available]]
==== ace.available

`ace.available Xd,Xs`
(((ACE, instruction, ace.available)))

Alias to the Metadata Variant of `ace.size`, as it returns zero if the algorithm is not supported.

[[ACE-instruction-clone]]
==== ace.clone

`ace.clone Kd|K[Xd],Ks|K[Xs]`
(((ACE, instruction, ace.clone)))

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Kd|K[Xd]' },
    { bits:  3, name: 0x3, attr: ['ace.exec','(Form D\')'] },
    { bits:  5, name: 'Ks|K[Xs]' },
    { bits:  5, name: 0x3, attr: ['ace.clone'] },
    { bits:  1, name: 0x0 },
    { bits:  2, name: 'R' },
    { bits:  4, name: 0x0 },
]}
....
+
Bits [27:26], i.e., field `R`, take the following values depending on how the CRs are given:
+
[upperalpha]
. `0b00` if the source and the output CRs are both encoded as immediates.
. `0b01` if the source CR is selected using a GPR and the output CR is encoded as an immediate.
. `0b10` if the source CR is encoded as immediate and the output CR is selected using a GPR.
. `0b11` if the source and the output CRs are both selected using the values of GPRs.

// Comment to ensure the proper indentation in the next Description

Description::
Clones source CR `Ks` (or the CR indexed by `Xs`) into destination CR `Kd` (or
into the CR indexed by `Xd`).

// NOTE: The `ace.clone` instruction is an optimization for the sequence `ace.export` followed by `ace.import`. While reusing cryptographic state (e.g., encrypting with the same counter) can enable certain attacks, this risk cannot be eliminated by omitting `ace.clone`, as a state can be exported and re-imported multiple times.

[[ACE-instruction-derive]]
==== ace.derive (optional)

`ace.derive Kd|K[Xd],Ks1|K[Xs1]` +
`ace.derive Kd|K[Xd],Ks1|K[Xs1],Vs2`
(((ACE, instruction, ace.derive)))

Encoding::
The encoding is a variant of Form A `ace.exec` encoding, and is thus an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Kd|K[Xd]' },
    { bits:  3, name: 0x0, attr: ['ace.exec (Form A)'] },
    { bits:  5, name: 'Ks1|K[Xs1]' },
    { bits:  5, name: 'Vs2', attr: ['use for additional input','no additional input (zero field)'] },
    { bits:  1, name: 0x1 },
    { bits:  2, name: 'R' },
    { bits:  1, name: 'z', attr: [0x1,0x0] },
    { bits:  3, name: 0x0 },
]}
....
+
This encoding differs from Form A `ace.exec` by having bit 25 set to 1.
Bits [27:26], i.e., field `R`, is encoded exactly as for `ace.clone` (cf.{nbsp}<<ACE-instruction-clone>>).
Bit 28 determines whether an additional vector register (or register group) is used to pass a parameter to the key derivation mechanism or not.

Description::
The instruction is used to derive a new context from an existing one, with its own opaque key material.
It is similar to `ace.clone`, but the derived context is not a copy of the source context,
rather, it is a new context that is derived from it, for instance, through a key derivation mechanism.
This instruction can be used multiple times, to generate multiple derived contexts.


[[ACE-instruction-state]]
==== ace.state/ace.dir

`ace.state`/`ace.dir Kd|K[Xd],#immed7` +
`ace.state`/`ace.dir Kd|K[Xd],#immed7,Xs`
(((ACE, instruction, ace.state)))
(((ACE, instruction, ace.dir)))

Encoding::
`ace.state`/`ace.dir` is an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Kd|K[Xd]' },
    { bits:  3, name: 0x4, attr: ['ace.state'] },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
    { bits:  5, name: 'Xs' },
    { bits:  7, name: 'immed7' },
]}
....
+
Bit `r` (i.e., bit 15) is 0 if the context is encoded as an immediate, and 1 if a GPR is used to reference it.

Description::
`ace.state` and `ace.dir` are two names for the same instruction. +
`Kn` specifies the CR whose state is to be set. Alternatively, `Xn` is a GPR containing a value from 0 to 31 to dynamically select the target context. The `#immed` operand is a constant from the set of admissible values defined for each algorithm, used to manage the algorithm's internal state machine when additional states are required. `Xs` is a GPR that is either `X0` or contains an optional additional parameter for the state machine.

The state numbers used in this specification are defined in the following table.

[[ACE-state-constants]]
.Constants defining CC states
[float="center",align="center",width="100%",cols="^6%,<29%,<65%",options="header"]
|===
| Value | Mnemonic                      | Examples
|   0   | ace_state_initial +
ace_state_hash_initialize
| The context is initialized and ready for operation.
|   1   | ace_state_hash_absorb         | Start (and initialize) a hash function or the sub-function of an algorithm, preparing it to absorb blocks of data.
|   2   | ace_state_hash_finalize +
ace_state_hash_finalize_enc             | Finalize the internal state of a hash function (including for the encryption algorithm of an authenticated encryption mode of operation) and prepare it for outputting the result. In this state additional data may be absorbed, such as lengths.
|   3   | ace_state_hash_finalize_dec   | Finalize the internal state of a hash function for the decryption algorithm of an authenticated decryption mode of operation. In this state additional data may be absorbed, such as lengths.
|   4   | ace_state_hash_verify         | Finalize the internal state of a hash function and compare it to the provided value.
|   5   | ace_state_hash_last_block +
ace_state_last_block_enc +
| For a hash or MAC function, we provide the length of the last block of data. May be used also in the encryption path of authenticated encryption modes of operation.
|   6   | ace_state_last_block_dec      | For the decryption path of authenticated encryption modes of operation if the length of the last block must be given.
|   7   | ace_state_encrypt +
ace_const_operate
|  Encryption is requested. +
Algorithm is ready to process.
|   8   | ace_state_decrypt             | Decryption is requested.
|   9   | ace_state_set_public_value    | Set a public value (like a nonce or an IV) in an algorithm. Some algorithms require more than one public value (for instance, they may admit a re-useable hash of some associated data and a unique nonce), in which case the second public value can be set using the next message.
|  10   | ace_state_set_public_value_2  | Set the second public value in an algorithm.
|  11   | ace_state_input_for_derive    | Tells the CC to expect additional information for feeding the `ace.derive` instruction.
|  14   | ace_state_invalidated         | The algorithm has abnormally terminated. `ace.error` will always return error code _ace_err_invalid_.
|  15   | ace_state_completed           | The algorithm has correctly completed.
|===

Algorithms that significantly differ from those we describe in <<ACE-algorithms>> and therefore cannot share the same software for their usage,
may reuse the same values in [1..13] with new constant mnemonics to define their own states.

[[ACE-instruction-restrict]]
==== ace.restrict/ace.harden

`ace.restrict   Kd|K[Xd],Xs` +
`ace.harden     Kd|K[Xd],Xs`
(((ACE, instruction, ace.restrict)))
(((ACE, instruction, ace.harden)))

// Without this comment, the next part is not properly formatted...
Encoding::
The encoding uses `ace.exec` Form B', with bit 7 (which is in the `rd` field) set.
It is thus a variant of an R-type instruction.
The source register field encodes a GPR and not a vector register.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 0x1 },
    { bits:  3, name: 0x1, attr: ['ace.exec', '(Form B\')'] },
    { bits:  5, name: 'Kd|K[Xd]' },
    { bits:  5, name: 'Xs' },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....
+
If bit `r` (i.e., bit 27) is 0, the 5-bit destination field [11:7] contains the destination context number,
else it determines the GPR that contains the context number.

// comment

Description::
+
--
This instruction can be used to:

* Restrict the usage of a CC (as stored in a CR) to specific modes or to a specified `ASID` or `VMID`; and
* Activate the side-channel protection of the CC or increase it.

Let `m` be the metadata field of the CC in the destination CR.
The instruction works as follows:

* Bits [11:10] and [63:26] of the input register `Xs` have the same format as the corresponding bits of the metadata.
* Bits [9:0] and [25:12] of the input register `Xs` are ignored.
* Bits [11:10] can be used to turn on or increase the level of the side-channel protection of the algorithm in the CC, if the microarchitecture supports the corresponding implementation. The levels are defined in <<ACE-SC-protection-levels>>. Downgrading side-channel protection is not permitted, and attempting to do so will result in error _ace_err_invalid_ (cf.{nbsp}<<ACE-error-codes>>).
* A zero in any of the six bits `Xs`[31:26] means that the corresponding policy is not changed.
* A one in any of the four bits `Xs`[29:26] means that usage by the corresponding mode is forbidden, and the corresponding bit in the metadata of the destination CC is set to 1.
* If `Xs`[30] is set and `m`[30] is NOT set, then UC_Policy_3, i.e., `m`[47:32], is set to `Xs`[47:32].
* If `Xs`[31] is set and `m`[31] is NOT set, then UC_Policy_4, i.e., `m`[63:48], is set to `Xs`[63:48].
* If `Xs`[30] and `m`[30] are both set and `Xs`[47:32] <> `m`[47:32], or if `Xs`[31] and `m`[31] are both set and `Xs`[63:48] <> `m`[63:48], then `aceerror` is set to ace_error_invalid.
--
+

//

[[ACE-instruction-input]]
==== ace.input (optional)

`ace.input Kd|K[Xd],%offset(Xs)`
(((ACE, instruction, ace.input)))

Encoding::
`ace.input` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Kd','K[Xd]'] },
    { bits:  3, name: 'ace.input', attr: [0x4,0x5] },
    { bits:  5, name: 'Xs' },
    { bits: 12, name: 'imm' },
]}
....

// [.darkred]#(TBdetermined whether it is secure)# This instruction is trappable and may also be resumed or restarted.

[[ACE-instruction-output]]
==== ace.output (optional)

`ace.output  %offset(Xd),Ks|K[Xs]`
(((ACE, instruction, ace.output)))

Encoding::
`ace.output` is an S-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'imm[4:0]' },
    { bits:  3, name: 'ace.output', attr: [0x4,0x5] },
    { bits:  5, name: 'Xd' },
    { bits:  5, name: 'context', attr: ['Ks','K[Xs]'] },
    { bits:  7, name: 'imm[11:5]' },
]}
....


[[ACE-instruction-error]]
==== ace.error

`ace.error Xd`
(((ACE, instruction, ace.error)))

Description::
The ACE Unit may be in an error state due to the previous operation.
The corresponding error code is written into GPR `Xd`.
This is implemented as a read from CSR `aceerror`, which may cause the hart to wait if the error code is not yet available
(cf.{nbsp}<<ACE-CSR-ace-error>>).
The error code list is architected and given in <<ACE-error-codes>>.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-trappable-insns-support]]
==== Support for Trappable Operations

This section is non-normative.

Instructions `ace.init`, `ace.export`, `ace.import`, `ace.input`, and `ace.output` support long inputs and outputs.
To reduce hardware complexity, these operations can be trapped and emulated in software.
(((ACE, trappable instruction)))
Upon a trap, the handler identifies the trapped instruction and uses `ace.size` on the metadata to determine the size of the data to be transferred.
Then, the emulation uses custom instructions to move data between the ACE unit and the CPU.
Three types of supporting operations are required:

 * A `mv` instruction that loads a specified number of bytes from a GPR or vector register into the state of a CR within the ACE unit.
   Initially, `ace.size` returns the total payload length to transfer.
   After each move, this value is updated to reflect the remaining bytes.
   The instruction also updates the `acestart` CSR to follow the internal progress.
 * A corresponding `mv` instruction that exports a specified number of bytes from a CR to a GPR or vector register.
   The behavior of `ace.size` will be similar to that of the `mv` instruction, but it will count the number of bytes to be exported.
 * A “`close`” instruction to suspend or finalize the procedure.
   If executed before all bytes are transferred, the CR state matches that of an interrupted monolithic instruction, including the Completion metadata field and the `acestart` value. If executed after all bytes are transferred, it also performs any final cryptographic operations, such as authenticating the CR, if needed.

Interrupting the firmware implementation of `ace.init`, `ace.export`, `ace.import`, `ace.input`, or `ace.output` must leave the architectural state indistinguishable from the state expected from interrupting a monolithic implementation of the instructions.
in particular, they need to respect the value of `acestart` and update it in accordance with the expected architected behavior of the emulated instructions.

The supporting instructions themselves must be uninterruptible.

// ///////////////////////////////////////////////////////////////////////////////////////////

[#ACE-algorithms]
=== Algorithm-Specific Data Formats and Instruction Semantics

In this chapter we specify the behavior of Cryptographic Contexts for various cryptographic algorithms.
Some specifications are generic in the sense that they apply to all algorithms of a certain type and can be instantiated with different primitives with varying parameters such as block and key sizes.
Further specifications pertain to cryptographic algorithms that require specific primitives.

NOTE: This chapter is normative, defining the behavior of instructions and the data formats they use for certain classes of cryptographic algorithms including some mandatory ones. For example, AES-GCM-SIV is fully specified in <<ACE-GCM-SIV>>, where the block size `b` = 128 and the key size `k` is 128 or 256 bits and the hashing function is POLYVAL as defined in <<GCM-SIV>>. +
This specification ensures that an instantiation of the same mode of operation with a different primitive, such as SM4-GCM-SIV using the same hash, is also well defined.

Each algorithm is fully defined by the following information:

Parameters:::
These include:
* The block size, which is the size of the basic unit of information processed by the algorithm, usually the block size of the main underlying primitive;
* The key size, for keyed algorithms; and
* Any other parameter (for instance, counter size) that is necessary to instantiate the algorithm with compatible primitives.

Data Structures:::
These include:

. *Initialization Input*:
The data following the metadata block in the initialization input to `ace.init`, such as keys and other required secrets.
Fields are listed in the order they appear in the initialization input, each with its length in bytes.

. *Internal State*:
Information that must be maintained in the internal state of a CC.
The fields are unordered, and their lengths in bytes may differ from those listed—for example, in threshold or fault-tolerant implementations where redundancy is added. Notably, the full single-share key size is listed even when a System Key is used, as this reflects the size of the key material the algorithm operates on.

. *Serialized Content*:
The data that follows the metadata block in the plaintext portion of the SCC.
The fields are listed in the order they appear in the SCC, each with its length in bytes.

// Generic Functions:::
// If necessary, redefine generic functions that apply to all contexts.

Algorithm-Specific Functions:::
Any other function that is specific to the algorithm.

State Machine:::
This includes:

. A list of *states* in which the internal state machine of the logic is executed, together with their representation, either as a number in the range [0..15] or by more complex structures. The values must conform to <<ACE-state-constants>>.
. A complete list of the *allowed state transitions*, including the conditions under which each transition is allowed.
. The *behavior* of all ACE instructions at each state.

We also add pseudocode to clarify how the algorithms supported by an ACE unit are implemented in software using the ACE ISA.

// NOTE: While we do not specify the exact internal format of a CC in a CR, we observe that it must contain all the data in a Initialization Input or in a SCC (in plaintext), in some order within the CRF. Therefore, we assume that this information can be first copied into the CR as is, and then any aditional information will be reconstructed at the end of the configuration or import operation. This applies also to threshold implementations, where for any information in multiple shares the input can initially be input into the first share.  In the worst case, only 32 bits of additional information may be needed to be able to process incomplete CRs and SCCs.

The definitions of the algorithms also implicitly define the functions `SERIALIZE()` and `DESERIALIZE()` used in <<ACE-export>> and <<ACE-import>>.
These functions do not need to be explicitly implemented as functions that convert the internal memory in the CRF into a structured byte array, called
`content[]` in the aforementioned pseudocodes, that satisfies the architected definition of the _Serialized Content_ for each algorithm, and viceversa.
Instead, the output of `SERIALIZE()` and the input of `DESERIALIZE()` can just be an _interpretation_ of the internal memory in the CRF as if it were the SCC plaintext, such that any change in one (except for the absent fields) is reflected in the other, but does not have to be written explicitly in the inernal memory of the CRF.

[[ACE-generic-rules]]
==== Generic Rules

For modes of operations that can be instantiated with different primitives, we specify more general rules, where the differences between instantiations in some cases are limited to the widths of the inputs and outputs of the primitive. If the primitive is a block cipher, then `b` is its block width in bits.

Recall that the architecture views a CC as a structure with two fields: the metadata (currently 64 bits), which has a unique specification, and the content (variable length), which is algorithm-specific.

In the descriptions of the algorithms below, we do not need to redefine these two functions if they are not changed, i.e., if there are no changes to the metadata format.

If the number of states of the algorithm is at most 16 (including _initial_, _completed_, and _invalidated_), the `state` of the metadata is used to store this value.
Otherwise, the specification of the algorithm must include a suitable field in the content section of the CC/SCC.

An important rule is the following.
If an invalid input is provided to any ACE instruction, or a non-admitted instruction is executed, while processing the algorithm in CR, say, `Kn`,
the `Kn` is *invalidated*, namely, the following happens:
(((ACE, algorithm, invalid state)))
(((Cryptographic Register, invalidated)))

* `Kn` is put into state _invalidated_;
* For instructions that refer to `Kn`:
 ** any Form of `ace.exec` performs no operation and, if it provides an output, the latter is always zero;
 ** `ace.clone` and `ace.derive` clean the destination contexts;
 ** `ace.restrict` and `ace.harden` perform no operation;
 ** `ace.input` and `ace.output` perform no operation;
 ** `ace.state` perform no operation, unless it is used to return to state _initial_;
 ** `ace.error` always returns error _ace_err_invalid_ after any operation involving the CR except for
    `ace.import` and `ace.export`, `ace.clean`, `ace.init`, and `ace.size`, which all work normally, and using `ace.state` to return to state _initial_.
* The current instruction is terminated.

The function that puts the CR in this state is called `invalidate()`.

In state _completed_, only `ace.init`, `ace.export`, `ace.import`, `ace.clear`, and `ace.error` are permitted. Any other instruction that produces an output returns zero and *invalidates* the CR.

Operations performed by `ace.exec` or `ace.state`—as defined by the algorithm-specific rules—are uninterruptible. This includes processing of arbitrarily long vector inputs when all work is purely internal to ACE and in particular without access to external memory (e.g., encryption, decryption, hashing, or point multiplication). Because these operations may proceed independently of the CPU core, a hart implementation may require context-switching software to wait when accessing a CR that is being written. These instructions are therefore atomic and non-preemptible.

In what follows, when we write of "state _name_" we refer to the state which has number _ace_state_name_ as described in <<ACE-state-constants>>.

The rules from <<ACE-ECB-mode>> to  <<ACE-hash-functions>> can be instantiated, like the modes that they describe, with a variety of block ciphers and polynomials for GHASH- or POLYVAL-like hashes, where only the block and key sizes are needed to get a full specification.

// On the other hand, the specifications from <<ACE-hash-functions>> to <<ACE-Ascon>> are in general heavily primitive dependent.

[[ACE-rules-threshold-implementations]]
==== Rules for Threshold implementations

Any CC with its algorithms implemented as threshold implementation will always initialize, import and export _all_ its keys and secrets as _single_, _reconstructed_ _shares_.
The Configuration and SCC Formats will be the same as for the non-threshold implementation variants of the same algorithm, with the only difference being the value of the Side Channel Protection bits in the metadata.
For the purpose of architecture specification, all values are also always represented as a single share in this document.
Threshold implementations are simply implementation variants of the exact same algorithm.
(((ACE, algorithm, threshold variants)))

NOTE: This assumes that reconstructing a key or re-randomizing it are fast operations, such as ``xor``s with random values.
This in turn implies that ACE execution unit must have access to a source of randomness, or at least a PRNG that is seeded at hardware boot.

This ensures not only the compactness of a SCC, but also that the key can be ported across architectures.
In fact, some threshold implementations may have a different number of shares even if they claim the same order of side-channel protection.

[[ACE-rules-system-keys]]
==== Rules for System Keys

System keys that are referred to by an index will cause the following changes in all the algorithms described in what follows:

. In the initialization input and in the SCC, the key/main key field will contain the index of the key in the SKT in place of a key value.
. This field is always a 64-bit value, even if the key itself is larger. This saves space in the SCC and allows for faster export and import operations.
. For algorithms that require more than one key, such as XEX/XTS, ALL the keys are referred to by a single index, i.e., a single 64-bit value in the initialization input and the SCC.
. Accordingly, the SCC generation functions will support System Keys by producing and reading the shorter fields with the indexes in place of the longer fields that would be required when the key values are explicitly provided.

NOTE: Internally, the ACE unit can either directly use the value from the SKT, or copy it to the internal state of the CR.
The architecture does not restrict the choice of the implementation.
On the other hand, keys generated from a system block, using a custom "recipe", are always represented by their values and once generated have the exact same behavior as any other key that does not come from the SKT.

[[ACE-ECB-mode]]
==== Electronic Codebook Modes (Direct Encryption/Decryption)

While listing the rules for the ECB mode is in principle easy, it does display all the rules that are required to describe an arbitrarily complex mode.
(((ACE, algorithm, ECB)))

===== Specification

Parameters:::

* `b` = block size in bits (8|`b`). `VLEN` must be a multiple of `b`.
* `k` = key size in bits (8|`k`).

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k/8` bytes, or 8 bytes if a System Key index.

* *Internal State*:
 ** `key`: `k/8` bytes.

* *Serialized Content*:
[lowerroman]
 . `key`: `k/8` bytes, or 8 bytes if a System Key index.

Algorithm-Specific Functions:::

* `enc_blk(p) -> c` encrypts plaintext block `p` using the key, and returns the ciphertext result `c`.
* `dec_blk(c) -> p` decrypts ciphertext block `c` using the key, and returns the plaintext result `p`.

State Machine:::

* *States:* _initial_, _encrypt_, and _decrypt_
* *Allowed State Transitions:*
 ** From any state to state _encrypt_, if metadata allows encryption, else the CR is *invalidated*.
 ** From any state to state _decrypt_, if metadata allows decryption, else the CR is *invalidated*.
* *Behavior:*
 ** In state _initial_, any `ace.exec` will result in the CR being *invalidated*.
 ** In states _encrypt_ or _decrypt_, we can only issue a Form A `ace.exec`, i.e., `ace.exec Vd,Kn|K[Xn],Vs`.
  *** If the state is _encrypt_, then `Vd = enc_blk(Vs)`.
  *** If the state is _decrypt_, then `Vd = dec_blk(Vs)`.
  *** If `VLEN` is a multiple of `b`, then `ace.exec Vd,Kn|K[Xn],Vs` encrypts/decrypts block-by-block.
  *** If any other Form of `ace.exec` is issued, then the CR is *invalidated*.

//

[NOTE]
====
Supporting vector lengths smaller than a cipher's block size would complicate the architecture.
For example, even in a simple ECB mode, we would require instruction sequences like
----
ace.exec    K0,V0          // load lower half of plaintext
ace.exec    K0,V1          // load upper half of plaintext
ace.exec V0,K0             // store lower half of ciphertext
ace.exec V1,K0             // store upper half of ciphertext
----
(or similar ones) in place of a single `ace.exec Vd,Kn|K[Xn],Vs`.
Supporting this behaviour would not only complicate both the architecture and its implementation, but it would also burden the software using the feature.
Therefore, the present specification assumes that vector lengths (or vector groups) can be configured to at least the block size of the cipher.
====

===== Usage

The following pseudocode illustrates how to use an ECB CC to encrypt a block of data using a block cipher with a width of 128 bits (`VLEN` is also 128).

[[ACE-pseudocode-ECB-encryption]]
.Simple Pseudocode Example: Encryption with no Authentication
----
- Call OS API to get the necessary SCC. Assume X5 points to the SCC.
- Allocate memory for ciphertext buffer.

vsetvli zero,4,e32,m1,ta,ma               // Use 128-bit vectors
ace.import K0,(X5)                        // Import the SCC into CR K0
ace.error X1                              // Read error from a CSR
if (X1 != 0) then { handle error }        // ACE may fail to validate SCC, algorithm may
                                          // be not supported, or CRF memory may be full
ace.state K0,#ace_state_encrypt           // Configure CR for encryption
ace.error X1                              // Read error from a CSR
if (X1 != 0) then { handle error }        // Error if encryption not allowed

foreach (i from 0 to len_in_bytes(plaintext)/16-1) { // assume plaintext in whole blocks
    - load V0 from address plaintext+16*i
    ace.exec V0,K0,V0                     // Encrypt one block of the plaintext
    - store V0 at address ciphertext+16*i
}
----

// vle32.v  V0, (plaintext)              // load V0 from address plaintext+16*i
//                                       // assume plaintext is in a register
// ace.exec V0, K0, V                    // Encrypt one block of the plaintext
// vse32.v  V0, (ciphertext)             // store V0 at address ciphertext+16*i
// add plaintext, plaintext, 16          // advance plaintext pointer
// add ciphertext, ciphertext, 16        // advance ciphertext pointer

[[ACE-chaining]]
==== Chaining/Feedback Modes

There is no need to explicitly architect the behavior of chaining modes,
such as
Cipher Block Chaining (CBC),
Propagating Cipher Block Chaining (PCBC),
Cipher Feedback (CFB) and
Output Feedback (OFB)
as they can be easily implemented on top of the ECB functionality in software,
and no intermediate value in these algorithms needs to be kept secret.


[[ACE-keystream-modes]]
==== CTR/CRFSR/XCTR/XCRFSR Keystream Generation

In the "non-X" modes, i.e., in the CTR mode and its analogue that replaces the arithmetic counter by a CRFSR, the sum of the lengths of IV and counter/LFSR equals the block size of the underlying keyed PRP or PRF. IV and counter/CRFSR are concatenated to form the input to the keyed PRP or PRF.
(((ACE, algorithm, keystream generation)))

The "X" modes have both IV and counter/LFSR of the same size as the block size of the underlying keyed PRP or PRF:
IV and counter/CRFSR are ``xor``ed together to form the input to the keyed PRP or PRF -- which explains the "X" in the mode names.

===== Specification

Parameters:::
* `b` = block size in bits (8|`b`). For this algorithm `VLEN` must be a multiple of `b`.
* `k` = key size in bits (8|`k`).
* `j` = counter size in bits (8|`j`).
* `n` = IV size in bits (8|`n`).
* If the mode is CTR or CRFSR, it is `b = n + j`.
* If the mode is an "X" mode, it is `b = n = j`.

Data Structures:::
* *Initialization Input*:
[lowerroman]
 . `key`: `k/8` bytes, or 8 bytes if a System Key index.

* *Internal State*:
 ** `key`: `k/8` bytes.
 ** `IV`: `n/8` bytes.
 ** `ctr`: `j/8` bytes.

* *Serialized Content*:
[lowerroman]
 . `key`: `k/8` bytes, or 8 bytes if a System Key index.
 . `IV`: `n/8` bytes.
 . `ctr`: `j/8` bytes.

Algorithm-Specific Functions:::
* `keystream_block(p) -> c` -- usually an encryption function.
* `tick_ctr()` -- updates the `ctr` (either by a modular increment or a CRFSR).

State Machine:::
* *States:* _initial_, _set_public_value_, _operate_.
* *Allowed State Transitions:*
 ** _initial_ -> _set_public_value_ -> _operate_.
 ** All states to _initial_.
* *Behavior:*
 ** In state _initial_, the `ctr` and `IV` fields are set to 0 (`ctr` is set to 1 if the algorithm is CRFSR-based).
 ** In state _set_public_value_, only ``ace.exec`` instructions of Form B are allowed. +
     "```ace.exec Kn|K[Xn],Vs```" sets the IV value to `Vs`.
  *** If no such instruction is issued, the value of the IV will remain zero.
  *** If `VLEN` is larger than `b`, the most significant bits of `Vs` (i.e., the "tail" of the vector) are ignored.
  *** If such operations are issued more times, they will just update the IV value again. Since this can be done only before any encryption or decryption operation, this does not represent a security issue.
  *** Any other Form of `ace.exec` will produce a null output and *invalidate* the CR.
 ** In state _operate_, only ``ace.exec`` instructions of Form C are allowed. +
     "```ace.exec Vd,Kn|K[Xn]```" performs:
+
--
  . If in a CTR or CRFSR mode then `tmp ← keystream_block(IV @ ctr)`, +
    else (i.e., if in a XCTR or XCRFSR mode) `tmp ← keystream_block(IV xor ctr)`,
  . `tick_ctr()`, and
  . `Vd ← tmp`.
--
+
If `VLEN` is a multiple of `b`, the above three commands are applied to each of the `VLEN/b` `b`-bit blocks of `Vs`, producing each time the corresponding `b`-bit block of `Vd`.
If the number `x` of blocks to be processed in an entire run of the algorithm is not a multiple of `VLEN`/`b`, `VL` can be set to the remainder of the division of `x` by `VLEN`/`b` for the last instruction.

 ** In state _operate_, any other Form of `ace.exec` will produce a null output and *invalidate* the CR.

Note that if `ace.state` is issued to return to state _initial_, the CC can be reused with a new `IV`.

===== Usage

Example pseudocode is given in <<ACE-pseudocode-keystream-modes>> (for the case `b` = `VLEN` = 128).

[[ACE-pseudocode-keystream-modes]]
.Encrypt with Keystream Generation
----
// Acquire payload, initialize
- Info: plaintext = *PT
- Process gets a Keystream Generation CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero,4,e32,m1,ta,ma                      // Use 128-bit vectors
ace.import K0,(X5)

// The next operations set the nonce (and the derived Authentication Key).
ace.state K0,#ace_state_set_public_value
V0 ← nonce
ace.exec K0,V0

// Compute keystream, use it to encrypt plaintext
for i = 0 to len_in_bytes(PT)/16-1 do
    - load V0 from address PT+16*i
    ace.exec V1,K0
    V1 ← V1 xor V0
    - store V1 at address CT+16*i
----

[[ACE-XEX-XTS-modes]]
==== XEX/XTS modes (one or two keys)

The use of a single key or two independently sampled keys is determined by the algorithm, and it is not a configuration parameter for the algorithm.
We first define XEX mode functionality.
(((ACE, algorithm, XEX)))

===== Specification

Parameters:::

* `b` = block size in bits (8|`b`). For this algorithm we require `VLEN` to be an integer multiple of `b`.
* `k` = key size in bits (8|`k`).

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key1`: `k/8` bytes, or 8 bytes if a System Key index.
 . `key2`: `k/8` bytes  -- omitted if only one key is used or if both keys come from an entry in the SKT.

* *Internal State*:
 ** `key1`: `k/8` bytes.
 ** `key2`: `k/8` bytes.
 ** `mask`: `b/8` bytes.

* *Serialized Content*:
[lowerroman]
 . `key1`: `k/8` bytes, or 8 bytes if a System Key index.
 . `key2`: `k/8` bytes -- omitted if only one key is used or if both keys come from an entry in the SKT.
 . `mask`: `b/8` bytes.

Algorithm-Specific Functions:::

* `enc_blk(key,p) -> c` encrypts block `p` using the key, and returns the result `c`.
* `dec_blk(key,c) -> p` decrypts block `c` using the key, and returns the result `p`.
* `update_mask(mask) -> mask` -- updates the mask by a Galois Field multiplication in GF(2^b^).

State Machine:::

* *States:* _initial_, _set_public_value_, _encrypt_, and _decrypt_.

* *Allowed State Transitions:*
 ** _initial_ -> _set_public_value_.
 ** _set_public_value_ -> _initial_.
 ** _set_public_value_ -> _encrypt_, if metadata allows encryption, else the CR is *invalidated*.
 ** _set_public_value_ -> _decrypt_, if metadata allows decryption, else the CR is *invalidated*.
 ** _encrypt_, _decrypt_ -> _initial_.

* *Behavior:*
 ** In state _initial_:
  *** The `mask` field is set to zero.
  *** Any {nbsp}``ace.exec``{nbsp} operation will produce null outputs and causes the CR to be *invalidated*.
 ** In state _set_public_value_, only ``ace.exec`` instructions of Form B are allowed. +
 "```ace.exec Kn|K[Xn],Vs```" sets the _tweak_. The `mask` field is used to store the tweak: `mask <- Vs`.
  *** If no such instruction is issued, the value of the tweak will remain zero.
  *** If `VLEN` is larger than `b`, the most significant bits of `Vs` (i.e., the "tail" of the vector) are ignored.
  *** If "```ace.exec Kn|K[Xn],Vs```" is repeated, it will just re-write the mask.
  *** Other forms of `ace.exec` not allowed, will produce null outputs and the CR is *invalidated*.
 ** When transitioning from _set_public_value_ to either _encrypt_ or _decrypt_, the following operations are performed:
  . `mask <- enc_blk(key2,mask)` or `mask <- enc_blk(key1,mask)` if only one key is used.
  . If only one key is used then update mask: `mask <- update_mask(mask)`.
 ** In states _encrypt_ and _decrypt_, only ``ace.exec`` instructions of Form A are allowed. +
    "```ace.exec Vd,Kn|K[Xn],Vs```" performs the following operations:
+
--
  *** in state _encrypt_, computes `Vd = mask xor enc_blk(key1,Vs xor mask)` ... +
      in state _decrypt_, computes `Vd = mask xor dec_blk(key1,Vs xor mask)` ...
  *** ... and updates the mask: `mask <- update_mask(mask)`.
--
+
If `VLEN` is a multiple of `b`, the above commands are executed `VLEN/b` times, processing each `b`-bit block of `Vs` into a `b`-bit block of `Vd`. This operation is clearly parallelizable. If the number `x` of blocks to process is not a multiple of `VLEN`/`b`, `VL` can be set to the remainder of the division of `x` by `VLEN`/`b` for the last instruction.

//

Note that if `ace.state` is issued to return to state _initial_, the CC can be reused with a new tweak.

===== Usage

Using XEX mode is very easy. We include pseudocode for encryption only, decryption is entirely similar
(this example is also assuming `b` = `VLEN` = 128).

[[ACE-pseudocode-basic-IV-mode]]
.Pseudocode for encryption in any IV-based non-authenticated mode without associated data
----
// Acquire payload
- Info: plaintext = *PT
- Call an API to get the corresponding key from a key management applet or HW block.
- The API returns the SCC. Assume X5 is the pointer to it.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero,4,e32,m1,ta,ma                      // Use 128-bit vectors
ace.import K0,(X5)

ace.state K0, #const_set_public_value            // this can be an IV or a nonce.
V0 ← IV
ace.exec K0,V0

ace.state K0,#ace_state_encrypt                  // Configure CR for encryption
for i = 0 to ceil(len_in_bytes(plaintext)/16)-1 do
    - load V0 from address plaintext+16*i
    ace.exec V0,K0,V0                            // Encrypt one block of the plaintext
    - store V0 at address ciphertext+16*i
----

To implement the XTS mode, the ciphertext stealing part is easy to realize using the XEX algorithm together with vector masking and shifting operations.
(((ACE, algorithm, XTS)))

// N.B. another ace.state K0, #const_set_public_value would reset the internal state and allow to begin another decryption with a new IV.


[[ACE-GCM-mode]]
==== GCM Mode
(((ACE, algorithm, GCM)))

===== Specification

Parameters:::

* `b` = block size in bits (8|`b`). For this algorithm we require `VLEN` to be an integer multiple of `b`.
* `k` = key size in bits (8|`k`).

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k/8` bytes, or 8 bytes if a System Key index.

* *Internal State*:
 ** `key`: `k/8` bytes.
 ** `ctr`: `b/8` bytes.
 ** `hash_key`: `b/8` bytes.
 ** `auth_tag`: `b/8` bytes.

* *Serialized Content*:
[lowerroman]
 . `key`: `k/8` bytes, or 8 bytes if a System Key index.
 . `ctr`: `b/8` bytes.
 . `auth_tag`: `b/8` bytes.

NOTE: There are no fields for the lengths of the AD and of the plaintext, as they are maintained by the calling software.
Also, `hash_key` is not serialized, and thus it is recomputed upon `ace.import`.

Algorithm-Specific Functions:::

* `enc_blk(key,p) -> c` encrypts block `p` using the key, and returns the result `c`.

* `absorb(data)` absorbs data into the hash function by performing:
  . `auth_tag <- auth_tag xor Vs`.
  . `auth_tag <- auth_tag * hash_key`.

State Machine:::

* *States:* _initial_, _set_public_value_, _hash_absorb_, _encrypt_, _hash_finalize_enc_, _decrypt_, _hash_finalize_dec_, and _hash_verify_, _completed_.

* *Allowed State Transitions:*
 ** From all states to _initial_.
 ** _initial_ -> _set_public_value_ -> _hash_absorb_.
 ** _hash_absorb_ -> _encrypt_ -- if metadata allows encryption, else the CR is *invalidated*.
 ** _hash_absorb_ -> _decrypt_ -- if metadata allows decryption, else the CR is *invalidated*.
 ** _encrypt_ -> _hash_finalize_enc_, later automatically transitioning to _completed_.
 ** _decrypt_ -> _hash_finalize_dec_.
 ** _hash_finalize_dec_ -> _hash_verify_, later automatically transitioning to _completed_.

* *Behavior:*
 ** In state _initial_ :
  *** Any {nbsp}``ace.exec``{nbsp} operation will produce null outputs and causes the CR to be *invalidated*.
  *** The following initialization operations are performed:
   . `hash_key <- enc_blk(key,0)`,
   . `auth_tag <- 0`, and
   . `ctr <- 0`.
 ** In state _set_public_value_:
  *** Only  ``ace.exec`` instructions of Form B are allowed.
  "```ace.exec Kn|K[Xn],Vs```" sets
   . `ctr <- Vs @ (b/4-1)b'0 @ 1'b1`, i.e., the `b/4` most significant bits of `Vs` are ignored, and the `b/4` least significant bits of `ctr` represent the integer 1.
  *** If "```ace.exec Kn|K[Xn],Vs```," is repeated, it will just re-write the IV.
  *** If no such `ace.exec` to set the IV is issued, `ctr` remains zero.
  *** If `VLEN` is larger than `b`, the most significant bits of `Vs` (i.e., the "tail" of the vector) are ignored.
  *** Any other Form of `ace.exec` will produce null outputs and causes the CR to be *invalidated*.

 ** In state _hash_absorb_, only  ``ace.exec`` instructions of Form B are allowed. +
 "```ace.exec Kn|K[Xn],Vs```" absorbs a data block in `auth_tag`, i.e.:
+
--
 . `absorb(Vs)`.
--
+
If `VLEN` > `b`, the above operation is executed `VLEN/b` times, absorbing each time a `b`-bit block of `Vs` into the hash.
This operation is parallelizable by having the implementation precompute the first four powers of `hash_key`, keeping it internally in the CR (and reconstructing these powers after `ace.import`). If the number `x` of blocks to process is not a multiple of `VLEN`/`b`, `VL` can be set to the remainder of the division of `x` by `VLEN`/`b` for the last instruction.

** In state _encrypt_, only ``ace.exec`` instructions of Form A are allowed. +
   "```ace.exec Vd,Kn|K[Xn],Vs```" encrypts `Vs` into `Vd`, and absorbs the ciphertext `Vd` into the `auth_tag`, namely:
+
--
  *** If `ctr[b/4-1:0] = 0`, the CR is *invalidated*.
  . `tmp <- Vs xor enc_blk(key,ctr)`.
  . `absorb(tmp)`.
  . `ctr[b/4-1:0] <- ctr[b/4-1:0] + 1 % 2^b/4^`.
  . `Vd <- tmp`.
--
+
If `VLEN` is a multiple of `b`, the above are executed `VLEN/b` times, encrypting each `b`-bit block of `Vs` into the corresponding `b`-bit block of `Vd`. There is significant potential for parallelization, including in the `absorb` function. If the number `x` of blocks to encrypt is not a multiple of `VLEN`/`b`, `VL` can be set to the remainder of the division of `x` by `VLEN`/`b` for the last instruction.

** In state _hash_finalize_enc_, only ``ace.exec`` instructions of Form A are allowed. The value +
 `{nbsp}{nbsp}{nbsp}Vs = IntTo{b/2}Bits(bit_length(AD)) @ IntTo{b/2}Bits(bit_length(plaintext))` +
 must be set by the software, then,
  "```ace.exec Vd,Kn|K[Xn],Vs```"
  computes the authentication tag and completes the algorithm as follows:
+
--
  . `absorb(Vd)`.
  . `auth_tag <- auth_tag xor enc_blk(key,ctr[b-1,b/4] @ 0[b/4-1,0])`.
  . Finally, `auth_tag` is returned in `Vd`, and the state is changed to _completed_.
--
+
If `VLEN` is larger than `b`, the most significant bits of `Vs` (i.e., the "tail" of the vector) are ignored.

 ** In state _decrypt_, only  ``ace.exec`` instructions of Form A are allowed. +
 `ace.exec Vd,Kn|K[Xn],Vs`
   absorbs the ciphertext `Vs` into the `auth_tag`, then decrypts `Vs` into `Vd`, namely
+
--
  . If `ctr[b/4-1:0] = 0`, the CR is *invalidated*.
  . `absorb(Vs)`.
  . `Vd  <- Vs xor enc_blk(key,ctr)`.
  . `ctr[b/4-1:0] <- ctr[b/4-1:0] + 1`.
--
+
If `VLEN` is a multiple of `b`, the same behavior applies as in state _encrypt_.

** In state _hash_finalize_dec_, only a Form A ``ace.exec`` instruction is allowed.
The value +
 `{nbsp}{nbsp}{nbsp}Vs = IntTo{b/2}Bits(bit_length(AD)) @ IntTo{b/2}Bits(bit_length(plaintext))` +
 must be set by the software, then "```ace.exec Vd,Kn|K[Xn],Vs```" computes the authentication tag as follows:
+
--
  . `absorb(Vs)`.
  . `auth_tag <- auth_tag xor enc_blk(key,ctr[b-1,b/4] @ 0[b/4-1,0])`.
--
+
If `VLEN` is larger than `b`, the most significant bits of `Vs` (i.e., the "tail" of the vector) are ignored.

** In state _hash_verify_, only an ``ace.exec`` instruction of Form B, i.e., "```ace.exec Kn|K[Xn],Vs```" is allowed.
    It compares `Vs` with `auth_tag`:
+
--
  . If the values match, then the state is changed to _completed_, and `ace.error` returns no error,
  . else the state is changed to _completed_, and `ace.error` returns `ace_err_authentication`.
--
+
If `VLEN` is larger than `b`, only the `b` least significant bits of `Vs` are compared to `auth_tag`.

** Upon completion of `ace.import`, the ACE unit recomputes `hash_key`:
  . `hash_key <- enc_blk(key,0)`.

//

===== Usage

In <<ACE-pseudocode-GCM-encryption>> we show pseudocode for GCM encryption (again with `b` = `VLEN` = 128).
The code assumes that both AD and plaintext (or the ciphertext for the decryption) are zero-padded to a multiple of `b` bits, in this case 128 bits.

[[ACE-pseudocode-GCM-encryption]]
.GCM Encryption
----
// Acquire payload, initialize
- Info: authenticated data = *AD, plaintext = *PT
- Process gets a GCM encryption CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero,4,e32,m1,ta,ma                      // Use 128-bit vectors
ace.import K0,(X5)

// The next operations set the nonce (and the derived Authentication Key).
ace.state K0,#ace_const_set_public_value
V0 ← nonce
ace.exec K0,V0

// Compute AD contribution to Auth Data
ace.state K0,#ace_const_hash_absorb
for i = 0 to len_in_bytes(AD)/16-1  do
    - load V0 from address AD+16*i
    ace.exec K0,V0                               // Absorb it into hash

// Encrypt plaintext and continue computation of auth_tag
ace.state K0,#ace_const_encrypt
for i = 0 to len_in_bytes(PT)/16-1 do
    - load V0 from address PT+16*i
    ace.exec V1,K0,V0
    - store V1 at address CT+16*i

// Finally, we absorb the lengths into auth_tag, finalize it, and output it
ace.state K0,#ace_const_hash_finalize_enc
V1 ← IntTo64Bits(len(AD)) @ IntTo64Bits(len(PT))
ace.exec V2,K0,V1                                // V2 contains the finalized hash
----

GCM decryption differs from encryption as follows:
the roles of `PT` and `CT` are reversed,
states _encrypt_ and _hash_finalize_enc_ are replaced by states _decrypt_ and _hash_finalize_dec_,
and the last lines are as follows:

[[ACE-pseudocode-GCM-decryption-difference]]
.GCM Decryption
----
// Finally, we absorb the lengths into auth_tag, finalize it, and verify it
ace.state K0,#ace_const_hash_finalize_dec
V1 ← IntTo64Bits(len(AD)) @ IntTo64Bits(len(CT))
ace.exec V2,K0,V1                                // V2 contains the finalized hash

ace.state K0,#ace_const_hash_verify
V1 ← tag_from_payload
ace.exec K0,V1                                   // V1 contains the tag from the input
ace.error X1
if (X1 != 0) then { handle error }       // do not use the plaintext if error occurred
----

//

[discrete]
===== Alternative Examples

GCM security is not compromised if `H` is revealed.
Consequently, an implementation based on a simpler ECB mode CC is possible,
as shown below (for encryption only -- decryption is similar).
However, this significantly increases code size and requires implementing `galois_mult(V4,V3)`.
Adding a dedicated mode to the ACE unit is a minor effort, and it allows internal logic to optimize execution
beyond the capabilities of, for instance, a compiler on an in-order CPU. It also means that the CPU
does not have to implement the carryless multiplication (cf. <<ACE-V-dependency>>),
and only a shared ACE unit has to,
which saves hardware costs when several small cores share a single ACE unit.

[[ACE-pseudocode-GCM-encryption-alternate]]
.Implementing GCM encryption using an ECB CC
----
// Acquire payload, initialize
- Info: authenticated data = *AD, plaintext = *PT
- Process gets a GCM encryption CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero,4,e32,m1,ta,ma                      // Use 128-bit vectors
ace.import K0,(X5)                               // Imports SCC into CR K0
V5[127:32] ← IV
V5[31:0] ← 1

V3 ← 0                                           // “Auth Data 1”
ace.exec V4,K0,V3                                // compute H
for i = 0 to ceil(len_in_bytes(AD)/16)-1  do
    - load 16 bytes from AD+16*i into V1
    V3 ← V3 xor V1                               // Horner scheme add
    V3 ← galois_mult(V4,V3)                      // Horner scheme mult

counter ← 1                                      // a 32-bit integer value
for i = 0 to ceil(len_in_bytes(PT)/16)-1  do
    V5[32:0] ← counter
    - load 16 bytes from PT+16*i into V1
    ace.exec V2,K0,V5                            // create mask by encrypting the counter
    V1 ← V1 xor V2                               // CTR encrypt
    V3 ← V3 xor V1                               // Horner scheme add
    V3 ← galois_mult(V4,V3)                      // Horner scheme mult
    - store V1 at *(CT+16*i))
    counter ← counter + 1

V3 ← V3 xor (len_in_bits(AD) @ len_in_bits(PT))  // Horner scheme add
V3 ← galois_mult(V4,V3)                          // Horner scheme mult
V5[32:0] ← 1                                     // Prepare IV || 1 for tag encryption
ace.exec V2,K0,V5
tag ← V3 xor V2                                  // Last Horner scheme add
----



[[ACE-GCM-SIV]]
==== GCM-SIV mode

The GCM-SIV mode's main differences with GCM are that:

. Both encryption and authentication keys are derived from the main key, whereas in GCM the main key is used also for encryption;
. It is a MAC-then-Encrypt mode, whereas GCM is an Encrypt-then-MAC mode, therefore GCM-SIV is more amenable to Release of Unencrypted Plaintext (RUP) attacks;
. Encryption requires two passes over the plaintext, since the tag computed on the AD and plaintext is used also as the initialization vector for the CTR encryption.
(((ACE, algorithm, GCM-SIV)))

The third difference affects the state machine. While GCM-SIV's decryption state machine is similar to the GCM's, the encryption state machine is different:

* During encryption, the _hash_absorb_ state absorbs the entire associated data and plaintext. The _hash_finalize_enc_ state then absorbs the lengths and produces the SIV/tag. Finally, the _encrypt_ state performs a second pass to encrypt the plaintext using the SIV/tag as the initialization vector.
* During decryption, the _hash_absorb_ state absorbs only the associated data. The _decrypt_ state decrypts the ciphertext and simultaneously absorbs the plaintext into the hash. Finally, the _hash_finalize_dec_ state absorbs the lengths, produces the SIV/tag, and internally compares it to the provided SIV/tag.

===== Specification

Parameters:::

* `b` = block size in bits, (`8|b`). For this algorithm we require `VLEN` to be an integer multiple of `b`.
* `k` = key size in bits (8|`k`).
* It must be `k = b` or `k = 2b`.
* It must be established by the algorithm whether the authentication tag is `b` or `3b/4` bits long.

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k/8` bytes, or 8 bytes if a System Key index.

* *Internal State*:
 ** `key`: `k/8` bytes.
 ** `enc_key`: `k/8` bytes.
 ** `auth_key`: `b/8` bytes.
 ** `nonce`: `3b/32` bytes (`3b/4` bits).
 ** `ctr`: `b/32` bytes (`b/4` bits).
 ** `auth_tag`: `b/8` bytes.
 ** `SIV`: `b/8` or `3b/32` bytes (`b` or `3b/4` bits).
+
A `b`-bit `SIV` is computed by clearing the most significant bit of `auth_tag` and encrypting it. +
For a `3b/4`-bit `SIV`, a full `b`-bit `auth_tag` value is kept while absorbing data.
The public `SIV` value is computed by clearing the most significant bit of `auth_tag`, encrypting it, and then removing the `b/4` least significant bits.

* *Serialized Content*:
[lowerroman]
 . `key`: `k/8` bytes.
 . `nonce`, `3b/32` bytes.
 . `ctr`, `b/32` bytes.
 . `auth_tag`, `b/8` bytes.
 . `SIV`, `b/8` bytes.

NOTE: `hash_key` and `auth_key` are not serialized,
and must be recomputed upon each `ace.import`. +
 +
The `SIV` field is actually only needed for decryption, since it must be maintained separately from the `auth_tag` field, which changes with each processed block as it is computed, whereas for encryption it is first computed completely and then used in the encryption process. However, since the same CC could be configured to support both encryption and decryption, the `SIV` field always present in the internal state (even if not used) and in the exported state.

//

Algorithm-Specific Functions:::

* `enc_blk(key,p) -> c` encrypts block `p` using the key, and returns the result `c`.
* `absorb(data)` absorbs data into the hash function by performing a step of (a variant of) GHASH or POLYVAL as specified by the algorithm
   (for instance, AES-GCM-SIV uses POLYVAL):
  . `auth_tag <- auth_tag xor Vs`.
  . `auth_tag <- auth_tag * hash_key`, where `*` denotes either Galois field multiplication (for GHASH) or Montgomery multiplication (for POLYVAL/MHASH), as specified by the algorithm.
State Machine:::
* *States:* _initial_, _set_public_value_, _set_public_value_2_, _hash_absorb_, _hash_finalize_enc_, _hash_finalize_dec_, _encrypt_, _decrypt_, and _completed_.

* *Allowed State Transitions:*
 ** From all states to _initial_.
 ** For encryption:
    _initial_ -> _set_public_value_ -> _hash_absorb_ -> _hash_finalize_enc_ -> _encrypt_.
 ** For decryption: +
    _initial_ -> _set_public_value_ -> _set_public_value_2_ -> _hash_absorb_ -> _decrypt_ -> _hash_finalize_dec_.
 ** Transition to _encrypt_ possible only if metadata allows encryption, else the CR is *invalidated*.
 ** Transition to _decrypt_ possible only if metadata allows decryption, else the CR is *invalidated*.

* *Behavior:*
 ** In state _initial_ :
  *** Any {nbsp}``ace.exec``{nbsp} operation will produce a null output and the CR will be *invalidated*.
  *** The following initialization operations are performed:
    . `enc_key`, `auth_key <- RFC8452_KeyDeriv(key)`,
    . `nonce`, `ctr`, `auth_tag`, `SIV <- 0`.

  ** In states _set_public_value_, resp. _set_public_value_2_:
    *** We can only issue  ``ace.exec`` instructions of Form B, i.e., "```ace.exec Kn|K[Xn],Vs```", to set the value of `nonce`, resp. `SIV`.
    *** If "```ace.exec Kn|K[Xn],Vs```" is repeated, it will just re-write the value of `nonce`, resp. `SIV`.
    *** If no such `ace.exec` is issued, `nonce`, resp. `SIV`, remain equal to zero.
    *** If `VLEN` is larger than `b`, the most significant bits of `Vs` (i.e., the "tail" of the vector) are ignored.
    *** Other forms of `ace.exec` will produce null outputs and *invalidate* the CR.
+
NOTE: There is no harm in moving to state _set_public_value_2_ and setting the
SIV while encrypting, since that field is not used in the encryption path until
it is set (thus overwriting any previous content) by the state machine itself.
Accepting this redundant but harmless behavior simplifies the state machine.
+
** In state _hash_absorb_:
+
--
   *** Only ``ace.exec`` instructions of the Form "```ace.exec Kn|K[Xn],Vs```" are allowed. Such an instruction accumulates a value in the `auth_tag`:
   i.e., perform `absorb(Vs)`.
--
+
If `VLEN` is a multiple of `b`, `absorb` is executed on each of the `VLEN/b` blocks in `Vs`.

*** Other forms of `ace.exec` will produce null outputs and *invalidate* the CR.

** In state _hash_finalize_enc_, only an {nbsp}``ace.exec``{nbsp} of Form A is allowed. +
  "```ace.exec Vd,Kn|K[Xn],Vs```," where it is the responsibility of the user to set +
`{nbsp}{nbsp}{nbsp}Vs = IntTo{b/2}Bits(bit_length(AD)) @ IntTo{b/2}Bits(bit_length(plaintext))`, +
finalizes the computation of the SIV/tag, by performing:
+
--
    . `absorb(Vs)`.
    . `tmp <- enc_blk(enc_key, 1'b0 @ (auth_tag xor N)[b-2:0])`
    . If tag length is `b` bits, then
     *** `SIV <- tmp` and `Vd <- tmp`,
    . else (tag length is `3b/4` bits)
     *** `SIV <- tmp[b-1:b/4]` and `Vd <- (tmp >> b/4)`.
--
+
If `VLEN` is larger than `b`, the most significant bits of `Vs` beyond the `b`-th (i.e., the "tail" of the vector) are ignored.

*** Other forms of `ace.exec` will produce null outputs and *invalidate* the CR.

** In state _encrypt_, only  ``ace.exec`` instructions of the Form A are allowed, namely "```ace.exec Vd,Kn|K[Xn],Vs```," to encrypt `Vs` into `Vd` as follows:
+
--
. If `ctr = 0`, then the CR is *invalidated*.
   . If the `SIV` is `b`-bits long, then +
     *** ``Vd <- Vs xor enc_blk(key, 1'b1 @ SIV[b-2:b/4] @ (SIV[b/4-1:0] + ctr % 2^b/4^)),``
   . else (the `SIV` is `3b/4`-bits long) +
      *** ``Vd <- Vs xor enc_blk(key, 1'b1 @ SIV[3b/4-2:0] @ ctr``.
   . `ctr <- ctr + 1`.
--
+
If `VLEN` is a multiple of `b`, the above operations are applied to each of the `VLEN/b` blocks in `Vs`.

*** Other forms of `ace.exec` will produce null outputs and *invalidate* the CR.

** In state _decrypt_,  only  ``ace.exec`` instructions of the Form A are allowed, namely "```ace.exec Vd,Kn|K[Xn],Vs```," to decrypt `Vs` into `Vd` and then absorb the plaintext `Vs` into the `auth_tag`:
+
--
     . If `ctr = 0`, then the CR is *invalidated*.
     . If the `SIV` is `b`-bits long, then +
       *** ``Vd <- Vs xor enc_blk(key, 1'b1 @ SIV[b-2:b/4] @ (SIV[b/4-1:0] + ctr % 2^b/4^)),``
     . else (it is `3b/4`-bits long) +
       *** ``Vd <- Vs xor enc_blk(key, 1'b1 @ SIV[3b/4-2:0] @ ctr``.
     . `absorb(Vs)`.
     . `ctr <- ctr + 1`.
--
+
If `VLEN` is a multiple of `b`, the above operations are applied to each of the `VLEN/b` blocks in `Vs`.

*** Other forms of `ace.exec` will produce null outputs and *invalidate* the CR.

 ** In state _hash_finalize_dec_,
    only an ``ace.exec`` instruction of Form B is allowed,
    namely "```ace.exec Kn|K[Xn],Vs```," where it is the responsibility of the user to set +
    `{nbsp}{nbsp}{nbsp}Vs = IntTo{b/2}Bits(bit_length(AD)) @ IntTo{b/2}Bits(bit_length(plaintext))`. +
    ``ace.exec`` thus performs the following operations:
+
--
  . `absorb(Vs)` (which modifies `auth_tag`).
  . `tmp <- enc_blk(enc_key, 1'b0 @ (auth_tag xor N)[b-2:0])`.
  . If tag length is `b` bits, then
     *** `auth_tag <- tmp`,
  . else (tag length is `3b/4` bits)
     *** `auth_tag <- tmp[b-1:0] @ (b/4)b0`.
  . Finally, `auth_tag` and `SIV` are compared:
     *** If the values match, the state transitions to _completed_ and `ace.error` returns no error,
  else the state transitions to _completed_ and `ace.error` returns `ace_err_authentication`.
--
+
If `VLEN` is larger than `b`, the most significant bits of `Vs` beyond the `b`-th (i.e., the "tail" of the vector) are ignored.

  ** Upon completion of `ace.import`, the ACE unit recomputes `hash_key` and `auth_key`
    . `enc_key`, `auth_key <- RFC8452_KeyDeriv(key)`.

//

===== Usage

We show in <<ACE-pseudocode-GCM-SIV-encryption>> how to perform AEAD encryption with a GCM-SIV CC (with `b` = `VLEN` = 128).
<<ACE-pseudocode-GCM-SIV-decryption>> is the corresponding pseudocode for decryption.

[[ACE-pseudocode-GCM-SIV-encryption]]
.GCM-SIV Encryption
----
// Acquire payload, initialize
- Info: authenticated data = *AD
- Info: plaintext = *PT
- Call an API to get the corresponding key from a key management applet or HW block.
- The API returns the SCC. Assume X5 is the pointer to it.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero,4,e32,m1,ta,ma                      // Use 128-bit vectors
ace.import K0,(X5)

// Set the nonce (and the derived Authentication Key).
ace.state K0,#ace_const_set_public_value
V0 ← nonce
ace.exec K0,V0

for i = 0 to len_in_bytes(AD)/16-1  do
    - load V0 from address AD+16*i               // Load a block of associated data
    ace.exec K0,V0 		                         // Absorb it into hash

for i = 0 to len_in_bytes(PT)/16-1  do
    - load V0 from address PT+16*i               // Load a block of plaintext
    ace.exec K0,V0 		                         // Absorb it into hash
V0 ← IntTo64Bits(len(AD)) @ IntTo64Bits(len(PT))
ace.exec K0,V0		          	                 // Absorb lengths into hash

// Finalize the SIV computation, set and return it
ace.state K0,#ace_const_hash_finalize_enc
ace.exec V2,K0
- store V2 into tag

// Encrypt the plaintext
ace.state K0,#ace_const_encrypt
for i = 0 to len_in_bytes(PT)/16-1  do
    - load V0 from address PT+16*i               // Load a block of plaintext
    ace.exec V1,K0,V0                            // Encrypt the block
    - store V1 at address CT+16*i                // Store a block of ciphertext
----



[[ACE-pseudocode-GCM-SIV-decryption]]
.GCM-SIV Decryption
----
// Acquire payload, initialize
- Info: authenticated data = *AD
- Info: ciphertext = *CT
- Call an API to get the corresponding key from a key management applet or HW block.
- The API returns the SCC. Assume X5 is the pointer to it.
- Allocate memory for plaintext buffer PT (if not same as CT).

vsetvli zero,4,e32,m1,ta,ma                      // Use 128-bit vectors
ace.import K0,(X5)

// The next operations set the nonce and SIV.
ace.state K0,#ace_const_set_public_value
V0 ← nonce
ace.exec K0,V0
ace.state K0,#ace_const_set_public_value_2
V0 ← SIV
ace.exec K0,V0

// Compute AD contribution to Auth Data
ace.state K0,#ace_const_hash_absorb
for i = 0 to len_in_bytes(AD)/16-1  do
    - load V0 from address AD+16*i
    ace.exec K0,V0                              // Absorb it into hash

// Decrypt ciphertext and continue computation of auth_tag
for i = 0 to len_in_bytes(CT)/16-1 do
    - load V0 from address CT+16*i
    ace.exec V1,K0,V0
    - store V1 at address PT+16*i

// Finally, we absorb the lengths of AD and plaintext into auth_tag AND verify
ace.state K0,#ace_const_hash_finalize_enc
V0 ← IntTo64Bits(len(AD)) @ IntTo64Bits(len(PT))
ace.exec K0,V0
ace.error X1
if (X1 != 0) then { handle error }               // do not use the plaintext if error occurred
----



[[ACE-CMAC]]
==== CMAC Functions

CMAC is an algorithm for message authentication codes constructed from a block cipher.
It was designed by Tetsu Iwata and Kaoru Kurosawa and became a NIST recommendation in May 2005.
(((ACE, algorithm, CMAC)))

===== Specification

Parameters:::

* `b` = block size in bits (8|`b`).  For this algorithm we require `VLEN` to be an integer multiple of `b`.
* `k` = key size in bits (8|`k`).

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k/8` bytes.

* *Internal State*:
 ** `key`: `k/8` bytes.
 ** `hash`: `b/8` bytes.
 ** `last_block_len`: `8` bytes.

* *Serialized Content*:
[lowerroman]
 . `key`: `k/8` bytes.
 . `hash`: `b/8` bytes.
 . `last_block_len`: `8` bytes.

Algorithm-Specific Functions:::

* `enc_blk(key,p) -> c` encrypts block `p` using the key, and returns the result `c`.
* `gen_subkeys(K) -> K1,K2` generates subkeys `K1` and `K2` from the master key `K` as follows: First, let `C` be the non-leading coefficients of the lexicographically first irreducible binary polynomial of degree `b` with the minimal number of ones: `0x1B` for `b` = 64, `0x87` for `b` = 128, and `0x425` for `b` = 256, then
//First, `C` is a `b` bit value that, if interpreted as a polynomial in the letter `x` over GF(2), makes `x^b^ + const_Rb` irreducible.
 . `L <- AES-enc_blk(K, 0)`
 . if (`most_significant_bit(L){nbsp}{nbsp}= 0`) then
   { `K1 <- L{nbsp}{nbsp}<< 1` }
   else
   { `K1 <- (L{nbsp}{nbsp}<< 1) xor C` }.
 . if (`most_significant_bit(K1){nbsp}= 0`) then
   { `K2 <- K1{nbsp}<< 1` }
   else
   { `K2 <- (K1{nbsp}<< 1) xor C` }.
 . return ```(K1,K2)```.

State Machine:::

* *States:* _initial_ (0), _hash_absorb_, _hash_last_block_, _hash_finalize_, and _completed_.
* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_.
 ** _hash_absorb_ -> _hash_finalize_ -> _completed_.
 ** From any state to state _initial_.
* *Behavior:*
 ** In state _initial_:
  *** `last_block_len` is set to zero.
  *** `hash` is set to zero.
  *** Any `ace.exec` will result in the CR being *invalidated*.

 ** In state _hash_absorb_, we can only issue ``ace.exec`` instructions of Form B, i.e., "```ace.exec Kn|K[Xn],Vs```", to absorb the data block `Vs` into the hash. This is performed as follows:
+
--
  . `tmp <- hash xor Vs`.
   . `hash <- enc_blk(key,tmp)`.
--
+
If `VLEN` is a multiple of `b`, then the above operations are applied to each `b`-bit block of `Vs`.

 ** Upon issuing `ace.state Kn|K[Xn],#ace_state_last_block, Xs` where `Xs` contains the length of the last block in bits, the following happens:
   . if `partial_len` <> 0, then the CR is *invalidated*. (The previous block is not complete.)
   . if `Xs > b` then the CR is *invalidated*.
   . `last_block_len <- Xs`.

 ** In state _hash_last_block_,  we can only issue a single ``ace.exec`` instruction of Form B, i.e., "```ace.exec Kn|K[Xn],Vs```", to absorb the data block `Vs` and write the final hash value in `Vd`. After this, the state transitions to _completed_:
+
--
  . `K1,K2 <- gen_subkeys(key)`.
  . if `last_block_len` = `b`, then
    *** `tmp <- hash xor Vs xor K1`,
  . else
    *** `tmp <- Vs`
    *** Remove the `b` - `last_block_len` most significant bits of `tmp` and pad the resulting value with a `1` and sufficiently many `0` bits to make it `b` bits long.
    *** `tmp <- hash xor tmp xor K2`.
  . `hash <- enc_blk(key,tmp)`.
  . The state is changed to _hash_finalize_.

  ** In state _hash_finalize_,
    then we can issue one ``ace.exec`` instruction of Form C, i.e., "```ace.exec Vd,Kn|K[Xn]```", to output the hash.
    Upon issuing that instruction, the CC transitions to state _completed_ with no error.
--
+
If `VLEN` is larger than `b`, the most significant bits of `Vs` beyond the `b`-th (i.e., the "tail" of the vector) are ignored.


 ** In any state, issuing any Form of ``ace.exec`` that is not the allowed one will produce a null output and the CR will be *invalidated*.


[.darkred]#Fill missing example#



[[ACE-hash-functions]]
==== Hash and MAC Functions (Including XOF Variants Thereof)

We now define an interface for hash and MAC functions.
Because of the vast variety of such functions, we cannot define a completely general interface.
However, the interface defined here is sufficiently general to allow to describe most commonly used and standardized functions, such as
the SHA2, SHA3, SHAKE, and BLAKE families, as well HMAC keyed constructions.
(((ACE, algorithm, general hashing)))
(((ACE, algorithm, MAC functions)))
(((ACE, algorithm, XOF)))

===== Specification

Parameters:::

* `b` = block size in bits (8|`b`) -- this is the size of an absorbed block and may be different from the size of the internal state that is kept by the function.
* `n` = size of the internal state that is kept by the function (8|`n`).
Either the block size is an integer multiple of the vector length or the vector length is an integer multiple of the block size.
* `k` = key size in bits (8|`k`) -- only if keyed, i.e., a MAC.

Data Structures:::

* *Initialization Input*:
[lowerroman]
 . `key`: `k/8` bytes -- Only if keyed, i.e., a MAC.

* *Internal State*:
 ** `key`: `k/8` bytes -- Only if keyed, i.e., a MAC.
 ** `hash_state`: algorithm specific length.
 ** `last_block_len` -- Only if this Hash/MAC has special internal treatment for a fractional last block that goes beyond padding and appending the length, which are handled by user software  (field size at most two bytes).
 ** `used_VLEN` -- Current vector length in bits (up to MAXVLEN).
 ** `partial_len` -- Length of absorbed data so far for the current block (field size at most two bytes).
 ** `partial_block`: `b/8` bytes (a priori we cannot know whether `b > VLEN` or not, and changing the internal memory requirements of a CC depending on the `VLEN` can lead to memory exhaustion).

* *Serialized Content*:
[lowerroman]
 . `key`: `k/8` bytes -- Only if keyed, i.e., a MAC.
 . `hash_state`: `n/8` bytes.
 . padding: 2 bytes.
 . `used_VLEN`:  `2` bytes -- Current vector length in bits (up to MAXVLEN).
 . `last_block_len`: `2` bytes -- Only if this Hash/MAC has special internal treatment for a fractional last block that goes beyond padding and appending the length, which are handled by user software. Otherwise, this is zero.
 . `partial_len`: `2` bytes -- Length of absorbed data so far for the current block.
 . `partial_block`: `b/8` bytes -- We include it only if there is a partial block, and exclude it when not.
 We reuse the most significant bit of the `state` field to store this information.
 (In theory, we could include only the part filled so far, but this would complicate the parsing of a SCC.)

Algorithm-Specific Functions:::

* `process_block(p)`: process block `p` into the hash or MAC.

State Machine:::

* *States:* _initial_ (0), _hash_absorb_ (1 or 9), _hash_last_block_ (5 or 13), _hash_finalize_, and _completed_ (15).
The values 9 and 13 are used when there is a partial block.
* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_.
 **  If the algorithm has a special treatment for the last block, either if it is partial or always, then
  *** _hash_absorb_ ->  _hash_last_block ->  _hash_finalize_ -> _completed_.
  *** else _hash_absorb_ ->  _hash_finalize_ -> _completed_.
 ** From any state to state _initial_.

* *Behavior:*
 ** In state _initial_:
  *** `last_block_len`, `partial_len` and `partial_block` are set to zero.
  *** `hash`: the initial value is set as specified by the algorithm.
  *** `used_VLEN` is set to the current vector length.
  *** Any `ace.exec` will result in the CR being *invalidated*.

  ** In each state except _initial_, before performing any operation except `ace.import`, `ace.export`, and `ace.clone`, `used_VLEN` is compared to `VLEN`.
  If there is a mismatch, the CR will be *invalidated* and any operation will result in an invalid instruction exception.

  ** In state _hash_absorb_, we can only issue ``ace.exec`` instructions of Form B, i.e., "```ace.exec Kn|K[Xn],Vs```", to absorb the data block `Vs` into the hash:
  *** If `VLEN` is a multiple of `b` (including the case where `VLEN` = `b`), then `process_block` is applied to each `b`-bit segment of `Vs`.
  *** If `b` is a multiple of `VLEN` and `b` > `VLEN`, then
   . `Vs` is written to `partial_block` starting at byte offset `partial_len`.
   . `partial_len <- partial_len + VLEN`.
   . if `partial_len = b`, then
   .. `process_block` is applied to `partial_block`,
   .. `partial_len <- 0` and `partial_block` is cleared.

 ** Upon issuing `ace.state Kn|K[Xn],#ace_last_block, Xs` where `Xs` contains the length of the last block in bits, the following happens:
+
--
 . if `partial_len` <> 0, then the CR is *invalidated*. (The previous block is not complete.)
 . if `Xs > b`, then the CR is *invalidated*.
 . if `Xs = 0`, then the CR is *invalidated*.
 . `last_block_len <- Xs`.
--
+

 ** In state _hash_last_block_:
  *** if `last_block_len` = 0, then the CR is *invalidated*.
  *** If `VLEN` is a multiple of `b` (including the case where `VLEN` = `b`), then
      we only issue a single ``ace.exec`` instruction of Form B, i.e., "```ace.exec Kn|K[Xn],Vs```", to absorb the least significant `b` bits of data block `Vs`.
  *** If `b` is a multiple of `VLEN` and `b` > `VLEN`, then we can issue one or more ``ace.exec`` instructions of Form B, i.e., "```ace.exec Kn|K[Xn],Vs```", to absorb the data block `Vs` into the hash, i.e. "```ace.exec Kn|K[Xn],Vs```":
   . if `partial_len < b`, then
   .. The instruction must be of Form B, else the CR is *invalidated*.
   .. `Vs` is written to `partial_block` starting at byte offset `partial_len`.
   .. `partial_len <- partial_len + VLEN`.
   . else if `partial_len+VLEN = b`, then the CR is *invalidated*.

  ** In state _hash_finalize_:
   *** If the function is a XOF, then
       we can issue an arbitrarily large number of ``ace.exec`` of Form C instructions, i.e., "```ace.exec Vd,Kn|K[Xn]```", to output the hash.
       This can be done with any of the two mechanisms below, except that the state never transitions to _completed_.
   *** If `VLEN` is a multiple of `b` (including the case where `VLEN` = `b`), then
      we only issue a single ``ace.exec`` of Form C, i.e., "```ace.exec Vd,Kn|K[Xn]```", to output the hash.
      The value is, if necessary, finalized, before being output.
      The state is then changed to _completed_ with no errors (unless the algorithm is a XOF).
   *** If `b` is a multiple of `VLEN` and `b` > `VLEN`, then we can issue one or more ``ace.exec`` instructions of Form C, i.e., "```ace.exec Vd,Kn|K[Xn]```", to output the hash:
    . Upon entering state _hash_finalize_, `last_block_len` is reused to store the length of the output hash (in any case `b` if the algorithm is a XOF).
    . After each "```ace.exec Vd,Kn|K[Xn]```":
     .. We write a new block of the final value of the hash function to `Vd`, with the caveat that if `last_block_len` is non-zero, but strictly smaller than `VLEN`, the value in `Vd` is accordingly truncated and zero-padded.
     .. `last_block_len <- max(last_block_len - VLEN, 0)`
     .. if `last_block_len` = 0 then the state is changed to _completed_ with no errors, unless the algorithm is a XOF, in which case the internal state is updated again, `last_block_len <- b`, and more "```ace.exec Vd,Kn|K[Xn]```" instructions can be issued.

 ** In any state, issuing any Form of ``ace.exec`` that is not the allowed one will produce a null output and the CR will be *invalidated*.

NOTE: The description of states _hash_absorb_ and _hash_finalize_ should make it clear that allowing `b` and `VLEN` to be in relations other than one being an integer multiple of the other, as well as allowing a change of `VLEN`, would significantly complicate the state machine.

[[ACE-Ascon]]
==== Ascon Specific Rules

We now describe the state machines of the various Ascon-based algorithms standardized in [.darkred]#TBD#.
(((ACE, algorithm, Ascon)))

===== Ascon-128 and Ascon-128a authenticated ciphers

[.darkred]#TBD#

===== Ascon-Hash cryptographic hash

[.darkred]#TBD#

===== Ascon-Xof extendable-output function

[.darkred]#TBD#

===== Ascon-80pq cipher with the increased 160-bit key

[.darkred]#TBD#

// //////////////////////////////////////////////////////////////////////////////////////////

[[ACE-examples]]

=== Examples

==== Context Switching

[.darkred]#TBD.#

==== VM Migration

Users may migrate their virtual machines (VMs) between client devices with CPUs from different silicon providers—a practice already common when moving interrupted VMs between Intel and AMD systems.
In such a scenario, the ACE implementation on the destination device might have a Crypto Register File (CRF) with a smaller capacity (not necessarily a smaller internal memory, as the internal representation may be more redundant).
System software could then be unable to restore all cryptographic contexts.

To address this, the `aceccstatus` CSR can be used to enable lazy context reloading by causing the hart to trap to the parent mode if a CR being accessed is marked as "lazy".  When this requires freeing one or more CRs first, system software decides which contexts to evict.

==== Key Management and Provisioning Applications

Software environments that implement key management operations for other domains require their own RCSK. A system may contain multiple such software environments.

A Key Management Applet (KMA) will

[arabic]
. Generate or retrieve a key matching a request.
. Configure a CR with this key and its associated metadata.
. Export this CR to a SCC in memory.
. Relinquish control to the MM.

The MM, which controls the CSK, can then

[arabic, start=5]
. Set the RCSK to the KMA’s RCSK.
. Re-import the SCC into a CR
. Change the RCSK to match the Requester domain's RCSK.
. Export the key for the Requester's use.
. Relinquish control to the Requester.

This is the most generic approach and allows each piece of software to use a CR of choice to generate CCs and import SCCs.
Furthermore, it protects the key from other SW environments that may be crossed while transferring control between the Requester process, the MM, and the Key Management application.

// Various optimizations are possible, which can be interesting for embedded environments: Steps 3., 5., and 6. can be omitted if the CR used for these operations is fixed and no intermediate SW environments modify that CR.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-V-dependency]]
=== Dependency on the V Extension

While ACE can be implemented with the V extension as a requirement, we note that ACE actually depends on a minimal subset of the RISC-V Vector Extension (RVV), which we call RVV-mini, for correct operation.
Required features include:
(((RVV-mini)))

* Support for vector registers sufficiently wide to host the block-wise operations required by the algorithms supported by ACE;
* The `vsetvli` instruction with restricted parameters (e.g., "```vsetvli zero,4,e32,m1,ta,ma```" for 128-bit-side operations); unsupported configurations must generate defined errors;
* Unit-strided vector loads and stores exclusively; and
* Vector bitwise logical operations such as `vxor`, `vand`, and `vor`.

Moreover,

* floating-point, fixed-point, and most arithmetic vector operations are not required, and
* more complex operations for some corner-case cryptographic algorithms may be performed in GPRs, with results then inserted in vector registers via `vins`/`vext`.

RVV-mini must maintain full opcode compatibility with RVV to guarantee that ACE code runs unmodified on full RVV implementations.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-RCSK-vs-ID]]
=== Programmable RCSKs vs. ID-based Usage Control

This section is informative and non-normative.

ACE provides two architected layers of usage control:

. At the User and Supervisor levels, CC usage can be optionally constrained by ASID and VMID.
This is a lightweight mechanism.
Because filtering by ASID is inactive when the hart is in S mode or higher, context switching can be performed without modifying the RCSK.
. At higher privilege levels, not only the usage, but even the import of CCs can be restricted by a programmable RCSK.
This offers stronger security by also preventing unauthorized `ace.import` operations, but incurs higher overhead as it typically requires an `ecall`.

The envisioned usage model employs ASID/VMID filtering at the User level, and also at the Supervisor level in high-performance systems where migration is not required (e.g., automotive applications). Cryptographic domain separation via the RCSK is intended for Virtual Machines, Supervisor Domains, Worlds, and TEEs within those contexts, as these demand stronger security guarantees.

NOTE: Although the architecture does not prevent assigning unique RCSKs to U-mode processes, doing so would impose a substantial burden on system software due to per-context-switch `ecall` overhead.
Hardware support—such as automatic RCSK switching based on ASID/VMID, could alleviate this burden.
However, such a mechanism is not currently under consideration due to its architectural complexity, inflexibility, and hardware cost.
For example, it would necessitate secure management of large RCSK tables, including saving, restoring, and potentially migrating entire RCSK blocks.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-threat-model]]
=== Threat Model

The ACE threat model is straightforward.

**Assets** consist of _keys_ and any other information that could aid an adversary in recovering plaintext or forging ciphertext. This includes items such as masks in tweakable XEX modes and derived keys in AES-GCM-SIV. The critical properties of these assets are their _confidentiality_ and _integrity_.

**Adversaries** are assumed capable of compromising processes by exploiting software vulnerabilities.
They are also able to gain access to memory contents, for instance, by abusing hardware interfaces or by SoC/memory interposition.
The model does not include adversaries capable of sophisticated hardware attacks, such as using
a Focused Ion Beam/Scanning Electron Microscope (FIB/SEM) to tamper with the hardware's functionality.

Side channel attacks are addressed optionally. ACE offers interfaces to both SCA-unprotected and SCA-protected implementations of cryptographic algorithms, if these options are provided by the designer.

Threats can be addressed in four ways:

[horizontal]
**C:**:: _Control_ the threat by implementing full or partial mitigations.
**A:**:: _Accept_ the threat and its associated risks.
**T:**:: _Transfer_ the threat to another party better suited to address it.
**S:**:: _Suppress_ the features that give rise to the threat.

ACE is designed to avoid the "***A***" and "***S***" options (as much as possible). It _controls_ threats through its own mechanisms and _transfers_ residual risk—specifically, the risk of key extraction from the privileged or trusted software and hardware environments that manage keys—to those same environments. For example, trusted software environments may employ control-flow integrity, memory encryption with integrity protection, and anti-replay mechanisms, while hardware key-management blocks can be hardened to protect entrusted keys.

Direct plaintext leakage, memory corruption attacks against the ACE-using process, and Release of Unverified Plaintext (RUP) attacks on the cryptographic algorithms are considered out of scope. These threats cannot be mitigated by ACE because the processed information resides within the user execution context. Consequently, these threats are _accepted_.

// ///////////////////////////////////////////////////////////////////////////////////////////

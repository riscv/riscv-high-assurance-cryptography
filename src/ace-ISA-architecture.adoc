[[ACE-architecture]]
== Architecture

[[ACE-concepts]]
=== Fundamental Concepts

Cryptographic Context:::
(((Cryptographic Context)))
(((Cryptographic context, content)))
(((Cryptographic context, metadata)))
The fundamental concept of ACE is the _Cryptographic Context_ (CC), a data structure comprising a *metadata section* and a *content section* that are bound together.
The metadata defines the cryptographic algorithm and optional usage policies; the content holds sensitive material such as keys, secrets, and internal algorithm state.
While the metadata does not require confidentiality, the content must remain confidential. Both sections require integrity.
These requirements are enforced by enforcing that all access and modification of a CC follow the rules defined by the ACE architecture and the algorithm configured in the CC's metadata.

Cryptographic Register:::
(((Cryptographic Register)))
The primary mechanism for realizing cryptographic contexts is the _Cryptographic Register_ (CR).
CRs are architectural-i.e., per-hart-containers that safeguard sensitive information.
A CR is _configured_ by writing the metadata and clear content (e.g., key material) into it.
This operation also binds the content to the metadata, creating a cryptographic context.
A CC can only be used in cryptographic operations while resident in a CR.
Only the ACE unit may access or modify a CC within a CR, according to the rules imposed by the ACE architecture and the configured algorithm.
Crucially, the content cannot be extracted in a manner that would compromise its confidentiality.

Sealed Cryptographic Context:::
(((Cryptographic context, sealed)))
Since a piece of software that uses a CR may be preempted, CRs need to be reconfigured at context switch.
In order to allow efficient reconfiguration of CRs, and protect CCs also outside the architectural state,
a CC can be exported from a CR as a _Sealed Cryptographic Context_ (SCC), i.e., an encrypted and authenticated package.
A SCC can be reimported into a CR when needed.
These operations use _Context Sealing Keys_ (CSKs), which may be programmed by MM and depend on _Localities_ (see below).
A context sealed with a CKS cannot be reimported into a CR using a different CSK.
This allows for flexible separation of keys by spatial and temporal domains.

Object-Orientation:::
CCs are _objects_ that may expose a uniform interface despite being instances of different algorithms.  A CC encapsulates its own behavior, allowing, for instance, AES-128, AES-256, Калина-128, Калина-256, and SM4 instances in ECB mode to be used interchangeably without code changes.  Similarly, modes such as GCM-SIV or XEX/XTS, that can be instantiated with any of these algorithms would also offer the same binary interface, as long as the code supports variable SCC sizes, which can be dynamically discovered. Side-channel-resistant variants would also be supported transparently.

NOTE: An example of the flexibility of our approach is the ability to use the same binary interface for different algorithms and modes.
Consider a content distribution network that intends to use different ciphers for different markets.
The payloads would always be encrypted using GCM.
However, in the US and Europe the underlying block cipher would be the AES, in China SM4, in Russia Кузнечик and so on.
The CC would encapsulate the cipher and the same compiled binary would support all these GCM variants, cf.{nbsp}<<ACE-GCM-mode>>.

Usage Control Policy:::
(((Cryptographic context, Usage Control)))
An important distinction in ACE is between the _import_ and _export_ operations on CRs on one hand, and the _use_ of CCs therein in cryptographic operations on the other hand.
It must be always possible to export SCCs and reimport them into CRs, as well as clear and reinitialize CRs with new data:
If this were not possible, then a process may be able to deny all other processes access to ACE by simply configuring all the CRs.
Therefore, the optional _Usage Control policies_ in the metadata section may only be able to restrict the cryptographic operations that are allowed by the algorithms configured by a CC, including modifying its state, but not the operations that manage CRs and SCCs. [.darkred]#TBD: Add to each instruction whether it may be usage-controlled or not.#

NOTE: The distinction between CR/SCC management instructions and "use-of-CC-for-cryptography" operations is the reason we speak of _Usage Control_ in place of the term _Access Control_.

Locality:::
(((Cryptographic context, Locality)))
In addition to Usage Control policies,
ACE can bind CCs to a _Locality_, restricting their usage to a specific device, device class, software or hardware configuration, or boot cycle.
This binding uses both metadata and a _Derived CSK_ (DCSK) derived from the RCSK and a Locality-specific secret via a key derivation function for the purpose of importing and exporting opaque keys.
The system maintains a _Locality Secrets Table_ (LST) containing both system-wide values which are fixed, values that can be configured in an externally defined way, and fields that can be programmed by MM.
The metadata stores the Locality as an index into this table. See <<ACE-Localities>> for more details.

NOTE: The term "Locality" is borrowed from TPMs.
In TPMs, localities are 8-bit values used to restrict object usage by binding it to the source of a command (e.g., application, operating system, or driver layer).
However, these values are provided by the sources themselves or by the driver, and a single locality can be shared by all "Trusted OSes" (usually with a locality value of 4).
The ACE mechanism allows for more fine-grained control over key usage: The MM firmware can reprogram the corresponding Locality Secret to a unique value for each Trusted OS, for instance by reprogramming the "OSSecret" field in <<ACE-locality-indexes>>.

// ///////////////////////////////////////////////////////////////////////////////////////////

=== ACE Programmer's Model

The Atomic Cryptography Extension requires a subset of the V extension to be implemented, including the
vector register file (see <<ACE-V-dependency>>).
[.darkred]#Discussions are still ongoing on what subset will be required, and
if a dependency on just the GPRs can be provided in addition.#

[[ACE-instructions-overview]]
==== Instructions Overview

ACE provides a number of unprivileged instructions.
Some are implemented as CSR reads or writes.
The non-standard notation `L[Xd]`, for a GPR Xd refers to the CR whose number is contained in `Xd`,
and `Ln|L[Xn]` means that there are two different encodings for when the operand is `Ln` or `L[Xn]`.

.The ACE instructions
[width="100%",cols="17%,25%,58%",options="header",subs="+macros"]
|===
| Instruction     | Operands                         |  Description
| `ace.enable` +
`ace.disable`     |                                  |  Enables/Disables the feature in the current mode.
| `ace.reset`     |                                  |  Resets the feature in the current mode.
| `ace.init`      | `Ld\|L[Xd],%offset(Xs)`          |  Sets a CRs's metadata and content.
| `ace.clear`     | `Ld\|L[Xd]`                      |  Clears a CR and marks it as no longer in use and clean.
| `ace.export`    | `%offset(Xn),Ls\|L[Xs]`          |  Securely exports the content of a CR to memory.
| `ace.import{.S}` | `Ld\|L[Xd],%offset(Xn)`         |  Authenticates and imports a SCC from memory into a CR. +
 `ace.import.S` optionally supports system defined formats.
| `ace.exec`
| A. {nbsp}{nbsp} `Vd,Ln\|L[Xn],Vs` +
  B. {nbsp}{nbsp} `Ln\|L[Xn],Vs` +
  C. {nbsp}{nbsp} `Vd,Ln\|L[Xn]` +
  D. {nbsp}{nbsp} `Ln\|L[Xn]`
| Performs a cryptographic operation. The instruction may also modify the internal state of the CC in the CR. This instruction admits four _forms_, depending on whether it accepts an input or not, and whether it produces an output or not.
| `ace.size`
| `Xd,Ls\|L[Xs]` +
`Xd,Xs` .2+|  `ace.size` returns the size in bytes of a SCC that would be exported from Register `Ls` or `L[Xs]`, or from a CR that had `Xs` as its metadata block. +
Returns zero if the algorithm specified in `Xs` is not supported. +
`ace.available` is an alias for `ace.size`.
| `ace.available` | `Xd,Xs`
| `ace.clone`     | `Ld\|L[Xd],Ls\|L[Xs]`            |  Clones a source Register into a destination Register.
| `ace.derive`    | `Ld\|L[Xd],Ls\|L[Xs]` +
`Ld\|L[Xd],Ls\|L[Xs],Vs2` +
|  Optional. Uses the CC in the source Register to configure the destination Register. +
For instance, the source Register could contain a KEM that configures the destination Register with a symmetric key.
| `ace.state` +
`(ace.dir)`
| `Ld\|L[Xd],#immed` +
`Ld\|L[Xd],#immed,Xs`  |  Modifies the algorithm's state, such as triggering transitions between the different phases of hash functions or modes of operation, or provide additional information.
`ace.dir` is an alias for `ace.state`.
| `ace.restrict` +
  `(ace.harden)`  | `Ld\|L[Xd],Xs`                   |  Narrows the Usage Policies of a CC and turns on or increases the side-channel protection of the algorithm in it, if the microarchitecture supports it.
  Removing or reducing these protections is not permitted.
   `ace.harden` is an alias for `ace.restrict`.
| `ace.input`     | `Ld\|L[Xd],%offset(Xs)`          |  Optional. Provides an input to the algorithm configured in Register `Ld` or `L[Xd]`, in place of providing it through the `ace.exec` instruction. Needed only when the inputs are very long, such as the inputs to certain public key schemes.
| `ace.output`    | `%offset(Xd),Ls\|L[Xs]`          |  Optional. Writes the output of an algorithm configured in Register `Ls` or `L[Xs]`, in place of providing it through the `ace.exec` instruction. Needed when the outputs are very long, such as the outputs of certain public key schemes.
| `ace.error`     | `Xd`                             |  Write the error code of the ACE unit into GPR `Xd`.
|===

// ///////////////////////////////////////////////////////////////////////////////////////////

==== Cryptographic Contexts

ACE does not add a traditional register file.
Rather, it defines 32 Cryptographic Registers for storing cryptographic keys and metadata.
Each CR is identified by a number from 0 to 31, which the ACE unit uses to access its contents.
(((Cryptographic Context)))

Registers reside in a dedicated internal _CR file_ (LF) that is inaccessible to any entity outside the ACE implementation, including software, other hardware blocks, and invasive debug interfaces. The LF's memory capacity is implementation-defined and may be as large as 32 times the size of the largest possible CC; however, a smaller amount of memory may be used in practice. At a minimum, the LF must be capable of holding either (i) a single instance of the largest possible CC, or the largest CC pair in which the first CC derives the second (via `ace.derive`), as well as (ii) a metadata block for each other possible context.
(((Register file)))
(((Register, file)))

The size of each CR is dynamic, determined by the cryptographic algorithm with which it is configured.
This is an important difference with respect to GPRs and vector registers, which always have the same size.
ACE returns an error _ace_err_memory_ when insufficient memory prevents `ace.init` and `ace.import` operations, requiring the software to free memory by exporting or clearing a different CR. Implementations must provide sufficient LF memory to prevent infinite `ace.export`/ `ace.import` loops.

A further difference between CRs and registers is that CRs are not only addressable via static 5-bit immediate addressing (as normal registers), but also indirectly, i.e., via a value from 0 to 31 in any general-purpose register.
This has two major implications:

. Adding renaming to CRs would add significant complexity to the microarchitecture.
  However CRs are much less often redefined than, say, integer or floating point registers, except for internal implied changes, and therefore we can assume that CRs are not renamed without performance issues.
. An additional bit in the instruction encoding determines whether a CR number is given by a 5-bit immediate or by the value in a GPR.

[[ACE-CSR]]
==== CSRs

ACE extends the `*status` and `misa` CSRs and adds 20 new CSRs to manage its execution environment, of which 16 are optional and exclusive to MM.
It also requires a subset of the V extension to be implemented, including some CSRs (see <<ACE-V-dependency>> for details).

.New ACE CSRs
[cols="<16%,^11%,<24%,<49%"]
[float="center",align="center",options="header"]
|===
| Address        | Privilege | Name                     | Description
| 0xXXX          | URW       | `aceerror`               | Error code of the last ACE instruction
| 0xXXX          | URO       | `aceccstatus`            | Array of two-bit fields, one per CR, giving a fine-grained ACES state per CR
| 0xXXX          | URW       | `acestart`               | ACE start byte index
| 0xXXX--0xXXX   | MRW (RZ)  | `macercsk{0..7}`         | ACE Root Context Sealing Key
| 0xXXX--0xXXX   | MRW (RZ)  | `maceOSSecret{0..3}`     | ACE OS Secret
| 0xXXX--0xXXX   | MRW (RZ)  | `maceBootSecret0{0..3}`  | ACE Boot Secret
|===

[[ACE-ACE-field-in-misa]]
===== ACE field in `misa`

The `misa.ACE` field uses bit `L` (11) to indicate that the ACE extension is implemented.
(((CSR, CE field in `misa`)))

[[ACE-ACES-field-in-status]]
===== ACES field in `*status`, `aceconfigured`, and `acedirty`

An ACE context status field, ACES,
(((CSR,ACES field in *status)))
is added to `mstatus`[26:25], and is shadowed in `sstatus`[26:25] and in `vsstatus`[26:25] if the hypervisor extension is present.
Similar to the FS and VS fields, it can be used to optimize context switching.
If the ACE is implemented, the ACES field shall not be read-only zero.
Its possible values are described in <<ACE-aces-encoding>>.

[[ACE-aces-encoding]]
.Encoding of ACES status field
[float="center",align="center",width="100%",cols="^8%,<8%,<84%",options="header"]
|===
|Status |Name |Meaning
|   0   | Off                | ACE is not enabled.  Software must not assume that the contexts are cleared and the may be configured from other environments. They are however, not accessible.  The hart will trap if User asks to enable the feature.
|   1   | Initial            | ACE is enabled. The state shall be that no CR is configured. +
The ACE unit will erase all contexts if ACE is enabled by writing to the `aceenable` CSR.
|   2   | Clean              | ACE is enabled. The state matches the last value stored on a context swap (i.e., since the last time the value "Clean" was written to the ACES field).
|   3   | Dirty              | ACE is enabled. there may have been changes to some CR since the last time the value "Clean" was written.
|===

Writes to ACES do not affect the contents of the CRs:
Setting ACES <- Off does not destroy the state, nor does setting ACES <- Initial or Clean clear the CRs.

If the ACE unit contains state from a different process, and the ISE is disabled for the current one,
then supervisor mode is supposed to have set the state to Off.
Enabling ACE in a process will trap to the Supervisor to allow the latter to first save the state in case it was not saved before and then clear it.

//

[[fsxsstates-copy]]
.ACES state transitions in the no-lazy-loading mode
[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
|Current State +
Action |Off |Initial |Clean |Dirty
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|At context save in privileged code

|Save state? +
Next state
|No +
Off
|No +
Initial
|No +
Clean
|Yes +
Clean
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|At context restore in privileged code

|Restore state? +
Next state
|No +
Off
|Yes, to initial +
Initial
|Yes, from memory +
Clean
|N/A +
N/A
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|Execute instruction that possibly modifies state, including configuration

|Action? +
Next state
|Exception +
Off
|Execute +
Dirty
|Execute +
Dirty
|Execute +
Dirty
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|Execute instruction to `export` state

|Action? +
Next state
|Exception +
Off
|Execute +
Initial
|Execute +
Clean
|Execute +
Dirty
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|Execute instruction to unconfigure unit (`ace.reset`)

|Action? +
Next state
|Exception +
Off
|Execute +
Initial
|Execute +
Initial
|Execute +
Initial
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|Execute instruction to disable unit (`ace.disable`)

|Action? +
Next state
|Execute +
Off
|Execute +
Off
|Execute +
Off
|Execute +
Off
|===

[width=83,align=center,float=center,cols="<,<,<,<,<"]
|===
5+^|Execute instruction to enable unit (`ace.enable`)

|Action? +
Next state
|Execute +
Initial
|Execute +
Initial
|Execute +
Initial
|Execute +
Initial
|===

A further CSRs: `aceccstatus` is used to track the configuration and dirtiness of CRs in a more fine-grained manner:


. For RV64, `aceccstatus` has a size of 64 bits,
``aceconfigured[``2__i__+1,2__i__``]`` takes the same values as Off, Init, Clean, Dirty as defined for `*status.ACES` for CR #__i__.
. For RV32, there are two 32-bit registers `aceccstatush` and `aceccstatusl` (collectively referred to as `aceccstatus`)
where
``aceconfiguredl[``2__i__+1,2__i__``]`` takes the same values as Off, Init, Clean, Dirty as defined for `*status.ACES` for CR #__i__
and
``aceconfiguredh[``2__i__+1,2__i__``]`` for CR #__i__+16.

Using this CSR, privileged context switching code needs to save only the dirty CRs and restore only the configured ones.

We assume that the privileged code keeps track:

* for each process, and
** for each CR, whether it is:
 . unconfigured and
  .. there is no saved value for the current process; or
  .. there is a saved value for the current process -- or
 . configured and it contains a CC for the process, where
  .. the content is clean, or
  .. the content is dirty.

//
We now proceed to list the possible states a CR may have in the case we where we implement lazy loading.

*INITIAL* (`0b01`)::
*Description:* _The CR is unconfigured; there is no saved value for the current process._ +
** At context save in privileged code: Nothing to save.
** *Usage* gives error _ace_err_unconfigured_, does not trap.
** *Configuration* does not trap, works as expected-including errors with *export* or *clone* - and sets the status to *DIRTY*.

*OFF*  (`0b00`, also called *LAZY*)::
*Description:* _This is different from the global *OFF* state for the entire unit. It is used to denote that
the CR is unconfigured, but the privileged switching code has saved a value to be lazy-loaded for the current process._ +
** At context save in privileged code: Nothing to save.
** *Usage* or *export* cause a trap to allow the OS to lazy load a CC's value in the CR for the current process first.
    The instruction is restarted unrestricted and operates from the status *CLEAN*.
    The instruction may cause the CR to become *DIRTY*.
** *Configuration* of the CR works as expected, and sets the CR's status to *DIRTY*.

*CLEAN* (`0b10`)::
*Description:* _The CR is configured for the current process and loaded. Unchanged since last switch._ +
** At context save in privileged code: Nothing to save, since the CR is already clean and the saved state also marks it as clean.
** *Usage* is unrestricted; if the CC in the CR is potentially modified, `dirty <- 1` `{implies}` *DIRTY*.
** *Configuration* works as expected, and sets the CR's status to *DIRTY*.

*DIRTY* (`0b11`)::
*Description:* _The CR is configured for the current process and loaded. Potentially changed since last switch._ +
** At context save in privileged code: Nothing to save, the CR's state in the saved state must be marked as dirty.
*** The privileged code may also save the locked in the state, and mark this entry as clean.
** *Usage* is unrestricted.
** *Configuration*: Works as expected, and leaves the status unchanged.

// Now let us have a look at what can happen when privileged code restores a process's state.
// For a given CR, the privileged code may encounter seven distinct scenarios.
// The following list details each scenario and specifies the minimal action required by privileged code to implement fully lazy management.
//
// . The CR is unconfigured, and
//  .. no CC for that CR is in the saved state of the process.
//    * Nothing to do. Set state to *VOID*.
//  .. a CC for that CR is in the saved state of the process.
//    * Nothing to do. Set state to *LAZY*.
// . The CR is already configured
//  .. with a CC for the process.
//    * Nothing to do. Set state to *CLEAN* or *DIRTY* depending on the saved dirtiness state.
//  .. with a CC for a different process, and:
//   ... no CC for that CR is in the saved state of the process.
//     * Nothing to do. Set state to *ALIEN*.
//   ... a CC for that CR is in the saved state of the process.
//     * Nothing to do. Set state to *ALIEN_LAZY*.

// [[ACE-tracking-alien-hybrid]]
// ===== Support for Hybrid Laziness Tracking

[NOTE]
====
In practice, privileged code may combine both approaches. For example, lazy-loading could be employed only after migrating a virtual machine to a system with a smaller CR file, while otherwise following the simpler model. Over time, processes will adapt to the new hardware by offloading and reloading contexts as needed by following the recommendation to always check whether any configuration or import operation succeeds and manually managing the offloading.
The operating system designer ultimately selects the strategy best suited to their use cases.
The hardware provides sufficient information to enable adaptive, performance-optimized behavior.
====

// NOTE: The fine-grained tracking could be extended to all higher-privilege modes.
// The S/VS modes can trust the state reported by U-mode, as U cannot write to the relevant CSRs.
// However, M-mode and HS-mode cannot rely on the values reported by S/VS, because those modes can write to these privileged registers.
// Consequently, when M-mode (or HS-mode) context-switches an S-mode (or VS-mode) domain, it cannot perform a fine-grained determination of which CRs have been modified, it must rely only on the `*status.ACES` registers and must therefore save and restore all CRs.
// Adding further registers, such as S and VS versions of `aceccstatus` to track per-level modifications is possible and it would be beneficial for performance optimization.

[[ACE-CSR-ace-error]]
===== `aceerror`

The `aceerror` CSR is an 8-bit CSR that indicates the error condition on the last ACE instruction.
This implies that any read from the `aceerror` CSR may cause a hart to wait until the last operation in the ACE unit which has been issued by the same hart completes.
(((CSR,aceerror)))

It can be freely read and written, in particular by context switching software to make sure that the error status is properly handled when a process resumes execution.

In <<ACE-error-codes>> below, we define the mandatory error codes.
The range [0..127] of the error codes is reserved for RVI.
Error codes specific to custom algorithms may be freely defined in the range [128..255], and are allowed to overlap between algorithms.

[[ACE-error-codes]]
.Error codes and their meanings
[float="center",align="center",width="100%",cols="^6%,<24%,<70%",options="header"]
|===
|Value | Mnemonic                | Examples (((ACE, error codes)))
|  0   | ace_err_ok              | No error.
|  1   | ace_err_authentication  | Authentication failure in `ace.import`, but can also follow `ace.exec` with certain algorithms.
|  2   | ace_err_privilege       | `ace.exec`, `ace.state`, `ace.clone`, `ace.derive` failed because the access control policies in the metadata of the CC prevent usage in the current architectural state.
|  3   | ace_err_invalid         | Invalid input or operation. +
Examples:
the metadata section passed to `ace.init` is invalid;
encryption, resp., decryption is requested from a CC only configured for decryption, resp., encryption, and more generally
the current state of the CC does not expect the used Form of `ace.exec`;
the requested change of state in `ace.state` is not permitted;
the change in usage policies in `ace.restrict` is not permitted because it would either downgrade or overwrite the current restrictions in the CC in the CR;
software tried to use an incomplete CC in a CR as a source in a `ace.exec`, `ace.state`, `ace.input`, `ace.output`, `ace.clone`, `ace.derive`, `ace.harden`, `ace.restrict` operations.
|  4   | ace_err_unimplemented   | The requested algorithm is not implemented. May be triggered also on algorithm variants, for instance if `ace.harden` is issued on an algorithm for which a non-side channel protected version is not implemented.
|  5   | ace_err_memory          | The free internal LF memory is not sufficient to perform the `ace.init`, `ace.exec`, `ace.clone`, or `ace.derive`.
The implementation must make sure this cannot happen with any other operation.
If algorithms that support `ace.derive` are implemented, the implementation must make sure that both the input and output CCs of this operation can be allocated in the LF.
|  6   | ace_err_unconfigured    | Software tried to use an unconfigured CR as a source in one of the following instructions: `ace.exec`, `ace.state`, `ace.input`, `ace.output`, `ace.clone`, `ace.derive`, or `ace.harden`/`ace.restrict`.. +
This can be used in low LF memory situations to trigger a lazy re-load.
|===


[[ACE-acestart-definition]]
===== `acestart`

`acestart` is an XLEN-bit CSR that serves a similar role in ACE as `vstart` does in the V extension.
(((CSR, acestart)))

The instructions `ace.init`, `ace.import`, `ace.export`, `ace.input`, and `ace.output` may require significant execution time and can be interrupted by exceptions or interrupts. To allow resumption rather than restarting, an implementation may set the `acestart` CSR to a non‑zero value. Unlike the vector extension’s `vstart`, which tracks element indices, ACE has no notion of an element; `acestart` therefore records a byte offset. For a load‑type instruction (e.g., `ace.init`, `ace.import`, `ace.input`), this offset indicates how many bytes of input have already been read and processed. For a store‑type instruction (e.g., `ace.export`, `ace.output`), it indicates how many bytes of output have already been computed and written.

The `acestart` value is given in bytes, even though payload sizes are always multiples of 8 bytes. This design accommodates piecewise execution via traps for the `ace.init`, `ace.clear`, `ace.export`, `ace.import`, `ace.input`, and `ace.output` operations, which involve `mv` operations at long-word, quad-word, or vector-register granularity, cf.{nbsp}<<ACE-trappable-insns-support>> for more details.
This is also compatible with the fact that `ace.size` returns a size in bytes.

Like `vstart`, `acestart` is a standard RW CSR.
Typically, hardware sets this register during a trap.
Software may safely write 0 to fully restart an operation, and the register can be saved and restored during context switches.
However, software must not write arbitrary nonzero values to it, as this may raise an illegal-instruction exception, as the hardware or a trapped implementation are not required to support all possible values.
Only the instructions explicitly mentioned above support non-zero `acestart` values; other ACE instructions ignore this register, and will be restarted.

[NOTE]
====
_A single `acestart` value suffices due to the authenticated encryption algorithm used in the `ace.import` and `ace.export` instructions.
Their operations behave as follows:_

* `_ace.init_` _is a single-pass operation: the metadata section is read first, determining the payload length.
If sufficient memory is available, subsequent blocks are read sequentially and passed to a deserialization circuit to populate the CR with the CC._
* `_ace.import_` _operates similarly to `ace.init`: the metadata section is read first to determine the payload length. If sufficient memory is available, the remaining blocks are read, decrypted, and passed to a deserialization circuit to populate the CR._
* `_ace.export_` _involves two passes, but the first pass is entirely internal to the ACE unit. Hence, the first pass cannot cause a page fault, and is easily restarted. Specifically, it computes the SIV by applying POLYVAL to the serialized content of the CC in the CR. Subsequently, the serialized metadata, the nonce, and the SIV are written out, followed by the content serialized, encrypted and written out block by block. It is this last part that may cause page faults, and that may require resumption._

Although these operations are inherently complex, the ACE unit is architected to function like a separate machine executing simpler instructions sequentially. State machines receive commands from the CPU and break them into smaller steps.
Therefore, separating data transfer from cryptographic operations in import/export is unnecessary. Otherwise, the input would need to be stored within the ACE unit and then processed rather than processed inline while loading it with minimal overhead-and this may lead to higher internal resource requirements.

While resuming interrupted `ace.import` and `ace.export` operations is not necessarily significantly faster than restarting, because of the many cryptographic operations that are needed on the inputs and outputs, resuming avoids potential circular page-fault issues, and for this reason we proved support for it.
====

The exact semantics of `acestart`, including the points at which operations can be interrupted, are defined in <<ACE-formats>>

===== Reuse of ASID and VMID (to be verified)

We reuse the CSRs for `ASID`, resp., `VMID`
(i.e., the CSR fields `satp`.ASID and `hgatp`.VMID).
to give only certain User processes and Supervisor processes access to certain key spaces.
The maximal bit length of `ASID` is 9 for Sv32 addresses or 16 for Sv39, Sv48, and Sv57 addresses.
The maximal bit length of `VMID` is 7 for Sv32x4 or 14 for Sv39x4, Sv48x4, and Sv57x4 addresses.
In the metadata section, `ASID` and `VMID` are always zero padded to the maximal lengths of 16 and 14 bits, respectively.

[.darkred]#However, we need a mechanism to make sure that if the system is not configured to insert `ASID`, resp., `VMID` into the GVAs/GPAs, we can still use them for the purpose of policing the usage of CCs.#

[[ACE-providing-keys,Remark {counter:remark}]]
*Remark {counter:remark}.* _The software in each World/Supervisor Domain is normally responsible to generate or obtain their own keys, and if a process (applet) in one World/Supervisor Domain is responsible to provide keys to other Worlds/Supervisor Domains, it is the responsibility of the MM to perform an appropriate sequence of import, switch the CSK, then export operations._

[[ACE-CSR-macercsk]]
===== `macercsk`

If the RCSK can be programmed, it can only be programmed by M-mode.
(((CSR, `macercsk`)))
For this purpose, we use eight 32-bit WARL CSRs in RV32 and four 64-bit WARL CSRs in RV64.
The CSRs are: `macercsk0`, `macercsk1`, `macercsk2`, and `macercsk3` in RV64, to which we add
`macercsk4`, `macercsk5`, `macercsk6`, and `macercsk7` in RV32.
Bits [(_i_+1) XLEN - 1 : _i_ XLEN] of the RCSK are written to `macercsk{i}`.

Attempting to access the `macercsk` block outside of MM will cause an illegal instruction exception.

NOTE: Discoverability of whether the RCWK can be configured or not is not critical, since this is information known by the MM firmware.
[.darkred]#We can use the data structure pointed by `mconfigptr` in order to track optional features of ACE including whether the `macercsk` CSR block is implemented, and if not whether whether the value is ephemeral or fixed.#

//User mode, and even operating systems and hypervisors, need not be aware of the `macercsk` block. Other mechanisms could have been chosen to program the CSK, such as an MM-exclusive dedicated hardware interface or memory-mapped interface.

NOTE: Mechanisms for persisting Root Context Sealing Keys (RCSKs) across reboots or transferring them between devices are outside the scope of the ACE architecture. Such mechanisms are system-specific and fall under the purview of MM firmware.
For cross-device migration, the use of a public-key key-encapsulation mechanism (KEM) is recommended.

===== Re-configurable Localities

Two groups of CSRs, only accessible and programmable by MM, are used for two reconfigurable Localities (cf.{nbsp}<<ACE-concepts>>).
These are:

* CSRs `maceOSSecret0` and `maceOSSecret1`, to configure the "OSSecret" entry in RV64, to which RV32 adds `maceOSSecret2` mand `maceOSSecret3`.
(((CSR, `maceOSSecret*`)))
* CSRs `maceBootSecret0` and `maceBootSecret1`, to configure the "BootSecret" entry in RV64, to which RV32 adds `maceBootSecret2` and `maceBootSecret3` (cf.{nbsp}<<ACE-Localities>>).
(((CSR, `maceBootSecret*`)))


Bits [(_i_+1) XLEN - 1 : _i_ XLEN] of the "OSSecret", resp., "BootSecret", are configured by writing to `maceOSSecret{i}`, resp. `maceBootSecret{i}`.

[NOTE]
====
The reason `maceBootSecret*` must be reconfigurable is that it must change in a VM if the latter's virtual hardware is re-booted, and this can happen independently from the underlying host and other VMs. For instance, a VM may be frozen, then the host may be rebooted, and then the VM may be resumed, in which case no boot session occurred in the VM, while it happened in the host hardware.
====

//User mode, and even operating systems and hypervisors, need not be aware of the `maceOSSecret{i}` and `maceBootSecret{i}` blocks. Other mechanisms could have //been chosen to program the "OS Secret" and  "Boot Session" entries, such as an MM-exclusive dedicated hardware interface or memory-mapped interface.

[[ACE-data-structures]]
==== Data Structures

ACE defines two distinct representations of cryptographic information: the configuration format, which is loaded into a CR to create a CC, and the encrypted, authenticated SCC format. These two  formats are architected for software portability and interoperability.
The internal CC representation in a CR, on the other hand, is implementation-specific.

All data formats are little-endian.

[[ACE-metadata]]
===== Metadata Section Format

The metadata section is 64 bits long and its format described in <<ACE-metadata-standard>>.
This format is used for CR initialization, and CC export and import purposes.
The internal representation is implementation specific.
(((Cryptographic Context,metadata,format)))

[[ACE-metadata-standard]]
.Format of the Metadata Section
[width="100%",cols="^9%,^7%,17%,67%",options="header"]
|===
|   Field | Width | Name                  | Description
|   [0:0] |   1  | Format                 | 0 for the current metadata format. +
Future format will have a 1 in this position and may be longer than 64 bits.
|   [1:1] |   1  | Reserved               | 0 for the current metadata format.
|   [9:2] |   8  | Algorithm              | Algorithm (such as primitive or mode). 0 means the CC is invalid.
| [11:10] |   2  | SC_Protection          | Level of Side Channel Protection, encoded as per <<ACE-SC-protection-levels>>.
| [13:12] |   2  | Direction_Policy       | Determines whether the CC may be used for encryption (bit 12 set), decryption (bit 13 set), or both (bits 12 and 13 set).
Valid only for encryption/decryption primitives or modes, and ignored, for instance, for hash functions.
| [15:14] |   2  | Key_Type               | By explicit value / Immutable (index) / Internally generated.
| [17:16] |   2  | Completion             | Defined in <<ACE-CR-complete>>.
Used to determine whether an operation must be restarted.
| [21:18] |   4  | State (also Direction) | Encoding the current state of the state machine of the algorithm as a number.
The value must be zero in the initialization data.
If the algorithm encoded in the CC has at most 16 states
(including _initial_, _completed_, and _invalidated_, cf. <<ACE-state-constants>>), then this number is stored in this field,
otherwise an algorithm-specific representation is used in the content, and this field only admits the values 0 (initial), 14 (invalidated), 15 (completed) or 1 (anything other operational state). The values must conform to <<ACE-state-constants>>.
| [25:22] |   4  | Locality               | Field which is either -1 or an index into the Locality Secrets Table.
| [29:26] |   4  | UC_Policy_1            | "UC Policy" means "Usage Control Policy". +
Disallow the _usage_ of this CC in User, (Virtual) Supervisor, Hypervisor, resp., MM if bit 26, 27, 28, resp. 29, is set..
| [31:30] |   2  | UC_Policy_2            | If bit 30, resp., 31, is set, then restrict the usage by `ASID`, resp., `VMID`. Restriction by `ASID` ignored if in S Mode or higher.
| [47:32] |  16  | UC_Policy_3            | Zero if bit 30 unset, else `ASID` to enforce.
| [63:48] |  16  | UC_Policy_4            | Zero if bit 31 unset, else `VMID` to enforce.
|===

Algorithms are encoded in a 8 bit field.
Algorithm numbers 0-191 are architecture-defined and the list of such encodings is maintained by RVI.
See <<ACE-algorithms>> for the currently encoded algorithms.
Algorithm numbers 192-255 are reserved for custom algorithms.

[[ACE-SC-protection-levels]]
.Encoding of Side-Channel Protection levels
[float="center",align="center",width="76%",cols="^8%,<68%",options="header"]
|===
| Value | Description
|   0   | No protection.
|   1   | Data independent timing, first-order threshold implementation.
|   2   | Data independent timing, first-order threshold, fault tolerant implementation.
|   3   | Custom, algorithm dependent.
|===

Custom algorithms may offer stronger side channel protection guarantees than those specified in the encoding values 0 to 2.
In such a case, the value of the SC_Protection field must be set to 3.

[[ACE-key-type]]
.Encoding of Key Type
[float="center",align="center",width="76%",cols="^8%,<68%",options="header"]
|===
| Value | Description
|   0   | Explicit value.
|   1   | Internal table. System specific. For each algorithm as specified in <<ACE-algorithms>>, the part of the content that normally contains the key(s) is replaced by a 64-bit value which is an index into the internal System Keys Table (SKT) --- for both Configuration Input and the SCCs. The actual value of the key is never included in exported content. For threshold algorithms, ACE may copy the key material from the SKT into the CR and expand it into multiple shares.
|   2   | Internally generated key. System specific.  In the Configuration Input, the part of the content that normally contains the key(s) is replaced by a "recipe" in a system-specific format. The format is not specified by the ISA and may not be portable to other systems. Once the key material has been internally generated, the value is included in the SCC as part of the content - not the "recipe" - as for any other key(s) for the same specified algorithm.  The Key_Type field of the metadata in all representations of the CC, will keep the value 2.
|   3   | Invalid.
|===

[[ACE-CR-complete]]
.Encoding of Completion field
[float="center",align="center",width="58%",cols="^8%,<50%",options="header"]
|===
| Value | Description
|   0   | No `ace.init`, `ace.input`, `ace.output`, `ace.import` or `ace.export` operation currently incomplete.
|   1   | `ace.init`, `ace.input`, or `ace.output` was interrupted.
|   2   | `ace.import` was interrupted.
|   3   | `ace.export` was interrupted.
|===

NOTE: The information in the Completion field is necessary to make sure that any cryptographic operation attempted on a CR containing an incomplete CC raises an error or is trapper.

// is in principle known to the system software/firmware stack, we duplicate it into the metadata to ensure that it remains accessible after nested interrupts, i.e., after switching partially configured/imported or exported CCs in or out. While authentication also guarantees the integrity of the SCCs and of their import, this is both a robustness measure and serves to simplify system stacks.[.darkred]#Do we really need it?#

NOTE: The "state" field accommodates modes of operation with a small number of states.
For algorithms with more complex state machines, machine state information can be stored in a custom data section of the CC.

If the H extension is not enabled, bit 28 must be set to 1, and bits 31 and [63:48] must be set to 0.
The "UC_Policy_4" field is 16 bits long for compatibility with architectures employing 16-bit `VMID` fields (for instance, in heterogeneous systems).
While interoperability cannot be guaranteed when this policy is used, this ensures that the two top bits are not used for other purposes. +
Filtering usage by Supervisor Domain or World ID is not supported, and not only because of lack of space in a 64-bit metadata section:
Reconfiguring the RCSK is a better approach for such isolation requirements, whereas isolation by `ASID` and `VMID` is a weaker security feature.

[[ACE-Localities]]
===== Localities

Internally, ACE keeps a table of 128-bit Locality Secrets (LS), the Locality Secrets Table (LST).
Some entries of the LST are fixed or configurable only using an implementation-specific authenticated hardware procedure, and these are
global and shared across all ACE units.
A few entries may be programmed by MM and are architectural, i.e., per hart.

If the Locality Field of a CC is -1 (all ones), then the RCSK is used.
Otherwise, this value is used as an index _i_ in the LST, and the actual CSK is derived from the RCSK and LST[_i_].
//The encryption and authentication keys are then derived from the DCSK.

In <<ACE-locality-indexes>>, we list the mandatory entries.
Column "MM-Config." indicates whether MM may be allowed to configure the entry.
We also specify the domain of each Locality Secret, i.e., whether the value is
chip-wide (should be the same across all chiplets in the same SoC, two distinct SoCs the same decide may have different values),
device-wide, or (usually) OS-wide.

[[ACE-locality-indexes]]
.Mandatory Locality Values
[width="100%",cols="23%,50%,^9%,^9%,^9%",options="header"]
|===
.>| Name .>| Description .>| Domain | MM-Config. .>| Value +
(Index)
| (No Locality binding)     | No CSK derivation. CC bound to Root CSK only. | -- | -- | -1 (15)
| ChipManufacturerSecret    | Identifies the manufacturer of the SoC. Permanent. | SoC | N | 0
| ChipModelSecret           | Identifies specific chip model/family. Permanent. | SoC | N | 1
| ChipUniqueSecret          | Unique for each SoC. Permanent. | SoC | N | 2
| OEMSecret                 | Provisioned by OEM to differentiate their products from the competition.
                              Can be permanent, or optionally reconfigurable by impdef HW authenticated mechanisms. | Device | N | 3
| ProductSecret             | Identifies device/system type/model (product). Not necessarily permanent. Reconfigurable like OEM_Secret. | Device | N | 4
| DeviceSecret              | Unique device (entire system) secret (not the device ID such as a serial number, but it can be derived from it, for instance by hashing). Shared across all harts in a SoC and shareable across multiple SoCs in a single device. Sharing mechanism impdef, i.e., not architected. Reconfigurable like OEM_Secret. | Device | N | 5
| OSSecret                  | Identifies Operating System (or System Stack).
                              Not permanent, must be configured during (virtual) boot. | OS | Allowed | 6
| BootSecret                | Regenerated at each (virtual) boot. | OS | Allowed | 7
| Reserved                  | Reserved for future use (RZ if not defined). | Impdef | Impdef | 8-14
|===

The constant Localities_MAX is the maximum number of Localities supported by the system.

NOTE: MM is responsible for virtualizing the OSSecret and BootSession_Secret Locality Secrets.

*Example*: _If a key's metadata specifies a Locality field value of 2, the key for import/export operations is derived from the RCSK and the OEM Secret. If we generate an SCC with `ace.export` on a first device, an `ace.import` of the resulting SCC on a second device will trigger an authentication failure if the OEM Secrets differ._

NOTE: _A CC may reference a key via an index into the system-defined System Key Table (SKT).
A device-specific SKT entry may correspond to a different key on another device, leading to unspecified behavior.
Implementations of the STK must provide a suitable Locality to the ACE unit during CC configuration,
and set usage policies that are at least as strict as the key's own._

[[ACE-formats]]
===== Formats of Configuration Inputs and Sealed Configuration Contexts

The formats of the configuration payload, of the content section, and of SCCs
depends on the algorithm being used.
Each algorithm must provide following functions:

* `metadata_serialize(CR) -> byte array`: Serializes the metadata in a CR into a 64-bit block.
* `metadata_deserialize(CC,byte array) -> CR.metadata`: Takes a metadata block formatted as described in <<ACE-metadata>> and deserializes it to the internal representation of the metadata section.
* `initial_content_deserialize(CC,byte array) -> CR.content`:
Reads the information provided to `ace.init` as the byte array that follows the metadata, and deserializes it for the internal representation.
It must be the same as the format used for the SCC except for some omitted fields.
* `content_serialize(CR) -> byte array`: Serializes the content of the CC in a CR to a byte array.
* `content_deserialize(CR,byte array) -> CC.content`:
Takes the decrypted byte array, that comes after the metadata, nonce and authentication tag, and deserializes it into a CR's content.
The format depends on the algorithm which is specified in metadata information.

The size of a SCC, and of all byte arrays read or written by the above five functions, must be a multiple of 8 bytes.
See <<ACE-algorithms>> for algorithm-specific details on the inputs and outputs of these functions.

Format of Configuration Input:::
(((Cryptographic context, configuration input)))
The format of the input to `ace.init` is simple.
The first 8 bytes must contain the 64-bit metadata section as specified in <<ACE-metadata>>,
followed by the content, i.e., the key(s) and possibly other information, to be passed to `initial_content_deserialize`.

Plaintext Format of SCC:::
(((Cryptographic context, SCC plaintext)))
`bytes 0..7  {nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}` contain the 64-bit metadata section, +
`bytes 8..19  {nbsp}{nbsp}{nbsp}{nbsp}{nbsp}` contain the nonce (96 bits), +
`bytes 20..31  {nbsp}{nbsp}{nbsp}{nbsp}` contain the tag (96 bits), and +
`bytes 32..u+31  {nbsp}{nbsp}` contain `content_serialize(CR.content)`, which has a byte length of `u`.
+
Only the serialization of the content is encrypted, while both metadata and content are included in the computation of the authentication tag, as described next.

//

We now define the RFC8452 Key Derivation and the DCSK Derivation functions.

.RFC8452 Key Derivation
[sail]
----
function RFC8452_KeyDeriv(K) = {
  struct { AESE256(K, (0[125:0] @ 0b101))[63:0] @ AESE256(K, (0[125:0] @ 0b100))[63:0] @
           AESE256(K, (0[125:0] @ 0b011))[63:0] @ AESE256(K, (0[125:0] @ 0b010))[63:0],
           AESE256(K, (0[125:0] @ 0b001))[63:0] @ AESE256(K, (0[125:0] @ 0b000))[63:0] }
}
----

.Derived Key Derivation
[sail]
----
function DCSK_KeyDeriv(K,L) = {
  AESE256(K, L ^ (0[125:0] @ 0b010))[127:0] @
  AESE256(K, L ^ (0[125:0] @ 0b000))[127:0]
}
----

We can now define the generation of the SCC from the CC in a CR.

.Generation of the SCC from a CC Using AES-GCM-SIV (RFC8452)
[sail]
----
metadata : bits(64);
last_block_fractional : boolean;
content : array[num_blocks] of bits(128); // last block is zero-padded
                                          // if last_block_fractional = true
M : array[num_blocks+2] of bits(128);
let N : bits(96) = random(96 bits);
Kenc : bits(256);
Kauth : bits(128);

if (metadata.Locality == 15) then {
    CSK = RCSK;
} else {
    CSK = DCSK_KeyDeriv(RCSK, LST[metadata.Locality]);
}

{Kenc, Kauth} = RFC8452_KeyDeriv(CSK);
let T : bits(96) = POLYVAL(Kauth, 128b'(metadata) @ content)[95:0];

// note: 128bits(metadata) = 64b'0 * metadata
let SIV : bits(96) = AESE(Kenc, 0 1b'0 @ ((T xor N)[126:0]))[127:32];

M[0][127:0] = N[63:0] @ metadata[63:0];
M[1][127:0] = SIV[95:0] @ N[95:64];
if (last_block_fractional) then last = num_blocks - 1 else last = num_blocks - 2;
foreach(i from 0 to last) {
    M[i + 2][127:0] = content[i] xor AESE(Kenc, 1 @ SIV[94:0] @ (binary(i)[31:0]));
}
if (last_block_fractional) then {
    M[last + 1][63:0] = content[last + 1]
                        xor AESE(Kenc, 1 @ SIV[94:0] @ (binary(last + 1)[31:0]))[63:0];
}
----

NOTE: Due to the computational cost of the derivation functions, implementations may
cache recently used derived keys for both the Root RCSK and Locality-derived keys.

===== Use of `acestart`

[.darkred]#*TBD* Specify the exact semantics of `acestart`, define the points at which operations can be interrupted:#

* Any number of bytes can be initialized or imported in a CR, and exported from it, before the operation is preempted, depending on the alignment of the data.
* `acestart` counts all the bytes of the payload, including the metadata for all inputs and outputs, and the nonce and the tag as well for SCCs.
* The internal state shall always assumes that all internal operations that would be performed in the algorithms above are performed as follows
 ** `ace.init`:
  *** Once the first 8 bytes are read, the metadata must be completely processed and imported in the CR.
  *** Whenever 8+16__i__ bytes have been read, also _i_ blocks of content must be processed and imported in the CR.
   For instance, if 28 bytes have been read in, the incomplete state has processed the metadata and the first content block, and knows 4 further bytes.
  *** If the operation is preempted, `acestart` will be the number of bytes read.
  *** The corresponding exported SCC will include an 8-byte block in clear after the metadata with the `acestart` value, followed by the nonce and the tag, and the content will only contain the payload imported and read so far, zero padded up to a multiple of 8 bytes. This content is of course encrypted.
  The AEAD algorith will use `64b'(length of payload) @ metadata` in place of `128b'(metadata)`.
  *** in the worst case, a SCC will be 8 bytes longer than the standard size for a complete exported CR for the same algorithm.

 ** `ace.export` [.red]#TBD#
 ** `ace.import` [.red]#TBD#

[.red]#TBD: define the SCC formats for incomplete CCs.#

[[ACE-RCSK-vs-ID]]
=== Programmable RCSKs vs. ID-based Usage Control

(This section is informative and non-normative.)

ACE provides two architected layers of usage control:

. At the User and Supervisor levels, CC usage can be optionally constrained by ASID and VMID.
This is a lightweight mechanism.
Because filtering by ASID is inactive when the hart is in S mode or higher, context switching can be performed without modifying the RCSK.
. At higher privilege levels, not only the usage, but even the import of CCs can be restricted by a programmable RCSK.
This offers stronger security by also preventing unauthorized `ace.import` operations, but incurs higher overhead as it typically requires an `ecall`.

The envisioned usage model employs ASID/VMID filtering at the U level, and potentially at the S level in high-performance systems where migration is not required (e.g., automotive applications). Cryptographic domain separation via the RCSK is intended for Virtual Machines, Supervisor Domains, Worlds, and TEEs within those contexts, as these demand stronger security guarantees.

Although the architecture does not preclude assigning unique RCSKs to individual U processes, doing so would impose a significant burden on the system software stack. Hardware support could mitigate this—for example, by automatically switching RCSKs based on ASID/VMID without per-context-switch `ecall` overhead. Such a solution is not currently being explored due to its architectural complexity and inflexibility, and HW cost-for instance, it would require secure management of very large RCSK tables, including the potential need to save, restore, or migrate of entire blocks of RCSKs.

[comment]
--
ACE has two architected layers of  Usage Control .

At the U and S levels, CCs usage can be constrained by ASID and VMID. This is a lightweight solution.
Since ASID filtering is not active while the hart is in S mode or higher, context switching can be performed without changing the RCSK.

At higher levels, even import of CCs can be constrained by a programmable RCSK.
This is a more secure solution, and prevents also `ace.import`, but it is also heavier, since it requires an `ecall`.

Indeed, we have envisioned a system where ASID/VMID filtering is used at the U level, and possibly at S as well in systems where migration is not supported but high performance is (such as automotive applications). The cryptographic domain separation by RCSK is for VMs, Supervisor Domains, Worlds, and also for TEEs in the previous contexts as well, since these require higher security guarantees.

While the architecture does not prevent individual RCSKs per U-mode process, this would add burden to the system stack.
This could be accelerated by hardware support, for instance, by providing a mechanism to change automatically RCSKs depending on the ASID/VMID without requiring an `ecall` per context switch. We are not exploring such a solution for now because it would be very difficult to architect and unflexible.
--

// ///////////////////////////////////////////////////////////////////////////////////////////

=== Supported Algorithms

[.darkred]#Add algorithm numbers!#

We architect support for several algorithms, and also define a minimal subset (current suggestion):

* AES-128 and AES-256 encryption and decryption.
* AES-CTR, AES-GCM, AES-GCM-SIV, AES-XTS using AES-128/256.
* AES-CMAC using AES-128/256.
* SHA-2, SHA-2-HMAC.

The list of other architected algorithms is TBD, but it must include at least

* AES-192, alone and with the above modes.
* SM4 Block Cipher.
* The Ascon suite (Ascon-128/128a-AEAD, Ascon-Hash, Ascon-XOF, Ascon-80pq).
* SHA-3, SHA-3-HMAC.
* SM3 Secure Hash.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-instructions-detailed]]
=== Instructions

We now give detailed descriptions of the instructions, including their semantics and encoding.

NOTE: Instructions `ace.init`, `ace.import`, `ace.export`, `ace.input`, and `ace.output` perform direct memory accesses.
This does not violate the RISC-V load/store architecture principles, as ACE is architected to behave like an _attached_ unit, which may have its own interfaces.

NOTE: The encodings presented here are just examples, and may not be final.
They serve as a starting point for discussion and refinement as
well as a proof that, at the time of this writing, the ACE instruction set
can be encoded.

NOTE: ACE is an ideal candidate for the Composable Custom Extensions framework,
even though our aim is to make it into a ratified extension.

In all cases where a GPR is used to index a CR, we exclude the use of the zero-hardwired GPR `X0` as the index register-that is, the encoding of the register cannot be zero. This is reserved to encode some special operation, and otherwise raises an invalid-instruction exception.

[[ACE-instruction-enable-enable]]
==== ace.enable/ace.disable/ace.reset

`ace.enable` +
`ace.disable` +
`ace.reset`
(((ACE, instruction, ace.enable)))
(((ACE, instruction, ace.disable)))
(((ACE, instruction, ace.reset)))

Encoding::
+
--
This is an I-type instruction.

[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 0x0, attr: ['invalid GPR'] },
    { bits:  3, name: 'ace.clear', attr: [0x7] },
    { bits:  5, name: 0x0 },
    { bits: 12, name: 'immed12' },
]}
....

NOTE: This instruction shares its encoding with `ace.clear` with `3b'111` as instruction code (use a GPR to select the CR).
However, the zero in the source field [11:7] for indirect CR indexing is defined as invalid/special, and this allows to define this instruction.#
--
+

Description::
+
--
Enable, disable, or reset the feature in the current process domain:

* If the `immed12` = 1, then the feature is enabled. The alias for this instruction is `ace.enable`.
* If the `immed12` = 0, then the feature is disabled. The alias for this instruction is `ace.disable`.
* If the `immed12` = `0xa11`, then all CRs are cleared and the new state of the ACE unit is Clear.
The alias for this instruction is `ace.reset`.

`ace.enable` must be issued before using any ACE operation, i.e. `ace.config` passing the immediate 1.

NOTE: The advantage of `ace.reset` with respect to a loop that clears all CRs is that the entire LF memory is cleared without the need for compaction/management between the separate `ace.clear` operations and this opertation cannot be interrupted, reducing potential wasteful context saves.

The instruction will trap in the following cases: [.red]#TBD#.
--
+



// [.darkred]#Proposal: With the immediate `0xa11` (all), all CRs will be cleared, as if `ace.clear` had been called on each of them, but the feature is not disabled.



See
//<<ACE-CSR-enable>> and
<<ACE-ACES-field-in-status>> for more details.

[[ACE-instruction-init]]
==== ace.init

`ace.init Ld|L[Xd],%offset(Xs)`
(((ACE, instruction, ace.init)))

Encoding::
`ace.init` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Ls','L[Xd]'] },
    { bits:  3, name: 'ace.init', attr: [0x4,0x5] },
    { bits:  5, name: 'Xs' },
    { bits: 12, name: 'imm', attr: ['offset'] },
]}
....

Description::
`ace.init` configures a CR with metadata and content.
`Ld` is the source CR to be configured (encoded as a 5-bit immed).
`Xd`, alternatively, is a GPR containing a number from 0 to 31 to select the context
to be configured.
`Xs` points to the region of memory containing the metadata and the key material.


NOTE: The operation can be conceptually split into two phases.
In the first phase, the metadata
block is read, which determines the length of the remaining information.
Then, in the second phase, the configuration material is read and processed.

// [.darkred]#(TBdetermined whether it is secure)# This instruction is trappable and may also be resumed or restarted.

[[ACE-instruction-clear]]
==== ace.clear

`ace.clear Ld|L[Xd]`
(((ACE, instruction, ace.clear)))

Encoding::
`ace.clear` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Ls','L[Xd]'] },
    { bits:  3, name: 'ace.clear', attr: [0x6,0x7] },
    { bits:  5, name: 0x0 },
    { bits: 12, name: 0x0 },
]}
....

Description::
`Ld` is the source CR to be cleared (encoded as a 5-bit immed). +
`Xd` alternatively, is a GPR containing a number from 0 to 31 to select the context to be cleared. +

[[ACE-instruction-export]]
==== ace.export

`ace.export %offset(Xd),Cs|L[Xs]`
(((ACE, instruction, ace.export)))

Encoding::
`ace.export` is an S-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'imm[4:0]' },
    { bits:  3, name: 'ace.export', attr: [0x0,0x1] },
    { bits:  5, name: 'Xd' },
    { bits:  5, name: 'context', attr: ['Ls','L[Xs]'] },
    { bits:  7, name: 'imm[11:5]' },
]}
....

Description::
Exports the Register `Ls` or `L[Xs]` to memory, starting at address `Xd`, using
the procedure described in <<ACE-formats>>.
If the context `Ls` is clear, or `Xs` is out of range,
the operation will report error ace_err_invalid.

The instruction must be resumable in case of interrupts.
Similarly to entire-vector-register store instructions, `ace.export` appears to other harts as
sequences of individual stores.

[[ACE-instruction-import]]
==== ace.import

`ace.import Ld|L[Xd],%offset(Xn)` +
`ace.import.S Ld|L[Xd],%offset(Xn)`
(((ACE, instruction, ace.import)))
(((ACE, instruction, ace.import.S)))

Encoding::
`ace.import` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Ld','L[Xd]'] },
    { bits:  3, name: 'ace.import', attr: ['0    0    S','0    1    S'] },
    { bits:  5, name: 'Xn' },
    { bits: 12, name: 'imm' },
]}
....

Description::
`Ld` is the destination CR into which the SCC is imported, as an immed (5-bit).
Alternatively, the number of the CR into which import the SCC is stored in
the GPR `Xd` as a number from 0 to 31. `Xn` is the GPR containing the base address
of the buffer with the source SCC. +
The bit S takes the values 0 (false) or 1 (true).
It is set to true if the key is in a system defined format
(`ace.import.S`)
and not the format defined by the present architecture
(`ace.import`).

The instruction must be resumable in case of interrupts.
Similarly to entire-vector-register load instructions, `ace.import` appears to other harts as
sequences of individual loads.

NOTE: The operation can be conceptually split into two phases.
In the first phase, the metadata
block is read, which determines the length of the remaining information.
Then, in the second phase, the rest of the SCC is read and processed.

NOTE: There is no further specification as to what the system defined format is in the encoding of the instruction, and in case more than one system defined format is defined, the data format itself must distinguish between them.
In other words, it is the responsibility of the system to augment all the system defined formats with a unique identifiers to distingush the formats from each other.

NOTE: The `ace.export` instruction does not have a `ace.export.S` analogue of `ace.import.S`.
This means that system HW dynamically generated keys can be imported but not exported in the same form: they must be exported in the format architected in this specification.

// If the value cannot be transported to other devices or to
// other Locality states of the same device, the internal logic must bind them to a
// specific DCSK). The instruction imports them like software keys and sets
// the appropriate policies.

// [.darkred]#(TBdetermined whether it is secure)# This instruction is trappable and may also be resumed or restarted.

[[ACE-instruction-exec]]
==== ace.exec

The `ace.exec` instruction admits four Forms, namely
(((ACE, instruction, ace.exec)))

[upperalpha]
. `ace.exec  Vd,Ln|L[Xn],Vs` {nbsp}{nbsp} takes an input vector and writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}Ln|L[Xn],Vs` {nbsp}{nbsp} takes an input vector but does not write to an output vector.
. `ace.exec  Vd,Ln|L[Xn]{nbsp}{nbsp}{nbsp}` {nbsp}{nbsp} does not take an input but writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}Ln|L[Xn]{nbsp}{nbsp}{nbsp}` {nbsp}{nbsp} does not take an input vector and does not write to an output vector.

Form D instructions perform internal processing only in the CC in the given CR.

// Without this comment, the next part is not properly formatted...
Encoding::
`ace.exec` is an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Vd', attr: ['rd'] },
    { bits:  3, name: 'ace.exec' },
    { bits:  5, name: 'Ln|L[Xn]', attr: ['rs1'] },
    { bits:  5, name: 'Vs', attr: ['rs2'] },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....
+
Bit `r` (i.e., bit 27) takes the value 0 if the context is encoded as an immediate,
and it takes the value 1 if a GPR (scalar integer value) is used to reference it.
For the four Forms A-D above, the encodings are:
+
[upperalpha]
. `ACE.exec` = `0b000`.
. `ACE.exec` = `0b001` and `rs2`=`0b00000`.
. `ACE.exec` = `0b010` and `rd`=`0b00000`.
. `ACE.exec` = `0b011` and `rs2`=`rd`=`0b00000`.

NOTE: We admit variants of Forms B and D, which we call Form B', resp., Form D',
with non-zero values in `rd`, resp., `rs2`, to encode additional instructions.

// To make indent in next line correct

Description::
Performs a cryptographic operation such as an encryption or decryption, absorbing a value in a hash, and possibly returning a value.

NOTE: In many algorithms, the next state is often implied by the preceding operation.
For example, in AEAD algorithms, setting an IV or nonce could implicitly transition to the state for absorbing associated data.
However, to ensure consistency, ACE requires explicit state transitions even when this incurs additional instructions.
Exceptions are made only when strictly necessary for security, such as automatic transitions from hash finalization to verification,
or to the _completed_ or _invalidated_ states (see <<ACE-state-constants>> and <<ACE-algorithms>>).

[[ACE-instruction-size]]
==== ace.size

The `ace.size` instruction is used to determine the size of a SCC in order to reserve the necessary space for it in memory.
(((ACE, instruction, ace.size)))

===== Context Variant

`ace.size Xd,Cs|L[Xs]`

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus is an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x3, attr: ['ace.exec', '(Form D\')'] },
    { bits:  5, name: 'Ls|L[Xs]' },
    { bits:  5, name: 0x1, attr: ['ace.size'] },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....
+
Bit `r` (i.e., bit 27) is 0 if the CR is encoded as an immediate, and 1 if the CR's number is given in a GPR.

Description::
This instruction writes the size of the SCC corresponding to the source CR,
and zero if the algorithm is not supported.

Knowledge of the size of the SCC is needed by any feature that relies on `ace.export`, e.g., context switching.

NOTE: The value can significantly differ from the internal resource usage to store the CC's data in a CR —
it can be larger (for simple primitives, because of the nonce/SIV overhead) but
also smaller (for keys split into shares for threshold implementations, but saved
externally in reconstructed form).

===== Metadata Variant

`ace.size Xd,Xs`

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus is an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x3, attr: ['ace.exec', '(Form D\')'] },
    { bits:  5, name: 'Xs' },
    { bits:  5, name: 0x2, attr: ['ace.size'] },
    { bits:  7, name: 0x0 },
]}
....

Description::
This instruction writes the size of a SCC having the metadata section given in `Xn` into GPR `Xd`, and zero if the algorithm is not supported.
Only the Algorithm and SC_Protection fields of the metadata section of a CC are considered.

[[ACE-instruction-available]]
==== ace.available

`ace.available Xd,Xs`
(((ACE, instruction, ace.available)))

Alias to the Metadata Variant of `ace.size`, as it returns zero if the algorithm is not supported.

[[ACE-instruction-clone]]
==== ace.clone

`ace.clone Ld|L[Xd],Cs|L[Xs]`
(((ACE, instruction, ace.clone)))

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus is an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Ld|L[Xd]' },
    { bits:  3, name: 0x3, attr: ['ace.exec','(Form D\')'] },
    { bits:  5, name: 'Ls|L[Xs]' },
    { bits:  5, name: 0x3, attr: ['ace.clone'] },
    { bits:  1, name: 0x0 },
    { bits:  2, name: 'R' },
    { bits:  4, name: 0x0 },
]}
....
+
Bits [27:26], i.e., field `R`, take following values depending on how the CRs are given:
+
[upperalpha]
. `0b00` if the source and the output CRs are both encoded as immediates.
. `0b01` if the source CR is selected using a GPR and the output CR is encoded as an immediate.
. `0b10` if the source CR is encoded as immediate and the output CR is selected using a GPR.
. `0b11` if the source and the output CRs are both selected using the values of GPRs.

// Comment to ensure the proper indentation in th next Description

Description::
Clones source Register `Ls` (or the CR indexed by `Xs`) into destination Register `Ld` (or
into the CR indexed by `Xd`).

// NOTE: The `ace.clone` instruction is an optimization for the sequence `ace.export` followed by `ace.import`. While reusing cryptographic state (e.g., encrypting with the same counter) can enable certain attacks, this risk cannot be eliminated by omitting `ace.clone`, as a state can be exported and re‑imported multiple times.

[[ACE-instruction-derive]]
==== ace.derive (optional)

`ace.derive Ld|L[Xd],Cs1|L[Xs1]` +
`ace.derive Ld|L[Xd],Cs1|L[Xs1],Vs2`
(((ACE, instruction, ace.derive)))

Encoding::
The encoding is a variant of Form A `ace.exec` encoding, and is thus is an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Ld|L[Xd]' },
    { bits:  3, name: 0x0, attr: ['ace.exec (Form A)'] },
    { bits:  5, name: 'Ls1|L[Xs1]' },
    { bits:  5, name: 'Vs2', attr: ['use for additional input','no additional input (zero field)'] },
    { bits:  1, name: 0x1 },
    { bits:  2, name: 'R' },
    { bits:  1, name: 'z', attr: [0x1,0x0] },
    { bits:  3, name: 0x0 },
]}
....
+
This encoding differs from Form A `ace.exec` by having bit 25 set to 1.
Bits [27:26], i.e., field `R`, is encoded exactly as for `ace.clone` (cf.{nbsp}<<ACE-instruction-clone>>).
Bit 28 determines whether an additional vector register (or register group) is used to pass a parameter to the key derivation mechanism or not.

Description::
The instruction is used to derive a new context from an existing one, with its own opaque key material.
It is similar to `ace.clone`, but the derived context is not a copy of the source context,
rather, it is a new context that is derived from it, for instance, through a key derivation mechanism.
This instruction can be used multiple times, to generate multiple derived contexts.


[[ACE-instruction-state]]
==== ace.state/ace.dir

`ace.state`/`ace.dir Ld|L[Xd],#immed7` +
`ace.state`/`ace.dir Ld|L[Xd],#immed7,Xs`
(((ACE, instruction, ace.state)))
(((ACE, instruction, ace.dir)))

Encoding::
`ace.state`/`ace.dir` is an R-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Ld|L[Xd]' },
    { bits:  3, name: 0x4, attr: ['ace.state'] },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
    { bits:  5, name: 'Xs' },
    { bits:  7, name: 'immed7' },
]}
....
+
Bit `r` (i.e., bit 15) is 0 if the context is encoded as an immediate, and 1 if a GPR is used to reference it.

Description::
`ace.state` and `ace.dir` are two names for the same instruction. +
`Ln` specifies the CR whose state is to be set. Alternatively, `Xn` is a GPR containing a value from 0 to 31 to dynamically select the target context. The `#immed` operand is a constant from the set of admissible values defined for each algorithm, used to manage the algorithm's internal state machine when additional states are required. `Xs` is a GPR that is either `X0` or contains an optional additional parameter for the state machine.

The state numbers used in this specification are defined in the following table.

[[ACE-state-constants]]
.Constants defining CC states
[float="center",align="center",width="100%",cols="^6%,<29%,<65%",options="header"]
|===
| Value | Mnemonic                      | Examples
|   0   | ace_state_initial +
ace_state_hash_initialize
| The context is initialized and ready for operation.
|   1   | ace_state_hash_absorb         | Start (and initialize) a hash function or the sub-function of an algorithm, preparing it to absorb blocks of data.
|   2   | ace_state_hash_finalize +
ace_state_hash_finalize_enc             | Finalize the internal state of a hash function (including for the encryption algorithm of an for an authenticated encryption mode of operation) and prepare it for outputting the result. In this state additional data may be absorbed, such as lengths.
|   3   | ace_state_hash_finalize_dec   | Finalize the internal state of a hash function for the decryption algorithm an authenticated decryption mode of operation. In this state additional data may be absorbed, such as lengths.
|   4   | ace_state_hash_verify         | Finalize the internal state of a hash function and compare it to the provided value.
|   5   | ace_state_hash_last_block +
ace_state_last_block_enc +
| For a hash or MAC function, we provide the length of the last block of data. May be used also in the encryption path of authenticated encryption modes of operation.
|   6   | ace_state_last_block_dec      | For the decryption path of authenticated encryption modes of operation if the length of the last block must be given.
|   7   | ace_state_encrypt +
ace_const_operate
|  Encryption is requested. +
Algorithm is ready to process.
|   8   | ace_state_decrypt             | Decryption is requested.
|   9   | ace_state_set_public_value    | Set a public value (like a nonce or an IV) in an algorithm. Some algorithms require more than one public value (for instance, they may admit a re-useable hash of some associated data and a unique nonce), in which case the second public value can be set using the next message.
|  10   | ace_state_set_public_value_2  | Set the second public value in an algorithm.
|  11   | ace_state_input_for_derive    | Tells the CC to expect additional information for feeding the `ace.derive` instruction.
|  14   | ace_state_invalidated         | The algorithm has abnormally terminated. `ace.error` will always return error code _ace_err_invalid_.
|  15   | ace_state_completed           | The algorithm has correctly completed.
|===

Algorithms that significantly differ from those we describe in <<ACE-algorithms>> and therefore cannot share the same software for their usage,
may reuse the same values in [1..13] with new constant mnemonics to define their own states.

[[ACE-instruction-restrict]]
==== ace.restrict/ace.harden

`ace.restrict   Ld|L[Xd],Xs` +
`ace.harden     Ld|L[Xd],Xs`
(((ACE, instruction, ace.restrict)))
(((ACE, instruction, ace.harden)))

// Without this comment, the next part is not properly formatted...
Encoding::
The encoding uses `ace.exec` Form B', with bit 7 (which is in the `rd` field) set.
It is thus a variant of an R-type instruction.
The source register field encodes a GPR and not a vector register.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 0x1 },
    { bits:  3, name: 0x1, attr: ['ace.exec', '(Form B\')'] },
    { bits:  5, name: 'Ld|L[Xd]' },
    { bits:  5, name: 'Xs' },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....
+
If bit `r` (i.e., bit 27) is 0, the 5-bit destination field [11:7] contains the destination context number,
else it determines the GPR that contains the context number.

// comment

Description::
+
--
This instruction can be used to:

* Restrict the usage of a CC (as stored in a CR) to specific modes or to a specified `ASID` or `VMID`; and
* Activate the side-channel protection of the CC or increase it.

Let `m` be the metadata field of the CC in the destination CR.
The instruction works as follows:

* Bits [11:10] and [63:26] of the input register `Xs` have the same format as the corresponding bits of the metadata.
* Bits [9:0] and [25:12] of the input register `Xs` are ignored.
* Bits [11:10] can be used to turn on or increase the level of the side-channel protection of the algorithm in the CC, if the microarchitecture supports the corresponding implementation. The levels are defined in <<ACE-SC-protection-levels>>. Downgrading side-channel protection is not permitted, and attempting to do so will result in error _ace_err_invalid_ (cf.{nbsp}<<ACE-error-codes>>).
* A zero in any of the six bits `Xs`[30:25] means that the corresponding policy is not changed.
* A one in the any of the four bits `Xs`[28:25] means that usage by the corresponding mode is forbidden, and the corresponding bit in the metadata of the destination CC is set to 1.
* If `Xs`[30] is set and `m`[30] is NOT set, then Usage_Policy_3, i.e., `m`[47:32], is set to `Xs`[47:32].
* If `Xs`[31] is set and `m`[31] is NOT set, then Usage_Policy_4, i.e., `m`[63:48], is set to `Xs`[63:48].
* If `Xs`[30] and `m`[30] are both set and `Xs`[47:32] <> `m`[47:32], or if `Xs`[31] and `m`[31] are both set and `Xs`[63:48] <> `m`[63:48], then `aceerror` is set to ace_error_invalid.
--
+

[[ACE-instruction-input]]
==== ace.input (optional)

`ace.input Ld|L[Xd],%offset(Xs)`
(((ACE, instruction, ace.input)))

Encoding::
`ace.input` is an I-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Ld','L[Xd]'] },
    { bits:  3, name: 'ace.input', attr: [0x4,0x5] },
    { bits:  5, name: 'Xs' },
    { bits: 12, name: 'imm' },
]}
....

// [.darkred]#(TBdetermined whether it is secure)# This instruction is trappable and may also be resumed or restarted.

[[ACE-instruction-output]]
==== ace.output (optional)

`ace.output  %offset(Xd),Cs|L[Xs]`
(((ACE, instruction, ace.output)))

Encoding::
`ace.output` is an S-type instruction.
+
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'imm[4:0]' },
    { bits:  3, name: 'ace.output', attr: [0x4,0x5] },
    { bits:  5, name: 'Xd' },
    { bits:  5, name: 'context', attr: ['Ls','L[Xs]'] },
    { bits:  7, name: 'imm[11:5]' },
]}
....


[[ACE-instruction-error]]
==== ace.error

`ace.error Xd`
(((ACE, instruction, ace.error)))

Description::
The ACE Unit may be in an error state due to the previous operation.
The corresponding error code is written into GPR `Xd`.
This is implemented as a read from CSR `aceerror`, which may cause the hart to wait if the error code is not yet available
(cf.{nbsp}<<ACE-CSR-ace-error>>).
The error code list is architected and given in <<ACE-error-codes>>.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-trappable-insns-support]]
==== Support for Trappable Operations

Instructions `ace.init`, `ace.export`, `ace.import`, `ace.input`, and `ace.output` support arbitrarily long inputs and outputs.
To reduce hardware complexity, these operations can be trapped and emulated in software using custom instructions.
(((ACE, trappable instruction)))

Upon a trap, the handler identifies the trapped instruction and uses the Algorithm field of the metadata block
`ace.size` to determine the size of the data to be transferred.

In order to support interrupts of the emulation libraries, such instructions need to respect the value of `acestart` and update it in accordance with the expected architected behavior the trapped instructions.  We provide here non-normative definition for such a set of instructions in <<ACE-trappable-insns-support>>.
Three types of supporting operations are required:

 * A `mv` instruction that loads a specified number of bytes from a GPR or vector register into a the state of a CR within the ACE unit.
   Initially, `ace.size` returns the total payload length to transfer.
   After each move, this value is updated to reflect the remaining bytes.
   The instruction also updates the `acestart` CSR to follow the internal progress.
 * A corresponding `mv` instruction that exports a specified number of bytes from a CR to a GPR or vector register.
   The behavior of `ace.size` will be similar to that of the move instruction, but it will count the number of bytes to be exported.
 * A “`close`” instruction to suspend or finalize the procedure.
   If executed before all bytes are transferred, the CR state matches that of an interrupted monolithic instruction, including the Completion metadata field and the `acestart` value. If executed after all bytes are transferred, it also performs any final cryptographic operations, such as authenticating the CR, if needed.

These supporting instructions must be uninterruptible.

The initial cryptographic phase of `ace.export` and the authentication phase of `ace.import` must be uninterruptible as well.
Even if these parts are executed concurrently with other operations, the trap handler may need to wait for these steps to complete before proceeding with memory/move operations.

The support instructions are implementation-specific and not explicitly defined in the architecture.
However, interrupting the firmware implementation of `ace.init`, `ace.export`, `ace.import`, `ace.input` or `ace.output`
must leave the architectural state indistinguishable from the state expected from interrupting a monolithic implementation of the instructions.

// ///////////////////////////////////////////////////////////////////////////////////////////

[#ACE-algorithms]
=== Data Formats and Instruction Semantics for Various Cryptographic Algorithms

In this chapter we specify the behavior of Cryptographic Contexts for various cryptographic algorithms.
Some specifications are generic in the sense that they apply to all algorithms of a certain type and can be instantiated with different primitives with varying parameters such as block and key sizes.
Other specifications pertain to algorithms that are specific to certain cryptographic primitives.

NOTE: This chapter is normative because it defines the behavior of the instructions and the data formats they use.
For instance, since AES-GCM-SIV is one of the mandatory algorithms, its behavior is completely determined by the specification of <<ACE-GCM-SIV>>
where the block size is `b` = 128 and the key size `k` can be 128, or 256 bits.
The specification of GCM-SIV here also guarantees that all implementations of, say, SM4-GCM-SIV (with the binary field in Montgomery representation using the same polynomial as AES-GCM-SIV) would be able to interoperate.

Each algorithm is fully defined by the following information:

Parameters:::
These include:
* The block size, which is the size of the basic unit of information processed by the algorithm, usually the block size of the main underlying primitive;
* The key size, for keyed algorithms; and
* Any other parameter (for instance, counter size) that is necessary to instantiate the algorithm with compatible primitives.

Data Structures:::
These include:

. *Configuration Input*:
The data following the metadata block in the initialization input to `ace.init`, such as keys and other required secrets.
Fields are listed in the order they appear in the configuration input, each with its length in bytes.

. *Internal State*:
Information that must be maintained in the internal state of a CC.
The fields are unordered, and their lengths in bytes may differ from those listed—for example, in threshold or fault-tolerant implementations where redundancy is added. Notably, the full single-share key size is listed even when a System Key is used, as this reflects the size of the key material the algorithm operates on.

. *Serialized Content*:
The data that follows the metadata block in the plaintext portion of the SCC, as serialized by the algorithm's `content_serialize` function. The fields are listed in the order they appear in the SCC, each with its length in bytes.

Generic Functions:::
If necessary, redefine generic functions that apply to all contexts.
Each algorithm must provide the functions described in <<ACE-formats>>.

Algorithmic-Specific Functions:::
Any other function that is specific to the algorithm.

State Machine:::
This includes:

. A list of *states* in which the internal state machine of the logic is executed, together with their representation, either as a number in the range [0..15] or by more complex structures. The values must conform to <<ACE-state-constants>>.
. A complete list of the *allowed state transitions*, including the conditions under which each transition is allowed.
. The *behavior* of all ACE instructions at each state.

We also add pseudocode to clarify how the algorithms supported by an ACE unit are implemented in software using the ACE ISA.

[[ACE-generic-rules]]
==== Generic Rules

For modes of operations that can be instantiated with different primitives, we specify more general rules, where the differences between instantiations in some cases are limited to the widths of the inputs and outputs of the primitive. If the primitive is a block cipher, then `b` is its block width in bits.

Recall that the architecture views a CC as a structure with two fields: the metadata (currently 64 bits), which has a unique specification, and the content (variable length), which is algorithm-specific.

In the descriptions of the algorithms below, we do not need to redefine these two functions if they are not changed, i.e., if there are no changes to the metadata format.

If the number of states of the algorithm is at most 16 (including _initial_, _completed_, and _invalidated_), the `state` of the metadata is used to store this value.
Otherwise, the specification of the algorithm must include a suitable field in the content section of the CC/SCC.

An important rule is the following.
If an invalid input is provided to any ACE instruction, or a non-admitted instruction is executed, while processing the algorithm in CR, say, `Ln`,
the `Ln` is *invalidated*, namely, the following happens:
(((ACE, algorithm, invalid state)))
(((Register, invalidated)))

* `Ln` is put into state _invalidated_;
* For instructions that refer to `Ln`:
 ** any Form of `ace.exec` performs no operation and, if it provides an output, the latter is always zero;
 ** `ace.clone` and `ace.derive` clean the destination contexts;
 ** `ace.restrict` and `ace.harden` perform no operation;
 ** `ace.input` and `ace.output` perform no operation;
 ** `ace.state` perform no operation, unless is is used to return to state _initial_;
 ** `ace.error` always returns error _ace_err_invalid_ after any operation involving the locke except for
    `ace.import` and `ace.export`, `ace.clean`, `ace.init`, and `ace.size`, which all work normally, and using `ace.state` to return to state _initial_.
* The current instruction is terminated.

The function that puts the CR in this state is called `invalidate()`.

In state _completed_, no operation can be performed except `ace.init`, `ace.export`, `ace.import`, `ace.clear`, or `ace.error`.
Any other operation, if it has an output, it returns zero, and will cause the CR to be *invalidated*.

All the operations performed by `ace.exec` or `ace.state` in the rules given for each algorithm are assumed to be *uninterruptible*.
This includes the case where very long vector inputs are processed but all operations are completely internal to ACE and require no external resource access, such as encryptions, decryptions, hashing, point multiplications, and other cryptographic operations.
Since such operations can operate independently of the CPU core, they may continue to execute also when the process that issued them is interrupted, so the hart implementation may cause the context switching software to wait when accessing a CR that is going to be written to.
We assume that these instructions perform atomically and uninterruptibly.

In what follows, when we write of "state _name_" we refer to the state which has number _ace_state_name_ as described in <<ACE-state-constants>>.

The rules from <<ACE-ECB-mode>> to <<ACE-CMAC>> can be instantiated, like the modes that they describe, with a variety of block ciphers and polynomials for GHASH- or POLYVAL-like hashes, where only the block and key sizes are needed to get a full specification.

On the other hand, the specifications from <<ACE-hash-functions>> to <<ACE-Ascon>> are in general heavily primitive dependent.

[[ACE-rules-threshold-implementations]]
==== Rules for Threshold implementations

Any CC with its algorithms implemented as threshold implementation will always initialize, import and export _all_ its keys and secrets as _single_, _reconstructed_ _shares_.
The Configuration and SCC Formats will be the same as for the non-threshold implementations variants of the same algorithm, with the only difference being the value of the Side Channel Protection bits in the metadata.
For the purpose of architecture specification, all values are also always represented as a single share in this document.
Threshold implementations are simply implementation variants of the exact same algorithm.
(((ACE, algorithm, threshold variants)))

NOTE: This assumes that reconstructing a key or re-randomizing it are fast operations, such as ``xor``s with random values.
This in turn implies that ACE execution unit must have access to a source of randomness, or at least a PRNG that is seeded at hardware boot.

This ensures not only the compactness of a SCC, but also that the key can be ported across architectures.
In fact, some threshold implementations may have a different number of shares even if they claim the same order of side-channel protection.

[[ACE-rules-system-keys]]
==== Rules for System Keys

System keys that are referred to by an index will cause following changes in all the algorithms described in what follows:

. In the configuration input and in the SCC, the key/main key field will contain the index of the key in the SKT in place of a key value.
. This field is always a 64-bit value, even if the key itself is larger. This saves space in the SCC and allows for faster export and import operations.
. For algorithms that require more than one key, such as XEX/XTS, ALL the keys are referred to by a single index, i.e., a single 64-bit value in the configuration input and the SCC.
. Accordingly, the `content_serialize` and `content_deserialize` functions will support System Keys by producing and reading the shorter fields with the indexes in place of the longer fields that would be required when the key values are explicitly provided.

NOTE: Internally, the ACE unit can either directly use the value from the SKT, or copy it to the internal state of the Register.
The architecture does not restrict the choice of the implementation.

// On the other hand, keys generated from a system block, using a custom "recipe", are always represented by their values and once generated have the exact same behavior as any other key that does not come from the SKT.

[[ACE-ECB-mode]]
==== Electronic Codebook Modes (Direct Encryption/Decryption)

While listing the rules for the ECB mode is in principle easy, it does display all the rules that are required to describe an arbitrarily complex mode.
(((ACE, algorithm, ECB)))

===== Specification

Parameters:::

* `b` = block size in bits (8|`b`). `VLEN` must be a multiple of `b`.
* `k` = key size in bits (8|`k`).

Data Structures:::

* *Configuration Input*:
[lowerroman]
 . `key`: `k/8` bytes, or 8 bytes if a System Key index.

* *Internal State*:
 ** `key`: `k/8` bytes.

* *Serialized Content*:
[lowerroman]
 . `key`: `k/8` bytes, or 8 bytes if a System Key index.

Algorithm-Specific Functions:::

* `enc_block(p) -> c` encrypts plaintext block `p` using the key, and returns the ciphertext result `c`.
* `dec_block(c) -> p` decrypts ciphertext block `c` using the key, and returns the plaintext result `p`.

State Machine:::

* *States:* _initial_, _encrypt_, and _decrypt_
* *Allowed State Transitions:*
 ** From any state to state _encrypt_, if metadata allows encryption, else the CR is *invalidated*.
 ** From any state to state _decrypt_, if metadata allows decryption, else the CR is *invalidated*.
* *Behavior:*
 ** In state _initial_, any `ace.exec` will result in the CR being *invalidated*.
 ** In state _encrypt_:
  *** If{nbsp} `ace.exec Vd,Ln|L[Xn],Vs` {nbsp}is issued, then {nbsp} `Vd = enc_block(Vs)`.
  *** If `VLEN` is a multiple of `b`, then `ace.exec Vd,Ln|L[Xn],Vs` encrypts block-by-block.
  *** If any other Form of `ace.exec` is issued, then the CR is *invalidated*.
 ** In state _decrypt_:
  *** If{nbsp} `ace.exec Vd,Ln|L[Xn],Vs` {nbsp}is issued, then {nbsp} `Vd = dec_block(Vs)`.
  *** If `VLEN` is a multiple of `b`, then `ace.exec Vd,Ln|L[Xn],Vs` decrypts block-by-block.
  *** If any other Form of `ace.exec` is issued, then the CR is *invalidated*.

[NOTE]
====
[.darkred]#Supporting vector lengths smaller than a cipher's block size would complicate the architecture.
For example, even in a simple ECB mode, we would require instruction sequences like#
----
ace.exec    L0,V0          // load lower half of plaintext
ace.exec    L0,V1          // load upper half of plaintext
ace.exec V0,L0             // store lower half of ciphertext
ace.exec V1,L0             // store upper half of ciphertext
----
[.darkred]#in place of a single `ace.exec Vd,Ln|L[Xn],Vs`.
Supporting this behaviour would not only complicate both the architecture and its implementation, but it would also burden the software using the feature.
Therefore, the present specification assumes that vector lengths (or vector groups) can be configured to at least the block size of the cipher.#
====

===== Usage

The following pseudocode illustrates how to use an ECB CC to encrypt a block of data using a block cipher with a width of 128 bits (`VLEN` is also 128).

[[ACE-pseudocode-ECB-encryption]]
.Simple Pseudocode Example: Encryption with no Authentication
----
- Call OS API to get the necessary SCC. Assume X5 points to the SCC.
- Allocate memory for ciphertext buffer.

vsetvli zero,4,e32,m1,ta,ma               // Use 128-bit vectors
ace.import L0,(X5)                        // Import the SCC into Register L0
ace.error X1                              // Read error from a CSR
if (X1 != 0) then { handle error }        // ACE may fail to validate SCC, algorithm may
                                          // be not supported, or LF memory may be full
ace.state L0,#ace_state_encrypt           // Configure CR for encryption
ace.error X1                              // Read error from a CSR
if (X1 != 0) then { handle error }        // Error if encryption not allowed

foreach (i from 0 to len_in_bytes(plaintext)/16-1) { // assume plaintext in whole blocks
    - load V0 from address plaintext+16*i
    ace.exec V0,L0,V0                     // Encrypt one block of the plaintext
    - store V0 at address ciphertext+16*i
}
----

// vle32.v  V0, (plaintext)              // load V0 from address plaintext+16*i
//                                       // assume plaintext is in a register
// ace.exec V0, L0, V                    // Encrypt one block of the plaintext
// vse32.v  V0, (ciphertext)             // store V0 at address ciphertext+16*i
// add plaintext, plaintext, 16          // advance plaintext pointer
// add ciphertext, ciphertext, 16        // advance ciphertext pointer




[[ACE-chaining]]
==== Chaining/Feedback Modes

There is no need to explicitly architect the behavior of chaining modes,
such as
Cipher Block Chaining (CBC),
Propagating Cipher Block Chaining (PCBC),
Cipher Feedback (CFB) and
Output Feedback (OFB)
as they can be easily implemented on top of the ECB functionality in software,
and no intermediate value in these algorithms needs to be kept secret.


[[ACE-keystream-modes]]
==== CTR/LFSR/XCTR/XLFSR Keystream Generation

In the "non-X" modes, i.e., in the CTR mode and its analague that replaces the arithmetic counter by a LFSR, the sum of the lengths of IV and counter/LSFR equals the block size of the underlying keyed PRP or PRF. IV and counter/LFSR are concatenated to form the input to the keyed PRP or PRF.
(((ACE, algorithm, keystream generation)))

The "X" modes have both IV and counter/LSFR of the same size as the block size of the underlying keyed PRP or PRF:
IV and counter/LFSR are ``xor``ed together to form the input to the keyed PRP or PRF -- which explains the "X" in the mode names.

===== Specification

Parameters:::
* `b` = block size in bits (8|`b`). For this algorithm `VLEN` must be a multiple of `b`.
* `k` = key size in bits (8|`k`).
* `j` = counter size in bits (8|`j`).
* `n` = IV size in bits (8|`n`).
* If the mode is CTR or LFSR, it is `b = n + j`.
* If the mode is an "X" mode, it is `b = n = j`.

Data Structures:::
* *Configuration Input*:
[lowerroman]
 . `key`: `k/8` bytes, or 8 bytes if a System Key index.

* *Internal State*:
 ** `key`: `k/8` bytes.
 ** `IV`: `n/8` bytes.
 ** `ctr`: `j/8` bytes.

* *Serialized Content*:
[lowerroman]
 . `key`: `k/8` bytes, or 8 bytes if a System Key index.
 . `IV`: `n/8` bytes.
 . `ctr`: `j/8` bytes.

Algorithm-Specific Functions:::
* `keystream_block(p) -> c` -- usually an encryption function.
* `tick_ctr()` -- updates the ctr (either by a modular increment or a LFSR).

State Machine:::
* *States:* _initial_, _set_public_value_, _operate_.
* *Allowed State Transitions:*
 ** _initial_ -> _set_public_value_ -> _operate_.
 ** All states to _initial_.
* *Behavior:*
 ** In state _initial_, the `ctr` and `IV` fields are set to 0 (`ctr` is set to 1 if the algorithm is LFSR-based).
 ** In state _set_public_value_, only ``ace.exec`` instructions of Form B are allowed. +
     "```ace.exec Ln|L[Xn],Vs```" sets the IV value to `Vs`.
  *** If no such instruction is issued, the value of the IV will remain zero.
  *** If `VLEN` is larger than `b`, the most significant bits of `Vs` (i.e., the "tail" of the vector) are ignored.
  *** If such operations are issued more times, they will just update the IV value again. Since this can be done only before any encryption or decryption operation, this does not represent a security issue.
  *** Any other Form of ``ace.exec`` will produce a null output and *invalidate* the CR.
 ** In state _operate_, only ``ace.exec`` instructions of Form C are allowed. +
     "```ace.exec Vd,Ln|L[Xn]```" performs:
+
--
  . If in a CTR or LFSR mode then `tmp ← keystream_block(IV @ ctr)`, +
    else (i.e., if in a XCTR or XLFSR mode) `tmp ← keystream_block(IV xor ctr)`,
  . `tick_ctr()`, and
  . `Vd ← tmp`.
--
+
If `VLEN` is a multiple of `b`, the above three commands are applied to each of the `VLEN/b` `b`-bit blocks of `Vs`, producing each time the corresponding `b`-bit block of `Vd`.
If the number `x` of blocks to be processed in an entire run of the algorithm is not a multiple of `VLEN`/`b`, `VL` can be set to the remainder of the division of `x` by `VLEN`/`b` for the last instruction.

 ** In state _operate_, any other Form of ``ace.exec`` will produce a null output and *invalidate* the CR.

Note that if `ace.state` is issued to return to state _initial_, the CC can be reused with a new `IV`.

===== Usage

Example pseudocode is given in <<ACE-pseudocode-keystream-modes>> (for the case `b` = `VLEN` = 128).

[[ACE-pseudocode-keystream-modes]]
.Encrypt with Keystream Generation
----
// Acquire payload, initialize
- Info: plaintext = *PT
- Process gets a Keystream Generation CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero,4,e32,m1,ta,ma                      // Use 128-bit vectors
ace.import L0,(X5)

// The next operations set the nonce (and the derived Authentication Key).
ace.state L0,#ace_state_set_public_value
V0 ← nonce
ace.exec L0,V0

// Compute keystream, use it to encrypt plaintext
for i = 0 to len_in_bytes(PT)/16-1 do
    - load V0 from address PT+16*i
    ace.exec V1,L0
    V1 ← V1 xor V0
    - store V1 at address CT+16*i
----

[[ACE-XEX-XTS-modes]]
==== XEX/XTS modes (one or two keys)

The use of a single key or two independently sampled keys is determined by the algorithm, and it is not a configuration parameter for the algorithm.
We first define XEX mode functionality.
(((ACE, algorithm, XEX)))

===== Specification

Parameters:::

* `b` = block size in bits (8|`b`). For this algorithm we require `VLEN` to be an integer multiple of `b`.
* `k` = key size in bits (8|`k`).

Data Structures:::

* *Configuration Input*:
[lowerroman]
 . `key1`: `k/8` bytes, or 8 bytes if a System Key index.
 . `key2`: `k/8` bytes  -- omitted if only one key is used or if both keys come from an entry in the SKT.

* *Internal State*:
 ** `key1`: `k/8` bytes.
 ** `key2`: `k/8` bytes.
 ** `mask`: `b/8` bytes.

* *Serialized Content*:
[lowerroman]
 . `key1`: `k/8` bytes, or 8 bytes if a System Key index.
 . `key2`: `k/8` bytes -- omitted if only one key is used or if both keys come from an entry in the SKT.
 . `mask`: `b/8` bytes.

Algorithm-Specific Functions:::

* `enc_block(key,p) -> c` encrypts block `p` using the key, and returns the result `c`.
* `dec_block(key,c) -> p` decrypts block `c` using the key, and returns the result `p`.
* `update_mask(mask) -> mask` -- updates the mask by a Galois Field multiplication in GF(2^b^)

State Machine:::

* *States:* _initial_, _set_public_value_, _encrypt_, and _decrypt_.

* *Allowed State Transitions:*
 ** _initial_ -> _set_public_value_.
 ** _set_public_value_ -> _initial_.
 ** _set_public_value_ -> _encrypt_, if metadata allows encryption, else the CR is *invalidated*.
 ** _set_public_value_ -> _decrypt_, if metadata allows decryption, else the CR is *invalidated*.
 ** _encrypt_, _decrypt_ -> _initial_.

* *Behavior:*
 ** In state _initial_:
  *** The `mask` field is set to zero.
  *** Any {nbsp}``ace.exec``{nbsp} operation will produce null outputs and causes the CR to be *invalidated*.
 ** In state _set_public_value_, only ``ace.exec`` instructions of Form B are allowed. +
 "```ace.exec Ln|L[Xn],Vs```" sets the _tweak_. The `mask` field is used to store the tweak: `mask <- Vs`.
  *** If no such instruction is issued, the value of the tweak will remain zero.
  *** If `VLEN` is larger than `b`, the most significant bits of `Vs` (i.e., the "tail" of the vector) are ignored.
  *** If "```ace.exec Ln|L[Xn],Vs```" is repeated, it will just re-write the mask.
  *** Other forms of `ace.exe` not allowed, will produce null outputs and the CR is *invalidated*.
 ** When transitioning from _set_public_value_ to either _encrypt_ or _decrypt_, the following operations are performed:
  . `mask <- enc_block(key2,mask)` or `mask <- enc_block(key1,mask)` if only one key is used.
  . If only one key is used then update mask: `mask <- update_mask(mask)`.
 ** In states _encrypt_ and _decrypt_, only ``ace.exec`` instructions of Form A are allowed. +
    "```ace.exec Vd,Ln|L[Xn],Vs```" performs the following operations:
+
--
  *** in state _encrypt_, computes `Vd = mask xor enc_block(key1,Vs xor mask)` ... +
      in state _decrypt_, computes `Vd = mask xor dec_block(key1,Vs xor mask)` ...
  *** ... and updates the mask: `mask <- update_mask(mask)`.
--
+
If `VLEN` is a multiple of `b`, the above commands are executed `VLEN/b` times, processing each `b`-bit block of `Vs` into a `b`-bit block of `Vd`. This operation is clearly parallelizable. If the number `x` of blocks to process is not a multiple of `VLEN`/`b`, `VL` can be set to the remainder of the division of `x` by `VLEN`/`b` for the last instruction.

//

Note that if `ace.state` is issued to return to state _initial_, the CC can be reused with a new `IV`.

===== Usage

Using XEX mode is very easy. We include pseudocode for encryption only, decryption is entirely similar
(this example is also assuming `b` = `VLEN` = 128).

[[ACE-pseudocode-basic-IV-mode]]
.Pseudocode for encryption in any IV-based non-authenticated mode without associated data
----
// Acquire payload
- Info: plaintext = *PT
- Call an API to get the corresponding key from a key management applet or HW block.
- The API returns the SCC. Assume X5 is the pointer to it.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero,4,e32,m1,ta,ma                      // Use 128-bit vectors
ace.import L0,(X5)

ace.state L0, #const_set_public_value            // this can be an IV or a nonce.
V0 ← IV
ace.exec L0,V0

ace.state L0,#ace_state_encrypt                  // Configure CR for encryption
for i = 0 to ceil(len_in_bytes(plaintext)/16)-1 do
    - load V0 from address plaintext+16*i
    ace.exec V0,L0,V0                            // Encrypt one block of the plaintext
    - store V0 at address ciphertext+16*i
----

To implement the XTS mode, the ciphertext stealing part is easy to realize using the XEX algorithm together with vector masking and shifting operations.
(((ACE, algorithm, XTS)))

// N.B. another ace.state L0, #const_set_public_value would reset the internal state and allow to begin another decryption with a new IV.


[[ACE-GCM-mode]]
==== GCM Mode
(((ACE, algorithm, GCM)))

===== Specification

Parameters:::

* `b` = block size in bits (8|`b`). For this algorithm we require `VLEN` to be an integer multiple of `b`.
* `k` = key size in bits (8|`k`).

Data Structures:::

* *Configuration Input*:
[lowerroman]
 . `key`: `k/8` bytes, or 8 bytes if a System Key index.

* *Internal State*:
 ** `key`: `k/8` bytes.
 ** `ctr`: `b/8` bytes.
 ** `hash_key`: `b/8` bytes.
 ** `auth_tag`: `b/8` bytes.

* *Serialized Content*:
[lowerroman]
 . `key`: `k/8` bytes, or 8 bytes if a System Key index.
 . `ctr`: `b/8` bytes.
 . `auth_tag`: `b/8` bytes.

NOTE: There are no fields for the lengths of the AD and of the plaintext, as they are maintained by the calling software.
Also, `hash_key` is not serialized, and thus it is recomputed upon `ace.import`.

Algorithm-Specific Functions:::

* `enc_block(key,p) -> c` encrypts block `p` using the key, and returns the result `c`.

* `absorb_into_hash(data)` absorbs data into the hash function by performing:
  . `auth_tag <- auth_tag xor Vs`.
  . `auth_tag <- auth_tag * hash_key`.

State Machine:::

* *States:* _initial_, _set_public_value_, _hash_absorb_, _encrypt_, _hash_finalize_enc_, _decrypt_, _hash_finalize_dec_, and _hash_verify_, _completed_.

* *Allowed State Transitions:*
 ** From all states to _initial_.
 ** _initial_ -> _set_public_value_ -> _hash_absorb_.
 ** _hash_absorb_ -> _encrypt_ -- if metadata allows encryption, else the CR is *invalidated*.
 ** _hash_absorb_ -> _decrypt_ -- if metadata allows decryption, else the CR is *invalidated*.
 ** _encrypt_ -> _hash_finalize_enc_, later automatically transitioning to _completed_.
 ** _decrypt_ -> _hash_finalize_dec_.
 ** _hash_finalize_dec_ -> _hash_verify_, later automatically transitioning to _completed_.

* *Behavior:*
 ** In state _initial_ :
  *** Any {nbsp}``ace.exec``{nbsp} operation will produce null outputs and causes the CR to be *invalidated*.
  *** The following initialization operations are performed:
   . `hash_key <- enc_block(key,0)`,
   . `auth_tag <- 0`, and
   . `ctr <- 0`.
 ** In state _set_public_value_:
  *** Only  ``ace.exec`` instructions of Form B are allowed.
  "```ace.exec Ln|L[Xn],Vs```" sets
   . `ctr <- Vs @ (b/4-1)b'0 @ 1b'1`, i.e., the `b/4` most significant bits of `Vs` are ignored, and the `b/4` least significant bits of `ctr` represent the integer 1.
  *** If "```ace.exec Ln|L[Xn],Vs```," is repeated, it will just re-write the IV.
  *** If no such "```ace.exec Ln|L[Xn],Vs```" to set is issued, `ctr` remains zero.
  *** If `VLEN` is larger than `b`, the most significant bits of `Vs` (i.e., the "tail" of the vector) are ignored.
  *** Any other Form of ``ace.exec`` will produce null outputs and causes the CR to be *invalidated*.

 ** In state _hash_absorb_, only  ``ace.exec`` instructions of Form B are allowed. +
 "```ace.exec Ln|L[Xn],Vs```" absorbs a data block in `auth_tag`, i.e.:
+
--
 . `absorb_into_hash(Vs)`.
--
+
If `VLEN > b`, the above operation is executed `VLEN/b` times, absorbing each time a `b`-bit block of `Vs` into the hash.
This operation is parallelizable by having the implementation precompute the first four powers of `hash_key`, keeping it internally in the CR (and reconstructing these powers after `ace.import`). If the number `x` of blocks to process is not a multiple of `VLEN`/`b`, `VL` can be set to the remainder of the division of `x` by `VLEN`/`b` for the last instruction.

** If state _encrypt_, only ``ace.exec`` instructions of Form A are allowed. +
   "```ace.exec Vd,Ln|L[Xn],Vs```" encrypts `Vs` into `Vd`, and absorbs the ciphertext `Vd` into the `auth_tag`, namely:
+
--
  . If `ctr[b/4-1:0] = 0`, the CR is *invalidated*.
  . `tmp <- Vs xor enc_block(key,ctr)`.
  . `absorb_into_hash(tmp)`.
  . `ctr[b/4-1:0] <- ctr[b/4-1:0] + 1 % 2^b/4^`.
  . `Vd <- tmp`.
--
+
If `VLEN` is a multiple of `b`, the above are executed `VLEN/b` times, encrypting each `b`-bit block of `Vs` into the corresponding `b`-bit block of `Vd`. There is significant potential for parallelization, including in the `absorb_into_hash` function. If the number `x` of blocks to encrypt is not a multiple of `VLEN`/`b`, `VL` can be set to the remainder of the division of `x` by `VLEN`/`b` for the last instruction.

** In state _hash_finalize_enc_, only ``ace.exec`` instructions of Form A are allowed. The value +
 `{nbsp}{nbsp}{nbsp}Vs = IntTo{b/2}Bits(bit_length(AD)) @ IntTo{b/2}Bits(bit_length(plaintext))` +
 must be set by the software, then,
  "```ace.exec Vd,Ln|L[Xn],Vs```"
  computes the authentication tag and completes the algorithm as follows:
+
--
  . `absorb_into_hash(Vd)`.
  . `auth_tag <- auth_tag xor enc_block(key,ctr[b-1,b/4] @ 0[b/4-1,0])`.
  . Finally, `auth_tag` is returned in `Vd`, and the state is changed to _completed_.
--
+
If `VLEN` is larger than `b`, the most significant bits of `Vs` (i.e., the "tail" of the vector) are ignored.

 ** In state _decrypt_, only  ``ace.exec`` instructions of Form A are allowed. +
 `ace.exec Vd,Ln|L[Xn],Vs`
   absorbs the ciphertext `Vs` into the `auth_tag`, then decrypts `Vs` into `Vd`, namely
+
--
  . If `ctr[b/4-1:0] = 0`, the CR is *invalidated*.
  . `absorb_into_hash(Vs)`.
  . `Vd  <- Vs xor enc_block(key,ctr)`.
  . `ctr[b/4-1:0] <- ctr[b/4-1:0] + 1`.
--
+
If `VLEN` is a multiple of `b`, the same behavior applies as in state _encrypt_.

** In state _hash_finalize_dec_, only a Form A ``ace.exec`` instruction are allowed.
The value +
 `{nbsp}{nbsp}{nbsp}Vs = IntTo{b/2}Bits(bit_length(AD)) @ IntTo{b/2}Bits(bit_length(plaintext))` +
 must be set by the software, then "```ace.exec Vd,Ln|L[Xn],Vs```" computes the authentication tag as follows:
+
--
  . `absorb_into_hash(Vs)`.
  . `auth_tag <- auth_tag xor enc_block(key,ctr[b-1,b/4] @ 0[b/4-1,0])`.
--
+
If `VLEN` is larger than `b`, the most significant bits of `Vs` (i.e., the "tail" of the vector) are ignored.

** In state _hash_verify_, only an ``ace.exec`` instructions of Form B, i.e., "```ace.exec Ln|L[Xn],Vs```" are allowed.
    It compares `Vs` with `auth_tag`:
+
--
  . If the values match, then the state is changed to _completed_, and `ace.error` returns no error,
  . else the state is changed to _completed_, and `ace.error` returns `ace_err_authentication`.
--
+
If `VLEN` is larger than `b`, only the `b` least significant bits `Vs` are compared to `auth_tag`.

** Upon completion of `ace.import`, the ACE unit recomputes `hash_key`:
  . `hash_key <- enc_block(key,0)`.

//

===== Usage

In <<ACE-pseudocode-GCM-encryption>> we show pseudocode for GCM encryption (again with `b` = `VLEN` = 128).
The code assumes that both AD and plaintext (or the ciphertext for the decryption) are zero-padded to a multiple of `b` bits, in this case 128 bits.

[[ACE-pseudocode-GCM-encryption]]
.GCM Encryption
----
// Acquire payload, initialize
- Info: authenticated data = *AD, plaintext = *PT
- Process gets a GCM encryption CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero,4,e32,m1,ta,ma                      // Use 128-bit vectors
ace.import L0,(X5)

// The next operations set the nonce (and the derived Authentication Key).
ace.state L0,#ace_const_set_public_value
V0 ← nonce
ace.exec L0,V0

// Compute AD contribution to Auth Data
ace.state L0,#ace_const_hash_absorb
for i = 0 to len_in_bytes(AD)/16-1  do
    - load V0 from address AD+16*i
    ace.exec L0,V0                               // Absorb it into hash

// Encrypt plaintext and continue computation of auth_tag
ace.state L0,#ace_const_encrypt
for i = 0 to len_in_bytes(PT)/16-1 do
    - load V0 from address PT+16*i
    ace.exec V1,L0,V0
    - store V1 at address CT+16*i

// Finally, we absorb the lengths into auth_tag, finalize it, and output it
ace.state L0,#ace_const_hash_finalize_enc
V1 ← IntTo64Bits(len(AD)) @ IntTo64Bits(len(PT))
ace.exec V2,L0, V1                               // V2 contains the finalized hash
----

GCM decryption differs from enc as follows:
the roles of `PT` and `CT` are reversed,
states _encrypt_ and _hash_finalize_enc_ are replaced by states _decrypt_ and _hash_finalize_dec_,
and the last lines are as follows:

[[ACE-pseudocode-GCM-decryption-difference]]
.GCM Decryption
----
// Finally, we absorb the lengths into auth_tag, finalize it, and verify it it
ace.state L0,#ace_const_hash_finalize_dec
V1 ← IntTo64Bits(len(AD)) @ IntTo64Bits(len(CT))
ace.exec V2,L0,V1                                // V2 contains the finalized hash

ace.state L0,#ace_const_hash_verify
V1 ← tag_from_payload
ace.exec L0,V1                                   // V1 contains the tag from the input
ace.error X1
if (X1 != 0) then { handle error }       // do not use the plaintext if error occurred
----

//

[discrete]
===== Alternative Examples

GCM security is not compromised if `H` is revealed.
Consequently, an implementation based on a simpler ECB mode CC is possible,
as shown below (for encryption only -- decryption is similar).
However, this significantly increases code size and requires implementing `galois_mult(V4,V3)`.
Adding a dedicated mode to the ACE unit is a minor effort, and it allows internal logic to optimize execution
beyond the capabilities of, for instance, a compiler on an in-order CPU. It also means that the CPU
does not have to implement the carryless multiplication (cf. <<ACE-V-dependency>>),
and only a shared ACE unit has to,
which saves hardware costs when several small cores share a single ACE unit.

[[ACE-pseudocode-GCM-encryption-alternate]]
.Implementing GCM encryption using an ECB CC
----
// Acquire payload, initialize
- Info: authenticated data = *AD, plaintext = *PT
- Process gets a GCM encryption CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero,4,e32,m1,ta,ma                      // Use 128-bit vectors
ace.import L0,(X5)                               // Imports SCC into Register L0
V5[127:32] ← IV
V5[31:0] ← 1

V3 ← 0                                           // “Auth Data 1”
ace.exec V4,L0,V3                                // compute H
for i = 0 to ceil(len_in_bytes(AD)/16)-1  do
    - load 16 bytes from AD+16*i into V1
    V3 ← V3 xor V1                               // Horner scheme add
    V3 ← galois_mult(V4,V3)                      // Horner scheme mult

counter ← 1                                      // a 32-bit integer value
for i = 0 to ceil(len_in_bytes(PT)/16)-1  do
    V5[32:0] ← counter
    - load 16 bytes from PT+16*i into V1
    ace.exec V2,L0,V5                            // create mask by encrypting the counter
    V1 ← V1 xor V2                               // CTR encrypt
    V3 ← V3 xor V1                               // Horner scheme add
    V3 ← galois_mult(V4,V3)                      // Horner scheme mult
    - store V1 at *(CT+16*i))
    counter ← counter + 1

V3 ← V3 xor (len_in_bits(AD) @ len_in_bits(PT))  // Horner scheme add
V3 ← galois_mult(V4,V3)                          // Horner scheme mult
V5[32:0] ← 1                                     // Prepare IV || 1 for tag encryption
ace.exec V2,L0,V5
tag ← V3 xor V2                                  // Last Horner scheme add
----



[[ACE-GCM-SIV]]
==== GCM-SIV mode

The GCM-SIV mode's main differences with GCM are that:

. Both encryption and authentication keys are derived from the main key, whereas in GCM the main key is used also for encryption;
. It is a MAC-then-Encrypt mode, whereas GCM is a Encrypt-then-MAC mode, therefore GCM-SIV is more amenable to Release of Unencrypted Plaintext (RUP) attacks;
. Encryption requires two passes over the plaintext, since the tag computed on the AD and plaintext is used also as the initialization vector for the CTR encryption.
(((ACE, algorithm, GCM-SIV)))

The third difference affects the state machine. While GCM-SIV's decryption state machine is similar to the GCM's, the encryption state machine is different:

* During encryption, the _hash_absorb_ state absorbs the entire associated data and plaintext. The _hash_finalize_enc_ state then absorbs the lengths and produces the SIV/tag. Finally, the _encrypt_ state performs a second pass to encrypt the plaintext using the SIV/tag as the initialization vector.
* During decryption, the _hash_absorb_ state absorbs only the associated data. The _decrypt_ state decrypts the ciphertext and simultaneously absorbs the plaintext into the hash. Finally, the _hash_finalize_dec_ state absorbs the lengths, produces the SIV/tag, and internally compares it to the provided SIV/tag.

===== Specification

Parameters:::

* `b` = block size in bits, (`8|b`). For this algorithm we require `VLEN` to be an integer multiple of `b`.
* `k` = key size in bits (8|`k`).
* It must be `k = b` or `k = 2b`.
* It must be established by the algorithm whether the authentication tag is `b` or `3b/4` bits long.

Data Structures:::

* *Configuration Input*:
[lowerroman]
 . `key`: `k/8` bytes, or 8 bytes if a System Key index.

* *Internal State*:
 ** `key`: `k/8` bytes.
 ** `enc_key`: `k/8` bytes.
 ** `auth_key`: `b/8` bytes.
 ** `nonce`: `3b/32` bytes (`3b/4` bits).
 ** `ctr`: `b/32` bytes (`b/4` bits).
 ** `auth_tag`: `b/8` bytes.
 ** `SIV`: `b/8` or `3b/32` bytes (`b` or `3b/4` bits).
+
A `b`-bit `SIV` is computed by clearing the most significant bit of `auth_tag` and encrypting it. +
For a `3b/4`-bit `SIV`, a full `b`-bit `auth_tag` value is kept while absorbing data.
The public `SIV` value is computed by clearing the most significant bit of `auth_tag`, encrypting it, and then removing the `b/4` least significant bits.

* *Serialized Content*:
[lowerroman]
 . `key`: `k/8` bytes.
 . `nonce`, `3b/32` bytes.
 . `ctr`, `b/32` bytes.
 . `auth_tag`, `b/8` bytes.
 . `SIV`, `b/8` bytes.

NOTE: `hash_key` and `auth_key` are not serialized,
and must be recomputed upon each `ace.import`. +
 +
The `SIV` field is actually only needed for decryption, since it must be maintained separately from the `auth_tag` field, which changes with each processed block as it is computed, whereas for encryption it is first computed completely and then used in the encryption process. However, since the same CC could be configured to support both encryption and decryption, the `SIV` field always present in the internal state (even if not used) and in the exported state.

//

Algorithm-Specific Functions:::

* `enc_block(key,p) -> c` encrypts block `p` using the key, and returns the result `c`.
* `absorb_into_hash(data)` absorbs data into the hash function by performing a step of (a variant of) GHASH or POLYVAL as specified by the algorithm
   (for instance, AES-GCM-SIV uses POLYVAL):
  . `auth_tag <- auth_tag xor Vs`.
  . `auth_tag <- auth_tag * hash_key`, where `*` denotes either Galois field multiplication (for GHASH) or Montgomery multiplication (for POLYVAL/MHASH), as specified by the algorithm.
State Machine:::
* *States:* _initial_, _set_public_value_, _set_public_value_2_, _hash_absorb_, _hash_finalize_enc_, _hash_finalize_dec_, _encrypt_, _decrypt_, and _completed_.

* *Allowed State Transitions:*
 ** From all states to _initial_.
 ** For encryption:
    _initial_ -> _set_public_value_ -> _hash_absorb_ -> _hash_finalize_enc_ -> _encrypt_.
 ** For decryption: +
    _initial_ -> _set_public_value_ -> _set_public_value_2_ -> _hash_absorb_ -> _decrypt_ -> _hash_finalize_dec_.
 ** Transition to _encrypt_ possible only if metadata allows encryption, else the CR is *invalidated*.
 ** Transition to _decrypt_ possible only if metadata allows decryption, else the CR is *invalidated*.

* *Behavior:*
 ** In state _initial_ :
  *** Any {nbsp}``ace.exec``{nbsp} operation will produce a null output and the CR will be *invalidated*.
  *** The following initialization operations are performed:
    . `enc_key`, `auth_key <- RFC8452_KeyDeriv(key)`,
    . `nonce`, `ctr`, `auth_tag`, `SIV <- 0`.

  ** In states _set_public_value_, resp. _set_public_value_2_:
    *** We can only issue  ``ace.exec`` instructions of Form B, i.e. "```ace.exec Ln|L[Xn],Vs```," to set the value of `nonce`, resp. `SIV`.
    *** If "```ace.exec Ln|L[Xn],Vs```" is repeated, it will just re-write the value of `nonce`, resp. `SIV`.
    *** If no such "```ace.exec Ln|L[Xn],Vs```" is issued, `nonce`, resp. `SIV`, remain equal to zero.
    *** If `VLEN` is larger than `b`, the most significant bits of `Vs` (i.e., the "tail" of the vector) are ignored.
    *** Other forms of `ace.exe` will produce null outputs and *invalidate* the CR.
+
NOTE: There is no harm in moving to state _set_public_value_2_ and setting the
SIV while encrypting, since that field is not used in the encryption path until
it is set (thus overwriting any previous content) by the state machine itself.
Accepting this redundant but harmless behavior simplifies the state machine.
+
** In state _hash_absorb_:
+
--
   *** Only ``ace.exec`` instructions of the Form "```ace.exec Ln|L[Xn],Vs```" are allowed. Such an instruction accumulates a value in the `auth_tag`:
   i.e., perform `absorb_into_hash(Vs)`.
--
+
If `VLEN` is a multiple of `b`, `absorb_into_hash` is executed on each of the `VLEN/b` blocks in `Vs`.

*** Other forms of `ace.exec` will produce null outputs and *invalidate* the CR.

** In state _hash_finalize_enc_, only an {nbsp}``ace.exec``{nbsp} of Form A is allowed. +
  "```ace.exec Vd,Ln|L[Xn],Vs```," where it is the responsibility of the user to set +
`{nbsp}{nbsp}{nbsp}Vs = IntTo{b/2}Bits(bit_length(AD)) @ IntTo{b/2}Bits(bit_length(plaintext))`, +
finalizes the computation of the SIV/tag, by performing:
+
--
    . `absorb_into_hash(Vs)`.
    . `tmp <- enc_block(enc_key, 1b'0 @ (auth_tag xor N)[b-2:0])`
    . If tag length is `b` bits, then
     *** `SIV <- tmp` and `Vd <- tmp`,
    . else (tag length is `3b/4` bits)
     *** `SIV <- tmp[b-1:b/4]` and `Vd <- (tmp >> b/4)`.
--
+
If `VLEN` is larger than `b`, the most significant bits of `Vs` (i.e., the "tail" of the vector) are ignored.

*** Other forms of `ace.exec` will produce null outputs and *invalidate* the CR.

** In state _encrypt_, only  ``ace.exec`` instructions of the Form A are allowed, namely "```ace.exec Vd,Ln|L[Xn],Vs```," to encrypt `Vs` into `Vd` as follows:
+
--
. If `ctr = 0`, then the CR is *invalidated*.
   . If the `SIV` is `b`-bits long, then +
     *** ``Vd <- Vs xor enc_block(key, 1b1 @ SIV[b-2:b/4] @ (SIV[b/4-1:0] + ctr % 2^b/4^)),``
   . else (the `SIV` is `3b/4`-bits long) +
      *** ``Vd <- Vs xor enc_block(key, 1b1 @ SIV[3b/4-2:0] @ ctr``.
   . `ctr <- ctr + 1`.
--
+
If `VLEN` is a multiple of `b`, the above operations are applied to each of the `VLEN/b` blocks in `Vs`.

*** Other forms of `ace.exec` will produce null outputs and *invalidate* the CR.

** In state _decrypt_,  only  ``ace.exec`` instructions of the Form A are allowed, namely "```ace.exec Vd,Ln|L[Xn],Vs```," to decrypt `Vs` into `Vd` and then absorb the plaintext `Vs` into the `auth_tag`:
+
--
     . If `ctr = 0`, then the CR is *invalidated*.
     . If the `SIV` is `b`-bits long, then +
       *** ``Vd <- Vs xor enc_block(key, 1b1 @ SIV[b-2:b/4] @ (SIV[b/4-1:0] + ctr % 2^b/4^)),``
     . else (it is `3b/4`-bits long) +
       *** ``Vd <- Vs xor enc_block(key, 1b1 @ SIV[3b/4-2:0] @ ctr``.
     . `absorb_into_hash(Vs)`.
     . `ctr <- ctr + 1`.
--
+
If `VLEN` is a multiple of `b`, the above operations are applied to each of the `VLEN/b` blocks in `Vs`.

*** Other forms of `ace.exec` will produce null outputs and *invalidate* the CR.

 ** In state _hash_finalize_dec_,
    only an ``ace.exec`` instruction of Form B is allowed,
    namely "```ace.exec Ln|L[Xn],Vs```," where it is the responsibility of the user to set +
    `{nbsp}{nbsp}{nbsp}Vs = IntTo{b/2}Bits(bit_length(AD)) @ IntTo{b/2}Bits(bit_length(plaintext))`. +
    ``ace.exec`` thus performs the following operations:
+
--
  . `absorb_into_hash(Vs)` (which modifies `auth_tag`).
  . `tmp <- enc_block(enc_key, 1b'0 @ (auth_tag xor N)[b-2:0])`.
  . If tag length is `b` bits, then
     *** `auth_tag <- tmp`,
  . else (tag length is `3b/4` bits)
     *** `auth_tag <- tmp[b-1:0] @ (b/4)b0`.
  . Finally, `auth_tag` and `SIV` are compared:
     *** If the values match, the state transitions to _completed_ and `ace.error` returns no error,
  else the state transitions to _completed_ and `ace.error` returns `ace_err_authentication`.
--
+
If `VLEN` is larger than `b`, the most significant bits of `Vs` beyojnd the `b`-th (i.e., the "tail" of the vector) are ignored.

  ** Upon completion of `ace.import`, the ACE unit recomputes `hash_key` and `auth_key`
    . `enc_key`, `auth_key <- RFC8452_KeyDeriv(key)`.

//

===== Usage

We show in <<ACE-pseudocode-GCM-SIV-encryption>> how to perform AEAD encryption with a GCM-SIV CC (with `b` = `VLEN` = 128).
<<ACE-pseudocode-GCM-SIV-decryption>> is the corresponding pseudocode for decryption.

[[ACE-pseudocode-GCM-SIV-encryption]]
.GCM-SIV Encryption
----
// Acquire payload, initialize
- Info: authenticated data = *AD
- Info: plaintext = *PT
- Call an API to get the corresponding key from a key management applet or HW block.
- The API returns the SCC. Assume X5 is the pointer to it.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero,4,e32,m1,ta,ma                      // Use 128-bit vectors
ace.import L0,(X5)

// Set the nonce (and the derived Authentication Key).
ace.state L0,#ace_const_set_public_value
V0 ← nonce
ace.exec L0,V0

for i = 0 to len_in_bytes(AD)/16-1  do
    - load V0 from address AD+16*i               // Load a block of associated data
    ace.exec L0,V0 		                         // Absorb it into hash

for i = 0 to len_in_bytes(PT)/16-1  do
    - load V0 from address PT+16*i               // Load a block of plaintext
    ace.exec L0,V0 		                         // Absorb it into hash
V0 ← IntTo64Bits(len(AD)) @ IntTo64Bits(len(PT))
ace.exec L0,V0		          	                 // Absorb lengths into hash

// Finalize the SIV computation, set and return it
ace.state L0,#ace_const_hash_finalize_enc
ace.exec V2,L0
- store V2 into tag

// Encrypt the plaintext
ace.state L0,#ace_const_encrypt
for i = 0 to len_in_bytes(PT)/16-1  do
    - load V0 from address PT+16*i               // Load a block of plaintext
    ace.exec V1,L0,V0                            // Encrypt the block
    - store V1 at address CT+16*i                // Store a block of ciphertext
----



[[ACE-pseudocode-GCM-SIV-decryption]]
.GCM-SIV Decryption
----
// Acquire payload, initialize
- Info: authenticated data = *AD
- Info: ciphertext = *CT
- Call an API to get the corresponding key from a key management applet or HW block.
- The API returns the SCC. Assume X5 is the pointer to it.
- Allocate memory for plaintext buffer PT (if not same as CT).

vsetvli zero,4,e32,m1,ta,ma                      // Use 128-bit vectors
ace.import L0,(X5)

// The next operations set the nonce and SIV.
ace.state L0,#ace_const_set_public_value
V0 ← nonce
ace.exec L0,V0
ace.state L0,#ace_const_set_public_value_2
V0 ← SIV
ace.exec L0,V0

// Compute AD contribution to Auth Data
ace.state L0,#ace_const_hash_absorb
for i = 0 to len_in_bytes(AD)/16-1  do
    - load V0 from address AD+16*i
    ace.exec L0,V0                              // Absorb it into hash

// Decrypt ciphertext and continue computation of auth_tag
for i = 0 to len_in_bytes(CT)/16-1 do
    - load V0 from address CT+16*i
    ace.exec V1,L0,V0
    - store V1 at address PT+16*i

// Finally, we absorb the lengths of AD and plaintext into auth_tag AND verify
ace.state L0,#ace_const_hash_finalize_enc
V0 ← IntTo64Bits(len(AD)) @ IntTo64Bits(len(PT))
ace.exec L0,V0
ace.error X1
if (X1 != 0) then { handle error }               // do not use the plaintext if error occurred
----



[[ACE-CMAC]]
==== CMAC Functions

CMAC is an algorithm for message authentication codes constructed from a block cipher.
it was designed by Tetsu Iwata and Kaoru Kurosawa and became a NIST recommendation in May 2005.
(((ACE, algorithm, CMAC)))

===== Specification

Parameters:::

* `b` = block size in bits (8|`b`).  For this algorithm we require `VLEN` to be an integer multiple of `b`.
* `k` = key size in bits (8|`k`).

Data Structures:::

* *Configuration Input*:
[lowerroman]
 . `key`: `k/8` bytes.

* *Internal State*:
 ** `key`: `k/8` bytes.
 ** `hash`: `b/8` bytes.
 ** `last_block_len`: `8` bytes.

* *Serialized Content*:
[lowerroman]
 . `key`: `k/8` bytes.
 . `hash`: `b/8` bytes.
 . `last_block_len`: `8` bytes.

Algorithm-Specific Functions:::

* `enc_block(key,p) -> c` encrypts block `p` using the key, and returns the result `c`.
* `gen_subkeys(K) -> K1,K2` generates subkeys `K1` and `K2` from the master key `K` as follows: First, let `C` be the non-leading coefficients of the lexicographically first irreducible binary polynomial of degree `b` with the minimal number of ones: `0x1B` for `b` = 64, `0x87` for `b` = 128, and `0x425` for `b` = 256, then
//First, `C` is a `b` bit value that, if interpreted as a polynomial in the letter `x` over GF(2), makes `x^b^ + const_Rb` irreducible.
 . `L <- AES-enc_block(K, 0)`
 . if (`most_significant_bit(L){nbsp}{nbsp}= 0`) then
   { `K1 <- L{nbsp}{nbsp}<< 1` }
   else
   { `K1 <- (L{nbsp}{nbsp}<< 1) xor C` }.
 . if (`most_significant_bit(K1){nbsp}= 0`) then
   { `K2 <- K1{nbsp}<< 1` }
   else
   { `K2 <- (K1{nbsp}<< 1) xor C` }.
 . return ```(K1,K2)```.

State Machine:::

* *States:* _initial_ (0), _hash_absorb_, _hash_last_block_, _hash_finalize_, and _completed_.
* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_.
 ** _hash_absorb_ -> _hash_finalize_ -> _completed_.
 ** From any state to state _initial_.
* *Behavior:*
 ** In state _initial_:
  *** `last_block_len` is set to zero.
  *** `hash` is set to zero.
  *** Any `ace.exec` will result in the CR being *invalidated*.

 ** In state _hash_absorb_, we can only issue instructions ``ace.exec`` of Form B, i.e., "```ace.exec Ln|L[Xn],Vs```", to absorb the data block `Vs` into the hash. This is performed as follows:
+
--
  . `tmp <- hash xor Vs`.
   . `hash <- enc_block(key,tmp)`.
--
+
If `VLEN` is a multiple of `b`, then the above operations are applied to each `b`-bit block of `Vs`.

 ** Upon issuing `ace.state Ln|L[Xn],#ace_state_last_block, Xs` where `Xs` contains the length of the last block in bits, following happens:
   . if `partial_len` <> 0, then the CR is *invalidated*. (The previous block is not complete.)
   . if `Xs > b` then the CR is *invalidated*.
   . `last_block_len <- Xs`.

 ** In state _hash_last_block_,  we can only issue a single instruction ``ace.exec`` of Form B, i.e., "```ace.exec Ln|L[Xn],Vs```", to absorb the data block `Vs` and write the final hash value in `Vd`. After this, the state transitions to _completed_:
+
--
  . `K1,K2 <- gen_subkeys(key)`.
  . if `last_block_len` = `b`, then
    *** `tmp <- hash xor Vs xor K1`,
  . else
    *** `tmp <- Vs`
    *** Remove the `b` - `last_block_len` most significant bits of `tmp` and pad the resulting value with a `1` and sufficiently many `0` bits to make it `b` bits long.
    *** `tmp <- hash xor tmp xor K2`.
  . `hash <- enc_block(key,tmp)`.
  . The state is changed to _hash_finalize_.

  ** In state _hash_finalize_,
    then we can issue one instructions ``ace.exec``of Form C, i.e., "```ace.exec Vd,Ln|L[Xn]```", to output the hash.
    Upon issuing that instruction, the CC transitions to state _completed_ with no error.
--
+
If `VLEN` is larger than `b`, the most significant bits of `Vs` beyojnd the `b`-th (i.e., the "tail" of the vector) are ignored.


 ** In any state, issuing any Form of ``ace.exec`` that is not the allowed one will produce a null output and the CR will be *invalidated*.


[.darkred]#Fill missing example#



[[ACE-hash-functions]]
==== Hash and MAC Functions (Including XOF Variants Thereof)

We now define an interface for hash and MAC functions.
Because of the vast veriety of such functions, we cannot define a completely general interface.
However, the interface defined here is sufficiently general to allow to describe most commonly used and standardized functions, such as
the SHA2, SHA3, SHAKE, and BLAKE families, as well HMAC keyed constructions.
(((ACE, algorithm, general hashing)))
(((ACE, algorithm, MAC functions)))
(((ACE, algorithm, XOF)))

===== Specification

Parameters:::

* `b` = block size in bits (8|`b`) -- this is the size of an absorbed block and may be different from the size of the internal state that is kept by the function.
* `n` = size of the internal state that is kept by the function (8|`n`).
Either the block size is an integer multiple of the vector length or the vector length is an integer multiple of the block size.
* `k` = key size in bits (8|`k`) -- only if keyed, i.e., a MAC.

Data Structures:::

* *Configuration Input*:
[lowerroman]
 . `key`: `k/8` bytes -- Only if keyed, i.e., a MAC.

* *Internal State*:
 ** `key`: `k/8` bytes -- Only if keyed, i.e., a MAC.
 ** `hash_state`: algorithm specific length.
 ** `last_block_len` -- Only if this Hash/MAC has special internal treatment for a fractional last block that goes beyond padding and appending the length, which are handled by user software  (field size at most two bytes).
 ** `used_VLEN` -- Current vector length in bits (up to MAXVLEN).
 ** `partial_len` -- Length of absorbed data so far for the current block (field size at most two bytes).
 ** `partial_block`: `b/8` bytes (a priori we cannot know whether `b > VLEN` or not, and changing the internal memory requirements of a CC depending on the `VLEN` can lead to memory exhaustion).

* *Serialized Content*:
[lowerroman]
 . `key`: `k/8` bytes -- Only if keyed, i.e., a MAC.
 . `hash_state`: : `n/8` bytes.
 . padding: 2 bytes.
 . `used_VLEN`:  `2` bytes -- Current vector length in bits (up to MAXVLEN).
 . `last_block_len`: `2` bytes -- Only if this Hash/MAC has special internal treatment for a fractional last block that goes beyond padding and appending the length, which are handled by user software. Otherwise, this is zero.
 . `partial_len`: `2` bytes -- Length of absorbed data so far for the current block.
 . `partial_block`: `b/8` bytes -- We include it only if there is a partial block, and exclude it when not.
 We reuse the most significant bit of the `state` field to store this information.
 (In theory, we could include only the part filled so far, but this would complicate the parsing of a SCC.)

Algorithm-Specific Functions:::

* `process_block(p)`: process block `p` into the hash or MAC.

State Machine:::

* *States:* _initial_ (0), _hash_absorb_ (1 or 9), _hash_last_block_ (5 or 13), _hash_finalize_, and _completed_ (15).
The values 9 and 13 are used when there is a partial block.
* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_.
 **  If the algorithm has a special treatment for the last block, either if it is partial or always, then
  *** _hash_absorb_ ->  _hash_last_block ->  _hash_finalize_ -> _completed_.
  *** else _hash_absorb_ ->  _hash_finalize_ -> _completed_.
 ** From any state to state _initial_.

* *Behavior:*
 ** In state _initial_:
  *** `last_block_len`, `partial_len` and `partial_block`` are set to zero.
  *** `hash`: the initial value is set as specified by the algorithm.
  *** `used_VLEN` is set to the current vector length.
  *** Any `ace.exec` will result in the CR being *invalidated*.

  ** In each state except _initial_, before performing any operation except `ace.import`, `ace.export`, and `ace.clone`, `used_VLEN` is compared to `VLEN`.
  If there is a mismatch, the CR will be *invalidated* and any operation will result in an invalid instruction exception.

  ** In state _hash_absorb_, we can only issue instructions ``ace.exec`` of Form B, i.e., "```ace.exec Ln|L[Xn],Vs```", to absorb the data block `Vs` into the hash:
  *** If `VLEN` is a multiple of `b` (including the case where `VLEN` = `b`), then `process_block` is applied to each `b`-bit segment of `Vs`.
  *** If `b` is a multiple of `VLEN` and `b` > `VLEN`, then
   . `Vs` is written to `partial_block` starting at byte offset `partial_len`.
   . `partial_len <- partial_len + VLEN`.
   . if `partial_len = b`, then
   .. `process_block` is applied to `partial_block`,
   .. `partial_len <- 0` and `partial_block` is cleared.

 ** Upon issuing `ace.state Ln|L[Xn],#ace_last_block, Xs` where `Xs` contains the length of the last block in bits, following happens:
+
--
 . if `partial_len` <> 0, then the CR is *invalidated*. (The previous block is not complete.)
 . if `Xs > b`, then the CR is *invalidated*.
 . if `Xs = 0`, then the CR is *invalidated*.
 . `last_block_len <- Xs`.
--
+

 ** In state _hash_last_block_:
  *** if `last_block_len` = 0, then the CR is *invalidated*.
  *** If `VLEN` is a multiple of `b` (including the case where `VLEN` = `b`), then
      we only issue a single ``ace.exec`` of Form B, i.e., "```ace.exec Ln|L[Xn],Vs```", to absorb the least significant `b` bits of data block `Vs`.
  *** If `b` is a multiple of `VLEN` and `b` > `VLEN`, then we can one or more instructions ``ace.exec`` of Form B, i.e., "```ace.exec Ln|L[Xn],Vs```", to absorb the data block `Vs` into the hash, i.e. "```ace.exec Ln|L[Xn],Vs```":
   . if `partial_len < b`, then
   .. The instruction must be of Form B, else the CR is *invalidated*.
   .. `Vs` is written to `partial_block` starting at byte offset `partial_len`.
   .. `partial_len <- partial_len + VLEN`.
   . else if `partial_len+VLEN = b`, then the CR is *invalidated*.

  ** In state _hash_finalize_:
   *** If the function is a XOF, then
       we can issue an arbitrarily large number of ``ace.exec`` of Form C instructions, i.e., "```ace.exec Vd,Ln|L[Xn]```", to output the hash.
       This can be done with any of the two mechanisms below, except that the state never transitions to _completed_.
   *** If `VLEN` is a multiple of `b` (including the case where `VLEN` = `b`), then
      we only issue a single ``ace.exec`` of Form C, i.e., "```ace.exec Vd,Ln|L[Xn]```", to output the hash.
      The value is, if necessary, finalized, before being output.
      The state is then changed to _completed_ with no errors (unless the algorithm is a XOF).
   *** If `b` is a multiple of `VLEN` and `b` > `VLEN`, then we can issue one or more instructions ``ace.exec``of Form C, i.e., "```ace.exec Vd,Ln|L[Xn]```", to output the hash:
    . Upon entering state _hash_finalize_, `last_block_len` is reused to store the length of the output hash (in any case `b` if the algorithm is a XOF).
    . After each "```ace.exec Vd,Ln|L[Xn]```":
     .. We write a new block of the final value of the hash function to `Vd`, with the caveat that if `last_block_len` is non zero, but strictly smaller than `VLEN`, the value in `Vd` is accordingly truncated and zero-padded.
     .. `last_block_len <- max(last_block_len - VLEN, 0)`
     .. if `last_block_len` = 0 then the state is changed to _completed_ with no errors, unless the algorithm is a XOF, in which case the internal state is updated again, `last_block_len <- b`, and more "```ace.exec Vd,Ln|L[Xn]```" instructions can be issued.

 ** In any state, issuing any Form of ``ace.exec`` that is not the allowed one will produce a null output and the CR will be *invalidated*.

NOTE: The description of states _hash_absorb_ and _hash_finalize_ should make it clear that allowing `b` and `VLEN` to be in relations other than one being an integer multiple of the other, as well as allowing a change of `VLEN`, would significantly complicate the state machine.

[[ACE-Ascon]]
==== Ascon Specific Rules

We now describe the state machines of the various Ascon-based algorithms standardized in [.darkred]#TBD#.
(((ACE, algorithm, Ascon)))

===== Ascon-128 and Ascon-128a authenticated ciphers

[.darkred]#TBD#

===== Ascon-Hash cryptographic hash

[.darkred]#TBD#

===== Ascon-Xof extendable-output function

[.darkred]#TBD#

===== Ascon-80pq cipher with the increased 160-bit key

[.darkred]#TBD#

// //////////////////////////////////////////////////////////////////////////////////////////

[[ACE-examples]]

=== Examples

==== Context Switching

[.darkred]#TBD.#

==== VM Migration

Users may migrate their virtual machines (VMs) between client devices with CPUs from different silicon providers—a practice already common when moving interrupted VMs between Intel and AMD systems. In such a scenario, the ACE implementation on the destination device might have a Register File (LF) with a smaller capacity (not necessarily a smaller internal memory, as the internal representation may be more redundant). System software could then be unable to restore all cryptographic contexts.

To address this, the `acelazy` CSR to enables lazy context reloading by causing the hart to trap to the parent mode if a CR being accessed is marked as "lazy", i.e., the corresponding bit in `acelazy` is set.  When this requires freeing one or more CRs first, system software decides which contexts to evict.

The same mechanism can also support lazy loading of contexts during ordinary context switches.

==== Key Management and Provisioning Applications

Software environments that implement key management operations for other domains require their own RCSK. A system may contain multiple such software environments.

A Key Management Applet (KMA) will

[arabic]
. Generate or retrieve a key matching a request.
. Configure a CR with this key and its associated metadata.
. Export this CR to a SCC in memory.
. Relinquish control to the MM.

The MM, which controls the CSK, can the

[arabic, start=5]
. Set the RCSK to the KMA’s RCSK.
. Re-import the SCC into a CR
. Change the RCSK to match the requester domain's RCSK.
. Export the key for the Requester's use.
. Relinquish control to the Requester.

This is the most generic approach and allows each piece of software to use a CR of choice to generate CCs and import SCCs.
Furthermore, it protects the key from other SW environments that may be crossed while transferring control between the Requester process, the MM, and the Key Management application.

// Various optimizations are possible, which can be interesting for embedded environments: Steps 3., 5., and 6. can be omitted if the CR used for these operations is fixed and no intermediate SW environments modify that CR.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-V-dependency]]
=== Dependency on the V Extension

While ACE can be implemented with the V extension as a requirement, we note that ACE actually depends on a minimal subset of the RISC-V Vector Extension (RVV), which we call RVV-mini, for correct operation.
Required features include:
(((RVV-mini)))

* Support for vector registers sufficiently wide to host the block-wise operations required by the algorithms supported by ACE;
* The `vsetvli` instruction with restricted parameters (e.g., "```vsetvli zero,4,e32,m1,ta,ma```" for 128-bit-side operations); unsupported configurations must generate defined errors;
* Unit-strided vector loads and stores exclusively; and
* Vector bitwise logical operations such as `vxor`, `vand`, and `vor`.

Moreover,

* floating-point, fixed-point, and most arithmetic vector operations are not required, and
* more complex operations for some corner-case cryptographic algorithms may be performed in GPRs, with results then inserted in vector registers via `vins`/`vext`.

RVV-mini must maintain full opcode compatibility with RVV to guarantee that ACE code runs unmodified on full RVV implementations.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-threat-model]]
=== Threat Model

The ACE threat model is straightforward.

**Assets** consist of _keys_ and any other information that could aid an adversary in recovering plaintext or forging ciphertext. This includes items such as masks in tweakable XEX modes and derived keys in AES-GCM-SIV. The critical properties of these assets are their _confidentiality_ and _integrity_.

**Adversaries** are assumed capable of compromising processes by exploiting software vulnerabilities.
They are also able to gain access to memory contents, for instance, by abusing hardware interfaces or by SoC/memory interposition.
The model does not include adversaries capable of sophisticated hardware attacks, such as using
a Focused Ion Beam/Scanning Electron Microscope (FIB/SEM) to tamper with the hardware's functionality.

Side channel attacks are addressed optionally. ACE offers interfaces to both SCA unprotected and protected implementations of cryptographic algorithms, if these options are provided by the designer.

Threats can be addressed in four ways:

[horizontal]
**C:**:: _Control_ the threat by implementing full or partial mitigations.
**A:**:: _Accept_ the threat and its associated risks.
**T:**:: _Transfer_ the threat to another party better suited to address it.
**S:**:: _Suppress_ the features that give rise to the threat.

ACE is designed to avoid the "***A***" and "***S***" options (as much as possible). It _controls_ threats through its own mechanisms and _transfers_ residual risk—specifically, the risk of key extraction from the privileged or trusted software and hardware environments that manage keys—to those same environments. For example, trusted software environments may employ control-flow integrity, memory encryption with integrity protection, and anti-replay mechanisms, while hardware key-management blocks can be hardened to protect entrusted keys.

Direct plaintext leakage, memory corruption attacks against the ACE-using process, and Release of Unverified Plaintext (RUP) attacks on the cryptographic algorithms are considered out of scope. These threats cannot be mitigated by ACE because the processed information resides within the user process domain. Consequently, these threats are _accepted_.

// ///////////////////////////////////////////////////////////////////////////////////////////

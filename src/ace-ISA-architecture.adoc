[[ACE-architecture]]
== Architecture

[[ACE-concepts]]
=== Fundamental Concepts

Opaque Key:::
The fundamental concept of ACE is the _opaque key_, i.e., a cryptographic key whose value remains hidden to software even while being used in cryptographic operations.

Cryptographic Context:::
ACE implements the concept of opaque key through _Cryptographic Contexts_ (CCs), architectural containers that protect sensitive information.
Each CC consists of a *metadata section* and of a *content section*.
The metadata section defines the cryptographic algorithm and optional usage policies, while the content section comprises sensitive material—including keys, other secrets, and internal algorithm state.
The confidentiality and integrity of CC content is enforced by restricting modifications and access to architectural mechanisms that enforce rules defined by the configured algorithm.

Object-Oriented Architecture:::
CCs are _objects_ that may expose a uniform interface despite implementing different algorithms.  A CC (or SCC) encapsulates its own behavior, allowing, for instance, AES-128, AES-256, Калина-128, Калина-256, and SM4 instances in ECB mode to be used interchangeably without code changes.  Similarly, modes such as GCM-SIV or XEX/XTS, that can be instantiated with any of these algorithms would also offer the same binary interface, as long as the code supports variable SCC sizes, which can be dynamically discovered. Side-channel-resistant variants would also be supported transparently.

Sealed Cryptographic Context:::
Only the ACE implementation can access CC content.
For protection outside the architectural state, a CC can be exported as a _Sealed Cryptographic Context_ (SCC), i.e., an encrypted and authenticated package containing metadata, a nonce, and authentication tag, and encrypted content.
SCCs can be reimported into CCs when needed.
These operations use a _Context Transport Key_ (CTK).
The most commonly used CTK is the _Root Context Transport Key_ (RCTK), which is stored in an MM-only CSR.
MM manages the RCTK unless it is hardwired or hardware-generated.
Besides the keys in a CC, also the keys in an SCC are called _opaque keys_.

Usage Control Policy:::
An important distinction in ACE is between the _import_ and _export_ operations on CCs, and the _use_ of CCs in cryptographic operations.
It must be always possible to import and export SCCs, and also to clear and overwrite CCs for the purpose of managing cryptographic operations, otherwise a process may be prevented from performing cryptographic operations by clobbering all the CCs.
Therefore, the _Usage Control policies_ in the metadata section may optionally restrict only the operations that perform algorithms that are configured by a CC's metadata, including modifying its state, to specified Modes, ASIDs and VMIDs.

Locality:::
In addition to Usage Control policies,
ACE can bind opaque keys to a _Locality_, restricting their usage to a specific device, device class, software or hardware configuration, or boot cycle.
This binding uses both metadata and a _Derived CTK_ (DCTK) derived from the RCTK and a Locality-specific secret via a key derivation function for the purpose of importing and exporting opaque keys.
The system maintains a _Locality Secrets Table_ (LST) containing both system-wide values which are fixed, values that can be configured in an externally defined way,
and fields that can be programmed by MM.
The metadata stores the Locality as an index into this table. See <<ACE-Localities>> for more details.

// ///////////////////////////////////////////////////////////////////////////////////////////

<<<

=== ACE Programmer's Model

[[ACE-instructions-overview]]
==== Instructions Overview

ACE provides a number of unprivileged instructions.
Some are implemented as CSR reads or writes.
The non-standard notation `C[Xd]`, for a GPR Xd refers to the CC whose number is contained in `Xd`,
and `Cn|C[Xn]` means that there are two different encodings for when the operand is `Cn` or `C[Xn]`.

.The ACE instructions
[width="100%",cols="16%,24%,60%",options="header",subs="+macros"]
|===
| Instruction     | Operands                        |  Description
| `ace.enable` +
`ace.disable`     |                                 |  Enables/Disables the feature in the current mode.  CSRW pseudo-operation.
| `ace.init`      | `Cd\|C[Xd], %offset(Xs)`         |  Sets the metadata and key(s) for the CC.
| `ace.clear`     | `Cd\|C[Xd]`                      |  Clears a CC and marks it as no longer in use and clean.
| `ace.export`    | `%offset(Xn), Cs\|C[Xs]`         |  Securely exports the content of a CC to memory.
| `ace.import` +
`ace.import.S`
| `Cd\|C[Xd], %offset(Xn)`      |  Authenticates and imports a SCC from memory into a CC. +
 `ace.import.S` provides optional support for system defined formats.
| `ace.exec`
| A. {nbsp}{nbsp} `Vd, Cn\|C[Xn], Vs` +
  B. {nbsp}{nbsp} `Cn\|C[Xn], Vs` +
  C. {nbsp}{nbsp} `Vd, Cn\|C[Xn]` +
  D. {nbsp}{nbsp} `Cn\|C[Xn]`
| Performs a cryptographic operation. The instruction may also modify the internal state of the CC. This instruction admits four _forms_, depending on whether it accepts an input or not, and whether it produces an output or not.
| `ace.size`
| `Xd, Cs\|C[Xs]` +
 `Xd, Xs`          |  Returns the size in bytes of the package exported from a specified CC, or from a metadata block.
| `ace.available` | `#immed`                          |  Informs whether a given algorithm is supported by the microarchitecture.
| `ace.clone`     | `Cd\|C[Xd], Cs\|C[Xs]`            |  Clones a CC into a second CC.
| `ace.derive`    | `Cd\|C[Xd], Cs\|C[Xs]`            |  Optional. Uses the source CC to configure the destination CC. Used if the source CC is, for instance, a KEM that configures the destination CC with a symmetric key. Then, the SW can clear the source CC to release resources.
| `ace.state` +
`(ace.dir)`
| `Cd\|C[Xd], #immed` +
`Cd\|C[Xd], #immed, Xs`  |  Triggers transitions in the state of the algorithm (such as the different stages of hash functions or modes of operation) or provide additional information.  `ace.dir` is an alias for `ace.state`.
| `ace.restrict` +
  `ace.harden`    | `Cd\|C[Xd], Xs`                  |  This instruction is used to narrow the Usage Policies of a CC and to turn on or increases the level of the side-channel protection of the algorithm in the CC, if the microarchitecture supports it.
  Removing or weakening existing Usage Policies and reducing the level of side-channel protection are not permitted.
   `ace.harden` is an alias for `ace.restrict`.
| `ace.input`     | `Cd\|C[Xd], %offset(Xs)`         |  Optional. Provides an input to the algorithm configured in the CC `Cd` or `CC[Xd]`, in place of providing it through the `ace.exec` instruction. Useful when the inputs are very long, such as the inputs to certain public key schemes. Mandatory only if required by some algorithms.
| `ace.output`    | `%offset(Xd), Cs\|C[Xs]`         |  Optional. Writes the output of an algorithm configured in the CC `Cs` or `CC[Xs]`, in place of providing it through the `ace.exec` instruction. Useful when the outputs are very long, such as the outputs of certain public key schemes. Mandatory only if required by some algorithms.
| `ace.error`     | `Xd, Cs\|C[Xs]`                  |  A CC Cs (or indexed by Xs) may be in an error state due to the previous operation. The error value is written into GPR Xd.
|===

NOTE: Instructions `ace.init`, `ace.import`, `ace.export`, `ace.input`, and `ace.output` perform direct memory accesses.
This does not violate the RISC-V load/store architecture principles, as ACE is architected as an _attached_ unit, which may have its own interfaces.

// ///////////////////////////////////////////////////////////////////////////////////////////

==== Cryptographic Contexts

The atomic cryptography extension does not add a traditional register file.
Rather, it defines 32 Cryptographic Contexts (CCs) for storing cryptographic keys and metadata.
Each CC is identified by a number from 0 to 31, which the ACE unit uses to access its contents.

Cryptographic Contexts (CCs) reside in a dedicated internal _context file_ (CF) that is inaccessible to any entity outside the ACE implementation, including software, other hardware blocks, and invasive debug interfaces. The CF's memory capacity is implementation-defined and may be as large as 32 times the size of the largest possible CC; however, a smaller amount of memory may be used in practice. At a minimum, the CF must be capable of holding either a single instance of the largest possible CC or the largest CC pair in which the first CC derives the second (via `ace.derive`).

The size of each CC is dynamic, determined by the cryptographic algorithm with which it is configured.
This is an important difference with respect to GPRs and vector registers, which always have the same size.
ACE returns an error ace_err_memory when insufficient memory prevents `ace.init` and `ace.import` operations, requiring the software to free memory by exporting or clearing a different CC. Implementations must provide sufficient CF memory to prevent infinite `ace.export`/`ace.import` loops.

A further difference between CCs and registers is that CCs
are not only addressable via static 5-bit immediate addressing (as normal registers), but also indirectly, i.e., via a value from 0 to 31 in any general-purpose register.
This has two major implications:

. Adding renaming to CCs would add significant complexity to the microarchitecture.
  However CCs are much less often redefined than, say, integer or floating point registers, except for internal implied changes, and therefore we can assume that CCs are not renamed without performance issues.
. An additional bit in the instruction encoding determines whether a CC number is given by a 5-bit immediate or by the value in a GPR.

[[ACE-registers]]
==== Registers

The atomic cryptography extension adds some unprivileged CSRs to a base scalar RISC-V ISA -- as well some privileged CSRs.
It also requires a subset of the V extension to be implemented, including the vector register file.

[[ACE-CSR-enable]]
===== aceenable

`aceenable` is a single-bit CSR.

Enabling ACE in any mode is done by writing a 1 to `aceenable`.
Disabling ACE is done by writing a zero to `aceenable`, which also clears the CCs, as described in <<ACE-tracking-cc-dirtiness>>.

While the standard floating-point and vector extensions do not support User Mode disable/enable instructions, the ACE unit can be enabled and disabled in User Mode, instead of using an OS call or trapping.
However, if the ACE unit contains state from a different process, and its interface is disabled for the current one, enabling it will trap to the Supervisor (as described in <<ACE-ACES-field>>) to allow the latter to first save the state in case it was not saved before and then clear it (lazy context switch).

When a process that has ACE enabled is preempted, the parent modes inherit the state to be able to export and
re-import the CCs. Hence, `aceenable` is not cleared, and the `*status.ACES` fields (see <<ACE-ACES-field>>) of the parent domains will take the value Enabled.
Tracking the CCs which are active, resp., dirty is done on an individual basis and is described in <<ACE-tracking-cc-dirtiness>>.


[[ACE-ACES-field]]
===== ACES field in *status

An ACE context status field, ACES, is added to `mstatus`[26:25], and it is shadowed in `sstatus`[26:25] and in `vsstatus`[26:25] if the hypervisor extension is present.
Like the FS and VS fields, it can be used to optimize context switching.
//Its status encoding differs from the FS, VS, and XS fields (which are defined in <<fsxsencoding>>).
Its possible values are described in <<ACE-fsxsencoding>>.

[[ACE-fsxsencoding]]
.Encoding of ACES status field
[float="center",align="center",width="100%",cols="^7%,<18%,<75%",options="header"]
|===
|Status |Name |Meaning
|   0   | Disabled-Clean     | ACE ISE not enabled, software assumes no context being configured for this hart. +
The ACE unit will erase all contexts if ACE is enabled by writing to the `aceenable` CSR.
|   1   | Disabled-Clobbered | ACE ISE not enabled, software assumes there are configured contexts left for this hart from other environments.
The hart will trap if ACE ISE is enabled by writing to the `aceenable` CSR. To be used only if explicitly supported in system SW stack, otherwise Disabled-Clean must be used.
|   2   | Enabled            | ACE ISE enabled.
|   3   | Invalid            | Reserved.
|===

The Disabled-Clean and Disabled-Clobbered states are set by the parent mode.
Disabled-Clobbered is used when the parent-mode software stack does not save Cryptographic Contexts before transferring control to a process that does not (yet) have enabled ACE. If that process later enables ACE by writing to `aceenable`, the hart traps to the parent mode, allowing lazy context save; the parent must then manually reset all Cryptographic Contexts. In contrast, a software stack that always saves the contexts of a switched-out process must configure only the Disabled-Clean state.
The Disabled-Clobbered state is primarily intended for small devices where thread migration between harts is infrequent, and possibly only one process may be dealing with cryptographic operations.

NOTE: It is responsibility of the exception handler to properly handle the contents of the CCs when the feature is enabled while ACES=Disabled-Clobbered, as described in <<ACE-tracking-cc-dirtiness>>.

Writes to ACES do not affect the contents of the CCs.
Setting ACES=Disabled-Clean or Disabled-Clobbered does not destroy the state, nor does setting ACES=Enabled clear the contents.

Fine-grained tracking activeness and dirtiness of individual CCs uses the `aceccactive` and `aceccdirty` CSRs, cf.{nbsp}<<ACE-tracking-cc-dirtiness>>.

===== aceerror

The `aceerror` CSR contains only as many bits as needed to encode the error status.

// All other bits are reserved for future use.
// It is not a complete analogue of `fcsr` or `vcsr` since, for instance, it does not have to encode information such as rounding modes.
// Also, the error status is a field and not a set of distinct condition codes.

[[ACE-tracking-cc-dirtiness]]
===== Tracking CC dirtiness

This is done by using two CSRs, which track the use and dirtiness of the CCs individually:

[arabic]
. `aceccactive`: 32 bits, with a bit per CC to denote whether the register is in use or not (cleared contextually to CC erasure to dispose of the key). Read-only.
. `aceccdirty`: 32 bits, with a bit per CC to track whether the corresponding CC has been modified since the last time the same bit has been cleared. +

If the _i_-th bit of `aceccdirty` is set, then the _i_-th bit of `aceccactive` must also be set.

Two types of actions can modify a CC and thus must update also `aceccdirty`:

* An explicit initialization/configuration/import; and
* Certain cryptographic operations, such as absorbing information in a hash function, that modify the internal state.

It is also possible to directly write to `aceccdirty` to optimize context switching.

Implementations are required to track the dirtiness of any CC precisely and individually.
This is different from the tracking of the dirtiness of the floating-point state, for instance.

Context-switching code must save CC number _i_ if the _i_-th bit of `aceccdirty` is set.
However, it can clear `aceccdirty` when returning control to the same process after restoring its ACE state.
This indicates to the context-switching code that there is no need to save the CC number _i_ again at the next context switch out of that process unless it has been modified again thus setting the _i_-th bit of `aceccdirty` anew.

Upon a write to `aceenable` that changes its value, the following happens to `aceccvalid` and `aceccdirty`:

* If ``aceenable``'s value is changed to 0, then all CCs are cleared, both `aceccvalid` and `aceccdirty` are set to 0, and ``*status.ACES`` is set to Disabled-Clean.
* If ``aceenable``'s value is changed to 1, and if the parent domain's ``*status.ACES``=Disabled-Clean, then we simply assume that the parent process has cleared the CC and set both `aceccvalid` and `aceccdirty` to 0 before transferring the control flow to the current process.
* If ``aceenable``'s value is changed to 1, and if the parent's ``*status.ACES``=Disabled-Clobbered, then the hart traps to allow the parent domain responsible for handling context-switched to finish saving the state and ensure that both `aceccvalid` and `aceccdirty` are set to 0, and finally set ``*status.ACES``=Disabled-Clean.
// [.red]#This behavior should be restricted only to User mode.#

[[ACE-ccstart-definition]]
===== ccstart

`ccstart` is an XLEN-bit CSR that serves a similar role in ACE as `vstart` does in the V extension.

The instructions `ace.init`, `ace.import`, `ace.export`, `ace.input`, and `ace.output` may require significant execution time and can be interrupted mid-instruction by interrupts or memory exceptions.
In such cases, implementations may set `ccstart` to a non-zero value, enabling the instruction to resume from the interruption point rather than restart from the beginning.
Since ACE does not have the concept of the length of an element,
`ccstart` represents a byte offset rather than an element index as in `vstart`.
Specifically, a load-type instruction was interrupted after reading _and_ processing `ccstart` bytes of input in the state, and a store-type instruction was interrupted after computing and writing `ccstart` bytes of output.

NOTE: The `ccstart` value is given in bytes, even though payload sizes are always multiples of 8 bytes. This design accommodates piecewise execution via traps for the `ace.init`, `ace.clear`, `ace.export`, `ace.import`, `ace.input`, and `ace.output` operations, which involve `mv` operations at long-word, quad-word, or vector-register granularity, cf.{nbsp}<<ACE-trappable-insns-support>> for more details.
This is also compatible with the fact that `ace.size` returns a size in bytes.

Like `vstart`, `ccstart` is a standard read/write CSR; however, software must not write arbitrary non-zero values to it.
Normally, hardware sets this register on trap.
Software may safely write 0 to restart operations completely, and the register can be saved and restored during context switches.
Writing an arbitrary non-zero value may raise an illegal-instruction exception, as hardware is not required to support all values.
If no exception is raised and an invalid value is written, authentication will fail upon import because portions the content are replaced with arbitrary values, or exports will produce unauthenticatable output.  Only `ace.init` may still create a valid context, but since the key values were already in plaintext within the same domain, this does not expand the attack surface.

Only the instructions explicitly mentioned above support non-zero `ccstart` values; other ACE instructions ignore this register if set by software, and will be restarted.

[[ACE-why-restarting,Remark {counter:remark}]]
*Remark {counter:remark}.*
_A single `ccstart` value suffices due to the authenticated encryption algorithm used. The operations behave as follows:_

* `_ace.init_` _is a single-pass operation: the metadata section is read first, determining the payload length. If sufficient memory is available, subsequent blocks are read sequentially and passed to a deserialization circuit to populate the CC._
* `_ace.import_` _operates similarly to `ace.init`: the metadata section is read first to determine the payload length. If sufficient memory is available, the remaining blocks are read, decrypted, and passed to a deserialization circuit to populate the CC._
* `_ace.export_` _involves two passes, but the first pass is entirely internal to the ACE unit. Hence, the first pass cannot cause a page fault, and is easily restarted. Specifically, it computes the SIV by applying POLYVAL to the serialized CC content. Subsequently, the serialized metadata, the nonce, and the SIV are written out, followed by the CC content serialized, encrypted and written out block by block. It is this last part that may cause page faults, and that may require resumption._

_Although these operations are inherently complex, the ACE unit is architected to function like a separate machine executing simpler instructions sequentially. State machines (one per CPU hart connected to the ACE unit, potentially in a 1-to-1 configuration) receive commands from the CPU and break them into smaller steps._

_Therefore, separating data transfer from cryptographic operations in import/export is unnecessary. Otherwise, the loaded payload would need to be stored within the ACE unit rather than processed inline with minimal overhead, and this may lead to higher internal resource requirements_

_Finally, resuming requires at least as many cryptographic operations as restarting if the trapped domain also saves and resumes partial SCCs. Memory accesses may be reduced, but since data read from memory initially (for `ace.init` or `ace.export`) may no longer reside in the caches, resuming may offer better performance on some systems. Additionally, resuming avoids potential circular page-fault issues, as opposed to restarting._

[.red]#*TBD* Specify the exact semantics of `ccstart` and define the points at which various operations can be interrupted.#

===== Reuse of ASID and VMID (to be verified).

We reuse the CSRs for `ASID`, resp., `VMID`
(i.e., the CSR fields `satp`.ASID and `hgatp`.VMID).
to give only certain User processes and Supervisor processes access to certain key spaces.
The maximal bit length of `ASID` is 9 for Sv32 addresses or 16 for Sv39, Sv48, and Sv57 addresses.
The maximal bit length of `VMID` is 7 for Sv32x4 or 14 for Sv39x4, Sv48x4, and Sv57x4 addresses.
In the metadata section, `ASID` and `VMID` are always zero padded to the maximal lengths of 16 and 14 bits, respectively.

[.red]#However, we need a mechanism to make sure that if the system is not configured to insert `ASID`, resp., `VMID` into the GVAs/GPAs, we can still usage them for the purpose of policing the usage of CCs.#

[[ACE-providing-keys,Remark {counter:remark}]]
*Remark {counter:remark}.* _The software in each World/Supervisor Domain is normally responsible to generate or obtain their own keys, and if a process (applet) in one World/Supervisor Domain is responsible to provide keys to other Worlds/Supervisor Domains, it is the responsibility of the MM to perform an appropriate sequence of import, switch the CTK, then export operations._


===== Privileged Registers

====== ACE field in misa

The `misa.ACE` field uses bit `L` (11) to indicate that the ACE extension is implemented.
//This bit is chosen because the extension goes _beyond_ the cryptographic extension, which will likely use bit `K` (10).

====== acerctk

If the RCTK can be programmed, it can only be programmed by MM.
For this purpose, we need eight 32-bit CSRs are available, called `acerctk0`, `acerctk1` .. `acerctk7`, where register `acerctk{i}` contains bits [stem:[31+32\,i:32\,i]] of the RCTK.
No exception is raised if software running in any other mode tries to write to the `acerctk` block, such writes are simply ignored.
The `acerctk` block always reads as zero.

NOTE: Discoverability of whether the RCTK can be configured or not is not critical, since this is information known by the MM firmware.
[.red]#We can use the data structure pointed by `mconfigptr` in order to track optional features of ACE including whether the `acerctk` CSR block is implemented, and if not whether whether the value is ephemeral or fixed.# +
 +
User mode, and even operating systems and hypervisors, need not be aware of the `acerctk` block. Other mechanisms could have been chosen to program the CTK, such as an MM-exclusive dedicated hardware interface or memory-mapped interface.

====== Re-configurable Localities

Two groups of four consecutive 32-bit CSRs, programmable by MM, are used to define two reconfigurable Localities
(cf.{nbsp}<<ACE-concepts>>).
These groups are:
`ace_OS_Secret{i}`, for `i` in [0..3], to configure the "OS Secret" entry,
and `ace_Boot_Session{i}`, for `i` in [0..3], to configure the "Boot Session" entry (cf.{nbsp}<<ACE-Localities>>).

The reason `ace_Boot_Session*` must be reconfigurable is that it must change in a VM if the latter's virtual hardware is re-booted, and this can happen independently from the underlying host and other VMs. For instance, a VM may be frozen, then the host may be rebooted, and then the VM may be resumed, in which case no boot session occurred in the VM, while it happened in the host hardware.

NOTE: User mode, and even operating systems and hypervisors, need not be aware of the `ace_OS_Secret{i}` and `ace_Boot_Session{i}` blocks. Other mechanisms could have been chosen to program the "OS Secret" and  "Boot Session" entries, such as an MM-exclusive dedicated hardware interface or memory-mapped interface.

==== Data Structures

ACE defines two distinct representations of cryptographic information: the CC configuration format, and the encrypted, authenticated SCC format. These two  formats are architected for software portability and interoperability.
//, enabling virtual-machine migration across heterogeneous hardware—for example, between cloud or consumer devices with CPUs from different vendors.
The internal CC representation, on the other hand, is implementation-specific.

All data formats are little-endian.

NOTE: Mechanisms for persisting Context Transport Keys (CTKs) across reboots or transferring them between devices are outside the scope of the present ACE architecture. These are system-specific and belong to MM firmware. For cross-device migration, the use of a public-key key-encapsulation mechanism (KEM) is recommended.

[[ACE-metadata]]
===== Metadata Section Format

The metadata section is 64 bits long and its format described in <<ACE-metadata-standard>>.
This format is used for CC initialization, export and import purposes.
The internal representation is implementation specific.
// To initialize a CC, the first 64 bits of the input buffer contain the metadata in entirely in cleartext.
// The metadata is in cleartext also in exported SCCs.
// The entire metadata section is included in the computation of the authentication tag.
// The details are described in <<ACE-formats>>.

[#ACE-metadata-standard]
.Format of the Metadata Section
[width="100%",cols=">9%,^7%,17%,67%",options="header"]
|===
|   Field | Width | Name                  | Description
|     [0] |   1  | Format                 | 0 for the current metadata format. +
Future format will have a 1 in this position and may be longer than 64 bits.
|   [8:1] |   8  | Algorithm              | Algorithm (such as primitive or mode). 0 means the CC is invalid.
|  [10:9] |   2  | SC_Protection          | Level of Side Channel Protection, encoded as per <<ACE-SC-protection-levels>>.
| [12:11] |   2  | Direction_Policy       | Determines whether the CC may be used for encryption (bit 11 set), decryption (bit 12 set), or both (bits 11 and 12 set).
Valid only for encryption/decryption primitives or modes, and ignored, for instance, for hash functions.
| [14:13] |   2  | Key_Type               | By explicit value / Immutable (index) / Internally generated.
| [16:15] |   2  | Completion             | Defined in <<ACE-CC-complete>>.
Used to determine whether an operation must be restarted.
| [20:17] |   4  | Stage (also Direction) | Encoding the current state of the state machine of the algorithm as a number (also called the "stage" of the algorithm).
The value must be zero in the initialization data, but, internally, it can be changed immediately by the algorithm.
If the algorithm encoded in the CC has at most 14 states (and possibly state _completed_, cf. <<ACE-stage-constants>>), then this number is stored in this field, cf. <<stage-field>>,
otherwise an algorithm-specific representation is used in the content, and this field only admits the values 0 (initial), 14 (invalidated), 15 (completed) or 1 (anything other operational state). The values must conform to <<ACE-stage-constants>>.
|    [21] |   1  | Reserved               | Undefined.
| [25:22] |   4  | Locality               | Field which is either -1 or an index into the Locality Secrets Table.
| [29:26] |   4  | UC_Policy_1            | "UC Policy" means "Usage Control Policy". +
Disallow the _usage_ of this CC in User, (Virtual) Supervisor, Hypervisor, resp., MM if bit 25, 26, 27, resp. 28, is set. Cf. <<stage-no-H-no-VMID>>.
| [31:30] |   2  | UC_Policy_2            | If bit 29, resp., 30, is set, then restrict the usage by `ASID`, resp., `VMID`. Restriction by `ASID` ignored if in S Mode or higher. Cf. <<stage-no-H-no-VMID>>.
| [47:32] |  16  | UC_Policy_3            | Zero if bit 29 unset, else `ASID` to enforce.
| [63:48] |  16  | UC_Policy_4            | Zero if bit 30 unset, else `VMID` to enforce. Cf. <<stage-no-H-no-VMID>>.
|===

Algorithms are encoded in a 8 bit field.
A zero in the algorithm field means the CC is invalid.
Algorithm numbers 1-127 are architecture-defined and the list of such encodings is maintained by RVI.
See <<ACE-Algorithms>> for the currently encoded algorithms.
Algorithm numbers 128-255 are reserved for custom algorithms.

[[ACE-SC-protection-levels]]
.Encoding of Side-Channel Protection levels
[float="center",align="center",width="76%",cols="^8%,<68%",options="header"]
|===
| Value | Description
|   0   | No protection.
|   1   | Data independent timing, first-order threshold implementation.
|   2   | Data independent timing, first-order threshold, fault tolerant implementation.
|   3   | Custom, algorithm dependent.
|===

Custom algorithms may offer stronger side channel protection guarantees than those specified in the encoding values 0 to 2.
In such a case, the value of the SC_Protection field must be set to 3.

[[ACE-key-type]]
.Encoding of Key Type
[float="center",align="center",width="76%",cols="^8%,<68%",options="header"]
|===
| Value | Description
|   0   | Explicit value.
|   1   | Internal table. System specific. For each algorithm as specified in <<ACE-Algorithms>>, the part of the content that normally contains the key(s) is replaced by a 64-bit value which is an index into the internal Immutable System Keys Table (ISKT) --- for both Configuration Input and the SCCs. The actual value of the key is never included in exported content. For threshold algorithms, ACE may copy the key material from the ISKT into the CC and expand it into multiple shares.
|   2   | Internally generated key. System specific.  In the Configuration Input, the part of the content that normally contains the key(s) is replaced by a "recipe" in a system-specific format. The format is not specified by the ISA and may not be portable to other systems. Once the key material has been internally generated, the value is included in the SCC as part of the content - not the "recipe" - as for any other key(s) for the same specified algorithm.  Even in the SCC, however, the Key_Type field of the metadata, both internally and in the SCC, will keep the value 2.
|   3   | Invalid.
|===

[[ACE-CC-complete]]
.Encoding of Completion field
[float="center",align="center",width="58%",cols="^8%,<50%",options="header"]
|===
| Value | Description
|   0   | No `ace.init`, `ace.input`, `ace.output`, `ace.import` or `ace.export` operation currently incomplete.
|   1   | `ace.init`, `ace.input`, or `ace.output` was interrupted.
|   2   | `ace.import` was interrupted.
|   3   | `ace.export` was interrupted.
|===

NOTE: The information in the Completion field is in principle known to the system software/firmware stack, we duplicate it into the metadata to ensure that it remains accessible after nested interrupts, i.e., after switching partially configured/imported or exported CCs in or out. While authentication also guarantees the integrity of the SCCs and of their import, this is both a robustness measure and serves to simplify system stacks.

// Whether the CC is complete (00) or interrupted while being configured (01), imported (10) or exported (11). Necessary to know whether to restart operations.

[[stage-field,Remark {counter:remark}]]
*Remark {counter:remark}.* _The "state" field accommodates modes of operation with a small number of states.
For algorithms with more complex state machines, machine state information can be stored in a custom data section of the CC._

[[stage-no-H-no-VMID,Remark {counter:remark}]]
*Remark {counter:remark}.* _If the H extension is not enabled, bit 27 must be set to 1, and bits 30 and [63:48] must be set to 0.
The "UC_Policy_4" field is 16 bits long for compatibility with architectures employing 16-bit `VMID` fields (for instance, in heterogeneous systems).
While interoperability cannot be guaranteed when this policy is used, this ensures that the two top bits are not used for other purposes. +
Filtering usage by Supervisor Domain or World ID is not supported, and not only because of lack of space in a 64-bit metadata section:
Reconfiguring the RCTK is a better approach for such isolation requirements, whereas isolation by `ASID` and `VMID` is a weaker security feature._

[[ACE-Localities]]
===== Localities

Internally, ACE keeps a table of 128-bit Locality Secrets (LS), the Locality Secrets Table (LST).
Some of these entries are fixed, other values may be configurable only using an implementation-specific authenticated hardware procedure, and the remaining may be programmed by MM (*Note:* _we need to define the corresponding CSRs_).
The LST is a global table shared across all ACE units with some fields which can be MM-programmed and are architectural (i.e., per hart).
//Currently, the only two values that may be overridden by architectural values, in order to support multiple VMs/Supervisor Domains/Worlds are System_Secret and Boot_Session.

If the Locality Field of a context (CC/SCC) is -1 (all ones), then the RCTK is used.
Otherwise, this value is used as an index _i_ in the HST, and a derived key computed from RCTK and LST[_i_] is used for import/export in place of the RCTK.
The encryption and authentication keys are then derived from the DCTK.

In <<ACE-binding-indices>>, we list the mandatory entries.
Column "MM-Config." indicates whether MM may be allowed to configure the entry.
We also specify the domain of each Locality Secret, i.e., whether the value is
chip-wide (should be the same across all chiplets in the same SoC, two distinct SoCs the same decide may have different values),
device-wide, or (usually) OS-wide.
//The first two Locality Secrets are chip-wide, and should be the same across all chiplets in the same SoC -- a separate chip in the same system may have different values.
//Three further Locality Secrets must be the same across the entire device, and the Locality Secrets at indexes 5 and 6 can be reprogrammed by MM.

[[ACE-binding-indices]]
.Mandatory Locality Values
[width="100%",cols="17%,49%,^8,^8%,^8%",options="header"]
|===
.>| Name .>| Description .>| Domain | MM-Config. .>| Value +
(Index)
| No Locality binding       | No CTK derivation. CC bound to Root CTK only. | -- | -- | -1 (15)
| Chip_Manufacturer         | Identifies the manufacturer of the SoC. Permanent. | SoC | N | 0
| Chip_Model                | Identifies specific chip model/family. Permanent. | SoC | N | 1
| OEM_Secret                | Provisioned by OEM to differentiate their products from the competition.
                              Can be permanent in a device — optional reconfiguration using impdef HW authenticated mechanisms. | Device | N | 2
| Product                   | Identifies device/system type/model (product). Not necessarily permanent. Reconfigurable like OEM_Secret. | Device | N | 3
| Device                    | Unique device (entire system) secret (not the device ID such as a serial number, but it can be derived from it, for instance by hashing).
                               Shared across all harts in a Soc and shareable across multiple SoCs in a single device. Sharing mechanism impdef, i.e., not architected.
                               Reconfigurable like OEM_Secret. | Device | N | 4
| OS_Secret                 | Identifies Operating System (or System Stack). +
                              Not permanent, must be configured during (virtual) boot. | OS | Allowed | 5
| Boot_Session              | Regenerated at each (virtual) boot. | OS | Allowed | 6
| Reserved                  | Reserved for future use (RZ if not defined). | Impdef | Impdef | 7-14
|===

The constant Localities_MAX is the maximum number of Localities supported by the system.

// [[ACE-virtual-reboot,Remark {counter:remark}]]
// *Remark {counter:remark}.* _We need to mention what to do in case there is a reboot of a VM.
NOTE: MM is responsible for virtualizing the OS_Secret and Boot_Session Locality Secrets.

// , since some VMs may reboot while others may not.
// Also, do we want to allow a VM to have a different virtual hardware? Or does it always declare the same configuration as the underlying hardware?_
// In principle, all this can be done by calling into MM. MM would need to keep track of the Locality binding values and ensure that they are updated correctly when necessary.

*Example*: _If a key's metadata specifies a Locality field value of "2", the key for import/export operations is derived from the RCTK and the "OEM Secret".
Consequently, while `ace.export` remains functional on the same device to support context switching, an `ace.import` of the resulting SCC on a device from a different OEM will trigger an authentication failure (provided that the OEM Secrets are, in fact, different)._

NOTE: _In a CC, a key may be referred to using an index into an internal, system defined key table, the System Key Table (STK). If some of these keys are device specific, they will not work as intended on a second device.
If the Locality of this CC is not restricted, the internal key index may be interpreted as an internal key on a different device, with unspecified behavior.
Hence the implementation of the STK must also provide the proper Locality metadata to the ACE implementation to configure a CC._

[[ACE-formats]]
===== Formats of Configuration Inputs and Sealed Configuration Contexts

The format of the input to `ace.init` is simple: the first 8 bytes must contain the 64-bit metadata section, followed by any key and additional information in a format specified by the algorithm. The total length of this input must be a multiple of 8 bytes.
The lengths of the configuration payload, of the content section, and of SCCs is given in bytes.

Each algorithm must provide following functions:

* `metadata_serialize(CC) -> byte array`: Serializes the internal metadata into a 64-bit block for export.
* `metadata_deserialize(CC,byte array) -> CC.metadata`: Takes a metadata block formatted as described in <<ACE-metadata>> and deserializes it to the internal representation of the metadata section.
* `initial_content_deserialize(CC,byte array) -> CC.content`:
Reads the information provided to `ace.init` as the byte array that follows the metadata, and deserializes it for the internal representation.
It must be the same as the format used for the SCC except for some omitted fields.
* `content_serialize(CC) -> byte array`: Serializes a CC's content to a byte array to be encrypted for export.
* `content_deserialize(CC,byte array) -> CC.content`:
Takes the decrypted byte array, that comes after the metadata, nonce and authentication tag, and deserializes it into a CC's content.
The format depends on the algorithm which is specified in metadata information.

See <<ACE-Algorithms>> for algorithm specific details.

The size of a SCC, and of all byte arrays read or written by the above five functions, is a multiple of 8 bytes.

Format of Configuration Input:::
The first 8 bytes must contain the 64-bit metadata section as specified in <<ACE-metadata>>,
followed by the key(s) and possibly other information as specified by the algorithm.

Plaintext Format of SCC:::
`bytes[7:0] {nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}` contain the 64-bit metadata section, +
`bytes[19:8] {nbsp}{nbsp}{nbsp}{nbsp}{nbsp}` contain the nonce (96 bits) +
`bytes[31:20] {nbsp}{nbsp}{nbsp}{nbsp}` contain the SIV (96 bits) +
`bytes[u+31,32] {nbsp}{nbsp}` contain `content_serialize(CC.content)`, which has a byte length of `u`.

Only the serialization of the content is encrypted, while both metadata and content are included in the computation of the authentication tag, as described next.

//[[ACE-AEAD]]
//==== Authenticated Encryption of a Context

To describe how a SCC generated, we first define the RFC8452 Key Derivation and the DCTK Derivation functions.

.RFC8452 Key Derivation
[source,sail]
----
function RFC8452_KeyDeriv(K) = {
  struct {
    AESE256(K, (0[125:0] @ 0b101))[63:0] @ AESE256(K, (0[125:0] @ 0b100))[63:0] @
    AESE256(K, (0[125:0] @ 0b011))[63:0] @ AESE256(K, (0[125:0] @ 0b010))[63:0],
    AESE256(K, (0[125:0] @ 0b001))[63:0] @ AESE256(K, (0[125:0] @ 0b000))[63:0]
  }
}
----

.Derived Key Derivation
[source,sail]
----
function DCTK_KeyDeriv(K,L) = {
  AESE256(K, L ^ (0[125:0] @ 0b011))[63:0] @ AESE256(K, L ^ (0[125:0] @ 0b010))[63:0] @
  AESE256(K, L ^ (0[125:0] @ 0b001))[63:0] @ AESE256(K, L ^ (0[125:0] @ 0b000))[63:0]
}
----

We can now define the generation of the SCC from a CC.

.Generation of the SCC from a CC
[source,sail]
----
metadata : bits(64);
last_block_fractional : boolean;
content : array[num_blocks] of bits(128); // last block is zero-padded
                                          // if last_block_fractional = true
M : array[num_blocks+2] of bits(128);
let N : bits(96) = random(96 bits);
Kenc : bits(256);
Kauth : bits(128);

if (metadata.Locality == 15) then {
    CTK = RCTK;
} else {
    CTK = DCTK_KeyDeriv(RCTK, LST[metadata.Locality]);
}

{Kenc, Kauth} = RFC8452_KeyDeriv(CTK);
let T : bits(96) = POLYVAL(Kauth, metadata @ content
                                           @ IntTo64Bits(64)
                                           @ IntTo64Bits(len_in_bits(content)))[95:0];
let SIV : bits(96) = AESE(Kenc, 0 1b0 @ ((T xor N)[126:0]))[127:32];

M[0][127:0] = N[63:0] @ metadata[63:0];
M[1][127:0] = SIV[95:0] @ N[95:64];
if (last_block_fractional) then last = num_blocks - 1 else last = num_blocks - 2;
foreach(i from 0 to last) {
    M[i + 2][127:0] = content[i] xor AESE(Kenc, 1 @ SIV[94:0] @ (binary(i)[31:0]));
}
if (last_block_fractional) then {
    M[last + 1][63:0] = content[last + 1]
                        xor AESE(Kenc, 1 @ SIV[94:0] @ (binary(last + 1)[31:0]))[63:0];
}
----

NOTE: Due to the computational cost of the derivation functions, implementations may
cache recently used derived keys for both the Root RCTK and Locality-derived keys.

//NOTE: This simplification of AES-GCM-SIV does not require appending the lengths
// of metadata and content to the hash, as these lengths are already implied by the
// cleartext bits of the metadata, which are included in the authentication tag computation.

NOTE: Certain format details are fixed across algorithms. All pure ciphers use a single
key, regardless of whether they employ a normal or threshold implementation; threshold
implementations are always reduced to a single key. Some modes follow the same convention,
while others require algorithm-specific state formatting.

// The total output length must be a multiple of 64 bits. If the combined metadata and
// content do not meet this requirement, the final block is zero-padded.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-constants]]
==== Constants

[[ACE-error-codes]]
===== Error Codes

ACE error codes are 8-bit values.
The range [0..127] is reserved for RVI.
Error codes specific to custom algorithms may be freely defined in the range [128..255], and are allowed to overlap between algorithms.

In <<ACE-error-values>>, we define the mandatory error codes.

[[ACE-error-values]]
.Error values and their meanings
[float="center",align="center",width="100%",cols="^6%,<24%,<70%",options="header"]
|===
|Value | Mnemonic                  | Examples
|  0   | ace_err_ok                | No error.
|  1   | ace_err_authentication    | Authentication failure in `ace.import`, but can also follow `ace.exec` with certain algorithms.
|  2   | ace_err_privilege         | `ace.exec`, `ace.state`, `ace.clone`, `ace.derive` failed because the access control policies in the metadata prevent usage in the current architectural state.
|  3   | ace_err_invalid           | Invalid input or operation. +
Examples:
the metadata section passed to `ace.init` is invalid;
encryption, resp., decryption is requested from a CC only configured for decryption, resp., encryption, and more generally
the current state of the CC does not expect the used form of `ace.exec`;
the requested change of state in `ace.state` is not permitted;
the change in usage policies in `ace.restrict` is not permitted because it would either downgrade or overwrite the current restrictions in the CC;
a request to clone a CC violates the re-initialisation policies of the source CC;
software tried to use an incomplete CC as a source in a `ace.exec`, `ace.state`, `ace.input`, `ace.output`, `ace.clone`, `ace.derive`, `ace.harden`, `ace.restrict` operations.
|  4   | ace_err_unimplemented     | The requested algorithm is not implemented. May be triggered also on algorithm variants, for instance if `ace.harden` is issued on an algorithm for which a non-side channel protected version is not implemented.
|  5   | ace_err_memory            | The free internal CF memory is not sufficient to perform the `ace.init`, `ace.exec`, `ace.clone`, or `ace.derive`.
The implementation must make sure this cannot happen with any other operation.
If algorithms that support `ace.derive` are implemented, the implementation must make sure that both the input and output CCs of this operation can be allocated.
|  6   | ace_err_unallocated_CC    | Software tried to use an unallocated CC as a source in one of the following instructions: `ace.exec`, `ace.state`, `ace.input`, `ace.output`, `ace.clone`, `ace.derive`, or `ace.harden`/`ace.restrict`.. +
This can be used in low CF memory situations to trigger a lazy re-load of that CC.
|===

===== Supported Algorithms

[.red]#Add algorithm numbers!#

We architect support for several algorithms, and also define a minimal subset (current suggestion):

* AES-128 and AES-256 encryption and decryption.
* AES-CTR, AES-GCM, AES-GCM-SIV, AES-XTS using AES-128/256.
* AES-CMAC using AES-128/256.
* SHA-2, SHA-2-HMAC.

The list of other architected algorithms is TBD, but it must include at least

* AES-192, alone and with the above modes.
* SM4 Block Cipher.
* The Ascon suite (Ascon-128/128a-AEAD, Ascon-Hash, Ascon-XOF, Ascon-80pq).
* SHA-3, SHA-3-HMAC.
* SM3 Secure Hash.

===== Other Constants

In addition to error codes and algorithms encodings, ACE defines a few more constants, such as
those in <<ACE-stage-constants>> which are used in `ace.state`/`ace.dir` to change the state of a CC.

Algorithms that significantly differ from those we describe in <<ACE-algorithms>> and therefore cannot share the same software for their usage,
may reuse the same values in [1..13] with new constant mnemonics to define their own states.

[[ACE-stage-constants]]
.Constants defining CC states
[float="center",align="center",width="100%",cols="^6%,<29%,<65%",options="header"]
|===
| Value | Mnemonic                      | Examples
|   0   | ace_state_initial             | The context is initialized and ready for operation.
|   1   | ace_state_encrypt +
ace_const_operate
|  Encryption is requested. +
Algorithm is ready to process.
|   2   | ace_state_decrypt             | Decryption is requested.
|   3   | ace_state_hash_absorb         | Start (and initialize) a hash function or the sub-function of an algorithm, preparing it to absorb blocks of data.
|   4   | ace_state_hash_finalize +
ace_state_hash_finalize_enc             | Finalize the internal state of a hash function (including for the encryption algorithm of an for an authenticated encryption mode of operation) and prepare it for outputting the result. In this state additional data may be absorbed, such as lengths.
|   5   | ace_state_hash_finalize_dec   | Finalize the internal state of a hash function for the decryption algorithm an authenticated decryption mode of operation. In this state additional data may be absorbed, such as lengths.
|   6   | ace_state_hash_verify         | Finalize the internal state of a hash function and compare it to the provided value.
|   7   | ace_state_last_block_length   | For a hash or MAC function, the next `ace.exec` this is the length of the last block of data.
|   8   | ace_state_set_public_value    | Set a public value (like a nonce or an IV) in an algorithm. Some algorithms require more than one public value (for instance, they may admit a re-useable hash of some associated data and a unique nonce), in which case the second public value can be set using the next message.
|   9   | ace_state_set_public_value_2  | Set the second public value in an algorithm.
|  10   | ace_state_input_for_derive    | Tells the CC to expect additional information for feeding the `ace.derive` instruction.
|  14   | ace_state_invalidated         | The algorithm has abnormally terminated. `ace.error` will always return error code _ace_err_invalid_.
|  15   | ace_state_completed           | The algorithm has correctly completed.
|===

// ///////////////////////////////////////////////////////////////////////////////////////////
// ///////////////////////////////////////////////////////////////////////////////////////////

<<<

=== Instructions

We now give detailed descriptions of the instructions, including their semantics and encoding.

NOTE: These encodings are just examples, and may not be final.
They serve as a starting point for discussion and refinement as
well as a proof that, at the time of this writing, the ACE instruction set
can be encoded.

NOTE: ACE is an ideal candidate for the Composable Custom Extensions framework,
even though our aim is to make it into a ratified extension.


[[ACE-instruction-enable-enable]]
==== ace.enable/ace.enable

`ace.enable` +
`ace.disable`

Description::
Enable/Disable the feature in the current process domain and (*TBD* determine
how many contexts we need).
`ace.enable` must be issued before using any ACE operation.
 +
This is a pseudo-operation for a write to a WARL CSR. +
See <<ACE-CSR-enable>> and <<ACE-ACES-field>> for more details.

// When disabling:
//
// * Care is necessary in the design to allow a locking disablement without
//   erasing the registers when a parent gives control back to a child process
//   that does not use the feature.

[[ACE-instruction-init]]
==== ace.init

`ace.init Cd|C[Xd], %offset(Xs)`

Encoding::
`ace.init` is an I-type instruction.
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Cs','C[Xd]'] },
    { bits:  3, name: 'ace.init', attr: [0x4,0x5] },
    { bits:  5, name: 'Xs' },
    { bits: 12, name: 'imm', attr: ['offset'] },
]}
....

Description::
`Cd` is the source CC to be configured (encoded as a 5-bit immed). +
`Xd`, alternatively, is a GPR containing a number from 0 to 31 to select the context
to be configured. +
GPR `Xs` points to the region of memory containing the metadata and the key material.

Configures a CC with metadata and content.

// [.red]#(TBdetermined whether it is secure)# This instruction is trappable and may also be resumed or restarted.

[[ACE-instruction-clear]]
==== ace.clear

`ace.clear Cd|C[Xd]`

Encoding::
`ace.clear` is an I-type instruction.
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Cs','C[Xd]'] },
    { bits:  3, name: 'ace.clear', attr: [0x6,0x7] },
    { bits:  5, name: 0x0 },
    { bits: 12, name: 0x0 },
]}
....

Description::
`Cd` is the source CC to be cleared (encoded as a 5-bit immed). +
`Xd` alternatively, is a GPR containing a number from 0 to 31 to select the context to be cleared. +

[[ACE-instruction-export]]
==== ace.export

`ace.export %offset(Xd), Cs|C[Xs]`

Encoding::
`ace.export` is an S-type instruction.
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'imm[4:0]' },
    { bits:  3, name: 'ace.export', attr: [0x0,0x1] },
    { bits:  5, name: 'Xd' },
    { bits:  5, name: 'context', attr: ['Cs','C[Xs]'] },
    { bits:  7, name: 'imm[11:5]' },
]}
....

Description::
Exports the contents of CC `Cs` or `C[Xs]` to memory, starting at address `Xd`, using
the procedure described in <<ACE-formats>>.
If the context `Cs` is clear, or `Xs` is out of range,
the operation will report error ace_err_invalid.

The instruction must be resumable in case of interrupts.
Similarly to entire-vector-register store instructions, `ace.export` appears to other harts as
sequences of individual stores.

[[ACE-instruction-import]]
==== ace.import

`ace.import Cd|C[Xd], %offset(Xn)` +
`ace.import.S Cd|C[Xd], %offset(Xn)`

Encoding::
`ace.import` is an I-type instruction.
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Cd','C[Xd]'] },
    { bits:  3, name: 'ace.import', attr: ['0    0    S','0    1    S'] },
    { bits:  5, name: 'Xn' },
    { bits: 12, name: 'imm' },
]}
....

Description::
`Cd` is the destination CC to be imported, as an immed (5-bit). Alternatively,
the number of context into which import the SCC is stored in the GPR `Xd` as a
number from 0 to 31. `Xn` is the GPR containing the base address of the buffer
with the SCC. +
 +
The instruction must be resumable in case of interrupts.
Similarly to entire-vector-register load instructions, `ace.import` appears to other harts as
sequences of individual loads. +
 +
The bit S takes the values 0 (false) or 1 (true).
It is set to true if the key is in a system defined format
(`ace.import.S`)
and not the format defined by the present architecture
(`ace.import`). +

NOTE: There is no further specification as to
what the system defined format is in the encoding of the instruction, and in
case more than one system defined format is defined, the data format itself
must distinguish between them.  In other words, it is the responsibility of
the system to augment all the system defined formats with a unique identifier
that can be used to distinguish between them. +

NOTE: The `ace.export` instruction does not have a `ace.export.S` analogue of `ace.import.S`.
This means that system HW dynamically generated keys can be imported but not
exported in the same form: they must be exported in the format architected in
this specification.
// If the value cannot be transported to other devices or to
// other Locality states of the same device, the internal logic must bind them to a
// specific DCTK). The instruction imports them like software keys and sets
// the appropriate policies.

// [.red]#(TBdetermined whether it is secure)# This instruction is trappable and may also be resumed or restarted.

[[ACE-instruction-exec]]
==== ace.exec

The instruction admits four Forms, namely

[upperalpha]
. `ace.exec  Vd, Cn|C[Xn], Vs` {nbsp}{nbsp} takes an input vector and writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}{nbsp}Cn|C[Xn], Vs` {nbsp}{nbsp} takes an input vector but does not write to an output vector.
. `ace.exec  Vd, Cn|C[Xn]{nbsp}{nbsp}{nbsp}{nbsp}` {nbsp}{nbsp} does not take an input but writes to an output vector.
. `ace.exec  {nbsp}{nbsp}{nbsp}{nbsp}Cn|C[Xn]{nbsp}{nbsp}{nbsp}{nbsp}` {nbsp}{nbsp} does not take an input vector and does not write to an output vector.

Form D instructions perform internal processing only in the CC.

// Without this comment, the next part is not properly formatted...
Encoding::
`ace.exec` is an R-type instruction.
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Vd', attr: ['rd'] },
    { bits:  3, name: 'ace.exec' },
    { bits:  5, name: 'Cn|C[Xn]', attr: ['rs1'] },
    { bits:  5, name: 'Vs', attr: ['rs2'] },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....

Bit `r` (i.e., bit 27) takes the value 0 if the context is encoded as an immediate,
and it takes the value 1 if a GPR (scalar integer value) is used to reference it.
For the four Forms A-D above, the encodings are:

[upperalpha]
. `ACE.exec` = `0b000`.
. `ACE.exec` = `0b001` and `rs2`=`0b00000`.
. `ACE.exec` = `0b010` and `rd`=`0b00000`.
. `ACE.exec` = `0b011` and `rs2`=`rd`=`0b00000`.

Furthermore, we admit variants of Forms B and D, which we call Form B', resp., Form D',
with non-zero values in `rd`, resp., `rs2`,
to encode additional instructions.

// To make indent in next line correct

Description::
Performs a cryptographic operation such as an encryption or decryption,
absorbing a value in a hash, and possibly returning a value.

NOTE: In many algorithms, the successive stage is often implied by the operation
just performed. For instance, in AEAD algorithms, after setting an IV or a nonce,
one could argue that there is no need to explicitly move to the stage of absorbing
the associated data into the hash. However, to avoid inconsistency, we have chosen
to avoid implicit stage transitions, even if this could save a handful of instructions,
unless if strictly necessary. This can occur for security reasons, such as going to
hash finalization to hash verification states, or transitions to states such as
_completed_ or _invalidated_ (see <<ACE-stage-constants>> and <<ACE-Algorithms>>).

[[ACE-instruction-size]]
==== ace.size

===== Context Variant

`ace.size Xd, Cs|C[Xs]`

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus is an R-type instruction.
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x3, attr: ['ace.exec', '(Form D\')'] },
    { bits:  5, name: 'Cs|C[Xs]' },
    { bits:  5, name: 0x1, attr: ['ace.size'] },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....

Bit `r` (i.e., bit 27) is 0 if the context is encoded as an immediate, and 1 if a GPR is used to reference it.

Description::
This instruction writes the size of the SCC corresponding to CC `Cs`, or the CC
whose number is in `Xs`) into GPR `Xd`, and zero if the algorithm is not supported.

Knowing the size of the SCC serves to properly implement any feature that
relies on `ace.export`, for instance context switching.

NOTE: The value can significantly differ from the internal resource usage ot the CC —
it can be larger (for simple primitives, because of the nonce/SIV overhead) but
also smaller (for keys split into shares for threshold implementations, but saved
externally in reconstructed form).

===== Metadata Variant

`ace.size Xd, Xs`

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus is an R-type instruction.
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Xd' },
    { bits:  3, name: 0x3, attr: ['ace.exec', '(Form D\')'] },
    { bits:  5, name: 'Xs' },
    { bits:  5, name: 0x2, attr: ['ace.size'] },
    { bits:  7, name: 0x0 },
]}
....

Description::
This instruction writes the size of a SCC having the metadata section given in `Xn` into GPR `Xd`, and zero if the algorithm is not supported.
Only the Algorithm and SC_Protection fields of the metadata section of a CC are considered.

[[ACE-instruction-available]]
==== ace.available

`ace.available Xd, Xs`

The instruction is an alias to the Metadata Variant of `ace.size`, as the latter returns zero if the algorithm is not supported.

[[ACE-instruction-clone]]
==== ace.clone

`ace.clone Cd|C[Xd], Cs|C[Xs]`

Encoding::
The instruction is encoded using the Form D' `ace.exec` encoding, and is thus is an R-type instruction.
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Cd|C[Xd]' },
    { bits:  3, name: 0x3, attr: ['ace.exec','(Form D\')'] },
    { bits:  5, name: 'Cs|C[Xs]' },
    { bits:  5, name: 0x3, attr: ['ace.clone'] },
    { bits:  1, name: 0x0 },
    { bits:  2, name: 'R' },
    { bits:  4, name: 0x0 },
]}
....

Bits [27:26], i.e., field `R`, take following values depending on how the contexts are
referred:

[upperalpha]
. `0b00` if the source and the output contexts are both encoded as immediates.
. `0b01` if the source context is selected using a GPR and the output context is encoded as an immediate.
. `0b10` if the source context is encoded as immediate and the output context is selected using a GPR.
. `0b11` if the source and the output contexts are both selected using the values of GPRs.

// Comment to ensure the proper indentation in th next Description

Description::
Clones source CC `Cs` (or the CC indexed by `Xs`) into destination CC `Cd` (or
into the CC indexed by `Xd`).

// NOTE: The `ace.clone` instruction is an optimization for the sequence `ace.export` followed by `ace.import`. While reusing cryptographic state (e.g., encrypting with the same counter) can enable certain attacks, this risk cannot be eliminated by omitting `ace.clone`, as a state can be exported and re‑imported multiple times.

[[ACE-instruction-derive]]
==== ace.derive (optional)

`ace.derive Cd|C[Xd], Cs1|C[Xs1]` +
`ace.derive Cd|C[Xd], Cs1|C[Xs1], Vs2`

Encoding::
The instruction is encoded using a variant of Form A `ace.exec` encoding, and is thus is an R-type instruction.
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Cd|C[Xd]' },
    { bits:  3, name: 0x0, attr: ['ace.exec (Form A)'] },
    { bits:  5, name: 'Cs1|C[Xs1]' },
    { bits:  5, name: 'Vs2', attr: ['use for additional input','no additional input (zero field)'] },
    { bits:  1, name: 0x1 },
    { bits:  2, name: 'R' },
    { bits:  1, name: 'z', attr: [0x1,0x0] },
    { bits:  3, name: 0x0 },
]}
....

This encoding differs from Form A `ace.exec` by having bit 25 set to 1.
Bits [27:26], i.e., field `R`, is encoded exactly as for `ace.clone` (cf.{nbsp}<<ACE-instruction-clone>>).
Bit 28 determines whether an additional vector register (or register group) is used to pass a parameter to the key derivation mechanism or not.

Description::
The instruction is used to derive a new context from an existing one, with its own opaque key material.
It is similar to `ace.clone`, but the derived context is not a copy of the source context,
rather, it is a new context that is derived from it, for instance, through a key derivation mechanism.
This instruction can be used multiple times, to generate multiple derived contexts.

[[ACE-instruction-state]]
==== ace.state/ace.dir

`ace.state`/`ace.dir Cd|C[Xd], #immed7` +
`ace.state`/`ace.dir Cd|C[Xd], #immed7, Xs`

Encoding::
`ace.state`/`ace.dir` is an R-type instruction.
[wavedrom, , svg]
//
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 'Cd|C[Xd]' },
    { bits:  3, name: 0x4, attr: ['ace.state'] },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
    { bits:  5, name: 'Xs' },
    { bits:  7, name: 'immed7' },
]}
....

Bit `r` (i.e., bit 15) is 0 if the context is encoded as an immediate, and 1 if a GPR is used to reference it.

Description::
Two pseudo-instructions that map to the same instruction. +
`Cn` is the CC in which to set the stage (i.e., state number) of the internal state. +
`Xn` is a GPR containing a number from 0 to 31 to dynamically address the
context in which to change the stage of the internal state. +
The `#immed` is a constant from a set of admissible values that are defined for
each algorithm, to manage an internal state machine of said algorithm in case
more stages are needed. +
`Xs` is a GPR being either `X0` or containing an optional additional parameter for the state machine.

[[ACE-instruction-restrict]]
==== ace.restrict/ace.harden

`ace.restrict   Cd|C[Xd], Xs` +
`ace.harden     Cd|C[Xd], Xs`

// Without this comment, the next part is not properly formatted...
Encoding::
The encoding uses `ace.exec` Form B', with bit 7 (which is in the `rd` field) set.
It is thus a variant of an R-type instruction. +
The source register field encodes a GPR and not a vector register. +
If bit `r` (i.e., bit 27) is 0, the 5-bit destination field [11:7] contains the destination context number,
else it determines the GPR that contains the context number.
 +
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x5b, attr: ['custom-2'] },
    { bits:  5, name: 0x1 },
    { bits:  3, name: 0x1, attr: ['ace.exec', '(Form B\')'] },
    { bits:  5, name: 'Cd|C[Xd]' },
    { bits:  5, name: 'Xs' },
    { bits:  2, name: 0x0 },
    { bits:  1, name: 'r' },
    { bits:  4, name: 0x0 },
]}
....

// comment

Description::
This instruction restricts the usage of a CC to specific modes or to a specified `ASID` or `VMID`. +
It can also increase the side-channel protection level of the CC. +
Let `m` be the metadata field in the destination CC. The instruction works as follows:

* Bits [10:9] and [63:25] of the input register `Xs` have the same format as the corresponding bits of the metadata.
* Bits [8:0], [24:11] and 31 of the input register `Xs` are ignored.
* Bits [10:9] can be used to turn on or increase the level of the side-channel protection of the algorithm in the CC, if the microarchitecture supports the corresponding implementation. The levels are defined in <<ACE-SC-protection-levels>>. Downgrading side-channel protection is not permitted, and attempting to do so will result in error ace_err_invalid (cf.{nbsp}<<ACE-error-codes>>).
* A zero in any of the six bits `Xs`[30:25] means that the corresponding policy is not changed.
* A one in the any of the four bits `Xs`[28:25] means that usage by the corresponding mode is forbidden, and the corresponding bit in the metadata of the destination CC is set to 1.
* If `Xs`[29] is set and `m`[29] is NOT set, then Usage_Policy_3, i.e., `m`[47:32], is set to `Xs`[47:32].
* If `Xs`[30] is set and `m`[30] is NOT set, then Usage_Policy_4, i.e., `m`[63:48], is set to `Xs`[63:48].
* If `Xs`[29] and `m`[29] are both set and `Xs`[47:32] <> `m`[47:32], or if `Xs`[30] and `m`[30] are both set and `Xs`[63:48] <> `m`[63:48], then the error field of `acecsr` is set to ace_error_invalid.

[[ACE-instruction-input]]
==== ace.input (optional)

`ace.input Cd|C[Xd], %offset(Xs)`

Encoding::
`ace.input` is an I-type instruction.
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x27, attr: ['custom-1'] },
    { bits:  5, name: 'context', attr: ['Cd','C[Xd]'] },
    { bits:  3, name: 'ace.input', attr: [0x4,0x5] },
    { bits:  5, name: 'Xs' },
    { bits: 12, name: 'imm' },
]}
....

// [.red]#(TBdetermined whether it is secure)# This instruction is trappable and may also be resumed or restarted.

[[ACE-instruction-output]]
==== ace.output (optional)

`ace.output  %offset(Xd), Cs|C[Xs]`

Encoding::
`ace.output` is an S-type instruction.
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x0b, attr: ['custom-0'] },
    { bits:  5, name: 'imm[4:0]' },
    { bits:  3, name: 'ace.output', attr: [0x4,0x5] },
    { bits:  5, name: 'Xd' },
    { bits:  5, name: 'context', attr: ['Cs','C[Xs]'] },
    { bits:  7, name: 'imm[11:5]' },
]}
....

// [.red]#(TBdetermined whether it is secure)# This instruction is trappable and may also be resumed or restarted.

[[ACE-instruction-error]]
==== ace.error

`ace.error Xd, Cs|C[Xs]`

Description::
A CC `Cs` (or indexed by `Xs`) may be in an error state due to the previous
operation. The corresponding error value is written into GPR `Xd`.
This is implemented as a CSR read operation, reading the error field of
`acecsr` and masking it.
The error value list is architected and given in <<ACE-error-codes>>.

// ///////////////////////////////////////////////////////////////////////////////////////////

[[ACE-trappable-insns-support]]
==== Support for Trappable Operations

Instructions `ace.init`, `ace.export`, `ace.import`, `ace.input`, and `ace.output` support arbitrarily long inputs and outputs.
To reduce hardware complexity, these operations can be trapped and emulated in software using custom instructions.

Upon a trap, the handler identifies the trapped instruction and uses the Algorithm field of the metadata block
`ace.size` to determine the size of the data to be transferred.

In order to support interrupts of the emulation libraries, such instructions need to respect the value of `ccstart` and update it in accordance with the expected architected behavior the trapped instructions.  We provide here non-normative definition for such a set of instructions in <<ACE-trappable-insns-support>>.
Three types of supporting operations are required:

 * A `mv` instruction that loads a specified number of bytes from a GPR or vector register into a CC within the ACE unit.
   Initially, `ace.size` returns the total payload length to transfer.
   After each move, this value is updated to reflect the remaining bytes.
   The instruction also updates the `ccstart` CSR to follow the internal progress.
 * A corresponding `mv` instruction that exports a specified number of bytes from a CC to a GPR or vector register.
   The behavior of `ace.size` will be similar to that of the move instruction, but it will count the number of bytes to be exported.
 * A “`close`” instruction to suspend or finalize the procedure.
   If executed before all bytes are transferred, the CC state matches that of an interrupted monolithic instruction, including the Completion metadata field and the `ccstart` value. If executed after all bytes are transferred, it also performs any final cryptographic operations, such as authenticating the CC, if needed.

These supporting instructions must be uninterruptible.

Furthermore, the initial cryptographic phase of `ace.export` and the authentication phase of `ace.import` must be uninterruptible as well.
Even if these parts are executed concurrently with other operations, the trap handler may need to wait for these steps to complete before proceeding with memory/move operations.

The support instructions are implementation-specific and not explicitly defined in the architecture.
However, interrupting the firmware implementation of `ace.init`, `ace.export`, `ace.import`, `ace.input` or `ace.output`
must leave the architectural state indistinguishable from the state expected from interrupting a monolithic implementation of the instructions.

// ///////////////////////////////////////////////////////////////////////////////////////////

<<<

[[ACE-Algorithms]]
=== Data Formats and Instruction Semantics for Various Algorithms

In this chapter we describe the behavior of Cryptographic Contexts for various cryptographic algorithms.
Some of these descriptions are generic, others pertain to certain algorithms.

Each algorithm is fully defined by the following information:

Block Size:::
Size of the basic unit of information processed by the algorithm, usually the block size of the main underlying primitive.

Internal State:::
Information that must be in the internal state of a CC, in the order it is serialized to create the SCC.

Generic Functions:::
If necessary, overload generic functions that apply to all contexts, such as :
Each algorithm must provide the functions described in <<ACE-formats>>.

Algorithmic-Specific Functions:::
Any other function that is specific to the algorithm.

State Machine:::
This includes:

. A list of *States* in which the internal state machine of the logic is executed, together with their representation, either as a number in the range [0..15] or by more complex structures. The values must conform to <<ACE-stage-constants>>.
. A complete list of the *Allowed State Transitions*, including the conditions under which each transition is allowed.
. The *Behavior* of all ACE instructions at each state.

We also add pseudocode to clarify how the algorithms supported by an ACE unit are implemented in software using the ACE ISA.

[[ACE-generic-rules]]
==== Generic Rules

For modes of operations that can be instantiated with different primitives, we specify more general rules, where the differences between instantiations in some cases are limited to the widths of the inputs and outputs of the primitive. If the primitive is a block cipher, then `b` is its block width in bits.

Recall that the architecture views CC as a structure with two fields: the metadata (currently 64 bits), which has a unique specification, and the content (variable length), which is algorithm-specific.

In the descriptions of the algorithms below, we do not need to redefine these two functions if they are not changed, i.e., if there are no changes to the metadata format.

If the number of states of the algorithm is at most 16, we assume that the `stage` of the metadata is used to store this value.
Otherwise, the specification of the algorithm must include a suitable field in the content section of the CC/SCC.

An important rule is the following.
If an invalid input is provided to any ACE instruction, or a non-admitted instruction is executed, while processing the algorithm in CC, say, Cn,
the `Cn` is *invalidated*, namely, the following happens:

* `Cn` is put into state _invalidated_;
* For instructions that refers to `Cn`:
 ** any form of `ace.exec` performs no operation and, if it provides an output, the latter is always zero;
 ** `ace.clone` and `ace.derive` clean the destination contexts;
 ** `ace.restrict` and `ace.harden` perform no operation;
 ** `ace.input` and `ace.output` perform no operation;
 ** `ace.state` perform no operation, unless is is used to return to state _initial_;
 ** `ace.error` always returns error _ace_err_invalid_ after any operation involving the CC except for
    `ace.import` and `ace.export`, `ace.clean`, `ace.init`, and `ace.size`, which all work normally, and using `ace.stage` to return to state _initial_.

The function that puts the CC in this state is called `invalidate()`.

In state _completed_, no operation can be performed except `ace.init`, `ace.export`, `ace.import`, `ace.clear`, or `ace.error`.
Any other operation, if it has an output, it returns zero, and will cause the CC to be *invalidated*.

In what follows, when we write of "state _name_" we refer to the state which has number _ace_state_name_ as described in <<ACE-stage-constants>>.

The rules from <<ACE-ECB-mode>> to <<ACE-CMAC>> can be instantiated, like the modes that they describe, with a variety of block ciphers and polynomials for GHASH- or POLYVAL-like hashes, where only the block and key sizes are needed to get a full specification.

On the other hand, the specifications from <<ACE-hash-functions>> to <<ACE-Ascon>> are in general heavily primitive dependent.

[[ACE-rules-threshold-implementations]]
==== Rules for Threshold implementations

Any CC with its algorithms implemented as threshold implementation will always initialize, import and export _all_ its keys and secrets as _single_, _reconstructed_ _shares_.
The Configuration and SCC Formats will be the same as for the non-threshold implementations variants of the same algorithm, with the only difference being the value of the Side Channel Protection bits in the metadata.
For the purpose of architecture specification, all values are also always represented as a single share in this document.
Threshold implementations are simply implementation variants of the exact same algorithm.

NOTE: This assumes that reconstructing a key or re-randomizing it are fast operations, such as ``xor``s with random values.
This in turn implies that ACE execution unit must have access to a source of randomness, or at least a PRNG that is seeded at hardware boot.

This ensures not only the compactness of a SCC, but also that the key can be ported across architectures.
In fact, some threshold implementations may have a different number of shares even if they claim the same order of side-channel protection.

<<<

[[ACE-ECB-mode]]
==== Electronic Codebook Modes (Direct Encryption/Decryption)

While listing the rules for the ECB mode is in principle easy, it does display all the rules that are required to describe an arbitrarily complex mode.

// comment to reset formatting

Block Size:::

* `b` = block size in bits, (8|`b`)

Internal state:::

* *Metadata*: 64 bits.
* *Content Fields*:
** `key`: `k` bits (8|`k`, in fact it is almost always 128|`k`).

Generic Functions:::

* `initial_content_deserialize`.
 ** Length = `k/8` bytes.
 ** `input[k/8-1:0] = key`.

Algorithm-Specific Functions:::

* `enc_block(p) -> c` encrypts plaintext block `p` using the key, and returns the ciphertext result `c`.
* `dec_block(c) -> p` decrypts ciphertext block `c` using the key, and returns the plaintext result `p`.

State Machine:::

* *States:* _initial_ (0), _encrypt_ (1), and _decrypt_ (2)
* *Allowed State Transitions:*
 ** From any state to state _encrypt_, if metadata allows encryption, else the CC is *invalidated*.
 ** From any state to state _decrypt_, if metadata allows decryption, else the CC is *invalidated*.
* *Behavior:*
 ** In state _initial_, any `ace.exec` will result in the CC being *invalidated*.
 ** In state _encrypt_:
  *** If{nbsp} `ace.exec Vd, Cn|C[Xn], Vs` {nbsp}is issued, then {nbsp} `Vd = enc_block(Vs)`.
  *** If any other form of `ace.exec` is issued, then the CC is *invalidated*.
 ** In state _decrypt_:
  *** If{nbsp} `ace.exec Vd, Cn|C[Xn], Vs` {nbsp}is issued, then {nbsp} `Vd = dec_block(Vs)`.
  *** If any other form of `ace.exec` is issued, then the CC is *invalidated*.

<<<
[discrete]
==== Usage Examples

We give pseudocode to illustrate how to use an ECB CC to encrypt a block of data using a block cipher
with a width of 128 bits.

[[ACE-pseudocode-ECB-encryption]]
.Simple Pseudocode Example: Encryption with no Authentication
[C]
----
- Call OS API to get the necessary SCC. Assume X5 points to the SCC.
- Allocate memory for ciphertext buffer.

ace.import C0, (X5)                       // Import the SCC into CC C0
ace.error X1                              // Read error from a CSR
if (X1 != 0) then { handle error }        // ACE may fail to validate SCC, algorithm
                                          // not supported, or CF memory full
vsetvli zero, 4, e32, m1, ta, ma          // Use 128-bit vectors
ace.state C0, #ace_state_encrypt          // Configure CC for encryption
ace.error X1                              // Read error from a CSR
if (X1 != 0) then { handle error }        // Error if encryption is not allowed by CC

foreach (i from 0 to len_in_bytes(plaintext)/16-1) { // assume plaintext in whole blocks
    - load V0 from address plaintext+16*i
    ace.exec V0, C0, V                    // Encrypt one block of the plaintext
    - store V0 at address ciphertext+16*i
}
----

// vle32.v  V0, (plaintext)              // load V0 from address plaintext+16*i
//                                       // assume plaintext is in a register
// ace.exec V0, C0, V                    // Encrypt one block of the plaintext
// vse32.v  V0, (ciphertext)             // store V0 at address ciphertext+16*i
// add plaintext, plaintext, 16          // advance plaintext pointer
// add ciphertext, ciphertext, 16        // advance ciphertext pointer




[[ACE-chaining]]
==== Chaining/Feedback Modes

There is no need to explicitly architect the behavior of chaining modes,
such as
Cipher Block Chaining (CBC),
Propagating Cipher Block Chaining (PCBC),
Cipher Feedback (CFB) and
Output Feedback (OFB)
as they can be easily implemented on top of the ECB functionality in software,
and no intermediate value in these algorithms needs to be kept secret.

<<<

[[ACE-keystream-modes]]
==== CTR/LFSR/XCTR/XLFSR Modes to Produce a Keystream

In the "non-X" modes, i.e., in the CTR mode and its analague that replaces the arithmetic counter by a LFSR, the sum of the lengths of IV and counter/LSFR equals the block size of the underlying keyed PRP or PRF. IV and counter/LFSR are concatenated to form the input to the keyed PRP or PRF.

The "X" modes have both IV and counter/LSFR of the same size as the block size of the underlying keyed PRP or PRF:
IV and counter/LFSR are ``xor``ed together to form the input to the keyed PRP or PRF -- which explains the "X" in the mode names.

//

Block Size:::

* `b` = block size in bits, (8|`b`):

Internal state:::

* *Metadata*: 64 bits.
* *Content Fields*:
 ** `key`: `k` bits (8|`k`).
 ** `IV`: `n` bits (8|`n`).
 ** `counter`: `j` bits (8|`j`).
 ** If the mode is CTR or LFSR. then `b = n + j`, else (i.e., it is an "X" mode) `b = n = j`.

Generic Functions:::

* `initial_content_deserialize`.
 ** Length = `k/8` bytes.
 ** `input[k/8-1:0] = key`.
 ** `input[(k+n)/8-1:k/8] = IV`.
 ** `input[(k+n+j)/8-1:(k+n)/8] = counter`.

Algorithm-Specific Functions:::

* `keystream_block(p) -> c` -- usually an encryption function.
* `tick_counter()` -- updates the counter (either by a modular increment or a LFSR).

State Machine:::

* *States:* _initial_ (0), _set_public_value_ (8), _operate_ (1).
* *Allowed State Transitions:*
 ** _initial_ -> _set_public_value_ -> _operate_.
 ** All states to _initial_.
* *Behavior:*
 ** In state _initial_ , the `counter` and `IV` fields are set to 0 (`counter` is set to 1 if the algorithm is LFSR-based).
 ** In state _set_public_value_, we can only issue ``ace.exec`` instructions of Form B, namely, "```ace.exec Cn|C[Xn], Vs```", which set the IV value to `Vs`.
 *** If no such instruction is issued, the value of the IV will remain zero.
  *** If such operations are issued more times, they will just update the IV value again. Since this can be done only before any encryption or decryption operation, this does not represent a security issue.
  *** Any other form of {nbsp}``ace.exec``{nbsp} will produce a null output and *invalidate* the CC.
 ** In state _operate_, we can only issue ``ace.exec`` instructions of Form C, "```ace.exec Vd, Cn|C[Xn]```", which perform:
  . If in a CTR or LFSR mode then `tmp ← keystream_block(IV @ counter)`, +
    else (i.e., if in a XCTR or XLFSR mode) `tmp ← keystream_block(IV xor counter)`,
  . `tick_counter()`, and
  . `Vd ← tmp`.
 ** In state _operate_, any other form of {nbsp}``ace.exec``{nbsp} will produce a null output and *invalidate* the CC.
 ** If `ace.stage` is issued to return to state _initial_, the CC can be reused with a new counter.

<<<

[[ACE-XEX-XTS-modes]]
==== XEX/XTS modes (one or two keys)

Note that the use of a single key or two independently sampled keys is determined by the algorithm field, and it is not determined by a configuration parameter for the same algorithm.
We first define XEX mode functionality.

Block Size:::

* `b` = block size in bits, (8|`b`).

Internal state:::

* *Metadata*: 64 bits.
* *Content Fields*:
 ** `key1`: `k` bits (8|`k`).
 ** `key2`: `k` bits (8|`k`) (omitted if only one key is used).
 ** `mask`: `b` bits (8|`n`). Initially, this field will be set to zero, then contain the _tweak_, which is then encrypted to get the first mask.

Generic Functions:::

* `initial_content_deserialize`:
 ** Length = `k/8` bytes.
 ** `input[k/8-1:0] = key1`.
 ** `input[2k/8-1:k/8] = key2`.
* `content_serialize`:
 ** Length = `(2k+b)/8` bytes if two keys are used, or `(k+b)/8` bytes if only one key is used.
 ** `output[k/8-1:0] = key1`.
 ** `output[2k/8-1:k/8] = key2` -- omitted if only one key is used.
 ** If two keys are used, then `output[(2k+b)/8-1:2k/8] = mask`, +
    else (if only one key is used), then `output[(k+b)/8-1:k/8] = mask`.
* `content_deserialize` converts the output of `content_serialize` back to the original input format.

Algorithm-Specific Functions:::

* `enc_block(key,p) -> c` encrypts block `p` using the key, and returns the result `c`.
* `dec_block(key,c) -> p` decrypts block `c` using the key, and returns the result `p`.
* `update_mask(mask) -> mask` -- updates the mask by a Galois Field multiplication in GF(2^b^)

State Machine:::

* *States:* _initial_ (0), _set_public_value_ (8), _encrypt_ (1), and _decrypt_ (2).
* *Allowed State Transitions:*
 ** _initial_ -> _set_public_value_.
 ** _set_public_value_ -> _initial_.
 ** _set_public_value_ -> _encrypt_, if metadata allows encryption, else the CC is *invalidated*.
 ** _set_public_value_ -> _decrypt_, if metadata allows decryption, else the CC is *invalidated*.
 ** _encrypt_, _decrypt_ -> _initial_.
* *Behavior:*
 ** In state _initial_:
  *** The `mask` field is set to zero.
  *** Any {nbsp}``ace.exec``{nbsp} operation will produce null outputs and causes the CC to be *invalidated*.
 ** In state _set_public_value_, we can only issue ``ace.exec`` instructions of Form B, namely, "```ace.exec Cn|C[Xn], Vs```", to set the
 _tweak_. The `mask` field is used to initially store the tweak: `mask <- Vs`.
  *** If no such instruction is issued, the value of the tweak will remain zero.
  *** If "```ace.exec Cn|C[Xn], Vs```" is repeated, it will just re-write the tweak.
  *** Other forms of `ace.exe` not allowed, will produce null outputs and the CC is *invalidated*.
 ** When transitioning from _set_public_value_ to either _encrypt_ or _decrypt_, the following operations are performed:
  . First, `mask <- enc_block(key2,mask)`.
  . If only one key is used then update mask: `mask <- update_mask(mask)`.
 ** In _encrypt_ and _decrypt_ states, we can only issue ``ace.exec`` instructions of Form A, i.e., "```ace.exec Vd, Cn|C[Xn], Vs```", which:
  *** in state _encrypt_, computes `Vd = mask xor enc_block(Vs xor mask)` ...
  *** in state _decrypt_, computes `Vd = mask xor dec_block(Vs xor mask)` ...
  *** ... and updates the mask: `mask <- update_mask(mask)`.
  *** If `ace.stage` is issued to return to state _initial_, we can reuse the CC with a new `IV`.

[discrete]
==== Usage Examples

Using such an XEX mode is very easy. We include pseudocode for encryption only, decryption is entirely similar.

[[ACE-pseudocode-basic-IV-mode]]
.Pseudocode for encryption in any IV-based non-authenticated modes without associated data
[C]
----
// Acquire payload
- Info: plaintext = *PT
- Call an API to get the corresponding key from a key management applet or HW block.
- The API returns the SCC. Assume X5 is the pointer to it.
- Allocate memory for ciphertext buffer CT (if not same as PT).

ace.import C0, (X5)

vsetvli zero, 4, e32, m1, ta, ma       // Use 128-bit vectors

ace.stage C0, #const_set_public_value  // the “public” value is often an IV or a nonce.
V0 ← IV
ace.exec C0, V0

ace.state C0, #ace_state_encrypt       // Configure CC for encryption
for i = 0 to ceil(len_in_bytes(plaintext)/16)-1  do
    - load V0 from address plaintext+16*i
    ace.exec V0, C0, V0                // Encrypt one block of the plaintext
    - store V0 at address ciphertext+16*i
----

To implement the XTS mode, the ciphertext stealing part is easy to realize using the XEX algorithm together with vector masking and shifting operations.

// N.B. another ace.stage C0, #const_set_public_value would reset the internal state and allow to begin another decryption with a new IV.

<<<

[[ACE-GCM-mode]]
==== GCM mode

Block Size:::

* `b` = block size in bits, (8|b).

Internal state:::

* *Metadata*: 64 bits.
* *Content Fields*:
 ** `key`: `k` bits (8|`k`).
 ** `counter`: `b` bits.
 ** `hash_key`: `b` bits.
 ** `auth_tag`: `b` bits.

NOTE: Note that there are no fields for the lengths of the AD and of the plaintext.
These values must be maintained by the calling software.

Generic Functions:::

* `initial_content_deserialize`
 ** Length = `k/8` bytes.
 ** `input[k/8-1:0] = key`.

* `content_serialize`:
 ** Length = `(k+2b)/8` bytes.
 ** `input[k/8-1:0] = key`.
 ** `input[(k+b)/8-1:k/8] = counter`.
 ** `input[(k+2b)/8-1:(k+b)/8] = auth_tag`.
 ** Note that `hash_key` is not serialized.

* `content_deserialize` converts the output of `content_serialize` back to the original input format.

Algorithm-Specific Functions:::

* `enc_block(key,p) -> c` encrypts block `p` using the key, and returns the result `c`.

* `absorb_into_hash(data)` absorbs data into the hash function by performing:
  . `auth_tag <- auth_tag xor Vs`.
  . `auth_tag <- auth_tag * hash_key`.

State Machine:::

* *States:* _initial_ (0), _set_public_value_ (8), _hash_absorb_ (3), _encrypt_ (1), _hash_finalize_enc_ (4), _decrypt_ (2), _hash_finalize_dec_ (5), and _hash_verify_ (6).

* *Allowed State Transitions:*
 ** From all states to _initial_.
 ** _initial_ -> _set_public_value_ -> _hash_absorb_.
 ** _hash_absorb_ -> _encrypt_ -- if metadata allows encryption, else the CC is *invalidated*.
 ** _hash_absorb_ -> _decrypt_ -- if metadata allows decryption, else the CC is *invalidated*.
 ** _encrypt_ -> _hash_finalize_enc_, later automatically transitioning to _completed_.
 ** _decrypt_ -> _hash_finalize_dec_.
 ** _hash_finalize_dec_ -> _hash_verify_, later automatically transitioning to _completed_.

* *Behavior:*
 ** In state _initial_ :
  *** Any {nbsp}``ace.exec``{nbsp} operation will produce null outputs and causes the CC to be *invalidated*.
  *** The following initialization operations are performed:
    . `hash_key <- enc_block(key,0)`,
    . `auth_tag <- 0`, and
    . `counter <- 0`.
 ** In state _set_public_value_:
  *** We can only issue  ``ace.exec`` instructions of Form B, i.e., "```ace.exec Cn|C[Xn], Vs```," to set
       . `counter <- Vs << b/4`  (i.e., the `b/4` most significant bits of `Vs` are ignored, and the `b/4` least significant bits of `counter` are set to zero.)
  *** If{nbsp} `ace.exec Cn|C[Xn], Vs`,{nbsp} is repeated, it will just re-write the IV.
  *** If no such {nbsp} `ace.exec Cn|C[Xn], Vs`{nbsp} to set is issued, counter remains zero.
  *** Any other form of {nbsp}``ace.exec``{nbsp} will produce null outputs and causes the CC to be *invalidated*.

 ** In state _hash_absorb_, we can only issue  ``ace.exec`` instructions of Form B, i.e., "```ace.exec Cn|C[Xn], Vs```" to absorb a data block in `auth_tag`, i.e.:
   . `absorb_into_hash(Vs)`.
 ** If the _encrypt_ state, we can only issue  ``ace.exec`` instructions of Form A, namely "```ace.exec Vd, Cn|C[Xn], Vs```" to
   encrypt `Vs` into `Vd`, and absorb the ciphertext `Vd` into the `auth_tag`, namely
    . If `counter[b/4-1:0] = 0`, the CC is *invalidated*.
    . `tmp <- Vs xor enc_block(key,counter)`.
    . `absorb_into_hash(tmp)`.
    . `counter[b/4-1:0] <- counter[b/4-1:0] + 1 % 2^b/4^`.
    . `Vd <- tmp`.

 ** In state _hash_finalize_enc_, we can only issue a single ``ace.exec`` instruction of Form A, namely, "```ace.exec Vd, Cn|C[Xn], Vs```," where it is the responsibility of the user to set +
 `Vs = IntTo{b/2}Bits(bit_length(AD)) @ IntTo{b/2}Bits(bit_length(plaintext))`, +
 to compute the authentication tag and complete the algorithm as follows:
    . `absorb_into_hash(Vd)`.
    . `auth_tag <- auth_tag xor enc_block(key,counter[b-1,b/4] @ 0[b/4-1,0])`.
    . Finally, `auth_tag` is returned in `Vd`, and the state is changed to _completed_.
 ** In state _decrypt_, we can only issue  ``ace.exec`` instructions of the form{nbsp} `ace.exec Vd, Cn|C[Xn], Vs`{nbsp} to
   absorb the ciphertext `Vs` into the `auth_tag`, then decrypt `Vs` into `Vd`, namely
   . If `counter[b/4-1:0] = 0`, the CC is *invalidated*.
   . `absorb_into_hash(Vs)`.
   . `Vd  <- Vs xor enc_block(key,counter)`.
   . `counter[b/4-1:0] <- counter[b/4-1:0] + 1`.
 ** In state _hash_finalize_dec_, we can only issue an {nbsp}``ace.exec``{nbsp} of Form A{nbsp} `ace.exec Vd, Cn|C[Xn], Vs`{nbsp} where it is the responsibility of the user to set +
 `Vs = IntTo{b/2}Bits(bit_length(AD)) @ IntTo{b/2}Bits(bit_length(plaintext))`, +
 to compute the authentication tag as follows:
    . `absorb_into_hash(Vs)`.
   . `auth_tag <- auth_tag xor enc_block(key,counter[b-1,b/4] @ 0[b/4-1,0])`.
 ** In state _hash_verify_, we can only issue  ``ace.exec`` instructions of the form{nbsp} `ace.exec Cn|C[Xn], Vs`{nbsp}.
    `Vs` is compared to `auth_tag`:
    *** If the values match, then the state is changed to _completed_, and `ace.error` returns no error,
        else the state is changed to _completed_, and `ace.error` returns `ace_err_authentication`.
 ** Upon completion of `ace.import`, the ACE unit recomputes `hash_key`:
  . `hash_key <- enc_block(key,0)`.

//
[discrete]
==== Usage Examples

In <<ACE-pseudocode-GCM-encryption>> we show pseudocode for GCM encryption.

[[ACE-pseudocode-GCM-encryption]]
.GCM Encryption
[C]
----
// Acquire payload, initialize
- Info: authenticated data = *AD, plaintext = *PT
- Process gets a GCM encryption CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma       // Use 128-bit vectors
ace.import C0, (X5)

// The next operations set the nonce (and the derived Authentication Key).
ace.stage C0, #ace_const_set_public_value
V0 ← nonce
ace.exec C0, V0

// Compute AD contribution to Auth Data
ace.stage C0, #ace_const_hash_absorb
for i = 0 to len_in_bytes(AD)/16-1  do
    - load V0 from address AD+16*i
    ace.exec C0, V0                    // Absorb it into hash

// Encrypt plaintext and continue computation of auth_tag
for i = 0 to len_in_bytes(PT)/16-1 do
    - load V0 from address PT+16*i
    ace.exec V1, C0, V0
    - store V1 at address CT+16*i

// Finally, we absorb the lengths into auth_tag, finalize it, and output it
ace.stage C0, #ace_const_hash_finalize_enc
V1 ← IntTo64Bits(len(AD)) @ IntTo64Bits(len(PT))
ace.exec V2, C0, V1                    // V2 contains the finalized hash
----

GCM decryption differs from enc as follows:
the roles of `PT` and `CT` are reversed,
states _encrypt_ and _hash_finalize_enc_ are replaced by states _decrypt_ and _hash_finalize_dec_,
and the last lines are as follows:

[[ACE-pseudocode-GCM-decryption-difference]]
.GCM Decryption
[C]
----
// Finally, we absorb the lengths into auth_tag, finalize it, and verify it it
ace.stage C0, #ace_const_hash_finalize_dec
V1 ← IntTo64Bits(len(AD)) @ IntTo64Bits(len(CT))
ace.exec V2, C0, V1                    // V2 contains the finalized hash

ace.stage C0, #ace_const_hash_verify
V1 ← tag_from_payload
ace.exec C0, V1                        // V1 contains the tag from the input ciphertext
ace.error X1
if (X1 != 0) then { handle error }     // do not use the plaintext if error occurred
----

//
[discrete]
==== Alternative Examples

GCM security is not compromised if `H` is revealed.
Consequently, an implementation based on a simpler ECB mode CC is possible,
as shown below (for encryption only -- decryption is similar).
However, this significantly increases code size and requires implementing `galois_mult(V4,V3)`.
Adding a dedicated mode to the ACE unit is a minor effort, and it allows internal logic to optimize execution
beyond the capabilities of, for instance, a compiler on an in-order CPU. It also means that the CPU
does not have to implement the carryless multiplication (cf. <<ACE-Dependencies>>),
which saves hardware costs when several small cores share a single ACE unit.

[[ACE-pseudocode-GCM-encryption-alternate]]
.Implementing GCM encryption using an ECB CC
[C]
----
// Acquire payload, initialize
- Info: authenticated data = *AD, plaintext = *PT
- Process gets a GCM encryption CC from an API. Assume X5 is the pointer to the CC.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma       // Use 128-bit vectors
ace.import C0, (X5)                    // Imports SCC into CC C0
V5[127:32] ← IV

V3 ← 0                                 // “Auth Data 1”
ace.exec V4, C0, V3                    // compute H
for i = 0 to len_in_bytes(AD)/16-1  do
    - load 16 bytes from AD+16*i into V1
    V3 ← V3 xor V1                     // Horner scheme add
    V3 ← galois_mult(V4,V3)            // Horner scheme mult

counter ← 1                            // a 32-bit integer value
for i = 0 to len_in_bytes(PT)/16-1  do
    V5[32:0] ← counter
    - load 16 bytes from PT+16*i into V1
    ace.exec V2, C0, V5                // create mask by encrypting the counter
    V1 ← V1 xor V2                     // CTR encrypt
    V3 ← V3 xor V1                     // Horner scheme add
    V3 ← galois_mult(V4,V3)            // Horner scheme mult
    - store V1 at *(ciphertext+16*i))
    counter ← counter+1

V3 ← V3 xor (len(AD) || len(CT))       // Horner scheme add
V3 ← galois_mult(V4,V3)                // Horner scheme mult
V5[32:0] ← 0                           // Prepare IV || 0 for tag encryption
ace.exec V2, C0, V5
tag ← V3 xor V2                        // Last Horner scheme add
----

<<<

[[ACE-GCM-SIV]]
==== GCM-SIV mode

The GCM-SIV mode's main differences with GCM are that

. Both encryption and authentication keys are derived from the main key, whereas in GCM the main key is used also for encryption;
. It is a MAC-then-Encrypt mode, whereas GCM is a Encrypt-then-MAC mode, therefore GCM-SIV is more amenable to Release of Unencrypted Plaintext (RUP) attacks;
. Encryption requires two passes over the plaintext, since the tag computed on the AD and plaintext is used also as the initialization vector for the CTR encryption.

The third difference affects the state machine. While GCM-SIV's decryption state machine is similar to the GCM's, the encryption state machine is different:

* During encryption, in state _hash_absorb_ we absorb the entire associated data, then the plaintext, and finally we move to state _hash_finalize_enc_ where we also absorb the lengths and produce the SIV/tag. After that, we move to state _encrypt_ where we perform a second pass on the the plaintext to encrypt it using the SIV/tag as the initialization vector.
* During decryption, on the other hand, in state _hash_absorb_ we absorb only the associated data, and in state _decrypt_ the ciphertext is decrypted and the plaintext is absorbed into the hash contextually -- only then we move to state _hash_finalize_dec_ to absorb the lengths, produce the SIV/tag, and later it is internally compared to the actual SIV/tag.

// Comment to reset indentation of blocks

Block Size:::

* `b` = block size in bits, (`8|b`).

Internal state:::

* *Metadata*: 64 bits.
* *Content Fields*:
 ** `key`: `k` bits (8|`k`). `k = b` or `k = 2b`.
 ** `nonce`: `3b/4` bits.
 ** `counter`: `b/4` bits.
 ** `auth_tag`: `b` bits.
 ** `SIV`: `b` or `3b/4` bits.
  *** A `b`-bit `SIV` is computed by clearing the most significant bit of `auth_tag` and encrypting it.
  *** For a `3b/4`-bit `SIV`, a full `b`-bit `auth_tag` value is kept while absorbing data.
 The public `SIV` value is computed by clearing the most significant bit of `auth_tag`, encrypting it, and then removing the `b/4` least significant bits. +
 ** `enc_key`: `k` bits.
 ** `auth_key`: `b` bits.

NOTE: The `SIV` field is actually only needed for decryption, since it must be maintained separately from the `auth_tag` field, which changes with each processed block as it is computed, whereas for encryption it is first computed completely and then used in the encryption process.

Generic Functions:::

* `initial_content_deserialize`
 ** Length = `k/8` bytes.
 ** `input[k/8-1:0] = key`.

* `content_serialize`:
 ** Length = `(k+3b)/8` bytes.
 ** `input[k/8-1:0] = key`.
 ** `input[(k+b)/8-1:k/8] = nonce @ counter`.
 ** `input[(k+2b)/8-1:(k+b)/8] = auth_tag`.
 ** `input[(k+3b)/8-1:(k+2b)/8] = SIV`.
 ** Note that `hash_key` and `auth_key` are not serialized.

* `content_deserialize` converts the output of `content_serialize` back to the original input format.

Algorithm-Specific Functions:::

* `enc_block(key,p) -> c` encrypts block `p` using the key, and returns the result `c`.
* `absorb_into_hash(data)` absorbs data into the hash function by performing a step of (a variant of) GHASH or POLYVAL as specified by the algorithm
   (for instance, AES-GCM-SIV uses POLYVAL):
  . `auth_tag <- auth_tag xor Vs`.
  . `auth_tag <- auth_tag * hash_key`, where `*` denotes either Galois field multiplication (for GHASH) or Montgomery multiplication (for POLYVAL/MHASH), as specified by the algorithm.
State Machine:::
* *States:* _initial_ (0), _set_public_value_ (8), _set_public_value_2_ (9), _hash_absorb_ (3), _hash_finalize_enc_ (4), _hash_finalize_dec_ (5), _encrypt_ (1), and _decrypt_ (2).

* *Allowed State Transitions:*
 ** From all states to _initial_.
 ** For encryption: +
    _initial_ -> _set_public_value_ -> _hash_absorb_ -> _hash_finalize_enc_ -> _encrypt_.
 ** For decryption: +
    _initial_ -> _set_public_value_ -> _set_public_value_2_ -> _hash_absorb_ -> _decrypt_ -> _hash_finalize_dec_.
 ** Transition to _encrypt_ possible only if metadata allows encryption, else the CC is *invalidated*.
 ** Transition to _decrypt_ possible only if metadata allows decryption, else the CC is *invalidated*.

* *Behavior:*
 ** In state _initial_ :
  *** Any {nbsp}``ace.exec``{nbsp} operation will produce a null output and the CC will be *invalidated*.
  *** The following initialization operations are performed:
    . `enc_key`, `auth_key <- RFC8452_KeyDeriv(key)`,
    . `nonce`, `counter`, `auth_tag`, `SIV` <- 0`.

  ** In states _set_public_value_, resp. _set_public_value_2_:
    *** We can only issue  ``ace.exec`` instructions of Form B, i.e. "```ace.exec Cn|C[Xn], Vs```," to set the value of `nonce`, resp. `SIV`.
    *** If{nbsp} `ace.exec Cn|C[Xn], Vs`,{nbsp} is repeated, it will just re-write the value of `nonce`, resp. `SIV`.
    *** If no such {nbsp} `ace.exec Cn|C[Xn], Vs`{nbsp} to set is issued, `nonce`, resp. `SIV`, remains zero.
    *** Other forms of `ace.exe` are not allowed, they will produce null outputs and the CC is *invalidated*.

NOTE: There is no harm in setting the SIV while encrypting, since that field is not used in the encryption path until it is set by the state machine itself.
Accepting this redundant behavior simplifies the implementation of the state machine.

  ** In state _hash_absorb_:
   *** We only issue  ``ace.exec`` instructions of the form{nbsp} `ace.exec Cn|C[Xn], Vs`{nbsp} to accumulate a value in the `auth_tag`:
   i.e., perform `absorb_into_hash(Vs)`.
   *** Other forms of `ace.exec` are not allowed, they will produce null outputs and the CC is *invalidated*.

  ** In state _hash_finalize_enc_,
  we can only issue an {nbsp}``ace.exec``{nbsp} of Form A, i.e., "```ace.exec Vd, Cn|C[Xn], Vs```," where it is the responsibility of the user to set +
  `Vs = IntTo{b/2}Bits(bit_length(AD)) @ IntTo{b/2}Bits(bit_length(plaintext))`, +
  to finalize the computation of the SIV/tag, by performing:
    . `absorb_into_hash(Vs)` (which modifies `auth_tag`).
    . `tmp <- enc_block(enc_key, 1b0 @ ((auth_tag xor N)[b-2:0]))`
    . If tag length is `b` bits, then
     *** `SIV <- tmp`.
     *** `Vd <- tmp`.
    . else (tag length is `3b/4` bits)
     *** `SIV <- tmp[b-1:b/4]`.
     *** `Vd <- (tmp >> b/4)`.

  ** In state _encrypt_, we can only issue  ``ace.exec`` instructions of the Form A, namely "```ace.exec Vd, Cn|C[Xn], Vs```," to encrypt `Vs` into `Vd` as follows:
   . If `counter = 0`, then the CC is *invalidated*.
   . If the `SIV` is `b`-bits long, then +
     *** ``Vd <- Vs xor enc_block(key, 1b1 @ SIV[b-2:b/4] @ (SIV[b/4-1:0] + counter % 2^b/4^)),``
   . else (the `SIV` is `3b/4`-bits long) +
      *** ``Vd <- Vs xor enc_block(key, 1b1 @ SIV[3b/4-2] @ counter``.
   . `counter <- counter + 1`.

 ** In state _decrypt_,  we can only issue  ``ace.exec`` instructions of the Form A, i.e., "```ace.exec Vd, Cn|C[Xn], Vs```," to
   decrypt `Vs` into `Vd` and then absorb the plaintext `Vs` into the `auth_tag`, namely
     . If `counter = 0`, then the CC is *invalidated*.
     . If the `SIV` is `b`-bits long, then +
       *** ``Vd <- Vs xor enc_block(key, 1b1 @ SIV[b-2:b/4] @ (SIV[b/4-1:0] + counter % 2^b/4^)),``
     . else (it is `3b/4`-bits long) +
       *** ``Vd <- Vs xor enc_block(key, 1b1 @ SIV[3b/4-2] @ counter``.
     . `absorb_into_hash(Vs)`.
     . `counter <- counter + 1`.

 ** In state _hash_finalize_dec_,
    we can only issue an ``ace.exec`` of Form B, namely "```ace.exec Cn|C[Xn], Vs```," where it is the responsibility of the user to set +
    `Vs = IntTo{b/2}Bits(bit_length(AD)) @ IntTo{b/2}Bits(bit_length(plaintext))`. +
    The semantics are almost identical to issuing a Form A ``ace.exec`` in state _hash_finalize_dec_ except that the SIV/tag value is _not_ output, but is only kept in `auth_tag`. +
    Then the computation of the authentication tag is finalized as follows:
    . `absorb_into_hash(Vs)` (which modifies `auth_tag`).
    . `tmp <- enc_block(enc_key, 1b0 @ ((auth_tag xor N)[b-2:0]))`
    . If tag length is `b` bits, then
     *** `auth_tag <- tmp`.
    . else (tag length is `3b/4` bits)
     *** `auth_tag <- tmp[b-1:0] @ (b/4)b0`.
   . Finally, `auth_tag` and `SIV` are compared:
   *** If the values match, then the state is changed to _completed_, and `ace.error` returns no error,
       else the state is changed to _completed_, and `ace.error` returns `ace_err_authentication`.

  ** Upon completion of `ace.import`, the ACE unit recomputes `hash_key` and `auth_key`
    . `enc_key`, `auth_key <- RFC8452_KeyDeriv(key)`.

//

[discrete]
==== Usage Examples

We show in <<ACE-pseudocode-GCM-SIV-encryption>> how to use a GCM-SIV CC to perform AEAD encryption.
<<ACE-pseudocode-GCM-SIV-decryption>> is the corresponding pseudocode for decryption.

[[ACE-pseudocode-GCM-SIV-encryption]]
.GCM-SIV Encryption
[C]
----
// Acquire payload, initialize
- Info: authenticated data = *AD
- Info: plaintext = *PT
- Call an API to get the corresponding key from a key management applet or HW block.
- The API returns the SCC. Assume X5 is the pointer to it.
- Allocate memory for ciphertext buffer CT (if not same as PT).

vsetvli zero, 4, e32, m1, ta, ma       // Use 128-bit vectors
ace.import C0, (X5)

// Set the nonce (and the derived Authentication Key).
ace.stage C0, #ace_const_set_public_value
V0 ← nonce
ace.exec C0, V0

for i = 0 to len_in_bytes(AD)/16-1  do
    - load V0 from address AD+16*i     // Load a block of associated data
    ace.exec C0, V0 		           // Absorb it into hash
for i = 0 to len_in_bytes(PT)/16-1  do
    - load V0 from address PT+16*i     // Load a block of plaintext
    ace.exec C0, V0 		           // Absorb it into hash
V0 ← IntTo64Bits(len(AD)) @ IntTo64Bits(len(PT))
ace.exec C0, V0		          	       // Absorb lengths into hash

// Finalize the SIV computation, set and return it
ace.stage C0, #ace_const_hash_finalize_enc
ace.exec V2, C0
- store V2 into tag

// Encrypt the plaintext
ace.stage C0, #ace_const_encrypt
for i = 0 to len_in_bytes(PT)/16-1  do
    - load V0 from address PT+16*i     // Load a block of plaintext
    ace.exec V1, C0, V0                // Encrypt the block
    - store V1 at address CT+16*i      // Store a block of ciphertext
----

[[ACE-pseudocode-GCM-SIV-decryption]]
.GCM-SIV Decryption
[C]
----
// Acquire payload, initialize
- Info: authenticated data = *AD
- Info: ciphertext = *CT
- Call an API to get the corresponding key from a key management applet or HW block.
- The API returns the SCC. Assume X5 is the pointer to it.
- Allocate memory for plaintext buffer PT (if not same as CT).

vsetvli zero, 4, e32, m1, ta, ma       // Use 128-bit vectors
ace.import C0, (X5)

// The next operations set the nonce (and the derived Authentication Key).
ace.stage C0, #ace_const_set_public_value
V0 ← nonce
ace.exec C0, V0

ace.stage C0, #ace_const_set_public_value_2
V0 ← SIV
ace.exec C0, V0

// Compute AD contribution to Auth Data
ace.stage C0, #ace_const_hash_absorb
for i = 0 to len_in_bytes(AD)/16-1  do
    - load V0 from address AD+16*i
    ace.exec C0, V0                    // Absorb it into hash

// Decrypt ciphertext and continue computation of auth_tag
for i = 0 to len_in_bytes(CT)/16-1 do
    - load V0 from address CT+16*i
    ace.exec V1, C0, V0
    - store V1 at address PT+16*i

// Finally, we absorb the lengths of AD and plaintext into auth_tag AND verify
ace.stage C0, #ace_const_hash_finalize_enc
V0 ← IntTo64Bits(len(AD)) @ IntTo64Bits(len(PT))
ace.exec C0, V0

ace.error X1
if (X1 != 0) then { handle error }     // do not use the plaintext if error occurred
----


<<<

[[ACE-CMAC]]
==== CMAC functions

// comment to reset formatting

Block Size:::

* `b` = block size in bits, (8|`b`)

Internal state:::

* *Metadata*: 64 bits.
* *Content Fields*:
** `key`: `k` bits (8|`k`, in fact it is almost always 128|`k`).
** `hash`: `b` bits.

Generic Functions:::

* `initial_content_deserialize`.
 ** Length = `k/8` bytes.
 ** `input[k/8-1:0] = key`.

Algorithm-Specific Functions:::

* `enc_block(key,p) -> c` encrypts block `p` using the key, and returns the result `c`.

State Machine:::

* *States:* _initial_ (0), _hash_absorb_ (3), _hash_finalize_ (4), _last_block_length_ (7)
* *Allowed State Transitions:*
 ** _initial_ -> _hash_absorb_.
 ** _hash_absorb_ -> _last_block_length_, _hash_finalize_.
 ** _last_block_length_ -> _hash_finalize_.
 ** From any state to state _initial_.
* *Behavior:*
 ** In state _initial_, any `ace.exec` will result in the CC being *invalidated*.
 ** In state _hash_absorb_, we can only issue instructions ``ace.exec`` of form B, i.e., "```ace.exec Cn|C[Xn], Vs```", to absorb the data block `Vs` into the hash.
 ** Upon issuing `ace.stage Cn|C[Xn], #ace_state_hash_finalize, Xs` where `Xs` contains the length of the last block, the CC will transition to state _hash_finalize_, where any further {nbsp} `ace.exec Cn|C[Xn], Vs` will simply set (and possibly overwrite) the last partial block.
 ** In state _hash_finalize_, the computation of the hash is completed, and it can be exported using "```ace.exec Vd, Cn|C[Xn]```."
 ** In any state, issuing a different form of ``ace.exec`` then the allowed one will produce a null output and the CC will be *invalidated*.

<<<

[[ACE-hash-functions]]
==== Hash Functions

[.red]#TBD#

<<<

[[ACE-Ascon]]
==== Ascon Specific Rules

===== Ascon-128 and Ascon-128a authenticated ciphers

[.red]#TBD#

===== Ascon-Hash cryptographic hash

[.red]#TBD#

===== Ascon-Xof extendable-output function

[.red]#TBD#

===== Ascon-80pq cipher with the increased 160-bit key

[.red]#TBD#

// //////////////////////////////////////////////////////////////////////////////////////////

<<<

[[ACE-examples]]

=== Examples

==== Key Management and Provisioning Applications

Software environments that implement key management operations for other domains require their own RCTK. A system may contain multiple such software environments.

A Key Management Applet (KMA) will

[arabic]
. Generate or retrieve a key matching a request.
. Configure a CC with this key and its associated metadata.
. Export this CC to a SCC in memory.
. Relinquish control to the MM.

The MM, which controls the CTK, can the

[arabic, start=5]
. Set the RCTK to the KMA’s RCTK.
. Re-import the SCC into a CC
. Change the RCTK to match the requester domain's RCTK.
. Export the key for the Requester's use.
. Relinquish control to the Requester.

This is the most generic approach and allows each piece of software to use a CC of choice to generate and import SCCs.
Furthermore, it protects the key from other SW environments that may be crossed while transferring control between the Requester process, the MM, and the Key Management application.

// Various optimizations are possible, which can be interesting for embedded environments: Steps 3., 5., and 6. can be omitted if the CC used for these operations is fixed and no intermediate SW environments modify that CC.

[comment]
--
.Simple Example: Encryption, no Authentication
[%linenums,C]
----
Call OS API to get the necessary SCC. X5 points to the SCC.
Allocate memory for ciphertext buffer.
ace.import C0, [X5]                    // Import the SCC into CC C0
ace.error X1
if (X1 != 0) then { handle error }
Configure vector unit to use 128-bit vectors.
ace.state C0, #ace_const_encrypt
ace.error X1
if (X1 != 0) then { handle error }
   // If encryption is not allowed
for i = 0 to ceil(len_in_bytes(plaintext)/16)-1 do
    - load V0 from address plaintext+16*i
    ace.exec V0, C0, V0                // Encrypt one block of the plaintext
    - store V0 at address ciphertext+16*i
----
--

// ==== Decryption and Authentication, encrypt–then–MAC
//
// This example assumes a keyed hash function (MAC) where the CC/SCC includes the key.
// With the hash function programmed in CC C1, `ace.state C1, #ace_const_hash_start` initializes or resets the function to compute a new hash with the same key.
// `ace.state C1, #ace_const_hash_finalize` finalizes the operation, allowing the hash value to be extracted via one or more `ace.exec V0, C1` instructions.
// `#ace_const_hash_start` is always valid and resets the state, whereas `#ace_const_hash_finalize` is valid only after initialization, and it can be called also with an empty payload.
//
// Following `#ace_const_hash_start`, only Form B `ace.exec` instructions are permitted.
// Following `#ace_const_hash_finalize`, only Form C `ace.exec` instructions are permitted. Attempting to extract data beyond the full hash length results in zero output and raises an error.
//
// .Decryption and Authentication, encrypt–then–MAC
//
// [C]
// ----
// - Process obtains an AES-encrypted, hashed, payload (the ciphertext) from a service.
// - Process calls an OS API to get CCs for the encryption and authentication keys.
// - OS API returns two encrypted and authenticated payloads.
//
// // Process imports first SCC (for decryption) into C0:
// ace.import C0, [X5]
//
// // Process imports second SCC (for hashing) into C1:
// ace.import C1, [X6]
//
// - Allocate memory for plaintext buffer.
// // Configure vector register file for 128-bit registers and AES.
// vsetvli zero, 4, e32, m1, ta, ma
//
// ace.state C0, #ace_const_decrypt
// ace.error X1,C0
// if (X1 != 0) then { handle error }
//
// ace.state C1, #ace_const_hash_start    // To start hashing
// foreach (i from 0 to ceil(len_in_bytes(ciphertext)/16)-1) {
//   - load V0 from address ciphertext+16*i
//   ace.exec ignore, C1, V0              // Absorb one 128-bit block
// }
//
// ace.state C1, #ace_const_hash_finalize
// ace.exec V1, C1
// // if the hash is longer, then extract the next 16 bytes using `ace.exec V2, C1`
//
// Compare tags. If they do not match, report error.
//
// foreach (i from 0 to ceil(len_in_bytes(ciphertext)/16)-1) {
//   - load V0 from address ciphertext+16*i
//   ace.exec V0, C0, V0				  // Decryption
//   - store V0 at address plaintext+16*i
// }
// ----
//
// Note that invoking `ace.state C1, #ace_const_hash_start` would allow to reuse C1 to compute additional hashes/MACs.

// ///////////////////////////////////////////////////////////////////////////////////////////

<<<

[[ACE-Dependencies]]
=== Impact and Dependency on Other Extensions

While ACE can be implemented with the V extension as a requirement, we note that ACE actually depends on a minimal subset of the RISC-V Vector Extension (RVV), which we call RVV-mini, for correct operation.
Required features include:

* Support for vector registers sufficiently wide to host the block-wise operations required by the algorithms supported by ACE;
* The `vsetvli` instruction with restricted parameters (e.g., "`vsetvli zero, 4, e32, m1, ta, ma`" for 128-bit-side operations); unsupported configurations must generate defined errors;
* Unit-strided vector loads and stores exclusively; and
* Vector bitwise logical operations such as `vxor`, `vand`, and `vor`.

Moreover,

* floating-point, fixed-point, and most arithmetic vector operations are not required and
* more complex operations for some corner-case cryptographic algorithms may be performed in GPRs, with results then inserted in vector registers via `vins`/`vext`.

RVV-mini must maintain full opcode compatibility with RVV to guarantee that ACE code runs unmodified on full RVV implementations.

// ///////////////////////////////////////////////////////////////////////////////////////////

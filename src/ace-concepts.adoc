[[ACE-concepts]]
=== Fundamental Concepts

The fundamental concept of ACE is the _opaque key_, i.e., a cryptographic key whose value remains hidden to software even while being used in cryptographic operations.

ACE implements this concept through _Cryptographic Contexts_ (CCs), architectural containers that protect sensitive cryptographic material.
Each CC consists of a _metadata_ section and of a _content_ section.
The metadata section defines the cryptographic algorithm and optional usage policies, while the content section comprises sensitive materialâ€”including keys, other secrets, and internal algorithm state.
The confidentiality and integrity of CC content is enforced by restricting modifications and access to architectural mechanisms that enforce rules defined by the configured algorithm.

Only the ACE implementation can access CC content.
For protection outside the architectural state, a CC can be exported as a _Sealed Cryptographic Context_ (SCC), i.e., an encrypted and authenticated package containing metadata, a nonce, and authentication tag, and encrypted content.
SCCs can be reimported into CCs when needed.
These operations use a _Context Transport Key_ (CTK) stored in a CSR Machine Mode-only register.
Machine Mode manages the CTK unless it is hardwired or hardware-generated.

The _opaque keys_ are the keys within CCs and SCCs.

An important distinction in ACE is between the _access_ to CCs for the purpose of importing and exporting SCCs, and the _use_ of CCs in cryptographic operations.
It must be always possible to import and export SCCs, and also to clear and overwrite CCs for the purpose of managing cryptographic operations, otherwise a process may be prevented from performing cryptographic operations.
The _use control policies_ in the metadata section limit only the operations that execute algorithms that are configured by a CC's metadata, including modifying its state.

In addition to use control policies,
ACE can bind opaque keys to a _Locale_, restricting their use to a specific device, device class, software or hardware configuration, or boot cycle.
This binding uses a _Locale CTK_ derived from the CTK and a locale-specific secret via a key derivation function.
The system maintains a _Locale Secrets Table_ (LST) containing both fixed system-wide and Machine-Mode-programmable values.
The metadata stores the Locale as an index into this table.

[.red]#*Discussion point:* _Can optional limitations even to import and export make sense and be useful?#_

[.red]#*Discussion point:* _Everything in this specification is still valid if the number of CCs is reduced to, say, 8. Immediate values to refer to CCs are still 5 bits long because the same field can also be used to refer to a GPR, but the only valid values for the CC number are 0 to 7._#

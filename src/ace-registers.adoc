[[ACE-registers]]
=== Registers

The atomic cryptography extension does not add a register file, but it adds 32 Cryptographic Contexts and
some unprivileged CSRs to a base scalar RISC-V ISA -- as well some privileged CSRs.
It also requires a subset of the V extension to be implemented.

[.red]#*NB:* _Everything in this specification is still valid is the number of CCs is reduced to, say, 8. Immediate values to refer to CCs are still 5 bits long because the same field can also be used to refer to a GPR, but the only valid values for the CC number are 0 to 7._#

==== Cryptographic Contexts

The atomic cryptography extension defines 32 Cryptographic Contexts (CCs) for storing cryptographic keys and metadata.
Each CC is identified by a number from 0 to 31, which the ACE unit uses to access its contents.
CCs are addressed via static 5-bit immediate addressing (as normal registers) as well as, unlike traditional registers, via a value from 0 to 31 in any general-purpose register.

CCs reside in a dedicated internal _context file_ (CF) that is inaccessible to any entity outside the ACE security perimeter, including software, other hardware blocks, and invasive debug interfaces. CF memory capacity is implementation-defined, in theory up to 32 times the size of the largest possible CC, but in practice a smaller amount of memory can be used.

CC sizes are dynamic, determined by the cryptographic algorithm defined in each CC.
ACE returns an error when insufficient memory prevents `ace.init` or `ace.import` operations, requiring the software to free memory by exporting or clearing a different CC. Implementations must provide sufficient CF memory to prevent infinite `ace.export`/`ace.import` loops.

==== ACE field in `misa`

We define the `misa.ACE` field to reflect that the ACE has been implemented, as the `L` bit (bit number 11).
We suggest this bit because this extension goes _beyond_ the cryptographic extension, which will likely use the letter `K` (bit number 10).

==== ACES field in `*status`

An ACE context status field, ACES, is added to `mstatus`[26:25] and shadowed in `sstatus`[26:25],
and possibly `vsstatus`[26:25] if the hypervisor extension is present.
It can be used, like the FS and VS fields, to optimize context switching.
Its status encoding differs from the FS, VS, and XS fields (which are defined in <<fsxsencoding>>).
The three possible status values are: Disabled-Clean, Disabled-Dirty, and Enabled, as described in <<ACE-fsxsencoding>>.

[[ACE-fsxsencoding]]
.Encoding of ACES[1:0] status field
[float="center",align="center",width="100%",cols="^7%,<18%,<75%",options="header"]
|===
|Status |Name |Meaning
|   0   | Disabled-Clean     | ACE ISE not enabled, software assumes no context being configured for this hart. +
The ACE unit will erase all contexts if ACE is enabled by writing to the `acecsr` CSR.
|   1   | Disabled-Clobbered | ACE ISE not enabled, software assumes there are configured contexts left for this hart from other environments.
The hart will trap if ACE ISE is enabled by writing to the `acecsr` CSR. To be used only if explicitly supported in system SW stack, otherwise Disabled-Clean should be used.
|   2   | Enabled            | ACE ISE enabled.
|   3   | Invalid            | Reserved.
|===

The Disabled-Clean and Disabled-Clobbered states are set by the parent mode to optimize context switching. Disabled-Clobbered is used when the parent-mode software stack does not save cryptographic contexts before transferring control to a process that does not (yet) have enabled ACE. If that process later enables ACE by writing to `acecsr`, the hart traps to the parent mode, allowing lazy context save; the parent must then manually reset all cryptographic contexts. In contrast, a software stack that always saves the contexts of a switched-out process should configure only the Disabled-Clean state, as enabling ACE in this case will automatically reset all contexts. The Disabled-Clobbered state is primarily intended for small devices where thread migration between harts is infrequent.

Changing the setting of ACES has no effect on the contents of the CCs.
In particular, setting ACES=Disabled-Clean or Disabled-Clobbered does not destroy the state, nor does setting ACES=Enabled clear the contents.

[.red]#*TBD* _An exception code must be allocated for when ACE enablement occurs while ACES=Disabled-Clobbered._#

==== `aceenable`

`aceenable` is a CSR that has only one bit defined.

Enabling ACE in User Mode is done by writing a 1 to `aceenable`.
This will allow the unit to perform operations, access the general purpose and vector registers, as well as the cryptographic contexts.
Disabling ACE in User Mode is done by writing a zero to `aceenable`.
This will also clear the contents of all cryptographic contexts.

[.red]#*TBD* _Describe also the effect on `aceccactive` and `aceccdirty`._#

While the standard floating-point and vector extensions do not support user-mode disable/enable instructions, the ACE unit can be enabled and disabled in User Mode. Instead of using an OS call or trapping, enablement and disablement will be mostly performed inside the ACE unit. However, if, as described above, the ACE unit contains state from a different process, and its interface is disabled for the current one, enabling it will trap to the parent mode to allow the parent to first save the state in case it was not saved before and then clear it (lazy context switch), or only clear it if it was saved earlier.

==== `aceerror`

The `aceerror` CSR contains only as many bits as needed to encode the error status.

// All other bits are reserved for future use.
// It is not a complete analogue of `fcsr` or `vcsr` since, for instance, it does not have to encode information such as rounding modes.
// Also, the error status is a field and not a set of distinct condition codes.

==== `acectk`

To program the CTK in the ACE unit, we need 256-bit worth of CSRs, reserved to M mode.

For this purpose, eight 32-bit CSRs are allocated, called `acectk0`, `acectk1` .. `acectk7`.

`acectk{i}` contains bits [stem:[31+32\,i:32\,i]] of the CTK.

The `acectk` block, if writable, is writable exclusively by MM.
Either all the `acectk` CSRs are writable, or none of them are.

The `acectk` block reads as zero in all cases.

There is need to raise exceptions if SW running in an any other mode tries to write to it or read it.

[.red]#*TBD*: _How to discover whether `acectk` is writable or not by MM?_
Can we use a second `misa` bit?
Low priority.#


==== Tracking CC dirtiness

This is done by using two CSRs, which track the usage and dirtiness of the CCs individually:

[arabic]
. `aceccactive`: 32 bits, with a bit per CC to denote whether the register is in use or not (cleared contextually to CC erasure to dispose of the key). Read-only.
. `aceccdirty`: 32 bits, with a bit per CC to track whether the corresponding CC has been modified since the last time the same bit has been cleared. +

Two types actions can modify a CC and thus must update also `aceccdirty`:

* An explicit configuration/import; and
* Certain cryptographic operations, such as absorbing information in a hash function, that modify the internal state.

It is also possible to directly write to `aceccdirty` (this is useful to optimize context switching).

Implementations are required to track the dirtiness of any CC precisely and individually.
This is different from the tracking of the dirtiness of the floating-point state, for instance.

==== ccstart

`ccstart` is a XLEN bits wide CSR which plays a similar role in ACE than `vstart` in the V extension.

Since `ace.init`, `ace.import`, `ace.export`, `ace.input`, and `ace.output` may take a long time, they can be interrupted mid-instruction by interrupts or memory exceptions.
In this case implementations have the option to set `ccstart` to a non-zero value, which means when the vector instruction is started again it will not restart from the beginning, but it will be resumed.
Since ACE makes no requirements about the width of the memory accesses performed, `ccstart` will not be an element index, but rather a long-word offset.
In other words, the current instruction has been interrupted after reading or writing 4 times `ccstart` bytes or output or input.

Like `vstart`, `ccstart` is a normal read/write CSR, but it is not intended to be written with arbitrary non-zero values by software; normally it is written by hardware on trap.
Software can safely write 0 to it to completely restart operations, and it can also be saved/restored on context switches.
Writing an arbitrary non-zero value may raise an illegal-instruction exception because hardware is not required to support all values.  If not, and a higher value of `ccstart` is written, authentication will fail upon import because some parts of the content are replaced by possibly arbitrary values. Or exports will generate a non-authenticable output.  Only `ace.init` may still likely create a valid context, but the values of the key were already in the clear in the same domain, so this does not augment the attack surface.

Only some specific instructions can have a non-zero `ccstart`, and the other ACE instructions will ignore this value if set by software.

[[ace-why-restarting,Remark {counter:remark}]]
*Remark {counter:remark}*:
_A single `ccstart` value is possible because of the used authentication encryption algorithm.
Let us look at the various operations:_

* `_ace.init_` _(formerly `ace.config`) is a single pass operation: The metadata block is read first, which also determines the length of the payload. If it fits in the available memory, then the blocks are read one by one and passed to a deserialisation circuit to fill the CC._
* `_ace.import_` _works very similarly to `ace.init`: the metadata block is read first to determines the length of the payload. If it fits in the available memory, then the remaining blocks are read one by one, decrypted, and then passed to a deserialisation circuit to fill the CC._
* `_ace.export_` _has two passes, but one is entirely internal, so it can easily be restarted (if we want), and, most importantly, it will NOT cause a page fault: namely the computation of the SIV using poly1305 on the serialisation of the CC's contents. Then, we write out the MD (serialised), nonce, SIV, and the serialisation of the CC contents is encrypted and written out block-wise._

_Note that even if such operations are per se complex, the ACE unit is de facto a separate machine that executes simpler instructions one by one, and these are generated by state machines (one per CPU hart connected to the ACE unit â€” it may be a 1-1 connection) that get the commands from the CPU and translate them. So, the ACE unit may even be able to reorder, pipeline, juggle these operations, even from different threads, as long as the operations talk to the correct hart-specific architectural states._

_So, we see no need to separate data transfer and crypto operations from import/export. Otherwise, we would *have* to assume that the loaded payload is stored somewhere inside the ACE unit, instead of being processed with minimal overhead._

_Finally, we observe that resuming would require *at least as many* cryptographic operations as restarting, if the domain in which the control flow is trapped also saves and resumes the partial SCCs.  The number of memory accesses may be reduced, since it cannot be guaranteed that the data that has been read from memory the first time (for `ace.init` or `ace.export`) is still in the caches, so performance may be still better with restarting on some systems. Also, restarting avoids potential circular page-fault problems._

[.red]#*TBD* specify the exact meaning of `ccstart`, and define the points where the various operations can be interrupted.
Also include negative values for internal poly1305 processing in `ace.export`.#

==== Reuse ASID and VMID (to be verified).

We reuse the CSRs for `ASID`, resp., `VMID`
(i.e., the CSR fields `satp`.ASID and `hgatp`.VMID).
to give only certain User processes and Supervisor processes access to certain key spaces.
The maximal bit length of `ASID` is 9 for Sv32 addresses or 16 for Sv39, Sv48, and Sv57.
The maximal bit length of `VMID` is 7 for Sv32x4 or 14 for Sv39x4, Sv48x4, and Sv57x4.
In the metadata blocks, `ASID` and `VMID` are always zero padded to the maximal lengths of 16 and 14 bits, respectively.

[.red]#However, we need a mechanism to make sure that if the system is not configured not to insert `ASID`, resp., `VMID` into the GVAs/GPAs, we can still use them for the purpose of policing the use of CCs.#

[[ace-providing-keys,Remark {counter:remark}]]
*Remark {counter:remark}*: _The software in each World/Supervisor Domain is normally responsible to generate or obtain their own keys, and if a process (applet) in one World/Supervisor Domain is responsible to provide keys to other Worlds/Supervisor Domains, it is the responsibility of the MM to perform an appropriate sequence of import, switch the CTK, then export operations._

==== Re-configurable Locales

We need three further groups of 4 32-bit CSRs, programmable by the MM, to define three reconfigurable locales (cf. <<ACE-Locales>>).

These three groups are:
`ace_OS_Secret` (i.e. `OS_Secret0`, `OS_Secret1`, `OS_Secret2`, `OS_Secret3`),
`ace_Boot_Session`, and
`ace_Revocation_Reserved` (with the individual CSRs in each group defined similarly to `OS_Secret`).

`Boot_Session` is reconfigurable because it may change in a VM if the latter's virtual hardware is re-booted, and this can happen independently from the underlying host and other VMs. For instance, a VM may be frozen, then the host may be rebooted, and then the VM may be resumed, in which case no boot session occurred in the VM, while it happened in the host hardware.

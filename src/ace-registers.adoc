[[ACE-registers]]
=== Registers

The atomic cryptography extension does not add a register file, but it adds 32 Cryptographic Contexts and
some unprivileged CSRs to a base scalar RISC-V ISA -- as well some privileged CSRs.
It also requires a subset of the V extension to be implemented.

==== Cryptographic Contexts

The atomic cryptography extension defines 32 Cryptographic Contexts (CCs) for storing cryptographic keys and metadata.
Each CC is identified by a number from 0 to 31, which the ACE unit uses to access its contents.
CCs are addressed via static 5-bit immediate addressing (as normal registers) as well as, unlike traditional registers, via a value from 0 to 31 in any general-purpose register.

Cryptographic Contexts (CCs) reside in a dedicated internal _context file_ (CF) that is inaccessible to any entity outside the ACE security perimeter, including software, other hardware blocks, and invasive debug interfaces. The CF's memory capacity is implementation-defined and may be as large as 32 times the size of the largest possible CC; however, a smaller amount of memory may be used in practice. At a minimum, the CF must be capable of holding either a single instance of the largest possible CC or the largest CC pair in which the first CC derives the second (via `ace.derive`).

The size of each CC is dynamic, determined by the cryptographic algorithm with which it is configured.
ACE returns an error when insufficient memory prevents `ace.init` and `ace.import` operations, requiring the software to free memory by exporting or clearing a different CC. Implementations must provide sufficient CF memory to prevent infinite `ace.export`/`ace.import` loops.
The same error may occur also if `ace.input` fails for the same reason.

==== PRIVILEGED: ACE field in misa

The `misa.ACE` field uses bit `L` (11) to indicate that the ACE extension is implemented.
//This bit is chosen because the extension goes _beyond_ the cryptographic extension, which will likely use bit `K` (10).

==== aceenable

`aceenable` is a single-bit CSR.

Enabling ACE in User Mode is done by writing a 1 to `aceenable`.
This will allow the unit to perform operations, access the general purpose and vector registers, as well as the cryptographic contexts.
Disabling ACE in User Mode is done by writing a zero to `aceenable`.
This will also clear the contents of all cryptographic contexts.

While the standard floating-point and vector extensions do not support User Mode disable/enable instructions, the ACE unit can be enabled and disabled in User Mode. Instead of using an OS call or trapping, enablement and disablement will be mostly performed inside the ACE unit. However, if, as described above, the ACE unit contains state from a different process, and its interface is disabled for the current one, enabling it will trap to the Supervisor (as described in <<ACE-ACES-field>>) to allow the latter to first save the state in case it was not saved before and then clear it (lazy context switch), or only clear it if it was saved earlier.

Writes to `aceenable` only affect the CCs upon disablement, as described in <<ACE-tracking-cc-dirtiness>>.

Enablement in other modes uses a special field in the `*status` CSRs. (cf.{nbsp}<<ACE-ACES-field>>).
Writing to `aceenable`, is allowed in more privileged modes, only affects the enablement of the feature in User mode.

==== PRIVILEGED: acectk

If the CTK can be programmed, it can only be programmed by Machine Mode.
For this purpose, we need eight 32-bit CSRs are available, called `acectk0`, `acectk1` .. `acectk7`, where register `acectk{i}` contains bits [stem:[31+32\,i:32\,i]] of the CTK.
No exception is raised if software running in any other mode tries to write to the `acectk` block, such writes are simply ignored.
The `acectk` block always reads as zero.

NOTE: Discoverability of whether the CTK can be configured or not is not critical, since this should be information known by the Machine Mode firmware.
[.red]#We can use the data structure pointed by `mconfigptr` in order to track optional features of ACE including whether the `acectk` CSR block is implemented, and if not whether whether the value is ephemeral or fixed.#

NOTE: User mode, and even operating systems and hypervisors, need not be aware of the `acectk` block. Other mechanisms could be used to program the CTK, such as a MM-exclusive dedicated hardware interface or memory-mapped interface.

[[ACE-ACES-field]]
==== ACES field in *status

An ACE context status field, ACES, is added to `mstatus`[26:25], and it is shadowed in `sstatus`[26:25] and in `vsstatus`[26:25] if the hypervisor extension is present.
Like the FS and VS fields, it can be used to optimize context switching.
//Its status encoding differs from the FS, VS, and XS fields (which are defined in <<fsxsencoding>>).
Its possible values are described in <<ACE-fsxsencoding>>.

[[ACE-fsxsencoding]]
.Encoding of ACES[1:0] status field
[float="center",align="center",width="100%",cols="^7%,<18%,<75%",options="header"]
|===
|Status |Name |Meaning
|   0   | Disabled-Clean     | ACE ISE not enabled, software assumes no context being configured for this hart. +
The ACE unit will erase all contexts if ACE is enabled by writing to the `aceenable` CSR.
|   1   | Disabled-Clobbered | ACE ISE not enabled, software assumes there are configured contexts left for this hart from other environments.
The hart will trap if ACE ISE is enabled by writing to the `aceenable` CSR. To be used only if explicitly supported in system SW stack, otherwise Disabled-Clean should be used.
|   2   | Enabled            | ACE ISE enabled.
|   3   | Invalid            | Reserved.
|===

The Disabled-Clean and Disabled-Clobbered states are set by the parent mode.
Disabled-Clobbered is used when the parent-mode software stack does not save cryptographic contexts before transferring control to a process that does not (yet) have enabled ACE. If that process later enables ACE by writing to `aceenable`, the hart traps to the parent mode, allowing lazy context save; the parent must then manually reset all cryptographic contexts. In contrast, a software stack that always saves the contexts of a switched-out process should configure only the Disabled-Clean state.
The Disabled-Clobbered state is primarily intended for small devices where thread migration between harts is infrequent, and possibly only one process may be dealing with cryptographic operations.

NOTE: It is responsibility of the exception handler to properly handle the contents of the CCs when the feature is enabled while ACES=Disabled-Clobbered, as
decribed in <<ACE-tracking-cc-dirtiness>>.

Writes to ACES do not affect the contents of the CCs.
Setting ACES=Disabled-Clean or Disabled-Clobbered does not destroy the state, nor does setting ACES=Enabled clear the contents.

The fine-grained tracking of activeness and dirtiness of individual CCs is done using the `aceccactive` and `aceccdirty` CSRs, cf.{nbsp}<<ACE-tracking-cc-dirtiness>>,
where also the effect of configuring and `aceenable` on `aceccactive` and `aceccdirty` is described.

==== aceerror

The `aceerror` CSR contains only as many bits as needed to encode the error status.

// All other bits are reserved for future use.
// It is not a complete analogue of `fcsr` or `vcsr` since, for instance, it does not have to encode information such as rounding modes.
// Also, the error status is a field and not a set of distinct condition codes.

[[ACE-tracking-cc-dirtiness]]
==== Tracking CC dirtiness

This is done by using two CSRs, which track the usage and dirtiness of the CCs individually:

[arabic]
. `aceccactive`: 32 bits, with a bit per CC to denote whether the register is in use or not (cleared contextually to CC erasure to dispose of the key). Read-only.
. `aceccdirty`: 32 bits, with a bit per CC to track whether the corresponding CC has been modified since the last time the same bit has been cleared. +

If the _i_-th bit of `aceccdirty` is set, then the _i_-th bit of `aceccactive` must also be set.

Two types actions can modify a CC and thus must update also `aceccdirty`:

* An explicit initialisation/configuration/import; and
* Certain cryptographic operations, such as absorbing information in a hash function, that modify the internal state.

It is also possible to directly write to `aceccdirty` to optimize context switching.

Implementations are required to track the dirtiness of any CC precisely and individually.
This is different from the tracking of the dirtiness of the floating-point state, for instance.

Context-switching code must save CC number _i_ if the _i_-th bit of `aceccdirty` is set.
However, it can clear `aceccdirty` when returning control to the same process after restoring its ACE state.
This will tell the context-switching code that there is no need to save the CC number _i_ again at the next context switch out of that process in case it has not been modified again, i.e, it the _i_-th bit of `aceccdirty` is stil; set.

Upon a write to `aceenable` that changes its value, the following happens to `aceccvalid` and `aceccdirty`:

* If `aceenable`'s value is changed to 0, then all CCs are cleared, both `aceccvalid` and `aceccdirty` are set to 0, and `*status.ACES` is set to Disabled-Clean.
* If `aceenable`'s value is changed to 1, and if the parent domain's `*status.ACES`=Disabled-Clean, then we simply assume that the parent process has cleared the CC and set both `aceccvalid` and `aceccdirty` to 0 before transferring the control flow to the current process.
* If `aceenable`'s value is changed to 1, and if the parent's `*status.ACES`=Disabled-Clobbered, then the hart traps to allow the parent domain responsible for handling context-switched to finish saving the state and ensure that both `aceccvalid` and `aceccdirty` are set to 0, and finally set `*status.ACES`=Disabled-Clean. [.red]#This behavior should be restricted only to User mode.#

[[ACE-ccstart-definition]]
==== ccstart

`ccstart` is an XLEN-bit CSR that serves a similar role in ACE as `vstart` does in the V extension.

The instructions `ace.init`, `ace.import`, `ace.export`, `ace.input`, and `ace.output` may require significant execution time and can be interrupted mid-instruction by interrupts or memory exceptions.
In such cases, implementations may set `ccstart` to a non-zero value, enabling the instruction to resume from the interruption point rather than restart from the beginning.
Since ACE does not have the concept of the length of an element,
`ccstart` represents a quad-word offset rather than an element index as in `vstart`.
Specifically, a load-type instruction was interrupted after reading _and_ processing 8 times `ccstart` bytes of input in the state,
and a store-type instruction was interrupted after computing and writing 8 times `ccstart` bytes of output.

Like `vstart`, `ccstart` is a standard read/write CSR; however, software should not write arbitrary non-zero values to it.
Normally, hardware sets this register on trap.
Software may safely write 0 to restart operations completely, and the register can be saved and restored during context switches.
Writing an arbitrary non-zero value may raise an illegal-instruction exception, as hardware is not required to support all values.
If no exception is raised and an invalid value is written, authentication will fail upon import because portions the content are replaced with arbitrary values, or exports will produce unauthenticatable output.  Only `ace.init` may still create a valid context, but since the key values were already in plaintext within the same domain, this does not expand the attack surface.

Only the instructions explicitly mentioned above support non-zero `ccstart` values; other ACE instructions ignore this register if set by software, and will be restarted.

[[ACE-why-restarting,Remark {counter:remark}]]
*Remark {counter:remark}.*
_A single `ccstart` value suffices due to the authenticated encryption algorithm used. The operations behave as follows:_

* `_ace.init_` _(formerly `ace.config`) is a single-pass operation: the metadata section is read first, determining the payload length. If sufficient memory is available, subsequent blocks are read sequentially and passed to a deserialization circuit to populate the CC._
* `_ace.import_` _operates similarly to `ace.init`: the metadata section is read first to determine the payload length. If sufficient memory is available, the remaining blocks are read, decrypted, and passed to a deserialization circuit to populate the CC._
* `_ace.export_` _involves two passes, but the first pass is entirely internal to the ACE unit. Hence, the first pass cannot cause a page fault, and is easily restarted. Specifically, it computes the SIV by applying POLYVAL to the serialized CC content. Subsequently, the serialized metadata, the nonce, and the SIV are written out, followed by the CC content serialized, encrypted and written out block by block. It is this last part that may cause page faults, and that may require resumption._

_Although these operations are inherently complex, the ACE unit is architected to function like a separate machine executing simpler instructions sequentially. State machines (one per CPU hart connected to the ACE unit, potentially in a 1-to-1 configuration) receive commands from the CPU and break them into smaller steps._

_Therefore, separating data transfer from cryptographic operations in import/export is unnecessary. Otherwise, the loaded payload would need to be stored within the ACE unit rather than processed inline with minimal overhead, and this may lead to higher internal resource requirements_

_Finally, resuming requires at least as many cryptographic operations as restarting if the trapped domain also saves and resumes partial SCCs. Memory accesses may be reduced, but since data read from memory initially (for `ace.init` or `ace.export`) may no longer reside in the caches, resuming may offer better performance on some systems. Additionally, resuming avoids potential circular page-fault issues, as opposed to restarting._

[.red]#*TBD* Specify the exact semantics of `ccstart` and define the points at which various operations can be interrupted.#

==== Reuse of ASID and VMID (to be verified).

We reuse the CSRs for `ASID`, resp., `VMID`
(i.e., the CSR fields `satp`.ASID and `hgatp`.VMID).
to give only certain User processes and Supervisor processes access to certain key spaces.
The maximal bit length of `ASID` is 9 for Sv32 addresses or 16 for Sv39, Sv48, and Sv57 addresses.
The maximal bit length of `VMID` is 7 for Sv32x4 or 14 for Sv39x4, Sv48x4, and Sv57x4 addresses.
In the metadata section, `ASID` and `VMID` are always zero padded to the maximal lengths of 16 and 14 bits, respectively.

[.red]#However, we need a mechanism to make sure that if the system is not configured not to insert `ASID`, resp., `VMID` into the GVAs/GPAs, we can still use them for the purpose of policing the use of CCs.#

[[ACE-providing-keys,Remark {counter:remark}]]
*Remark {counter:remark}.* _The software in each World/Supervisor Domain is normally responsible to generate or obtain their own keys, and if a process (applet) in one World/Supervisor Domain is responsible to provide keys to other Worlds/Supervisor Domains, it is the responsibility of the MM to perform an appropriate sequence of import, switch the CTK, then export operations._

==== PRIVILEGED: Re-configurable Locales

We need two further groups of four consecutive 32-bit CSRs, programmable by the Machine Mode, to define two reconfigurable locales
(cf.{nbsp}<<ACE-concepts>>).
These groups are:
`ace_OS_Secret{i}`, for `i` in [0..3], to configure the "OS Secret" entry,
and `ace_Boot_Session{i}`, for `i` in [0..3], to configure the "Boot Session" entry (cf.{nbsp}<<ACE-Locales>>).

The reason `ace_Boot_Session*` must be reconfigurable is that it must change in a VM if the latter's virtual hardware is re-booted, and this can happen independently from the underlying host and other VMs. For instance, a VM may be frozen, then the host may be rebooted, and then the VM may be resumed, in which case no boot session occurred in the VM, while it happened in the host hardware.

NOTE: User mode, and even operating systems and hypervisors, need not be aware of the `ace_OS_Secret{i}` and `ace_Boot_Session{i}` blocks. Other mechanisms could be used to program the "OS Secret" and  "Boot Session" entries, such as a MM-exclusive dedicated hardware interface or memory-mapped interface.

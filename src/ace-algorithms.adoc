[[ACE-Algorithms]]
=== Instruction Semantics and Data Formats for Various Algorithms

In this chapter we give the semantics of `ace.exec`, `ace.stage`, `ace.input` and `ace.output` for various algorithms.
Some of these are generic, others are specific to certain algorithms.

==== Generic Rules

For each algorithm, the following must be specified:

* State Machine, state numbers, admissible transitions.
* Length of the initialization content (input to `ace.init`), excluding metadata.
* Serialization and deserialization of the content, length of the serialized content.
* Any other algorithm-specific rules.

For modes of operations that can be instantiated with different primitives, we can specify more general rules, where the differences between instantiations in some cases are limited to the widths of their inputs and outputs of the primitive.

We represent a CC as a structure:
[C]
----
struct CC {
    metadata : bits(64);
    content : bits(...);
};
----

The `metadata_deserialize(CC) -> metadata` function takes a CC's metadata section and returns its metadata block formatted as described in <<ACE-metadata>>.

The `metadata_serialize(CC,metadata)` function takes a metadata block formatted as described in <<ACE-metadata>> and stores it into a CC's metadata section.

In the descriptions of the algorithms below, we do not need to redefine these two functions if they are not changed, i.e., if there are no changes to the metadata format.

===== Note on threshold implementations

Any CC with its algorithms implemented as threshold implementation will always export _all_ its keys and secrets in a single, reconstructed share.
The Configuration and SCC Formats will be the same as for the non-threshold implementations variants of the same algorithm, with the only difference being, in principle, the Side Channel Protection MD bits.
This implies that reconstructing a key or re-randomizing it are fast operations, such as `xor`s with random values.
This in turn implies that ACE execution unit must have access to a source of randomness, or at least a PRNG that is seeded at hardware boot.

This guarantees not only the compactness of the SCC format, but also that the key can be ported across architectures.
In fact, some threshold implementations may need 2, 3 or even more shares.

*Example*:
_AES-128 with a threshold implementation of a key. On implementations with two shares, the CC contains
`[metadata, first share, second share]`
and on implementations with three shares, the CC contains
`[metadata, first share, second share, third share]`. +
The SCC will however always contain the data in the following format: +
{nbsp}{nbsp}{nbsp} `[metadata (64 bits), Nonce (96 bits), SIV (96 bits), key (encrypted)]` +
This allows, for instance, a key to be migrated from a machine that has a 2-share implementation to a machine with a 3-share implementation._

<<<

[[ACE-ECB-mode]]
===== Electronic Codebook Modes (Direct Encryption/Decryption)

While listing the rules for the ECB mode is in principle easy, it does display all the rules that are required to describe an arbitrarily complex mode:

. The fields of the internal state, with their sizes in bits, in the order they would be serialized `content_serialize` and deserialized by `content_deserialize`.
. The width of unit processed by the algorithm, which also corresponds to the configured vector size.
. The descriptions of the generic functions of the algorithm, in case they differ from the default ones.
. Any algorithm-specific function.
. A description of the state machine, including a list of the possible states, their transitions, and the operations that are allowed at each state.

// comment to reset formatting

Internal state:::

* *Metadata*: 64 bits
* *Content Fields*:
 ** key: k bits (8|k, in fact it is almost always 128|k)

Processing unit (Block Size):::

* b = block size in bits, (8|b)

Generic Functions:::

* `initial_content_deserialize`. Length = k/8 bytes. input[k/8-1:0] = key.
// * `content_serialize`. output[k/8-1:0] = key, where k/8 = key  length in bits.
// * `content_deserialize` converts the output of `content_serialize` back to the original input format.

Algorithm-Specific Functions:::

* `encrypt_block(p) -> c` encrypts plaintext block `p` using the key, and returns the ciphertext result `c`.
* `decrypt_block(c) -> p` decrypts ciphertext block `c` using the key, and returns the plaintext result `p`.

State Machine:::

* States: _initial_ (0), _encrypt_ (1), and _decrypt_ (2)
* Allowed State Transitions
 ** from any state to encrypt, if metadata allows encryption, +
    else `ace.error` returns ace_error_invalid.
 ** from any state to decrypt, if metadata allows decryption, +
    else `ace.error` returns ace_error_invalid.
* Behavior
 ** In the "initial" state, any `ace.exec` will cause an ace_error_invalid error.
 ** In the "encrypt" state,
  *** if{nbsp} `ace.exec Vd, Cn|C[Xn], Vs` {nbsp}is issued, then {nbsp} `Vd = encrypt_block(Vs)`.
  *** If any other form of `ace.exec` is issued, then `ace.error` returns ace_error_invalid.
 ** In the "decrypt" state,
  *** if{nbsp} `ace.exec Vd, Cn|C[Xn], Vs` {nbsp}is issued, then {nbsp} `Vd = decrypt_block(Vs)`.
  *** If any other form of `ace.exec` is issued, then `ace.error` returns ace_error_invalid.


<<<

[[ACE-keystream-modes]]
===== CTR/LFSR/XCTR/XLFSR Modes to Produce a Keystream

The "X" modes have both IV and counter/LSFR of the same size as the block size of the underlying keyed PRP or PRF:
IV and counter/LFSR are `xor`ed together to form the input to the keyed PRP or PRF.

In the "non-X" modes the sums of the lengths of IV and counter/LSFR equal the block size of the underlying keyed PRP or PRF:
IV and counter/LFSR are concatenated to form the input to the keyed PRP or PRF.

Internal state:::

* *Metadata*: 64 bits
* *Content Fields*:
** key: k bits (8|k)
** IV: n bits (8|n)
** counter: j bits (8|j)

Processing unit (Block Size):::

* b = block size in bits, (8|b)
 ** If not an "X" mode, then b = n+j
 ** If an "X" mode, then b=n=j

Generic Functions:::

* `initial_content_deserialize`. Length = k/8 bytes. input[k/8-1:0] = key.
// * `content_serialize`
//   ** output[k/8-1:0] = key
//   ** output[(k+n)/8-1,k/8] = IV
//   ** output[(k+n+j)/8-1,(k+n)/8] = counter
// * `content_deserialize` converts the output of `content_serialize` back to the original input format.

Algorithm-Specific Functions:::

* `keystream_block(p) -> c` -- usually an encryption function
* `tick_counter()` -- updates the counter (either by a modular increment or a LFSR)

State Machine:::

* States: _initial_ (0), _set_public_value_ (1), and _operate_ (2).
* Allowed State Transitions
 ** initial -> set_public_value
 ** set_public_value -> any state.
* Behavior
 ** In the initial state, any `ace.exec` will result in `ace.error` returning ace_error_invalid
 ** Upon entering set_public_value, the counter field is set to 0 (or to 1 if LFSR).
 ** In "set_public_value" state, we can only issue `ace.exec Cn|C[Xn], Vs`, which overwrites the IV value (no harm if called more than once)
  *** Other forms of `ace.exe` not allowed, will cause an ace_error_invalid error.
 ** In "operate" state, we can only issue `ace.exec  Vd, Cn|C[Xn], which
  *** If in a "not-X" mode, `tmp = keystream_block(IV @ counter)`, `tick_counter`, `Vd = tmp`
  *** If in an "X" mode, `tmp = keystream_block(IV xor counter)`, `tick_counter`, `Vd = tmp`
  *** Other forms of `ace.exe` not allowed, will cause an ace_error_invalid error.

<<<

==== Specific Rules

[.red]#TBD#

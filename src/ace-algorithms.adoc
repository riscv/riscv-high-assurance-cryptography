[[ACE-Algorithms]]
=== Instruction Semantics and Data Formats for Various Algorithms

In this chapter we give the semantics of `ace.exec`, `ace.stage`, `ace.input` and `ace.output` for various algorithms.
Some of these are generic, others are specific to certain algorithms.

==== Generic Rules

For each algorithm, the following must be specified:

* State Machine, state numbers, admissible transitions.
* Length of the initialization content (input to `ace.init`), excluding metadata.
* Serialization and deserialization of the content, length of the serialized content.
* Any other algorithm-specific rules.

For modes of operations that can be instantiated with different primitives, we can specify more general rules, where the differences between instantiations in some cases are limited to the widths of their inputs and outputs of the primitive.

We represent a CC as a structure:
[C]
----
struct CC {
    metadata : bits(64);
    content : bits(...);
};
----

The `metadata_deserialize(CC) -> metadata` function takes a CC's metadata section and returns its metadata block formatted as described in <<ACE-metadata>>.

The `metadata_serialize(CC,metadata)` function takes a metadata block formatted as described in <<ACE-metadata>> and stores it into a CC's metadata section.

===== Note on threshold implementations

Any CC with its algorithms implemented as threshold implementation will always export _all_ its keys and secrets in a single, reconstructed share.
The Configuration and SCC Formats will be the same as for the non-threshold implementations variants of the same algorithm, with the only difference being, in principle, the Side Channel Protection MD bits.
This implies that reconstructing a key or re-randomizing it are fast operations, such as `xor`s with random values.
This in turn implies that ACE execution unit must have access to a source of randomness, or at least a PRNG that is seeded at hardware boot.

This guarantees not only the compactness of the SCC format, but also that the key can be ported across architectures.
In fact, some threshold implementations may need 2, 3 or even more shares.

*Example*:
_AES-128 with a threshold implementation of a key. On implementations with two shares, the CC contains
`[metadata, first share, second share]`
and on implementations with three shares, the CC contains
`[metadata, first share, second share, third share]`. +
The SCC will however always contain the data in the following format: +
{nbsp}{nbsp}{nbsp} `[metadata (64 bits), Nonce (96 bits), SIV (96 bits), key (encrypted)]` +
This allows, for instance, a key to be migrated from a machine that has a 2-share implementation to a machine with a 3-share implementation._

===== Electronic Codebook Modes (Direct Encryption/Decryption)

* Functions
 ** `metadata_deserialize`
 ** `metadata_serialize`
 ** `initial_content_deserialize`
 ** `content_serialize`
 ** `content_deserialize`
* State Machine
 ** States
 ** Transitions

===== Counter/LFSR Modes

[.red]#TBD#

==== Specific Rules

[.red]#TBD#

[[ACE-Dependencies]]
=== Impact and Dependency on Other Extensions

While ACE can be implemented with the V extension as a requirement, we note that
ACE actually depends on a minimal subset of the RISC-V Vector Extension (RVV), which we call RVV-mini, for correct operation.
Required features include:

* Vector registers of 128 bits or wider
* `vsetvli` instruction with restricted parameters (e.g., "`vsetvli zero, 4, e32, m1, ta, ma`" for 128-bit-side operations); unsupported configurations must generate defined errors;
* Unit-strided vector loads and stores exclusively; and
* Vector bitwise operations (`xor`, `and`, `or`) and `vsplatx` for protocol support including padding.

Moreover

* Floating-point, fixed-point, and most arithmetic vector operations are not required and
* more complex operations for some corner-case cryptographic algorithms may be performed in GPRs, with results then inserted in vector registers via `vins`/`vext`

RVV-mini must maintain full opcode compatibility with RVV to guarantee that ACE code runs unmodified on full RVV implementations.


[comment]
--
NO MOPs (Maybe OPerations): In theory if the vectors are 128 bits in an implementation or this RVV-mini, and in the same implementation ACE does not provide any input/output other than 128 bits in length, everything could work without “”. However, we still require it and, if it is not issued the vector instructions may not work, just as in full RVV. Hence, we do NOT ignore some of the parameters, but we also require them to be correct.
So in this case it seems that we can support vsetvli zero, 4, e32, m1, t?, ma. I think ma is necessary and t? could probably be tu or ta.
The RVV extension (subset) must be enabled on its own, so we also need `vsetvli` something (the “original” one from RVV, not some `ace.vsetvli` monster :-) ). (We probably almost always need just “vsetvli zero, 4, e32, m1, ta, ma” and the usual AES instructions require 4 32-bit elements). It is up to the implemented whether to allow the configuration of lengths such as 8 or 16 bits, which may be incompatible with ACE, in which case the ACE instructions (starting from `ace.init`) will return an error (as per aceerror/CSR read).
We probably do not need shifts and permutations? Insertion and extraction could be useful if we need to build padding schemes (as written above). We would not need them for metadata and, since we load the metadata from memory, and we build it with the integer instructions and store it to memory. This is to be discussed further. However, having the metadata set separately in `ace.init` can have advantages and we would need to make sure we either load one or two GPRs or a 128-bit vector register for the vector format.
Modes of operation: integer addition may be useful for counter-based modes which are not implemented in the HW. Counters can be computed in the integer registers and then vinserted into the vectors. This is not a problem not even in small in order devices, because updating counters can be done while one is waiting for the previous cryptographic operation to be completed in non-blocking mode. So we do not strictly need vector based integer operations.
--

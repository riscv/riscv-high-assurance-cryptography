[[ACE-Dependencies]]
=== Impact and Dependency on Other Extensions

The only impacted extension is RVV.
However, we do not need all features of RVV to allow ACE to be be fully functional.
It is therefore possible to define a "RVV-mini" that MUST be supported in order for ACE to work.
We need at least:

* A register file with 128-bit registers or longer.
* `vconfig` (to also determine how many vector registers we need).
* `vsetvli` (accepting only the necessary subset of parameters, for instance "`vsetvli zero, 4, e32, m1, ta, ma`" is we are only dealing with 128-bit blocks).
error in other cases).
* Load and store operations, we only need the unit-strided versions.
* Vector `xor`, `and`, and `or` to assist implementation of padding or of additional modes or protocols.
* `vsplatx` can also be useful to quickly fill a register with a pattern.
* We do not need floating point and fixed point operations, and probably also most arithmetic operations on vector elements (such as `add`, `sub`, `mul`, etc).
* If more complex calculations are needed, one can perform them on GPRs and use `vins`/`vext`.

We must re-use the same opcodes for the same operations —- code written for ACE with RVV-mini must be guaranteed to also run with full RVV.

[comment]
--
NO MOPs (Maybe OPerations): In theory if the vectors are 128 bits in an implementation or this RVV-mini, and in the same implementation ACE does not provide any input/output other than 128 bits in length, everything could work without “”. However, we still require it and, if it is not issued the vector instructions may not work, just as in full RVV. Hence, we do NOT ignore some of the parameters, but we also require them to be correct.
So in this case it seems that we can support vsetvli zero, 4, e32, m1, t?, ma. I think ma is necessary and t? could probably be tu or ta.
The RVV extension (subset) must be enabled on its own, so we also need vconfig something (the “original” one from RVV, not some ace.vconfig monster :-) ), vconfig 0. (vconfig imm where imm[4:0] is the number of registers we need, minus 1. Not sure we need a value for imm[6:5] and imm[7] since we do not need special lengths for the elements and Fixed point arithmetic, but since the example configuration is “vsetvli zero, 4, e32, m1, ta, ma” and the usual AES instructions require 4 32-bit elements, we can ask for imm[6:5] = 11 resp. 00 for 32 resp. 64 bit max element width). It is up to the implemented whether to allow the configuration of lengths such as 8 or 16 bits, which may be incompatible with ACE, in which case the ACE instructions (starting from ace.enable) will return an error (as per ace.error/CSR read).
We probably do not need shifts and permutations? Insertion and extraction could be useful if we need to build padding schemes (as written above). We would not need them for metadata and, since we load the metadata from memory, and we build it with the integer instructions and store it to memory. This is to be discussed further. However, having the metadata set separately in ace.config can have advantages and we would need to make sure we either load one or two GPRs or a 128-bit vector register for the vector format.
Modes of operation: integer addition may be useful for counter-based modes which are not implemented in the HW. Counters can be computed in the integer registers and then vinserted into the vectors. This is not a problem not even in small in order devices, because updating counters can be done while one is waiting for the previous cryptographic operation to be completed in non-blocking mode. So we do not strictly need vector based integer operations.
--
